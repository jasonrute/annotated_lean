<head>
<meta charset="UTF-8">
<link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro&display=swap" rel="stylesheet">
</head>

<body>
<pre>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  1  /-</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  2  Copyright (c) 2019 Scott Morrison. All rights reserved.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  3  Released under Apache 2.0 license as described in the file LICENSE.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  4  Authors: Reid Barton, Patrick Massot, Scott Morrison</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  5  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  6  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  7  import category_theory.concrete_category.unbundled_hom</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/concrete_category/unbundled_hom.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  8  import category_theory.full_subcategory</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/full_subcategory.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  9  import category_theory.monad.limits</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/monad/limits.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 10  import topology.uniform_space.completion</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/completion.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 11  import topology.category.Top.basic</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/category/Top/basic.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 12  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 13  /-!</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 14  # The category of uniform spaces</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 15  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 16  We construct the category of uniform spaces, show that the complete separated uniform spaces</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 17  form a reflective subcategory, and hence possess all limits that uniform spaces do.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 18  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 19  TODO: show that uniform spaces actually have all limits!</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 20  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 21  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 22  universes u</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 23  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 24  open category_theory</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 25  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 26  /-- A (bundled) uniform spaces. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 27  @[reducible] def UniformSpace : Type (u+1) := bundled uniform_space</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                              </code><font color='blue'><a title='category_theory.bundled'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='uniform_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/concrete_category/bundled.lean&#x27;, &#x27;line&#x27;: 24, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 112, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                              </code><font color='green'><a title='(Type u → Type v) → Type (max (u+1) v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='reducible'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='orange'><a title=' `bundled` is a type bundled with a type class instance for that type. Only
the type class is exposed as a parameter.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='A uniform space is a generalization of the &quot;uniform&quot; topological aspects of a
 metric space. It consists of a filter on `α × α` called the &quot;uniformity&quot;, which
 satisfies properties analogous to the reflexivity, symmetry, and triangle properties
 of a metric.

 A metric space has a natural uniformity, and a uniform space has a natural topology.
 A topological group also has a natural uniformity, even when it is not metrizable.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 28  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 29  namespace UniformSpace</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 30  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 31  instance (x : UniformSpace) : uniform_space x := x.str</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='UniformSpace'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='uniform_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.bundled.str'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;line&#x27;: 27, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 112, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/concrete_category/bundled.lean&#x27;, &#x27;line&#x27;: 24, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='UniformSpace.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='UniformSpace.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {c : Type u_1 → Type u_1} (c_1 : category_theory.bundled.{u_1 u_1} c), auto_param.{u_1+1} (c (@category_theory.bundled.α.{u_1 u_1} c c_1)) (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) name.anonymous))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='A (bundled) uniform spaces.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='A uniform space is a generalization of the &quot;uniform&quot; topological aspects of a
 metric space. It consists of a filter on `α × α` called the &quot;uniformity&quot;, which
 satisfies properties analogous to the reflexivity, symmetry, and triangle properties
 of a metric.

 A metric space has a natural uniformity, and a uniform space has a natural topology.
 A topological group also has a natural uniformity, even when it is not metrizable.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 32  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 33  /-- Construct a bundled `UniformSpace` from the underlying type and the typeclass. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 34  def of (α : Type u) [uniform_space α] : UniformSpace := ⟨α⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='blue'><a title='uniform_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='UniformSpace'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='tactic.apply_instance'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 112, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 27, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/tactic.lean&#x27;, &#x27;line&#x27;: 981, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='A uniform space is a generalization of the &quot;uniform&quot; topological aspects of a
 metric space. It consists of a filter on `α × α` called the &quot;uniformity&quot;, which
 satisfies properties analogous to the reflexivity, symmetry, and triangle properties
 of a metric.

 A metric space has a natural uniformity, and a uniform space has a natural topology.
 A topological group also has a natural uniformity, even when it is not metrizable.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='A (bundled) uniform spaces.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Try to solve the main goal using type class resolution.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 35  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 36  /-- The category instance on `UniformSpace`. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 37  instance concrete_category_uniform_continuous : unbundled_hom @uniform_continuous :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                </code><font color='blue'><a title='category_theory.unbundled_hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='uniform_continuous'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/concrete_category/unbundled_hom.lean&#x27;, &#x27;line&#x27;: 24, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 427, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                </code><font color='green'><a title='Π {c : Type u → Type u}, (Π {α β : Type u}, c α → c β → (α → β) → Prop) → Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : uniform_space.{u_1} α] [_inst_2 : uniform_space.{u_2} β], (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                </code><font color='orange'><a title=' A class for unbundled homs used to define a category. `hom` must
take two types `α`, `β` and instances of the corresponding structures,
and return a predicate on `α → β`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 38  ⟨@uniform_continuous_id, @uniform_continuous.comp⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='uniform_continuous_id'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='uniform_continuous.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 441, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 447, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : uniform_space.{u_1} α], @uniform_continuous.{u_1 u_1} α α _inst_1 _inst_1 (@id.{u_1+1} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [_inst_1 : uniform_space.{u_1} α] [_inst_2 : uniform_space.{u_2} β] [_inst_3 : uniform_space.{u_3} γ] {g : β → γ} {f : α → β}, @uniform_continuous.{u_2 u_3} β γ _inst_2 _inst_3 g → @uniform_continuous.{u_1 u_2} α β _inst_1 _inst_2 f → @uniform_continuous.{u_1 u_3} α γ _inst_1 _inst_3 (@function.comp.{u_1+1 u_2+1 u_3+1} α β γ g f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 39  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 40  instance (X Y : UniformSpace) : has_coe_to_fun (X ⟶ Y) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='UniformSpace'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='has_coe_to_fun'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='red'><a title='{&#x27;line&#x27;: 27, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/coe.lean&#x27;, &#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='green'><a title='Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Sort u → Sort (max u (v+1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='UniformSpace.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type (u_1+1)} [c : category_theory.has_hom.{u_1 u_1+1} obj], obj → obj → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='UniformSpace.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='A (bundled) uniform spaces.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 41  { F := λ _, X → Y, coe := category_theory.functor.map (forget UniformSpace) }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='category_theory.functor.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.forget'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='UniformSpace'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/concrete_category/basic.lean&#x27;, &#x27;line&#x27;: 51, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 27, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='(λ (X Y : category_theory.bundled.{u_1 u_1} uniform_space.{u_1}), (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β), @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ)) (@category_theory.bundled.α.{u_1 u_1} uniform_space.{u_1} X) (@category_theory.bundled.α.{u_1 u_1} uniform_space.{u_1} Y) (@category_theory.bundled.str.{u_1 u_1} uniform_space.{u_1} X) (@category_theory.bundled.str.{u_1 u_1} uniform_space.{u_1} Y)) X Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='UniformSpace.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='UniformSpace.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Π {C : Type u₁} [_inst_1 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [_inst_2 : category_theory.category.{v₂ u₂} D] (c : @category_theory.functor.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2) {X Y : C}, @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C _inst_1)) X Y → @category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D _inst_2)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2 c X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2 c Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (C : Type (u+1)) [_inst_1 : category_theory.concrete_category.{u} C], @category_theory.functor.{u u u+1 u+1} C (@category_theory.concrete_category.to_category.{u} C _inst_1) (Type u) category_theory.types.{u}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                       </code><font color='orange'><a title='The forgetful functor from a concrete category to `Type u`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='A (bundled) uniform spaces.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 42  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 43  @[simp] lemma coe_comp {X Y Z : UniformSpace} (f : X ⟶ Y) (g : Y ⟶ Z) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='blue'><a title='UniformSpace'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='red'><a title='{&#x27;line&#x27;: 27, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='green'><a title='Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='UniformSpace.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type (u_1+1)} [c : category_theory.has_hom.{u_1 u_1+1} obj], obj → obj → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='UniformSpace.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='UniformSpace.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type (u_1+1)} [c : category_theory.has_hom.{u_1 u_1+1} obj], obj → obj → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='UniformSpace.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='orange'><a title='A (bundled) uniform spaces.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 44    (f ≫ g : X → Z) = g ∘ f := rfl</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='function.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/function.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 25}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@category_theory.has_hom.hom.{u_1 u_1+1} UniformSpace.{u_1} (@category_theory.category_struct.to_has_hom.{u_1 u_1+1} UniformSpace.{u_1} (@category_theory.category.to_category_struct.{u_1 u_1+1} UniformSpace.{u_1} (@category_theory.bundled_hom.category.{u_1} uniform_space.{u_1} (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β), @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ)) (@category_theory.unbundled_hom.bundled_hom.{u_1} (λ (α : Type u_1), uniform_space.{u_1} α) uniform_continuous.{u_1 u_1} UniformSpace.concrete_category_uniform_continuous.{u_1})))) X Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type (u_1+1)} [c : category_theory.category_struct.{u_1 u_1+1} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{u_1 u_1+1} obj (@category_theory.category_struct.to_has_hom.{u_1 u_1+1} obj c) X Y → @category_theory.has_hom.hom.{u_1 u_1+1} obj (@category_theory.category_struct.to_has_hom.{u_1 u_1+1} obj c) Y Z → @category_theory.has_hom.hom.{u_1 u_1+1} obj (@category_theory.category_struct.to_has_hom.{u_1 u_1+1} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{u_1 u_1+1} UniformSpace.{u_1} (@category_theory.category_struct.to_has_hom.{u_1 u_1+1} UniformSpace.{u_1} (@category_theory.category.to_category_struct.{u_1 u_1+1} UniformSpace.{u_1} (@category_theory.bundled_hom.category.{u_1} uniform_space.{u_1} (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β), @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ)) (@category_theory.unbundled_hom.bundled_hom.{u_1} (λ (α : Type u_1), uniform_space.{u_1} α) uniform_continuous.{u_1 u_1} UniformSpace.concrete_category_uniform_continuous.{u_1})))) Y Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='UniformSpace.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='UniformSpace.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{u_1 u_1+1} UniformSpace.{u_1} (@category_theory.category_struct.to_has_hom.{u_1 u_1+1} UniformSpace.{u_1} (@category_theory.category.to_category_struct.{u_1 u_1+1} UniformSpace.{u_1} (@category_theory.bundled_hom.category.{u_1} uniform_space.{u_1} (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β), @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ)) (@category_theory.unbundled_hom.bundled_hom.{u_1} (λ (α : Type u_1), uniform_space.{u_1} α) uniform_continuous.{u_1 u_1} UniformSpace.concrete_category_uniform_continuous.{u_1})))) Y Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α β φ : Type u_1}, (β → φ) → (α → β) → α → φ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{u_1 u_1+1} UniformSpace.{u_1} (@category_theory.category_struct.to_has_hom.{u_1 u_1+1} UniformSpace.{u_1} (@category_theory.category.to_category_struct.{u_1 u_1+1} UniformSpace.{u_1} (@category_theory.bundled_hom.category.{u_1} uniform_space.{u_1} (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β), @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ)) (@category_theory.unbundled_hom.bundled_hom.{u_1} (λ (α : Type u_1), uniform_space.{u_1} α) uniform_continuous.{u_1 u_1} UniformSpace.concrete_category_uniform_continuous.{u_1})))) X Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {α : Type u_1} {a : α}, @eq.{u_1+1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 45  @[simp] lemma coe_id (X : UniformSpace) : (𝟙 X : X → X) = id := rfl</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='blue'><a title='UniformSpace'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='category_theory.category_struct.id'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='id'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='red'><a title='{&#x27;line&#x27;: 27, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 14, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='green'><a title='Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {obj : Type (u_1+1)} [c : category_theory.category_struct.{u_1 u_1+1} obj] (X : obj), @category_theory.has_hom.hom.{u_1 u_1+1} obj (@category_theory.category_struct.to_has_hom.{u_1 u_1+1} obj c) X X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='UniformSpace.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='UniformSpace.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='UniformSpace.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Sort u}, α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {α : Type u_1} {a : α}, @eq.{u_1+1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title='A (bundled) uniform spaces.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 46  @[simp] lemma coe_mk {X Y : UniformSpace} (f : X → Y) (hf : uniform_continuous f) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='blue'><a title='UniformSpace'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='uniform_continuous'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='red'><a title='{&#x27;line&#x27;: 27, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 427, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='green'><a title='Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='UniformSpace.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='UniformSpace.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : uniform_space.{u_1} α] [_inst_2 : uniform_space.{u_2} β], (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@coe_sort.{u_1+2 u_1+2} UniformSpace.{u_1} (@category_theory.bundled.has_coe_to_sort.{u_1 u_1} uniform_space.{u_1}) X → @coe_sort.{u_1+2 u_1+2} UniformSpace.{u_1} (@category_theory.bundled.has_coe_to_sort.{u_1 u_1} uniform_space.{u_1}) Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='orange'><a title='A (bundled) uniform spaces.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 47    ((⟨f, hf⟩ : X ⟶ Y) : X → Y) = f := rfl</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@coe_sort.{u_1+2 u_1+2} UniformSpace.{u_1} (@category_theory.bundled.has_coe_to_sort.{u_1 u_1} uniform_space.{u_1}) X → @coe_sort.{u_1+2 u_1+2} UniformSpace.{u_1} (@category_theory.bundled.has_coe_to_sort.{u_1 u_1} uniform_space.{u_1}) Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@uniform_continuous.{u_1 u_1} (@coe_sort.{u_1+2 u_1+2} UniformSpace.{u_1} (@category_theory.bundled.has_coe_to_sort.{u_1 u_1} uniform_space.{u_1}) X) (@coe_sort.{u_1+2 u_1+2} UniformSpace.{u_1} (@category_theory.bundled.has_coe_to_sort.{u_1 u_1} uniform_space.{u_1}) Y) (UniformSpace.uniform_space.{u_1} X) (UniformSpace.uniform_space.{u_1} Y) f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='UniformSpace.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type (u_1+1)} [c : category_theory.has_hom.{u_1 u_1+1} obj], obj → obj → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='UniformSpace.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='UniformSpace.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='UniformSpace.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@coe_sort.{u_1+2 u_1+2} UniformSpace.{u_1} (@category_theory.bundled.has_coe_to_sort.{u_1 u_1} uniform_space.{u_1}) X → @coe_sort.{u_1+2 u_1+2} UniformSpace.{u_1} (@category_theory.bundled.has_coe_to_sort.{u_1 u_1} uniform_space.{u_1}) Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {α : Type u_1} {a : α}, @eq.{u_1+1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 48  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 49  lemma hom_ext {X Y : UniformSpace} {f g : X ⟶ Y} : (f : X → Y) = g → f = g := subtype.eq</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='blue'><a title='UniformSpace'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='subtype.eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='red'><a title='{&#x27;line&#x27;: 27, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/subtype/basic.lean&#x27;, &#x27;line&#x27;: 22, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='green'><a title='Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='UniformSpace.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type (u_1+1)} [c : category_theory.has_hom.{u_1 u_1+1} obj], obj → obj → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='UniformSpace.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@category_theory.has_hom.hom.{u_1 u_1+1} UniformSpace.{u_1} (@category_theory.category_struct.to_has_hom.{u_1 u_1+1} UniformSpace.{u_1} (@category_theory.category.to_category_struct.{u_1 u_1+1} UniformSpace.{u_1} (@category_theory.bundled_hom.category.{u_1} uniform_space.{u_1} (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β), @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ)) (@category_theory.unbundled_hom.bundled_hom.{u_1} (λ (α : Type u_1), uniform_space.{u_1} α) uniform_continuous.{u_1 u_1} UniformSpace.concrete_category_uniform_continuous.{u_1})))) X Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='UniformSpace.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='UniformSpace.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{u_1 u_1+1} UniformSpace.{u_1} (@category_theory.category_struct.to_has_hom.{u_1 u_1+1} UniformSpace.{u_1} (@category_theory.category.to_category_struct.{u_1 u_1+1} UniformSpace.{u_1} (@category_theory.bundled_hom.category.{u_1} uniform_space.{u_1} (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β), @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ)) (@category_theory.unbundled_hom.bundled_hom.{u_1} (λ (α : Type u_1), uniform_space.{u_1} α) uniform_continuous.{u_1 u_1} UniformSpace.concrete_category_uniform_continuous.{u_1})))) X Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@category_theory.has_hom.hom.{u_1 u_1+1} UniformSpace.{u_1} (@category_theory.category_struct.to_has_hom.{u_1 u_1+1} UniformSpace.{u_1} (@category_theory.category.to_category_struct.{u_1 u_1+1} UniformSpace.{u_1} (@category_theory.bundled_hom.category.{u_1} uniform_space.{u_1} (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β), @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ)) (@category_theory.unbundled_hom.bundled_hom.{u_1} (λ (α : Type u_1), uniform_space.{u_1} α) uniform_continuous.{u_1 u_1} UniformSpace.concrete_category_uniform_continuous.{u_1})))) X Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{u_1 u_1+1} UniformSpace.{u_1} (@category_theory.category_struct.to_has_hom.{u_1 u_1+1} UniformSpace.{u_1} (@category_theory.category.to_category_struct.{u_1 u_1+1} UniformSpace.{u_1} (@category_theory.bundled_hom.category.{u_1} uniform_space.{u_1} (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β), @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ)) (@category_theory.unbundled_hom.bundled_hom.{u_1} (λ (α : Type u_1), uniform_space.{u_1} α) uniform_continuous.{u_1 u_1} UniformSpace.concrete_category_uniform_continuous.{u_1})))) X Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {α : Type u_1} {p : α → Prop} {a1 a2 : @subtype.{u_1+1} α (λ (x : α), p x)}, @eq.{u_1+1} α (@subtype.val.{u_1+1} α (λ (x : α), p x) a1) (@subtype.val.{u_1+1} α (λ (x : α), p x) a2) → @eq.{(max 1 (u_1+1))} (@subtype.{u_1+1} α (λ (x : α), p x)) a1 a2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='A (bundled) uniform spaces.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 50  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 51  /-- The forgetful functor from uniform spaces to topological spaces. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 52  instance has_forget_to_Top : has_forget₂ UniformSpace.{u} Top.{u} :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='blue'><a title='category_theory.has_forget₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='UniformSpace'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='Top'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/concrete_category/basic.lean&#x27;, &#x27;line&#x27;: 106, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 27, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/category/Top/basic.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='green'><a title='Π (C D : Type (u+1)) [_inst_1 : category_theory.concrete_category.{u} C] [_inst_2 : category_theory.concrete_category.{u} D], Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='orange'><a title='`has_forget₂ C D`, where `C` and `D` are both concrete categories, provides a functor
`forget₂ C D : C ⥤ C` and a proof that `forget₂ ⋙ (forget D) = forget C`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='A (bundled) uniform spaces.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='The category of topological spaces and continuous maps.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 53  unbundled_hom.mk_has_forget₂</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.unbundled_hom.mk_has_forget₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/concrete_category/unbundled_hom.lean&#x27;, &#x27;line&#x27;: 52, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {c : Type u → Type u} {hom : Π ⦃α β : Type u⦄, c α → c β → (α → β) → Prop} [𝒞 : @category_theory.unbundled_hom.{u} (λ (α : Type u), c α) hom] {c&#x27; : Type u → Type u} {hom&#x27; : Π ⦃α β : Type u⦄, c&#x27; α → c&#x27; β → (α → β) → Prop} [𝒞&#x27; : @category_theory.unbundled_hom.{u} (λ (α : Type u), c&#x27; α) hom&#x27;] (obj : Π ⦃α : Type u⦄, c α → c&#x27; α), (∀ ⦃α β : Type u⦄ ⦃Iα : c α⦄ ⦃Iβ : c β⦄ ⦃f : α → β⦄, @hom α β Iα Iβ f → @hom&#x27; α β (@obj α Iα) (@obj β Iβ) f) → @category_theory.has_forget₂.{u} (category_theory.bundled.{u u} c) (category_theory.bundled.{u u} c&#x27;) (@category_theory.bundled_hom.category_theory.concrete_category.{u} c (λ (α β : Type u) (Iα : c α) (Iβ : c β), @subtype.{u+1} (α → β) (@hom α β Iα Iβ)) (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), c α) hom 𝒞)) (@category_theory.bundled_hom.category_theory.concrete_category.{u} c&#x27; (λ (α β : Type u) (Iα : c&#x27; α) (Iβ : c&#x27; β), @subtype.{u+1} (α → β) (@hom&#x27; α β Iα Iβ)) (@category_theory.unbundled_hom.bundled_hom.{u} (λ (α : Type u), c&#x27; α) hom&#x27; 𝒞&#x27;))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='A custom constructor for forgetful functor between concrete categories defined using `unbundled_hom`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 54    @uniform_space.to_topological_space</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='uniform_space.to_topological_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 112, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π (α : Type u) [c : uniform_space.{u} α], topological_space.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 55    @uniform_continuous.continuous</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='uniform_continuous.continuous'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 591, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {α : Type u_1} {β : Type u_2} [_inst_1 : uniform_space.{u_1} α] [_inst_2 : uniform_space.{u_2} β] {f : α → β}, @uniform_continuous.{u_1 u_2} α β _inst_1 _inst_2 f → @continuous.{u_1 u_2} α β (@uniform_space.to_topological_space.{u_1} α _inst_1) (@uniform_space.to_topological_space.{u_2} β _inst_2) f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 56  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 57  end UniformSpace</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 58  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 59  /-- A (bundled) complete separated uniform space. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 60  structure CpltSepUniformSpace :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 61  (α : Type u)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 62  [is_uniform_space : uniform_space α]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='blue'><a title='uniform_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 112, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title='A uniform space is a generalization of the &quot;uniform&quot; topological aspects of a
 metric space. It consists of a filter on `α × α` called the &quot;uniformity&quot;, which
 satisfies properties analogous to the reflexivity, symmetry, and triangle properties
 of a metric.

 A metric space has a natural uniformity, and a uniform space has a natural topology.
 A topological group also has a natural uniformity, even when it is not metrizable.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 63  [is_complete_space : complete_space α]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='blue'><a title='complete_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/cauchy.lean&#x27;, &#x27;line&#x27;: 139, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='green'><a title='Π (α : Type u) [_inst_2 : uniform_space.{u} α], Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='A complete space is defined here using uniformities. A uniform space
 is complete if every Cauchy filter converges.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 64  [is_separated : separated α]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='separated'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/separation.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='green'><a title='Π (α : Type u) [_inst_4 : uniform_space.{u} α], Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 65  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 66  namespace CpltSepUniformSpace</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 67  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 68  instance : has_coe_to_sort CpltSepUniformSpace :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='has_coe_to_sort'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='CpltSepUniformSpace'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/coe.lean&#x27;, &#x27;line&#x27;: 47, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 60, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Sort u → Type (max u (v+1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='orange'><a title='A (bundled) complete separated uniform space.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 69  { S := Type u, coe := CpltSepUniformSpace.α }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='blue'><a title='CpltSepUniformSpace.α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='red'><a title='{&#x27;line&#x27;: 60, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='green'><a title='CpltSepUniformSpace.{u} → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 70  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 71  attribute [instance] is_uniform_space is_complete_space is_separated</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='blue'><a title='CpltSepUniformSpace.is_uniform_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='CpltSepUniformSpace.is_complete_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='CpltSepUniformSpace.is_separated'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='red'><a title='{&#x27;line&#x27;: 60, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 60, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 60, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='green'><a title='Π (c : CpltSepUniformSpace.{u}), uniform_space.{u} (c.α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ (c : CpltSepUniformSpace.{u}), @complete_space.{u} (c.α) (c.is_uniform_space)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ (c : CpltSepUniformSpace.{u}), @separated.{u} (c.α) (c.is_uniform_space)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 72  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 73  def to_UniformSpace (X : CpltSepUniformSpace) : UniformSpace :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='blue'><a title='CpltSepUniformSpace'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='UniformSpace'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='red'><a title='{&#x27;line&#x27;: 60, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 27, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='green'><a title='Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='orange'><a title='A (bundled) complete separated uniform space.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='A (bundled) uniform spaces.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 74  UniformSpace.of X</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='UniformSpace.of'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 34, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π (α : Type u) [_inst_1 : uniform_space.{u} α], UniformSpace.{u}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='CpltSepUniformSpace.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Construct a bundled `UniformSpace` from the underlying type and the typeclass.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 75  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 76  instance (X : CpltSepUniformSpace) : complete_space ((to_UniformSpace X).α) := CpltSepUniformSpace.is_complete_space X</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='CpltSepUniformSpace'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='complete_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='CpltSepUniformSpace.to_UniformSpace'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.bundled.α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='CpltSepUniformSpace.is_complete_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;line&#x27;: 60, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/cauchy.lean&#x27;, &#x27;line&#x27;: 139, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 73, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/concrete_category/bundled.lean&#x27;, &#x27;line&#x27;: 24, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 60, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π (α : Type u) [_inst_2 : uniform_space.{u} α], Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='CpltSepUniformSpace.{u_1} → UniformSpace.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='CpltSepUniformSpace.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {c : Type u_1 → Type u_1}, category_theory.bundled.{u_1 u_1} c → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='∀ (c : CpltSepUniformSpace.{u}), @complete_space.{u} (c.α) (c.is_uniform_space)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='CpltSepUniformSpace.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='A (bundled) complete separated uniform space.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='A complete space is defined here using uniformities. A uniform space
 is complete if every Cauchy filter converges.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 77  instance (X : CpltSepUniformSpace) : separated ((to_UniformSpace X).α) := CpltSepUniformSpace.is_separated X</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='CpltSepUniformSpace'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='separated'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='CpltSepUniformSpace.to_UniformSpace'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.bundled.α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='CpltSepUniformSpace.is_separated'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;line&#x27;: 60, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/separation.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 73, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/concrete_category/bundled.lean&#x27;, &#x27;line&#x27;: 24, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 60, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π (α : Type u) [_inst_4 : uniform_space.{u} α], Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='CpltSepUniformSpace.{u_1} → UniformSpace.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='CpltSepUniformSpace.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {c : Type u_1 → Type u_1}, category_theory.bundled.{u_1 u_1} c → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='∀ (c : CpltSepUniformSpace.{u}), @separated.{u} (c.α) (c.is_uniform_space)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='CpltSepUniformSpace.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='A (bundled) complete separated uniform space.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 78  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 79  /-- Construct a bundled `UniformSpace` from the underlying type and the appropriate typeclasses. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 80  def of (X : Type u) [uniform_space X] [complete_space X] [separated X] : CpltSepUniformSpace := ⟨X⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='blue'><a title='uniform_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='complete_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='separated'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='CpltSepUniformSpace'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 112, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/cauchy.lean&#x27;, &#x27;line&#x27;: 139, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/separation.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 60, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π (α : Type u) [_inst_2 : uniform_space.{u} α], Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π (α : Type u) [_inst_4 : uniform_space.{u} α], Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='A uniform space is a generalization of the &quot;uniform&quot; topological aspects of a
 metric space. It consists of a filter on `α × α` called the &quot;uniformity&quot;, which
 satisfies properties analogous to the reflexivity, symmetry, and triangle properties
 of a metric.

 A metric space has a natural uniformity, and a uniform space has a natural topology.
 A topological group also has a natural uniformity, even when it is not metrizable.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='A complete space is defined here using uniformities. A uniform space
 is complete if every Cauchy filter converges.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title='A (bundled) complete separated uniform space.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 81  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 82  /-- The category instance on `CpltSepUniformSpace`. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 83  instance concrete_category : concrete_category CpltSepUniformSpace :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='blue'><a title='category_theory.concrete_category'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='CpltSepUniformSpace'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/concrete_category/basic.lean&#x27;, &#x27;line&#x27;: 43, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 60, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='green'><a title='Type (u+1) → Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='orange'><a title='A concrete category is a category `C` with a fixed faithful functor `forget : C ⥤ Type`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='A (bundled) complete separated uniform space.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 84  induced_category.concrete_category to_UniformSpace</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.induced_category.concrete_category'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='CpltSepUniformSpace.to_UniformSpace'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/concrete_category/basic.lean&#x27;, &#x27;line&#x27;: 120, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 73, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C D : Type (u+1)} [_inst_1 : category_theory.concrete_category.{u} D] (f : C → D), category_theory.concrete_category.{u} (@category_theory.induced_category.{u u+1 u+1} C D (@category_theory.concrete_category.to_category.{u} D _inst_1) f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='CpltSepUniformSpace.{u_1} → UniformSpace.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 85  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 86  instance has_forget_to_UniformSpace : has_forget₂ CpltSepUniformSpace UniformSpace :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='blue'><a title='category_theory.has_forget₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='CpltSepUniformSpace'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='UniformSpace'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/concrete_category/basic.lean&#x27;, &#x27;line&#x27;: 106, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 60, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 27, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='green'><a title='Π (C D : Type (u+1)) [_inst_1 : category_theory.concrete_category.{u} C] [_inst_2 : category_theory.concrete_category.{u} D], Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='orange'><a title='`has_forget₂ C D`, where `C` and `D` are both concrete categories, provides a functor
`forget₂ C D : C ⥤ C` and a proof that `forget₂ ⋙ (forget D) = forget C`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='A (bundled) complete separated uniform space.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='A (bundled) uniform spaces.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 87  induced_category.has_forget₂ to_UniformSpace</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.induced_category.has_forget₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='CpltSepUniformSpace.to_UniformSpace'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/concrete_category/basic.lean&#x27;, &#x27;line&#x27;: 124, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 73, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C D : Type (u+1)} [_inst_1 : category_theory.concrete_category.{u} D] (f : C → D), @category_theory.has_forget₂.{u} (@category_theory.induced_category.{u u+1 u+1} C D (@category_theory.concrete_category.to_category.{u} D _inst_1) f) D (@category_theory.induced_category.concrete_category.{u} C D _inst_1 f) _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='CpltSepUniformSpace.{u_1} → UniformSpace.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 88  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 89  end CpltSepUniformSpace</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 90  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 91  namespace UniformSpace</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 92  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 93  open uniform_space</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 94  open CpltSepUniformSpace</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 95  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 96  /-- The functor turning uniform spaces into complete separated uniform spaces. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 97  noncomputable def completion_functor : UniformSpace ⥤ CpltSepUniformSpace :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 98  { obj := λ X, CpltSepUniformSpace.of (completion X),</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 99    map := λ X Y f, ⟨completion.map f.1, completion.uniform_continuous_map⟩,</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>100    map_comp&#x27; := λ X Y Z f g,</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>101    begin</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>102    apply subtype.eq,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>103    dsimp,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1239, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`dsimp` is similar to `simp`, except that it only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>104    rw ←completion.map_comp,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>105    refl,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1263, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Shorter name for the tactic `reflexivity`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>106    exact g.property,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>107    exact f.property</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>108    end }.</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>109  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>110  /-- The inclusion of any uniform spaces into its completion. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>111  def completion_hom (X : UniformSpace) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='blue'><a title='UniformSpace'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='red'><a title='{&#x27;line&#x27;: 27, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='green'><a title='Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='orange'><a title='A (bundled) uniform spaces.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>112    X ⟶ (forget₂ CpltSepUniformSpace UniformSpace).obj (completion_functor.obj X) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.forget₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='CpltSepUniformSpace'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='UniformSpace'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='UniformSpace.completion_functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/concrete_category/basic.lean&#x27;, &#x27;line&#x27;: 112, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 60, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 27, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 97, &#x27;column&#x27;: 18}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='UniformSpace.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type (u_1+1)} [c : category_theory.has_hom.{u_1 u_1+1} obj], obj → obj → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (C D : Type (u+1)) [_inst_1 : category_theory.concrete_category.{u} C] [_inst_2 : category_theory.concrete_category.{u} D] [_inst_3 : @category_theory.has_forget₂.{u} C D _inst_1 _inst_2], @category_theory.functor.{u u u+1 u+1} C (@category_theory.concrete_category.to_category.{u} C _inst_1) D (@category_theory.concrete_category.to_category.{u} D _inst_2)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type (u_1+1)} [_inst_1 : category_theory.category.{u_1 u_1+1} C] {D : Type (u_1+1)} [_inst_2 : category_theory.category.{u_1 u_1+1} D], @category_theory.functor.{u_1 u_1 u_1+1 u_1+1} C _inst_1 D _inst_2 → C → D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@category_theory.functor.{u_1 u_1 u_1+1 u_1+1} UniformSpace.{u_1} (@category_theory.bundled_hom.category.{u_1} uniform_space.{u_1} (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β), @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ)) (@category_theory.unbundled_hom.bundled_hom.{u_1} (λ (α : Type u_1), uniform_space.{u_1} α) uniform_continuous.{u_1 u_1} UniformSpace.concrete_category_uniform_continuous.{u_1})) CpltSepUniformSpace.{u_1} (@category_theory.concrete_category.to_category.{u_1} CpltSepUniformSpace.{u_1} CpltSepUniformSpace.concrete_category.{u_1})'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type (u_1+1)} [_inst_1 : category_theory.category.{u_1 u_1+1} C] {D : Type (u_1+1)} [_inst_2 : category_theory.category.{u_1 u_1+1} D], @category_theory.functor.{u_1 u_1 u_1+1 u_1+1} C _inst_1 D _inst_2 → C → D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='UniformSpace.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title=' The forgetful functor `C ⥤ D` between concrete categories for which we have an instance
`has_forget₂ C `.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='A (bundled) complete separated uniform space.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='A (bundled) uniform spaces.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='The functor turning uniform spaces into complete separated uniform spaces.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>113  { val := (coe : X → completion X),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='coe'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='uniform_space.completion'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/coe.lean&#x27;, &#x27;line&#x27;: 67, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/completion.lean&#x27;, &#x27;line&#x27;: 322, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='Π {a : Sort u} {b : Sort v} [_inst_1 : has_lift_t.{u v} a b], a → b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='UniformSpace.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π (α : Type u_1) [_inst_1 : uniform_space.{u_1} α], Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='UniformSpace.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title='Hausdorff completion of `α`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>114    property := completion.uniform_continuous_coe X }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='uniform_space.completion.uniform_continuous_coe'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/completion.lean&#x27;, &#x27;line&#x27;: 387, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='∀ (α : Type u_1) [_inst_1 : uniform_space.{u_1} α], @uniform_continuous.{u_1 u_1} α (@uniform_space.completion.{u_1} α _inst_1) _inst_1 (@uniform_space.completion.uniform_space.{u_1} α _inst_1) (@coe.{u_1+1 u_1+1} α (@uniform_space.completion.{u_1} α _inst_1) (@coe_to_lift.{u_1+1 u_1+1} α (@uniform_space.completion.{u_1} α _inst_1) (@uniform_space.completion.has_coe_t.{u_1} α _inst_1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='UniformSpace.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>115  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>116  @[simp] lemma completion_hom_val (X : UniformSpace) (x) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='blue'><a title='UniformSpace'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='red'><a title='{&#x27;line&#x27;: 27, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='green'><a title='Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='orange'><a title='A (bundled) uniform spaces.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>117    (completion_hom X) x = (x : completion X) := rfl</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='UniformSpace.completion_hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='uniform_space.completion'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 111, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/completion.lean&#x27;, &#x27;line&#x27;: 322, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π (X : UniformSpace.{u_1}), @category_theory.has_hom.hom.{u_1 u_1+1} UniformSpace.{u_1} (@category_theory.category_struct.to_has_hom.{u_1 u_1+1} UniformSpace.{u_1} (@category_theory.category.to_category_struct.{u_1 u_1+1} UniformSpace.{u_1} (@category_theory.bundled_hom.category.{u_1} uniform_space.{u_1} (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β), @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ)) (@category_theory.unbundled_hom.bundled_hom.{u_1} (λ (α : Type u_1), uniform_space.{u_1} α) uniform_continuous.{u_1 u_1} UniformSpace.concrete_category_uniform_continuous.{u_1})))) X (@category_theory.functor.obj.{u_1 u_1 u_1+1 u_1+1} CpltSepUniformSpace.{u_1} (@category_theory.concrete_category.to_category.{u_1} CpltSepUniformSpace.{u_1} CpltSepUniformSpace.concrete_category.{u_1}) UniformSpace.{u_1} (@category_theory.concrete_category.to_category.{u_1} UniformSpace.{u_1} (@category_theory.bundled_hom.category_theory.concrete_category.{u_1} uniform_space.{u_1} (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β), @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ)) (@category_theory.unbundled_hom.bundled_hom.{u_1} (λ (α : Type u_1), uniform_space.{u_1} α) uniform_continuous.{u_1 u_1} UniformSpace.concrete_category_uniform_continuous.{u_1}))) (@category_theory.forget₂.{u_1} CpltSepUniformSpace.{u_1} UniformSpace.{u_1} CpltSepUniformSpace.concrete_category.{u_1} (@category_theory.bundled_hom.category_theory.concrete_category.{u_1} uniform_space.{u_1} (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β), @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ)) (@category_theory.unbundled_hom.bundled_hom.{u_1} (λ (α : Type u_1), uniform_space.{u_1} α) uniform_continuous.{u_1 u_1} UniformSpace.concrete_category_uniform_continuous.{u_1})) CpltSepUniformSpace.has_forget_to_UniformSpace.{u_1}) (@category_theory.functor.obj.{u_1 u_1 u_1+1 u_1+1} UniformSpace.{u_1} (@category_theory.bundled_hom.category.{u_1} uniform_space.{u_1} (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β), @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ)) (@category_theory.unbundled_hom.bundled_hom.{u_1} (λ (α : Type u_1), uniform_space.{u_1} α) uniform_continuous.{u_1 u_1} UniformSpace.concrete_category_uniform_continuous.{u_1})) CpltSepUniformSpace.{u_1} (@category_theory.concrete_category.to_category.{u_1} CpltSepUniformSpace.{u_1} CpltSepUniformSpace.concrete_category.{u_1}) UniformSpace.completion_functor.{u_1} X))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='UniformSpace.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@coe_sort.{u_1+2 u_1+2} UniformSpace.{u_1} (@category_theory.bundled.has_coe_to_sort.{u_1 u_1} uniform_space.{u_1}) X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@coe_sort.{u_1+2 u_1+2} UniformSpace.{u_1} (@category_theory.bundled.has_coe_to_sort.{u_1 u_1} uniform_space.{u_1}) X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π (α : Type u_1) [_inst_1 : uniform_space.{u_1} α], Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='UniformSpace.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='∀ {α : Type u_1} {a : α}, @eq.{u_1+1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The inclusion of any uniform spaces into its completion.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='Hausdorff completion of `α`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>118  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>119  /-- The mate of a morphism from a `UniformSpace` to a `CpltSepUniformSpace`. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>120  noncomputable def extension_hom {X : UniformSpace} {Y : CpltSepUniformSpace}</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='blue'><a title='UniformSpace'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='CpltSepUniformSpace'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='red'><a title='{&#x27;line&#x27;: 27, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;line&#x27;: 60, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='green'><a title='Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='orange'><a title='A (bundled) uniform spaces.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='A (bundled) complete separated uniform space.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>121    (f : X ⟶ (forget₂ CpltSepUniformSpace UniformSpace).obj Y) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.forget₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='CpltSepUniformSpace'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='UniformSpace'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/concrete_category/basic.lean&#x27;, &#x27;line&#x27;: 112, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 60, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 27, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='UniformSpace.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type (u_1+1)} [c : category_theory.has_hom.{u_1 u_1+1} obj], obj → obj → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (C D : Type (u+1)) [_inst_1 : category_theory.concrete_category.{u} C] [_inst_2 : category_theory.concrete_category.{u} D] [_inst_3 : @category_theory.has_forget₂.{u} C D _inst_1 _inst_2], @category_theory.functor.{u u u+1 u+1} C (@category_theory.concrete_category.to_category.{u} C _inst_1) D (@category_theory.concrete_category.to_category.{u} D _inst_2)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type (u_1+1)} [_inst_1 : category_theory.category.{u_1 u_1+1} C] {D : Type (u_1+1)} [_inst_2 : category_theory.category.{u_1 u_1+1} D], @category_theory.functor.{u_1 u_1 u_1+1 u_1+1} C _inst_1 D _inst_2 → C → D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='CpltSepUniformSpace.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title=' The forgetful functor `C ⥤ D` between concrete categories for which we have an instance
`has_forget₂ C `.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='A (bundled) complete separated uniform space.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='A (bundled) uniform spaces.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>122    completion_functor.obj X ⟶ Y :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='UniformSpace.completion_functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 97, &#x27;column&#x27;: 18}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.functor.{u_1 u_1 u_1+1 u_1+1} UniformSpace.{u_1} (@category_theory.bundled_hom.category.{u_1} uniform_space.{u_1} (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β), @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ)) (@category_theory.unbundled_hom.bundled_hom.{u_1} (λ (α : Type u_1), uniform_space.{u_1} α) uniform_continuous.{u_1 u_1} UniformSpace.concrete_category_uniform_continuous.{u_1})) CpltSepUniformSpace.{u_1} (@category_theory.concrete_category.to_category.{u_1} CpltSepUniformSpace.{u_1} CpltSepUniformSpace.concrete_category.{u_1})'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type (u_1+1)} [_inst_1 : category_theory.category.{u_1 u_1+1} C] {D : Type (u_1+1)} [_inst_2 : category_theory.category.{u_1 u_1+1} D], @category_theory.functor.{u_1 u_1 u_1+1 u_1+1} C _inst_1 D _inst_2 → C → D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='UniformSpace.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type (u_1+1)} [c : category_theory.has_hom.{u_1 u_1+1} obj], obj → obj → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='CpltSepUniformSpace.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The functor turning uniform spaces into complete separated uniform spaces.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>123  { val := completion.extension f,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='uniform_space.completion.extension'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/completion.lean&#x27;, &#x27;line&#x27;: 446, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : uniform_space.{u_1} α] {β : Type u_2} [_inst_2 : uniform_space.{u_2} β], (α → β) → @uniform_space.completion.{u_1} α _inst_1 → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{u_1 u_1+1} UniformSpace.{u_1} (@category_theory.category_struct.to_has_hom.{u_1 u_1+1} UniformSpace.{u_1} (@category_theory.category.to_category_struct.{u_1 u_1+1} UniformSpace.{u_1} (@category_theory.bundled_hom.category.{u_1} uniform_space.{u_1} (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β), @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ)) (@category_theory.unbundled_hom.bundled_hom.{u_1} (λ (α : Type u_1), uniform_space.{u_1} α) uniform_continuous.{u_1 u_1} UniformSpace.concrete_category_uniform_continuous.{u_1})))) X (@category_theory.functor.obj.{u_1 u_1 u_1+1 u_1+1} CpltSepUniformSpace.{u_1} (@category_theory.concrete_category.to_category.{u_1} CpltSepUniformSpace.{u_1} CpltSepUniformSpace.concrete_category.{u_1}) UniformSpace.{u_1} (@category_theory.concrete_category.to_category.{u_1} UniformSpace.{u_1} (@category_theory.bundled_hom.category_theory.concrete_category.{u_1} uniform_space.{u_1} (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β), @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ)) (@category_theory.unbundled_hom.bundled_hom.{u_1} (λ (α : Type u_1), uniform_space.{u_1} α) uniform_continuous.{u_1 u_1} UniformSpace.concrete_category_uniform_continuous.{u_1}))) (@category_theory.forget₂.{u_1} CpltSepUniformSpace.{u_1} UniformSpace.{u_1} CpltSepUniformSpace.concrete_category.{u_1} (@category_theory.bundled_hom.category_theory.concrete_category.{u_1} uniform_space.{u_1} (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β), @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ)) (@category_theory.unbundled_hom.bundled_hom.{u_1} (λ (α : Type u_1), uniform_space.{u_1} α) uniform_continuous.{u_1 u_1} UniformSpace.concrete_category_uniform_continuous.{u_1})) CpltSepUniformSpace.has_forget_to_UniformSpace.{u_1}) Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title=' &quot;Extension&quot; to the completion. It is defined for any map `f` but
returns an arbitrary constant value if `f` is not uniformly continuous'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>124    property := completion.uniform_continuous_extension }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='uniform_space.completion.uniform_continuous_extension'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/completion.lean&#x27;, &#x27;line&#x27;: 456, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : uniform_space.{u_1} α] {β : Type u_2} [_inst_2 : uniform_space.{u_2} β] {f : α → β} [_inst_4 : @separated.{u_2} β _inst_2] [_inst_5 : @complete_space.{u_2} β _inst_2], @uniform_continuous.{u_1 u_2} (@uniform_space.completion.{u_1} α _inst_1) β (@uniform_space.completion.uniform_space.{u_1} α _inst_1) _inst_2 (@uniform_space.completion.extension.{u_1 u_2} α _inst_1 β _inst_2 f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>125  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>126  @[simp] lemma extension_hom_val {X : UniformSpace} {Y : CpltSepUniformSpace}</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='blue'><a title='UniformSpace'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='CpltSepUniformSpace'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='red'><a title='{&#x27;line&#x27;: 27, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;line&#x27;: 60, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='green'><a title='Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='orange'><a title='A (bundled) uniform spaces.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='A (bundled) complete separated uniform space.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>127    (f : X ⟶ (forget₂ _ _).obj Y) (x) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.forget₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/concrete_category/basic.lean&#x27;, &#x27;line&#x27;: 112, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='UniformSpace.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type (u_1+1)} [c : category_theory.has_hom.{u_1 u_1+1} obj], obj → obj → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (C D : Type (u+1)) [_inst_1 : category_theory.concrete_category.{u} C] [_inst_2 : category_theory.concrete_category.{u} D] [_inst_3 : @category_theory.has_forget₂.{u} C D _inst_1 _inst_2], @category_theory.functor.{u u u+1 u+1} C (@category_theory.concrete_category.to_category.{u} C _inst_1) D (@category_theory.concrete_category.to_category.{u} D _inst_2)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {C : Type (u_1+1)} [_inst_1 : category_theory.category.{u_1 u_1+1} C] {D : Type (u_1+1)} [_inst_2 : category_theory.category.{u_1 u_1+1} D], @category_theory.functor.{u_1 u_1 u_1+1 u_1+1} C _inst_1 D _inst_2 → C → D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='CpltSepUniformSpace.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title=' The forgetful functor `C ⥤ D` between concrete categories for which we have an instance
`has_forget₂ C `.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>128    (extension_hom f) x = completion.extension f x := rfl.</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='UniformSpace.extension_hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='uniform_space.completion.extension'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 120, &#x27;column&#x27;: 18}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/completion.lean&#x27;, &#x27;line&#x27;: 446, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {X : UniformSpace.{u_1}} {Y : CpltSepUniformSpace.{u_1}}, @category_theory.has_hom.hom.{u_1 u_1+1} UniformSpace.{u_1} (@category_theory.category_struct.to_has_hom.{u_1 u_1+1} UniformSpace.{u_1} (@category_theory.category.to_category_struct.{u_1 u_1+1} UniformSpace.{u_1} (@category_theory.bundled_hom.category.{u_1} uniform_space.{u_1} (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β), @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ)) (@category_theory.unbundled_hom.bundled_hom.{u_1} (λ (α : Type u_1), uniform_space.{u_1} α) uniform_continuous.{u_1 u_1} UniformSpace.concrete_category_uniform_continuous.{u_1})))) X (@category_theory.functor.obj.{u_1 u_1 u_1+1 u_1+1} CpltSepUniformSpace.{u_1} (@category_theory.concrete_category.to_category.{u_1} CpltSepUniformSpace.{u_1} CpltSepUniformSpace.concrete_category.{u_1}) UniformSpace.{u_1} (@category_theory.concrete_category.to_category.{u_1} UniformSpace.{u_1} (@category_theory.bundled_hom.category_theory.concrete_category.{u_1} uniform_space.{u_1} (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β), @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ)) (@category_theory.unbundled_hom.bundled_hom.{u_1} (λ (α : Type u_1), uniform_space.{u_1} α) uniform_continuous.{u_1 u_1} UniformSpace.concrete_category_uniform_continuous.{u_1}))) (@category_theory.forget₂.{u_1} CpltSepUniformSpace.{u_1} UniformSpace.{u_1} CpltSepUniformSpace.concrete_category.{u_1} (@category_theory.bundled_hom.category_theory.concrete_category.{u_1} uniform_space.{u_1} (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β), @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ)) (@category_theory.unbundled_hom.bundled_hom.{u_1} (λ (α : Type u_1), uniform_space.{u_1} α) uniform_continuous.{u_1 u_1} UniformSpace.concrete_category_uniform_continuous.{u_1})) CpltSepUniformSpace.has_forget_to_UniformSpace.{u_1}) Y) → @category_theory.has_hom.hom.{u_1 u_1+1} CpltSepUniformSpace.{u_1} (@category_theory.category_struct.to_has_hom.{u_1 u_1+1} CpltSepUniformSpace.{u_1} (@category_theory.category.to_category_struct.{u_1 u_1+1} CpltSepUniformSpace.{u_1} (@category_theory.concrete_category.to_category.{u_1} CpltSepUniformSpace.{u_1} CpltSepUniformSpace.concrete_category.{u_1}))) (@category_theory.functor.obj.{u_1 u_1 u_1+1 u_1+1} UniformSpace.{u_1} (@category_theory.bundled_hom.category.{u_1} uniform_space.{u_1} (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β), @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ)) (@category_theory.unbundled_hom.bundled_hom.{u_1} (λ (α : Type u_1), uniform_space.{u_1} α) uniform_continuous.{u_1 u_1} UniformSpace.concrete_category_uniform_continuous.{u_1})) CpltSepUniformSpace.{u_1} (@category_theory.concrete_category.to_category.{u_1} CpltSepUniformSpace.{u_1} CpltSepUniformSpace.concrete_category.{u_1}) UniformSpace.completion_functor.{u_1} X) Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{u_1 u_1+1} UniformSpace.{u_1} (@category_theory.category_struct.to_has_hom.{u_1 u_1+1} UniformSpace.{u_1} (@category_theory.category.to_category_struct.{u_1 u_1+1} UniformSpace.{u_1} (@category_theory.bundled_hom.category.{u_1} uniform_space.{u_1} (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β), @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ)) (@category_theory.unbundled_hom.bundled_hom.{u_1} (λ (α : Type u_1), uniform_space.{u_1} α) uniform_continuous.{u_1 u_1} UniformSpace.concrete_category_uniform_continuous.{u_1})))) X (@category_theory.functor.obj.{u_1 u_1 u_1+1 u_1+1} CpltSepUniformSpace.{u_1} (@category_theory.concrete_category.to_category.{u_1} CpltSepUniformSpace.{u_1} CpltSepUniformSpace.concrete_category.{u_1}) UniformSpace.{u_1} (@category_theory.concrete_category.to_category.{u_1} UniformSpace.{u_1} (@category_theory.bundled_hom.category_theory.concrete_category.{u_1} uniform_space.{u_1} (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β), @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ)) (@category_theory.unbundled_hom.bundled_hom.{u_1} (λ (α : Type u_1), uniform_space.{u_1} α) uniform_continuous.{u_1 u_1} UniformSpace.concrete_category_uniform_continuous.{u_1}))) (@category_theory.forget₂.{u_1} CpltSepUniformSpace.{u_1} UniformSpace.{u_1} CpltSepUniformSpace.concrete_category.{u_1} (@category_theory.bundled_hom.category_theory.concrete_category.{u_1} uniform_space.{u_1} (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β), @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ)) (@category_theory.unbundled_hom.bundled_hom.{u_1} (λ (α : Type u_1), uniform_space.{u_1} α) uniform_continuous.{u_1 u_1} UniformSpace.concrete_category_uniform_continuous.{u_1})) CpltSepUniformSpace.has_forget_to_UniformSpace.{u_1}) Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@coe_sort.{u_1+2 u_1+2} UniformSpace.{u_1} (@category_theory.bundled.has_coe_to_sort.{u_1 u_1} uniform_space.{u_1}) (CpltSepUniformSpace.to_UniformSpace.{u_1} (@category_theory.functor.obj.{u_1 u_1 u_1+1 u_1+1} UniformSpace.{u_1} (@category_theory.bundled_hom.category.{u_1} uniform_space.{u_1} (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β), @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ)) (@category_theory.unbundled_hom.bundled_hom.{u_1} (λ (α : Type u_1), uniform_space.{u_1} α) uniform_continuous.{u_1 u_1} UniformSpace.concrete_category_uniform_continuous.{u_1})) CpltSepUniformSpace.{u_1} (@category_theory.concrete_category.to_category.{u_1} CpltSepUniformSpace.{u_1} CpltSepUniformSpace.concrete_category.{u_1}) UniformSpace.completion_functor.{u_1} X))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : uniform_space.{u_1} α] {β : Type u_2} [_inst_2 : uniform_space.{u_2} β], (α → β) → @uniform_space.completion.{u_1} α _inst_1 → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{u_1 u_1+1} UniformSpace.{u_1} (@category_theory.category_struct.to_has_hom.{u_1 u_1+1} UniformSpace.{u_1} (@category_theory.category.to_category_struct.{u_1 u_1+1} UniformSpace.{u_1} (@category_theory.bundled_hom.category.{u_1} uniform_space.{u_1} (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β), @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ)) (@category_theory.unbundled_hom.bundled_hom.{u_1} (λ (α : Type u_1), uniform_space.{u_1} α) uniform_continuous.{u_1 u_1} UniformSpace.concrete_category_uniform_continuous.{u_1})))) X (@category_theory.functor.obj.{u_1 u_1 u_1+1 u_1+1} CpltSepUniformSpace.{u_1} (@category_theory.concrete_category.to_category.{u_1} CpltSepUniformSpace.{u_1} CpltSepUniformSpace.concrete_category.{u_1}) UniformSpace.{u_1} (@category_theory.concrete_category.to_category.{u_1} UniformSpace.{u_1} (@category_theory.bundled_hom.category_theory.concrete_category.{u_1} uniform_space.{u_1} (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β), @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ)) (@category_theory.unbundled_hom.bundled_hom.{u_1} (λ (α : Type u_1), uniform_space.{u_1} α) uniform_continuous.{u_1 u_1} UniformSpace.concrete_category_uniform_continuous.{u_1}))) (@category_theory.forget₂.{u_1} CpltSepUniformSpace.{u_1} UniformSpace.{u_1} CpltSepUniformSpace.concrete_category.{u_1} (@category_theory.bundled_hom.category_theory.concrete_category.{u_1} uniform_space.{u_1} (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β), @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ)) (@category_theory.unbundled_hom.bundled_hom.{u_1} (λ (α : Type u_1), uniform_space.{u_1} α) uniform_continuous.{u_1 u_1} UniformSpace.concrete_category_uniform_continuous.{u_1})) CpltSepUniformSpace.has_forget_to_UniformSpace.{u_1}) Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@coe_sort.{u_1+2 u_1+2} UniformSpace.{u_1} (@category_theory.bundled.has_coe_to_sort.{u_1 u_1} uniform_space.{u_1}) (CpltSepUniformSpace.to_UniformSpace.{u_1} (@category_theory.functor.obj.{u_1 u_1 u_1+1 u_1+1} UniformSpace.{u_1} (@category_theory.bundled_hom.category.{u_1} uniform_space.{u_1} (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β), @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ)) (@category_theory.unbundled_hom.bundled_hom.{u_1} (λ (α : Type u_1), uniform_space.{u_1} α) uniform_continuous.{u_1 u_1} UniformSpace.concrete_category_uniform_continuous.{u_1})) CpltSepUniformSpace.{u_1} (@category_theory.concrete_category.to_category.{u_1} CpltSepUniformSpace.{u_1} CpltSepUniformSpace.concrete_category.{u_1}) UniformSpace.completion_functor.{u_1} X))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {α : Type u_1} {a : α}, @eq.{u_1+1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The mate of a morphism from a `UniformSpace` to a `CpltSepUniformSpace`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title=' &quot;Extension&quot; to the completion. It is defined for any map `f` but
returns an arbitrary constant value if `f` is not uniformly continuous'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>129  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>130  @[simp] lemma extension_comp_coe {X : UniformSpace} {Y : CpltSepUniformSpace}</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='blue'><a title='UniformSpace'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='CpltSepUniformSpace'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='red'><a title='{&#x27;line&#x27;: 27, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;line&#x27;: 60, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='green'><a title='Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='orange'><a title='A (bundled) uniform spaces.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='A (bundled) complete separated uniform space.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>131  (f : to_UniformSpace (CpltSepUniformSpace.of (completion X)) ⟶ to_UniformSpace Y) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='CpltSepUniformSpace.to_UniformSpace'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='CpltSepUniformSpace.of'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='uniform_space.completion'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='CpltSepUniformSpace.to_UniformSpace'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 73, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 80, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/completion.lean&#x27;, &#x27;line&#x27;: 322, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 73, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='CpltSepUniformSpace.{u_1} → UniformSpace.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (X : Type u) [_inst_1 : uniform_space.{u} X] [_inst_2 : @complete_space.{u} X _inst_1] [_inst_3 : @separated.{u} X _inst_1], CpltSepUniformSpace.{u}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (α : Type u_1) [_inst_1 : uniform_space.{u_1} α], Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='UniformSpace.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {obj : Type (u_1+1)} [c : category_theory.has_hom.{u_1 u_1+1} obj], obj → obj → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='CpltSepUniformSpace.{u_1} → UniformSpace.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='CpltSepUniformSpace.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='orange'><a title='Construct a bundled `UniformSpace` from the underlying type and the appropriate typeclasses.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Hausdorff completion of `α`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>132  extension_hom (completion_hom X ≫ f) = f :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='UniformSpace.extension_hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='UniformSpace.completion_hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 120, &#x27;column&#x27;: 18}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 111, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {X : UniformSpace.{u_1}} {Y : CpltSepUniformSpace.{u_1}}, @category_theory.has_hom.hom.{u_1 u_1+1} UniformSpace.{u_1} (@category_theory.category_struct.to_has_hom.{u_1 u_1+1} UniformSpace.{u_1} (@category_theory.category.to_category_struct.{u_1 u_1+1} UniformSpace.{u_1} (@category_theory.bundled_hom.category.{u_1} uniform_space.{u_1} (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β), @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ)) (@category_theory.unbundled_hom.bundled_hom.{u_1} (λ (α : Type u_1), uniform_space.{u_1} α) uniform_continuous.{u_1 u_1} UniformSpace.concrete_category_uniform_continuous.{u_1})))) X (@category_theory.functor.obj.{u_1 u_1 u_1+1 u_1+1} CpltSepUniformSpace.{u_1} (@category_theory.concrete_category.to_category.{u_1} CpltSepUniformSpace.{u_1} CpltSepUniformSpace.concrete_category.{u_1}) UniformSpace.{u_1} (@category_theory.concrete_category.to_category.{u_1} UniformSpace.{u_1} (@category_theory.bundled_hom.category_theory.concrete_category.{u_1} uniform_space.{u_1} (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β), @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ)) (@category_theory.unbundled_hom.bundled_hom.{u_1} (λ (α : Type u_1), uniform_space.{u_1} α) uniform_continuous.{u_1 u_1} UniformSpace.concrete_category_uniform_continuous.{u_1}))) (@category_theory.forget₂.{u_1} CpltSepUniformSpace.{u_1} UniformSpace.{u_1} CpltSepUniformSpace.concrete_category.{u_1} (@category_theory.bundled_hom.category_theory.concrete_category.{u_1} uniform_space.{u_1} (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β), @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ)) (@category_theory.unbundled_hom.bundled_hom.{u_1} (λ (α : Type u_1), uniform_space.{u_1} α) uniform_continuous.{u_1 u_1} UniformSpace.concrete_category_uniform_continuous.{u_1})) CpltSepUniformSpace.has_forget_to_UniformSpace.{u_1}) Y) → @category_theory.has_hom.hom.{u_1 u_1+1} CpltSepUniformSpace.{u_1} (@category_theory.category_struct.to_has_hom.{u_1 u_1+1} CpltSepUniformSpace.{u_1} (@category_theory.category.to_category_struct.{u_1 u_1+1} CpltSepUniformSpace.{u_1} (@category_theory.concrete_category.to_category.{u_1} CpltSepUniformSpace.{u_1} CpltSepUniformSpace.concrete_category.{u_1}))) (@category_theory.functor.obj.{u_1 u_1 u_1+1 u_1+1} UniformSpace.{u_1} (@category_theory.bundled_hom.category.{u_1} uniform_space.{u_1} (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β), @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ)) (@category_theory.unbundled_hom.bundled_hom.{u_1} (λ (α : Type u_1), uniform_space.{u_1} α) uniform_continuous.{u_1 u_1} UniformSpace.concrete_category_uniform_continuous.{u_1})) CpltSepUniformSpace.{u_1} (@category_theory.concrete_category.to_category.{u_1} CpltSepUniformSpace.{u_1} CpltSepUniformSpace.concrete_category.{u_1}) UniformSpace.completion_functor.{u_1} X) Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (X : UniformSpace.{u_1}), @category_theory.has_hom.hom.{u_1 u_1+1} UniformSpace.{u_1} (@category_theory.category_struct.to_has_hom.{u_1 u_1+1} UniformSpace.{u_1} (@category_theory.category.to_category_struct.{u_1 u_1+1} UniformSpace.{u_1} (@category_theory.bundled_hom.category.{u_1} uniform_space.{u_1} (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β), @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ)) (@category_theory.unbundled_hom.bundled_hom.{u_1} (λ (α : Type u_1), uniform_space.{u_1} α) uniform_continuous.{u_1 u_1} UniformSpace.concrete_category_uniform_continuous.{u_1})))) X (@category_theory.functor.obj.{u_1 u_1 u_1+1 u_1+1} CpltSepUniformSpace.{u_1} (@category_theory.concrete_category.to_category.{u_1} CpltSepUniformSpace.{u_1} CpltSepUniformSpace.concrete_category.{u_1}) UniformSpace.{u_1} (@category_theory.concrete_category.to_category.{u_1} UniformSpace.{u_1} (@category_theory.bundled_hom.category_theory.concrete_category.{u_1} uniform_space.{u_1} (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β), @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ)) (@category_theory.unbundled_hom.bundled_hom.{u_1} (λ (α : Type u_1), uniform_space.{u_1} α) uniform_continuous.{u_1 u_1} UniformSpace.concrete_category_uniform_continuous.{u_1}))) (@category_theory.forget₂.{u_1} CpltSepUniformSpace.{u_1} UniformSpace.{u_1} CpltSepUniformSpace.concrete_category.{u_1} (@category_theory.bundled_hom.category_theory.concrete_category.{u_1} uniform_space.{u_1} (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β), @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ)) (@category_theory.unbundled_hom.bundled_hom.{u_1} (λ (α : Type u_1), uniform_space.{u_1} α) uniform_continuous.{u_1 u_1} UniformSpace.concrete_category_uniform_continuous.{u_1})) CpltSepUniformSpace.has_forget_to_UniformSpace.{u_1}) (@category_theory.functor.obj.{u_1 u_1 u_1+1 u_1+1} UniformSpace.{u_1} (@category_theory.bundled_hom.category.{u_1} uniform_space.{u_1} (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β), @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ)) (@category_theory.unbundled_hom.bundled_hom.{u_1} (λ (α : Type u_1), uniform_space.{u_1} α) uniform_continuous.{u_1 u_1} UniformSpace.concrete_category_uniform_continuous.{u_1})) CpltSepUniformSpace.{u_1} (@category_theory.concrete_category.to_category.{u_1} CpltSepUniformSpace.{u_1} CpltSepUniformSpace.concrete_category.{u_1}) UniformSpace.completion_functor.{u_1} X))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='UniformSpace.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type (u_1+1)} [c : category_theory.category_struct.{u_1 u_1+1} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{u_1 u_1+1} obj (@category_theory.category_struct.to_has_hom.{u_1 u_1+1} obj c) X Y → @category_theory.has_hom.hom.{u_1 u_1+1} obj (@category_theory.category_struct.to_has_hom.{u_1 u_1+1} obj c) Y Z → @category_theory.has_hom.hom.{u_1 u_1+1} obj (@category_theory.category_struct.to_has_hom.{u_1 u_1+1} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{u_1 u_1+1} UniformSpace.{u_1} (@category_theory.category_struct.to_has_hom.{u_1 u_1+1} UniformSpace.{u_1} (@category_theory.category.to_category_struct.{u_1 u_1+1} UniformSpace.{u_1} (@category_theory.bundled_hom.category.{u_1} uniform_space.{u_1} (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β), @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ)) (@category_theory.unbundled_hom.bundled_hom.{u_1} (λ (α : Type u_1), uniform_space.{u_1} α) uniform_continuous.{u_1 u_1} UniformSpace.concrete_category_uniform_continuous.{u_1})))) (CpltSepUniformSpace.to_UniformSpace.{u_1} (@CpltSepUniformSpace.of.{u_1} (@uniform_space.completion.{u_1} (@coe_sort.{u_1+2 u_1+2} UniformSpace.{u_1} (@category_theory.bundled.has_coe_to_sort.{u_1 u_1} uniform_space.{u_1}) X) (UniformSpace.uniform_space.{u_1} X)) (@uniform_space.completion.uniform_space.{u_1} (@coe_sort.{u_1+2 u_1+2} UniformSpace.{u_1} (@category_theory.bundled.has_coe_to_sort.{u_1 u_1} uniform_space.{u_1}) X) (UniformSpace.uniform_space.{u_1} X)) (@uniform_space.completion.complete_space.{u_1} (@coe_sort.{u_1+2 u_1+2} UniformSpace.{u_1} (@category_theory.bundled.has_coe_to_sort.{u_1 u_1} uniform_space.{u_1}) X) (UniformSpace.uniform_space.{u_1} X)) (@uniform_space.completion.separated.{u_1} (@coe_sort.{u_1+2 u_1+2} UniformSpace.{u_1} (@category_theory.bundled.has_coe_to_sort.{u_1 u_1} uniform_space.{u_1}) X) (UniformSpace.uniform_space.{u_1} X)))) (CpltSepUniformSpace.to_UniformSpace.{u_1} Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{u_1 u_1+1} UniformSpace.{u_1} (@category_theory.category_struct.to_has_hom.{u_1 u_1+1} UniformSpace.{u_1} (@category_theory.category.to_category_struct.{u_1 u_1+1} UniformSpace.{u_1} (@category_theory.bundled_hom.category.{u_1} uniform_space.{u_1} (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β), @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ)) (@category_theory.unbundled_hom.bundled_hom.{u_1} (λ (α : Type u_1), uniform_space.{u_1} α) uniform_continuous.{u_1 u_1} UniformSpace.concrete_category_uniform_continuous.{u_1})))) (CpltSepUniformSpace.to_UniformSpace.{u_1} (@CpltSepUniformSpace.of.{u_1} (@uniform_space.completion.{u_1} (@coe_sort.{u_1+2 u_1+2} UniformSpace.{u_1} (@category_theory.bundled.has_coe_to_sort.{u_1 u_1} uniform_space.{u_1}) X) (UniformSpace.uniform_space.{u_1} X)) (@uniform_space.completion.uniform_space.{u_1} (@coe_sort.{u_1+2 u_1+2} UniformSpace.{u_1} (@category_theory.bundled.has_coe_to_sort.{u_1 u_1} uniform_space.{u_1}) X) (UniformSpace.uniform_space.{u_1} X)) (@uniform_space.completion.complete_space.{u_1} (@coe_sort.{u_1+2 u_1+2} UniformSpace.{u_1} (@category_theory.bundled.has_coe_to_sort.{u_1 u_1} uniform_space.{u_1}) X) (UniformSpace.uniform_space.{u_1} X)) (@uniform_space.completion.separated.{u_1} (@coe_sort.{u_1+2 u_1+2} UniformSpace.{u_1} (@category_theory.bundled.has_coe_to_sort.{u_1 u_1} uniform_space.{u_1}) X) (UniformSpace.uniform_space.{u_1} X)))) (CpltSepUniformSpace.to_UniformSpace.{u_1} Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The mate of a morphism from a `UniformSpace` to a `CpltSepUniformSpace`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The inclusion of any uniform spaces into its completion.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>133  by { apply subtype.eq, funext x, exact congr_fun (completion.extension_comp_coe f.property) x }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='subtype.eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='blue'><a title='congr_fun'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='uniform_space.completion.extension_comp_coe'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/subtype/basic.lean&#x27;, &#x27;line&#x27;: 22, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1489, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 70, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/completion.lean&#x27;, &#x27;line&#x27;: 466, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 258, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {p : α → Prop} {a1 a2 : @subtype.{u_1+1} α (λ (x : α), p x)}, @eq.{u_1+1} α (@subtype.val.{u_1+1} α (λ (x : α), p x) a1) (@subtype.val.{u_1+1} α (λ (x : α), p x) a2) → @eq.{(max 1 (u_1+1))} (@subtype.{u_1+1} α (λ (x : α), p x)) a1 a2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {β : α → Type u_1} {f g : Π (x : α), β x}, @eq.{u_1+1} (Π (x : α), β x) f g → ∀ (a : α), @eq.{u_1+1} (β a) (f a) (g a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : uniform_space.{u_1} α] {β : Type u_1} [_inst_2 : uniform_space.{u_1} β] [_inst_4 : @separated.{u_1} β _inst_2] [_inst_5 : @complete_space.{u_1} β _inst_2] {f : @uniform_space.completion.{u_1} α _inst_1 → β}, @uniform_continuous.{u_1 u_1} (@uniform_space.completion.{u_1} α _inst_1) β (@uniform_space.completion.uniform_space.{u_1} α _inst_1) _inst_2 f → @eq.{u_1+1} (@uniform_space.completion.{u_1} α _inst_1 → β) (@uniform_space.completion.extension.{u_1 u_1} α _inst_1 β _inst_2 (@function.comp.{u_1+1 u_1+1 u_1+1} α (@uniform_space.completion.{u_1} α _inst_1) β f (@coe.{u_1+1 u_1+1} α (@uniform_space.completion.{u_1} α _inst_1) (@coe_to_lift.{u_1+1 u_1+1} α (@uniform_space.completion.{u_1} α _inst_1) (@uniform_space.completion.has_coe_t.{u_1} α _inst_1))))) f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@category_theory.has_hom.hom.{u_1 u_1+1} UniformSpace.{u_1} (@category_theory.category_struct.to_has_hom.{u_1 u_1+1} UniformSpace.{u_1} (@category_theory.category.to_category_struct.{u_1 u_1+1} UniformSpace.{u_1} (@category_theory.bundled_hom.category.{u_1} uniform_space.{u_1} (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β), @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ)) (@category_theory.unbundled_hom.bundled_hom.{u_1} (λ (α : Type u_1), uniform_space.{u_1} α) uniform_continuous.{u_1 u_1} UniformSpace.concrete_category_uniform_continuous.{u_1})))) (CpltSepUniformSpace.to_UniformSpace.{u_1} (@CpltSepUniformSpace.of.{u_1} (@uniform_space.completion.{u_1} (@coe_sort.{u_1+2 u_1+2} UniformSpace.{u_1} (@category_theory.bundled.has_coe_to_sort.{u_1 u_1} uniform_space.{u_1}) X) (UniformSpace.uniform_space.{u_1} X)) (@uniform_space.completion.uniform_space.{u_1} (@coe_sort.{u_1+2 u_1+2} UniformSpace.{u_1} (@category_theory.bundled.has_coe_to_sort.{u_1 u_1} uniform_space.{u_1}) X) (UniformSpace.uniform_space.{u_1} X)) (@uniform_space.completion.complete_space.{u_1} (@coe_sort.{u_1+2 u_1+2} UniformSpace.{u_1} (@category_theory.bundled.has_coe_to_sort.{u_1 u_1} uniform_space.{u_1}) X) (UniformSpace.uniform_space.{u_1} X)) (@uniform_space.completion.separated.{u_1} (@coe_sort.{u_1+2 u_1+2} UniformSpace.{u_1} (@category_theory.bundled.has_coe_to_sort.{u_1 u_1} uniform_space.{u_1}) X) (UniformSpace.uniform_space.{u_1} X)))) (CpltSepUniformSpace.to_UniformSpace.{u_1} Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@category_theory.bundled.α.{u_1 u_1} uniform_space.{u_1} (CpltSepUniformSpace.to_UniformSpace.{u_1} (@category_theory.functor.obj.{u_1 u_1 u_1+1 u_1+1} UniformSpace.{u_1} (@category_theory.bundled_hom.category.{u_1} uniform_space.{u_1} (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β), @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ)) (@category_theory.unbundled_hom.bundled_hom.{u_1} (λ (α : Type u_1), uniform_space.{u_1} α) uniform_continuous.{u_1 u_1} UniformSpace.concrete_category_uniform_continuous.{u_1})) CpltSepUniformSpace.{u_1} (@category_theory.concrete_category.to_category.{u_1} CpltSepUniformSpace.{u_1} CpltSepUniformSpace.concrete_category.{u_1}) UniformSpace.completion_functor.{u_1} X))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='Apply function extensionality and introduce new hypotheses.
The tactic `funext` will keep applying new the `funext` lemma until the goal target is not reducible to
```lean
  |-  ((fun x, ...) = (fun x, ...))
```
The variant `funext h₁ ... hₙ` applies `funext` `n` times, and uses the given identifiers to name the new hypotheses.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='funext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='X : UniformSpace.{u_1},
Y : CpltSepUniformSpace.{u_1},
f :
  @category_theory.has_hom.hom.{u_1 u_1+1} UniformSpace.{u_1}
    (@category_theory.category_struct.to_has_hom.{u_1 u_1+1} UniformSpace.{u_1}
       (@category_theory.category.to_category_struct.{u_1 u_1+1} UniformSpace.{u_1}
          (@category_theory.bundled_hom.category.{u_1} uniform_space.{u_1}
             (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β),
                @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{u_1} (λ (α : Type u_1), uniform_space.{u_1} α)
                uniform_continuous.{u_1 u_1}
                UniformSpace.concrete_category_uniform_continuous.{u_1}))))
    (CpltSepUniformSpace.to_UniformSpace.{u_1}
       (@CpltSepUniformSpace.of.{u_1}
          (@uniform_space.completion.{u_1}
             (@coe_sort.{u_1+2 u_1+2} UniformSpace.{u_1}
                (@category_theory.bundled.has_coe_to_sort.{u_1 u_1} uniform_space.{u_1})
                X)
             (UniformSpace.uniform_space.{u_1} X))
          (@uniform_space.completion.uniform_space.{u_1}
             (@coe_sort.{u_1+2 u_1+2} UniformSpace.{u_1}
                (@category_theory.bundled.has_coe_to_sort.{u_1 u_1} uniform_space.{u_1})
                X)
             (UniformSpace.uniform_space.{u_1} X))
          (@uniform_space.completion.complete_space.{u_1}
             (@coe_sort.{u_1+2 u_1+2} UniformSpace.{u_1}
                (@category_theory.bundled.has_coe_to_sort.{u_1 u_1} uniform_space.{u_1})
                X)
             (UniformSpace.uniform_space.{u_1} X))
          (@uniform_space.completion.separated.{u_1}
             (@coe_sort.{u_1+2 u_1+2} UniformSpace.{u_1}
                (@category_theory.bundled.has_coe_to_sort.{u_1 u_1} uniform_space.{u_1})
                X)
             (UniformSpace.uniform_space.{u_1} X))))
    (CpltSepUniformSpace.to_UniformSpace.{u_1} Y)
⊢ @eq.{u_1+1}
    (@category_theory.has_hom.hom.{u_1 u_1+1} CpltSepUniformSpace.{u_1}
       (@category_theory.category_struct.to_has_hom.{u_1 u_1+1} CpltSepUniformSpace.{u_1}
          (@category_theory.category.to_category_struct.{u_1 u_1+1} CpltSepUniformSpace.{u_1}
             (@category_theory.concrete_category.to_category.{u_1} CpltSepUniformSpace.{u_1}
                CpltSepUniformSpace.concrete_category.{u_1})))
       (@category_theory.functor.obj.{u_1 u_1 u_1+1 u_1+1} UniformSpace.{u_1}
          (@category_theory.bundled_hom.category.{u_1} uniform_space.{u_1}
             (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β),
                @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{u_1} (λ (α : Type u_1), uniform_space.{u_1} α)
                uniform_continuous.{u_1 u_1}
                UniformSpace.concrete_category_uniform_continuous.{u_1}))
          CpltSepUniformSpace.{u_1}
          (@category_theory.concrete_category.to_category.{u_1} CpltSepUniformSpace.{u_1}
             CpltSepUniformSpace.concrete_category.{u_1})
          UniformSpace.completion_functor.{u_1}
          X)
       Y)
    (@UniformSpace.extension_hom.{u_1} X Y
       (@category_theory.category_struct.comp.{u_1 u_1+1} UniformSpace.{u_1}
          (@category_theory.category.to_category_struct.{u_1 u_1+1} UniformSpace.{u_1}
             (@category_theory.bundled_hom.category.{u_1} uniform_space.{u_1}
                (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β),
                   @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{u_1} (λ (α : Type u_1), uniform_space.{u_1} α)
                   uniform_continuous.{u_1 u_1}
                   UniformSpace.concrete_category_uniform_continuous.{u_1})))
          X
          (@category_theory.functor.obj.{u_1 u_1 u_1+1 u_1+1} CpltSepUniformSpace.{u_1}
             (@category_theory.concrete_category.to_category.{u_1} CpltSepUniformSpace.{u_1}
                CpltSepUniformSpace.concrete_category.{u_1})
             UniformSpace.{u_1}
             (@category_theory.concrete_category.to_category.{u_1} UniformSpace.{u_1}
                (@category_theory.bundled_hom.category_theory.concrete_category.{u_1} uniform_space.{u_1}
                   (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β),
                      @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ))
                   (@category_theory.unbundled_hom.bundled_hom.{u_1} (λ (α : Type u_1), uniform_space.{u_1} α)
                      uniform_continuous.{u_1 u_1}
                      UniformSpace.concrete_category_uniform_continuous.{u_1})))
             (@category_theory.forget₂.{u_1} CpltSepUniformSpace.{u_1} UniformSpace.{u_1}
                CpltSepUniformSpace.concrete_category.{u_1}
                (@category_theory.bundled_hom.category_theory.concrete_category.{u_1} uniform_space.{u_1}
                   (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β),
                      @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ))
                   (@category_theory.unbundled_hom.bundled_hom.{u_1} (λ (α : Type u_1), uniform_space.{u_1} α)
                      uniform_continuous.{u_1 u_1}
                      UniformSpace.concrete_category_uniform_continuous.{u_1}))
                CpltSepUniformSpace.has_forget_to_UniformSpace.{u_1})
             (@category_theory.functor.obj.{u_1 u_1 u_1+1 u_1+1} UniformSpace.{u_1}
                (@category_theory.bundled_hom.category.{u_1} uniform_space.{u_1}
                   (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β),
                      @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ))
                   (@category_theory.unbundled_hom.bundled_hom.{u_1} (λ (α : Type u_1), uniform_space.{u_1} α)
                      uniform_continuous.{u_1 u_1}
                      UniformSpace.concrete_category_uniform_continuous.{u_1}))
                CpltSepUniformSpace.{u_1}
                (@category_theory.concrete_category.to_category.{u_1} CpltSepUniformSpace.{u_1}
                   CpltSepUniformSpace.concrete_category.{u_1})
                UniformSpace.completion_functor.{u_1}
                X))
          (@category_theory.functor.obj.{u_1 u_1 u_1+1 u_1+1} CpltSepUniformSpace.{u_1}
             (@category_theory.concrete_category.to_category.{u_1} CpltSepUniformSpace.{u_1}
                CpltSepUniformSpace.concrete_category.{u_1})
             UniformSpace.{u_1}
             (@category_theory.concrete_category.to_category.{u_1} UniformSpace.{u_1}
                (@category_theory.bundled_hom.category_theory.concrete_category.{u_1} uniform_space.{u_1}
                   (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β),
                      @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ))
                   (@category_theory.unbundled_hom.bundled_hom.{u_1} (λ (α : Type u_1), uniform_space.{u_1} α)
                      uniform_continuous.{u_1 u_1}
                      UniformSpace.concrete_category_uniform_continuous.{u_1})))
             (@category_theory.forget₂.{u_1} CpltSepUniformSpace.{u_1} UniformSpace.{u_1}
                CpltSepUniformSpace.concrete_category.{u_1}
                (@category_theory.bundled_hom.category_theory.concrete_category.{u_1} uniform_space.{u_1}
                   (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β),
                      @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ))
                   (@category_theory.unbundled_hom.bundled_hom.{u_1} (λ (α : Type u_1), uniform_space.{u_1} α)
                      uniform_continuous.{u_1 u_1}
                      UniformSpace.concrete_category_uniform_continuous.{u_1}))
                CpltSepUniformSpace.has_forget_to_UniformSpace.{u_1})
             Y)
          (UniformSpace.completion_hom.{u_1} X)
          f))
    f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='X : UniformSpace.{u_1},
Y : CpltSepUniformSpace.{u_1},
f :
  @category_theory.has_hom.hom.{u_1 u_1+1} UniformSpace.{u_1}
    (@category_theory.category_struct.to_has_hom.{u_1 u_1+1} UniformSpace.{u_1}
       (@category_theory.category.to_category_struct.{u_1 u_1+1} UniformSpace.{u_1}
          (@category_theory.bundled_hom.category.{u_1} uniform_space.{u_1}
             (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β),
                @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{u_1} (λ (α : Type u_1), uniform_space.{u_1} α)
                uniform_continuous.{u_1 u_1}
                UniformSpace.concrete_category_uniform_continuous.{u_1}))))
    (CpltSepUniformSpace.to_UniformSpace.{u_1}
       (@CpltSepUniformSpace.of.{u_1}
          (@uniform_space.completion.{u_1}
             (@coe_sort.{u_1+2 u_1+2} UniformSpace.{u_1}
                (@category_theory.bundled.has_coe_to_sort.{u_1 u_1} uniform_space.{u_1})
                X)
             (UniformSpace.uniform_space.{u_1} X))
          (@uniform_space.completion.uniform_space.{u_1}
             (@coe_sort.{u_1+2 u_1+2} UniformSpace.{u_1}
                (@category_theory.bundled.has_coe_to_sort.{u_1 u_1} uniform_space.{u_1})
                X)
             (UniformSpace.uniform_space.{u_1} X))
          (@uniform_space.completion.complete_space.{u_1}
             (@coe_sort.{u_1+2 u_1+2} UniformSpace.{u_1}
                (@category_theory.bundled.has_coe_to_sort.{u_1 u_1} uniform_space.{u_1})
                X)
             (UniformSpace.uniform_space.{u_1} X))
          (@uniform_space.completion.separated.{u_1}
             (@coe_sort.{u_1+2 u_1+2} UniformSpace.{u_1}
                (@category_theory.bundled.has_coe_to_sort.{u_1 u_1} uniform_space.{u_1})
                X)
             (UniformSpace.uniform_space.{u_1} X))))
    (CpltSepUniformSpace.to_UniformSpace.{u_1} Y)
⊢ @eq.{u_1+1}
    (@category_theory.bundled.α.{u_1 u_1} uniform_space.{u_1}
       (CpltSepUniformSpace.to_UniformSpace.{u_1}
          (@category_theory.functor.obj.{u_1 u_1 u_1+1 u_1+1} UniformSpace.{u_1}
             (@category_theory.bundled_hom.category.{u_1} uniform_space.{u_1}
                (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β),
                   @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{u_1} (λ (α : Type u_1), uniform_space.{u_1} α)
                   uniform_continuous.{u_1 u_1}
                   UniformSpace.concrete_category_uniform_continuous.{u_1}))
             CpltSepUniformSpace.{u_1}
             (@category_theory.concrete_category.to_category.{u_1} CpltSepUniformSpace.{u_1}
                CpltSepUniformSpace.concrete_category.{u_1})
             UniformSpace.completion_functor.{u_1}
             X)) →
     @category_theory.bundled.α.{u_1 u_1} uniform_space.{u_1} (CpltSepUniformSpace.to_UniformSpace.{u_1} Y))
    (@subtype.val.{u_1+1}
       (@category_theory.bundled.α.{u_1 u_1} uniform_space.{u_1}
          (CpltSepUniformSpace.to_UniformSpace.{u_1}
             (@category_theory.functor.obj.{u_1 u_1 u_1+1 u_1+1} UniformSpace.{u_1}
                (@category_theory.bundled_hom.category.{u_1} uniform_space.{u_1}
                   (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β),
                      @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ))
                   (@category_theory.unbundled_hom.bundled_hom.{u_1} (λ (α : Type u_1), uniform_space.{u_1} α)
                      uniform_continuous.{u_1 u_1}
                      UniformSpace.concrete_category_uniform_continuous.{u_1}))
                CpltSepUniformSpace.{u_1}
                (@category_theory.concrete_category.to_category.{u_1} CpltSepUniformSpace.{u_1}
                   CpltSepUniformSpace.concrete_category.{u_1})
                UniformSpace.completion_functor.{u_1}
                X)) →
        @category_theory.bundled.α.{u_1 u_1} uniform_space.{u_1} (CpltSepUniformSpace.to_UniformSpace.{u_1} Y))
       (λ
        (x :
          @category_theory.bundled.α.{u_1 u_1} uniform_space.{u_1}
            (CpltSepUniformSpace.to_UniformSpace.{u_1}
               (@category_theory.functor.obj.{u_1 u_1 u_1+1 u_1+1} UniformSpace.{u_1}
                  (@category_theory.bundled_hom.category.{u_1} uniform_space.{u_1}
                     (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β),
                        @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ))
                     (@category_theory.unbundled_hom.bundled_hom.{u_1} (λ (α : Type u_1), uniform_space.{u_1} α)
                        uniform_continuous.{u_1 u_1}
                        UniformSpace.concrete_category_uniform_continuous.{u_1}))
                  CpltSepUniformSpace.{u_1}
                  (@category_theory.concrete_category.to_category.{u_1} CpltSepUniformSpace.{u_1}
                     CpltSepUniformSpace.concrete_category.{u_1})
                  UniformSpace.completion_functor.{u_1}
                  X)) →
          @category_theory.bundled.α.{u_1 u_1} uniform_space.{u_1} (CpltSepUniformSpace.to_UniformSpace.{u_1} Y)),
          @filter.tendsto.{u_1 u_1}
            (prod.{u_1 u_1}
               (@category_theory.bundled.α.{u_1 u_1} uniform_space.{u_1}
                  (CpltSepUniformSpace.to_UniformSpace.{u_1}
                     (@category_theory.functor.obj.{u_1 u_1 u_1+1 u_1+1} UniformSpace.{u_1}
                        (@category_theory.bundled_hom.category.{u_1} uniform_space.{u_1}
                           (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β),
                              @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ))
                           (@category_theory.unbundled_hom.bundled_hom.{u_1}
                              (λ (α : Type u_1), uniform_space.{u_1} α)
                              uniform_continuous.{u_1 u_1}
                              UniformSpace.concrete_category_uniform_continuous.{u_1}))
                        CpltSepUniformSpace.{u_1}
                        (@category_theory.concrete_category.to_category.{u_1} CpltSepUniformSpace.{u_1}
                           CpltSepUniformSpace.concrete_category.{u_1})
                        UniformSpace.completion_functor.{u_1}
                        X)))
               (@category_theory.bundled.α.{u_1 u_1} uniform_space.{u_1}
                  (CpltSepUniformSpace.to_UniformSpace.{u_1}
                     (@category_theory.functor.obj.{u_1 u_1 u_1+1 u_1+1} UniformSpace.{u_1}
                        (@category_theory.bundled_hom.category.{u_1} uniform_space.{u_1}
                           (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β),
                              @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ))
                           (@category_theory.unbundled_hom.bundled_hom.{u_1}
                              (λ (α : Type u_1), uniform_space.{u_1} α)
                              uniform_continuous.{u_1 u_1}
                              UniformSpace.concrete_category_uniform_continuous.{u_1}))
                        CpltSepUniformSpace.{u_1}
                        (@category_theory.concrete_category.to_category.{u_1} CpltSepUniformSpace.{u_1}
                           CpltSepUniformSpace.concrete_category.{u_1})
                        UniformSpace.completion_functor.{u_1}
                        X))))
            (prod.{u_1 u_1}
               (@category_theory.bundled.α.{u_1 u_1} uniform_space.{u_1} (CpltSepUniformSpace.to_UniformSpace.{u_1} Y))
               (@category_theory.bundled.α.{u_1 u_1} uniform_space.{u_1}
                  (CpltSepUniformSpace.to_UniformSpace.{u_1} Y)))
            (λ
             (x_1 :
               prod.{u_1 u_1}
                 (@category_theory.bundled.α.{u_1 u_1} uniform_space.{u_1}
                    (CpltSepUniformSpace.to_UniformSpace.{u_1}
                       (@category_theory.functor.obj.{u_1 u_1 u_1+1 u_1+1} UniformSpace.{u_1}
                          (@category_theory.bundled_hom.category.{u_1} uniform_space.{u_1}
                             (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β),
                                @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ))
                             (@category_theory.unbundled_hom.bundled_hom.{u_1}
                                (λ (α : Type u_1), uniform_space.{u_1} α)
                                uniform_continuous.{u_1 u_1}
                                UniformSpace.concrete_category_uniform_continuous.{u_1}))
                          CpltSepUniformSpace.{u_1}
                          (@category_theory.concrete_category.to_category.{u_1} CpltSepUniformSpace.{u_1}
                             CpltSepUniformSpace.concrete_category.{u_1})
                          UniformSpace.completion_functor.{u_1}
                          X)))
                 (@category_theory.bundled.α.{u_1 u_1} uniform_space.{u_1}
                    (CpltSepUniformSpace.to_UniformSpace.{u_1}
                       (@category_theory.functor.obj.{u_1 u_1 u_1+1 u_1+1} UniformSpace.{u_1}
                          (@category_theory.bundled_hom.category.{u_1} uniform_space.{u_1}
                             (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β),
                                @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ))
                             (@category_theory.unbundled_hom.bundled_hom.{u_1}
                                (λ (α : Type u_1), uniform_space.{u_1} α)
                                uniform_continuous.{u_1 u_1}
                                UniformSpace.concrete_category_uniform_continuous.{u_1}))
                          CpltSepUniformSpace.{u_1}
                          (@category_theory.concrete_category.to_category.{u_1} CpltSepUniformSpace.{u_1}
                             CpltSepUniformSpace.concrete_category.{u_1})
                          UniformSpace.completion_functor.{u_1}
                          X)))),
               @prod.mk.{u_1 u_1}
                 (@category_theory.bundled.α.{u_1 u_1} uniform_space.{u_1}
                    (CpltSepUniformSpace.to_UniformSpace.{u_1} Y))
                 (@category_theory.bundled.α.{u_1 u_1} uniform_space.{u_1}
                    (CpltSepUniformSpace.to_UniformSpace.{u_1} Y))
                 (x
                    (@prod.fst.{u_1 u_1}
                       (@category_theory.bundled.α.{u_1 u_1} uniform_space.{u_1}
                          (CpltSepUniformSpace.to_UniformSpace.{u_1}
                             (@category_theory.functor.obj.{u_1 u_1 u_1+1 u_1+1} UniformSpace.{u_1}
                                (@category_theory.bundled_hom.category.{u_1} uniform_space.{u_1}
                                   (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β),
                                      @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ))
                                   (@category_theory.unbundled_hom.bundled_hom.{u_1}
                                      (λ (α : Type u_1), uniform_space.{u_1} α)
                                      uniform_continuous.{u_1 u_1}
                                      UniformSpace.concrete_category_uniform_continuous.{u_1}))
                                CpltSepUniformSpace.{u_1}
                                (@category_theory.concrete_category.to_category.{u_1} CpltSepUniformSpace.{u_1}
                                   CpltSepUniformSpace.concrete_category.{u_1})
                                UniformSpace.completion_functor.{u_1}
                                X)))
                       (@category_theory.bundled.α.{u_1 u_1} uniform_space.{u_1}
                          (CpltSepUniformSpace.to_UniformSpace.{u_1}
                             (@category_theory.functor.obj.{u_1 u_1 u_1+1 u_1+1} UniformSpace.{u_1}
                                (@category_theory.bundled_hom.category.{u_1} uniform_space.{u_1}
                                   (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β),
                                      @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ))
                                   (@category_theory.unbundled_hom.bundled_hom.{u_1}
                                      (λ (α : Type u_1), uniform_space.{u_1} α)
                                      uniform_continuous.{u_1 u_1}
                                      UniformSpace.concrete_category_uniform_continuous.{u_1}))
                                CpltSepUniformSpace.{u_1}
                                (@category_theory.concrete_category.to_category.{u_1} CpltSepUniformSpace.{u_1}
                                   CpltSepUniformSpace.concrete_category.{u_1})
                                UniformSpace.completion_functor.{u_1}
                                X)))
                       x_1))
                 (x
                    (@prod.snd.{u_1 u_1}
                       (@category_theory.bundled.α.{u_1 u_1} uniform_space.{u_1}
                          (CpltSepUniformSpace.to_UniformSpace.{u_1}
                             (@category_theory.functor.obj.{u_1 u_1 u_1+1 u_1+1} UniformSpace.{u_1}
                                (@category_theory.bundled_hom.category.{u_1} uniform_space.{u_1}
                                   (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β),
                                      @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ))
                                   (@category_theory.unbundled_hom.bundled_hom.{u_1}
                                      (λ (α : Type u_1), uniform_space.{u_1} α)
                                      uniform_continuous.{u_1 u_1}
                                      UniformSpace.concrete_category_uniform_continuous.{u_1}))
                                CpltSepUniformSpace.{u_1}
                                (@category_theory.concrete_category.to_category.{u_1} CpltSepUniformSpace.{u_1}
                                   CpltSepUniformSpace.concrete_category.{u_1})
                                UniformSpace.completion_functor.{u_1}
                                X)))
                       (@category_theory.bundled.α.{u_1 u_1} uniform_space.{u_1}
                          (CpltSepUniformSpace.to_UniformSpace.{u_1}
                             (@category_theory.functor.obj.{u_1 u_1 u_1+1 u_1+1} UniformSpace.{u_1}
                                (@category_theory.bundled_hom.category.{u_1} uniform_space.{u_1}
                                   (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β),
                                      @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ))
                                   (@category_theory.unbundled_hom.bundled_hom.{u_1}
                                      (λ (α : Type u_1), uniform_space.{u_1} α)
                                      uniform_continuous.{u_1 u_1}
                                      UniformSpace.concrete_category_uniform_continuous.{u_1}))
                                CpltSepUniformSpace.{u_1}
                                (@category_theory.concrete_category.to_category.{u_1} CpltSepUniformSpace.{u_1}
                                   CpltSepUniformSpace.concrete_category.{u_1})
                                UniformSpace.completion_functor.{u_1}
                                X)))
                       x_1)))
            (@uniformity.{u_1}
               (@category_theory.bundled.α.{u_1 u_1} uniform_space.{u_1}
                  (CpltSepUniformSpace.to_UniformSpace.{u_1}
                     (@category_theory.functor.obj.{u_1 u_1 u_1+1 u_1+1} UniformSpace.{u_1}
                        (@category_theory.bundled_hom.category.{u_1} uniform_space.{u_1}
                           (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β),
                              @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ))
                           (@category_theory.unbundled_hom.bundled_hom.{u_1}
                              (λ (α : Type u_1), uniform_space.{u_1} α)
                              uniform_continuous.{u_1 u_1}
                              UniformSpace.concrete_category_uniform_continuous.{u_1}))
                        CpltSepUniformSpace.{u_1}
                        (@category_theory.concrete_category.to_category.{u_1} CpltSepUniformSpace.{u_1}
                           CpltSepUniformSpace.concrete_category.{u_1})
                        UniformSpace.completion_functor.{u_1}
                        X)))
               (@category_theory.bundled.str.{u_1 u_1} uniform_space.{u_1}
                  (CpltSepUniformSpace.to_UniformSpace.{u_1}
                     (@category_theory.functor.obj.{u_1 u_1 u_1+1 u_1+1} UniformSpace.{u_1}
                        (@category_theory.bundled_hom.category.{u_1} uniform_space.{u_1}
                           (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β),
                              @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ))
                           (@category_theory.unbundled_hom.bundled_hom.{u_1}
                              (λ (α : Type u_1), uniform_space.{u_1} α)
                              uniform_continuous.{u_1 u_1}
                              UniformSpace.concrete_category_uniform_continuous.{u_1}))
                        CpltSepUniformSpace.{u_1}
                        (@category_theory.concrete_category.to_category.{u_1} CpltSepUniformSpace.{u_1}
                           CpltSepUniformSpace.concrete_category.{u_1})
                        UniformSpace.completion_functor.{u_1}
                        X))))
            (@uniformity.{u_1}
               (@category_theory.bundled.α.{u_1 u_1} uniform_space.{u_1} (CpltSepUniformSpace.to_UniformSpace.{u_1} Y))
               (@category_theory.bundled.str.{u_1 u_1} uniform_space.{u_1}
                  (CpltSepUniformSpace.to_UniformSpace.{u_1} Y))))
       (@UniformSpace.extension_hom.{u_1} X Y
          (@category_theory.category_struct.comp.{u_1 u_1+1} UniformSpace.{u_1}
             (@category_theory.category.to_category_struct.{u_1 u_1+1} UniformSpace.{u_1}
                (@category_theory.bundled_hom.category.{u_1} uniform_space.{u_1}
                   (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β),
                      @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ))
                   (@category_theory.unbundled_hom.bundled_hom.{u_1} (λ (α : Type u_1), uniform_space.{u_1} α)
                      uniform_continuous.{u_1 u_1}
                      UniformSpace.concrete_category_uniform_continuous.{u_1})))
             X
             (@category_theory.functor.obj.{u_1 u_1 u_1+1 u_1+1} CpltSepUniformSpace.{u_1}
                (@category_theory.concrete_category.to_category.{u_1} CpltSepUniformSpace.{u_1}
                   CpltSepUniformSpace.concrete_category.{u_1})
                UniformSpace.{u_1}
                (@category_theory.concrete_category.to_category.{u_1} UniformSpace.{u_1}
                   (@category_theory.bundled_hom.category_theory.concrete_category.{u_1} uniform_space.{u_1}
                      (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β),
                         @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ))
                      (@category_theory.unbundled_hom.bundled_hom.{u_1} (λ (α : Type u_1), uniform_space.{u_1} α)
                         uniform_continuous.{u_1 u_1}
                         UniformSpace.concrete_category_uniform_continuous.{u_1})))
                (@category_theory.forget₂.{u_1} CpltSepUniformSpace.{u_1} UniformSpace.{u_1}
                   CpltSepUniformSpace.concrete_category.{u_1}
                   (@category_theory.bundled_hom.category_theory.concrete_category.{u_1} uniform_space.{u_1}
                      (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β),
                         @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ))
                      (@category_theory.unbundled_hom.bundled_hom.{u_1} (λ (α : Type u_1), uniform_space.{u_1} α)
                         uniform_continuous.{u_1 u_1}
                         UniformSpace.concrete_category_uniform_continuous.{u_1}))
                   CpltSepUniformSpace.has_forget_to_UniformSpace.{u_1})
                (@category_theory.functor.obj.{u_1 u_1 u_1+1 u_1+1} UniformSpace.{u_1}
                   (@category_theory.bundled_hom.category.{u_1} uniform_space.{u_1}
                      (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β),
                         @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ))
                      (@category_theory.unbundled_hom.bundled_hom.{u_1} (λ (α : Type u_1), uniform_space.{u_1} α)
                         uniform_continuous.{u_1 u_1}
                         UniformSpace.concrete_category_uniform_continuous.{u_1}))
                   CpltSepUniformSpace.{u_1}
                   (@category_theory.concrete_category.to_category.{u_1} CpltSepUniformSpace.{u_1}
                      CpltSepUniformSpace.concrete_category.{u_1})
                   UniformSpace.completion_functor.{u_1}
                   X))
             (@category_theory.functor.obj.{u_1 u_1 u_1+1 u_1+1} CpltSepUniformSpace.{u_1}
                (@category_theory.concrete_category.to_category.{u_1} CpltSepUniformSpace.{u_1}
                   CpltSepUniformSpace.concrete_category.{u_1})
                UniformSpace.{u_1}
                (@category_theory.concrete_category.to_category.{u_1} UniformSpace.{u_1}
                   (@category_theory.bundled_hom.category_theory.concrete_category.{u_1} uniform_space.{u_1}
                      (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β),
                         @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ))
                      (@category_theory.unbundled_hom.bundled_hom.{u_1} (λ (α : Type u_1), uniform_space.{u_1} α)
                         uniform_continuous.{u_1 u_1}
                         UniformSpace.concrete_category_uniform_continuous.{u_1})))
                (@category_theory.forget₂.{u_1} CpltSepUniformSpace.{u_1} UniformSpace.{u_1}
                   CpltSepUniformSpace.concrete_category.{u_1}
                   (@category_theory.bundled_hom.category_theory.concrete_category.{u_1} uniform_space.{u_1}
                      (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β),
                         @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ))
                      (@category_theory.unbundled_hom.bundled_hom.{u_1} (λ (α : Type u_1), uniform_space.{u_1} α)
                         uniform_continuous.{u_1 u_1}
                         UniformSpace.concrete_category_uniform_continuous.{u_1}))
                   CpltSepUniformSpace.has_forget_to_UniformSpace.{u_1})
                Y)
             (UniformSpace.completion_hom.{u_1} X)
             f)))
    (@subtype.val.{u_1+1}
       (@category_theory.bundled.α.{u_1 u_1} uniform_space.{u_1}
          (CpltSepUniformSpace.to_UniformSpace.{u_1}
             (@category_theory.functor.obj.{u_1 u_1 u_1+1 u_1+1} UniformSpace.{u_1}
                (@category_theory.bundled_hom.category.{u_1} uniform_space.{u_1}
                   (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β),
                      @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ))
                   (@category_theory.unbundled_hom.bundled_hom.{u_1} (λ (α : Type u_1), uniform_space.{u_1} α)
                      uniform_continuous.{u_1 u_1}
                      UniformSpace.concrete_category_uniform_continuous.{u_1}))
                CpltSepUniformSpace.{u_1}
                (@category_theory.concrete_category.to_category.{u_1} CpltSepUniformSpace.{u_1}
                   CpltSepUniformSpace.concrete_category.{u_1})
                UniformSpace.completion_functor.{u_1}
                X)) →
        @category_theory.bundled.α.{u_1 u_1} uniform_space.{u_1} (CpltSepUniformSpace.to_UniformSpace.{u_1} Y))
       (λ
        (x :
          @category_theory.bundled.α.{u_1 u_1} uniform_space.{u_1}
            (CpltSepUniformSpace.to_UniformSpace.{u_1}
               (@category_theory.functor.obj.{u_1 u_1 u_1+1 u_1+1} UniformSpace.{u_1}
                  (@category_theory.bundled_hom.category.{u_1} uniform_space.{u_1}
                     (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β),
                        @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ))
                     (@category_theory.unbundled_hom.bundled_hom.{u_1} (λ (α : Type u_1), uniform_space.{u_1} α)
                        uniform_continuous.{u_1 u_1}
                        UniformSpace.concrete_category_uniform_continuous.{u_1}))
                  CpltSepUniformSpace.{u_1}
                  (@category_theory.concrete_category.to_category.{u_1} CpltSepUniformSpace.{u_1}
                     CpltSepUniformSpace.concrete_category.{u_1})
                  UniformSpace.completion_functor.{u_1}
                  X)) →
          @category_theory.bundled.α.{u_1 u_1} uniform_space.{u_1} (CpltSepUniformSpace.to_UniformSpace.{u_1} Y)),
          @filter.tendsto.{u_1 u_1}
            (prod.{u_1 u_1}
               (@category_theory.bundled.α.{u_1 u_1} uniform_space.{u_1}
                  (CpltSepUniformSpace.to_UniformSpace.{u_1}
                     (@category_theory.functor.obj.{u_1 u_1 u_1+1 u_1+1} UniformSpace.{u_1}
                        (@category_theory.bundled_hom.category.{u_1} uniform_space.{u_1}
                           (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β),
                              @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ))
                           (@category_theory.unbundled_hom.bundled_hom.{u_1}
                              (λ (α : Type u_1), uniform_space.{u_1} α)
                              uniform_continuous.{u_1 u_1}
                              UniformSpace.concrete_category_uniform_continuous.{u_1}))
                        CpltSepUniformSpace.{u_1}
                        (@category_theory.concrete_category.to_category.{u_1} CpltSepUniformSpace.{u_1}
                           CpltSepUniformSpace.concrete_category.{u_1})
                        UniformSpace.completion_functor.{u_1}
                        X)))
               (@category_theory.bundled.α.{u_1 u_1} uniform_space.{u_1}
                  (CpltSepUniformSpace.to_UniformSpace.{u_1}
                     (@category_theory.functor.obj.{u_1 u_1 u_1+1 u_1+1} UniformSpace.{u_1}
                        (@category_theory.bundled_hom.category.{u_1} uniform_space.{u_1}
                           (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β),
                              @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ))
                           (@category_theory.unbundled_hom.bundled_hom.{u_1}
                              (λ (α : Type u_1), uniform_space.{u_1} α)
                              uniform_continuous.{u_1 u_1}
                              UniformSpace.concrete_category_uniform_continuous.{u_1}))
                        CpltSepUniformSpace.{u_1}
                        (@category_theory.concrete_category.to_category.{u_1} CpltSepUniformSpace.{u_1}
                           CpltSepUniformSpace.concrete_category.{u_1})
                        UniformSpace.completion_functor.{u_1}
                        X))))
            (prod.{u_1 u_1}
               (@category_theory.bundled.α.{u_1 u_1} uniform_space.{u_1} (CpltSepUniformSpace.to_UniformSpace.{u_1} Y))
               (@category_theory.bundled.α.{u_1 u_1} uniform_space.{u_1}
                  (CpltSepUniformSpace.to_UniformSpace.{u_1} Y)))
            (λ
             (x_1 :
               prod.{u_1 u_1}
                 (@category_theory.bundled.α.{u_1 u_1} uniform_space.{u_1}
                    (CpltSepUniformSpace.to_UniformSpace.{u_1}
                       (@category_theory.functor.obj.{u_1 u_1 u_1+1 u_1+1} UniformSpace.{u_1}
                          (@category_theory.bundled_hom.category.{u_1} uniform_space.{u_1}
                             (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β),
                                @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ))
                             (@category_theory.unbundled_hom.bundled_hom.{u_1}
                                (λ (α : Type u_1), uniform_space.{u_1} α)
                                uniform_continuous.{u_1 u_1}
                                UniformSpace.concrete_category_uniform_continuous.{u_1}))
                          CpltSepUniformSpace.{u_1}
                          (@category_theory.concrete_category.to_category.{u_1} CpltSepUniformSpace.{u_1}
                             CpltSepUniformSpace.concrete_category.{u_1})
                          UniformSpace.completion_functor.{u_1}
                          X)))
                 (@category_theory.bundled.α.{u_1 u_1} uniform_space.{u_1}
                    (CpltSepUniformSpace.to_UniformSpace.{u_1}
                       (@category_theory.functor.obj.{u_1 u_1 u_1+1 u_1+1} UniformSpace.{u_1}
                          (@category_theory.bundled_hom.category.{u_1} uniform_space.{u_1}
                             (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β),
                                @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ))
                             (@category_theory.unbundled_hom.bundled_hom.{u_1}
                                (λ (α : Type u_1), uniform_space.{u_1} α)
                                uniform_continuous.{u_1 u_1}
                                UniformSpace.concrete_category_uniform_continuous.{u_1}))
                          CpltSepUniformSpace.{u_1}
                          (@category_theory.concrete_category.to_category.{u_1} CpltSepUniformSpace.{u_1}
                             CpltSepUniformSpace.concrete_category.{u_1})
                          UniformSpace.completion_functor.{u_1}
                          X)))),
               @prod.mk.{u_1 u_1}
                 (@category_theory.bundled.α.{u_1 u_1} uniform_space.{u_1}
                    (CpltSepUniformSpace.to_UniformSpace.{u_1} Y))
                 (@category_theory.bundled.α.{u_1 u_1} uniform_space.{u_1}
                    (CpltSepUniformSpace.to_UniformSpace.{u_1} Y))
                 (x
                    (@prod.fst.{u_1 u_1}
                       (@category_theory.bundled.α.{u_1 u_1} uniform_space.{u_1}
                          (CpltSepUniformSpace.to_UniformSpace.{u_1}
                             (@category_theory.functor.obj.{u_1 u_1 u_1+1 u_1+1} UniformSpace.{u_1}
                                (@category_theory.bundled_hom.category.{u_1} uniform_space.{u_1}
                                   (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β),
                                      @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ))
                                   (@category_theory.unbundled_hom.bundled_hom.{u_1}
                                      (λ (α : Type u_1), uniform_space.{u_1} α)
                                      uniform_continuous.{u_1 u_1}
                                      UniformSpace.concrete_category_uniform_continuous.{u_1}))
                                CpltSepUniformSpace.{u_1}
                                (@category_theory.concrete_category.to_category.{u_1} CpltSepUniformSpace.{u_1}
                                   CpltSepUniformSpace.concrete_category.{u_1})
                                UniformSpace.completion_functor.{u_1}
                                X)))
                       (@category_theory.bundled.α.{u_1 u_1} uniform_space.{u_1}
                          (CpltSepUniformSpace.to_UniformSpace.{u_1}
                             (@category_theory.functor.obj.{u_1 u_1 u_1+1 u_1+1} UniformSpace.{u_1}
                                (@category_theory.bundled_hom.category.{u_1} uniform_space.{u_1}
                                   (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β),
                                      @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ))
                                   (@category_theory.unbundled_hom.bundled_hom.{u_1}
                                      (λ (α : Type u_1), uniform_space.{u_1} α)
                                      uniform_continuous.{u_1 u_1}
                                      UniformSpace.concrete_category_uniform_continuous.{u_1}))
                                CpltSepUniformSpace.{u_1}
                                (@category_theory.concrete_category.to_category.{u_1} CpltSepUniformSpace.{u_1}
                                   CpltSepUniformSpace.concrete_category.{u_1})
                                UniformSpace.completion_functor.{u_1}
                                X)))
                       x_1))
                 (x
                    (@prod.snd.{u_1 u_1}
                       (@category_theory.bundled.α.{u_1 u_1} uniform_space.{u_1}
                          (CpltSepUniformSpace.to_UniformSpace.{u_1}
                             (@category_theory.functor.obj.{u_1 u_1 u_1+1 u_1+1} UniformSpace.{u_1}
                                (@category_theory.bundled_hom.category.{u_1} uniform_space.{u_1}
                                   (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β),
                                      @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ))
                                   (@category_theory.unbundled_hom.bundled_hom.{u_1}
                                      (λ (α : Type u_1), uniform_space.{u_1} α)
                                      uniform_continuous.{u_1 u_1}
                                      UniformSpace.concrete_category_uniform_continuous.{u_1}))
                                CpltSepUniformSpace.{u_1}
                                (@category_theory.concrete_category.to_category.{u_1} CpltSepUniformSpace.{u_1}
                                   CpltSepUniformSpace.concrete_category.{u_1})
                                UniformSpace.completion_functor.{u_1}
                                X)))
                       (@category_theory.bundled.α.{u_1 u_1} uniform_space.{u_1}
                          (CpltSepUniformSpace.to_UniformSpace.{u_1}
                             (@category_theory.functor.obj.{u_1 u_1 u_1+1 u_1+1} UniformSpace.{u_1}
                                (@category_theory.bundled_hom.category.{u_1} uniform_space.{u_1}
                                   (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β),
                                      @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ))
                                   (@category_theory.unbundled_hom.bundled_hom.{u_1}
                                      (λ (α : Type u_1), uniform_space.{u_1} α)
                                      uniform_continuous.{u_1 u_1}
                                      UniformSpace.concrete_category_uniform_continuous.{u_1}))
                                CpltSepUniformSpace.{u_1}
                                (@category_theory.concrete_category.to_category.{u_1} CpltSepUniformSpace.{u_1}
                                   CpltSepUniformSpace.concrete_category.{u_1})
                                UniformSpace.completion_functor.{u_1}
                                X)))
                       x_1)))
            (@uniformity.{u_1}
               (@category_theory.bundled.α.{u_1 u_1} uniform_space.{u_1}
                  (CpltSepUniformSpace.to_UniformSpace.{u_1}
                     (@category_theory.functor.obj.{u_1 u_1 u_1+1 u_1+1} UniformSpace.{u_1}
                        (@category_theory.bundled_hom.category.{u_1} uniform_space.{u_1}
                           (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β),
                              @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ))
                           (@category_theory.unbundled_hom.bundled_hom.{u_1}
                              (λ (α : Type u_1), uniform_space.{u_1} α)
                              uniform_continuous.{u_1 u_1}
                              UniformSpace.concrete_category_uniform_continuous.{u_1}))
                        CpltSepUniformSpace.{u_1}
                        (@category_theory.concrete_category.to_category.{u_1} CpltSepUniformSpace.{u_1}
                           CpltSepUniformSpace.concrete_category.{u_1})
                        UniformSpace.completion_functor.{u_1}
                        X)))
               (@category_theory.bundled.str.{u_1 u_1} uniform_space.{u_1}
                  (CpltSepUniformSpace.to_UniformSpace.{u_1}
                     (@category_theory.functor.obj.{u_1 u_1 u_1+1 u_1+1} UniformSpace.{u_1}
                        (@category_theory.bundled_hom.category.{u_1} uniform_space.{u_1}
                           (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β),
                              @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ))
                           (@category_theory.unbundled_hom.bundled_hom.{u_1}
                              (λ (α : Type u_1), uniform_space.{u_1} α)
                              uniform_continuous.{u_1 u_1}
                              UniformSpace.concrete_category_uniform_continuous.{u_1}))
                        CpltSepUniformSpace.{u_1}
                        (@category_theory.concrete_category.to_category.{u_1} CpltSepUniformSpace.{u_1}
                           CpltSepUniformSpace.concrete_category.{u_1})
                        UniformSpace.completion_functor.{u_1}
                        X))))
            (@uniformity.{u_1}
               (@category_theory.bundled.α.{u_1 u_1} uniform_space.{u_1} (CpltSepUniformSpace.to_UniformSpace.{u_1} Y))
               (@category_theory.bundled.str.{u_1 u_1} uniform_space.{u_1}
                  (CpltSepUniformSpace.to_UniformSpace.{u_1} Y))))
       f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='X : UniformSpace.{u_1},
Y : CpltSepUniformSpace.{u_1},
f :
  @category_theory.has_hom.hom.{u_1 u_1+1} UniformSpace.{u_1}
    (@category_theory.category_struct.to_has_hom.{u_1 u_1+1} UniformSpace.{u_1}
       (@category_theory.category.to_category_struct.{u_1 u_1+1} UniformSpace.{u_1}
          (@category_theory.bundled_hom.category.{u_1} uniform_space.{u_1}
             (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β),
                @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{u_1} (λ (α : Type u_1), uniform_space.{u_1} α)
                uniform_continuous.{u_1 u_1}
                UniformSpace.concrete_category_uniform_continuous.{u_1}))))
    (CpltSepUniformSpace.to_UniformSpace.{u_1}
       (@CpltSepUniformSpace.of.{u_1}
          (@uniform_space.completion.{u_1}
             (@coe_sort.{u_1+2 u_1+2} UniformSpace.{u_1}
                (@category_theory.bundled.has_coe_to_sort.{u_1 u_1} uniform_space.{u_1})
                X)
             (UniformSpace.uniform_space.{u_1} X))
          (@uniform_space.completion.uniform_space.{u_1}
             (@coe_sort.{u_1+2 u_1+2} UniformSpace.{u_1}
                (@category_theory.bundled.has_coe_to_sort.{u_1 u_1} uniform_space.{u_1})
                X)
             (UniformSpace.uniform_space.{u_1} X))
          (@uniform_space.completion.complete_space.{u_1}
             (@coe_sort.{u_1+2 u_1+2} UniformSpace.{u_1}
                (@category_theory.bundled.has_coe_to_sort.{u_1 u_1} uniform_space.{u_1})
                X)
             (UniformSpace.uniform_space.{u_1} X))
          (@uniform_space.completion.separated.{u_1}
             (@coe_sort.{u_1+2 u_1+2} UniformSpace.{u_1}
                (@category_theory.bundled.has_coe_to_sort.{u_1 u_1} uniform_space.{u_1})
                X)
             (UniformSpace.uniform_space.{u_1} X))))
    (CpltSepUniformSpace.to_UniformSpace.{u_1} Y),
x :
  @category_theory.bundled.α.{u_1 u_1} uniform_space.{u_1}
    (CpltSepUniformSpace.to_UniformSpace.{u_1}
       (@category_theory.functor.obj.{u_1 u_1 u_1+1 u_1+1} UniformSpace.{u_1}
          (@category_theory.bundled_hom.category.{u_1} uniform_space.{u_1}
             (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β),
                @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{u_1} (λ (α : Type u_1), uniform_space.{u_1} α)
                uniform_continuous.{u_1 u_1}
                UniformSpace.concrete_category_uniform_continuous.{u_1}))
          CpltSepUniformSpace.{u_1}
          (@category_theory.concrete_category.to_category.{u_1} CpltSepUniformSpace.{u_1}
             CpltSepUniformSpace.concrete_category.{u_1})
          UniformSpace.completion_functor.{u_1}
          X))
⊢ @eq.{u_1+1}
    (@category_theory.bundled.α.{u_1 u_1} uniform_space.{u_1} (CpltSepUniformSpace.to_UniformSpace.{u_1} Y))
    (@subtype.val.{u_1+1}
       (@category_theory.bundled.α.{u_1 u_1} uniform_space.{u_1}
          (CpltSepUniformSpace.to_UniformSpace.{u_1}
             (@category_theory.functor.obj.{u_1 u_1 u_1+1 u_1+1} UniformSpace.{u_1}
                (@category_theory.bundled_hom.category.{u_1} uniform_space.{u_1}
                   (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β),
                      @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ))
                   (@category_theory.unbundled_hom.bundled_hom.{u_1} (λ (α : Type u_1), uniform_space.{u_1} α)
                      uniform_continuous.{u_1 u_1}
                      UniformSpace.concrete_category_uniform_continuous.{u_1}))
                CpltSepUniformSpace.{u_1}
                (@category_theory.concrete_category.to_category.{u_1} CpltSepUniformSpace.{u_1}
                   CpltSepUniformSpace.concrete_category.{u_1})
                UniformSpace.completion_functor.{u_1}
                X)) →
        @category_theory.bundled.α.{u_1 u_1} uniform_space.{u_1} (CpltSepUniformSpace.to_UniformSpace.{u_1} Y))
       (λ
        (x :
          @category_theory.bundled.α.{u_1 u_1} uniform_space.{u_1}
            (CpltSepUniformSpace.to_UniformSpace.{u_1}
               (@category_theory.functor.obj.{u_1 u_1 u_1+1 u_1+1} UniformSpace.{u_1}
                  (@category_theory.bundled_hom.category.{u_1} uniform_space.{u_1}
                     (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β),
                        @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ))
                     (@category_theory.unbundled_hom.bundled_hom.{u_1} (λ (α : Type u_1), uniform_space.{u_1} α)
                        uniform_continuous.{u_1 u_1}
                        UniformSpace.concrete_category_uniform_continuous.{u_1}))
                  CpltSepUniformSpace.{u_1}
                  (@category_theory.concrete_category.to_category.{u_1} CpltSepUniformSpace.{u_1}
                     CpltSepUniformSpace.concrete_category.{u_1})
                  UniformSpace.completion_functor.{u_1}
                  X)) →
          @category_theory.bundled.α.{u_1 u_1} uniform_space.{u_1} (CpltSepUniformSpace.to_UniformSpace.{u_1} Y)),
          @filter.tendsto.{u_1 u_1}
            (prod.{u_1 u_1}
               (@category_theory.bundled.α.{u_1 u_1} uniform_space.{u_1}
                  (CpltSepUniformSpace.to_UniformSpace.{u_1}
                     (@category_theory.functor.obj.{u_1 u_1 u_1+1 u_1+1} UniformSpace.{u_1}
                        (@category_theory.bundled_hom.category.{u_1} uniform_space.{u_1}
                           (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β),
                              @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ))
                           (@category_theory.unbundled_hom.bundled_hom.{u_1}
                              (λ (α : Type u_1), uniform_space.{u_1} α)
                              uniform_continuous.{u_1 u_1}
                              UniformSpace.concrete_category_uniform_continuous.{u_1}))
                        CpltSepUniformSpace.{u_1}
                        (@category_theory.concrete_category.to_category.{u_1} CpltSepUniformSpace.{u_1}
                           CpltSepUniformSpace.concrete_category.{u_1})
                        UniformSpace.completion_functor.{u_1}
                        X)))
               (@category_theory.bundled.α.{u_1 u_1} uniform_space.{u_1}
                  (CpltSepUniformSpace.to_UniformSpace.{u_1}
                     (@category_theory.functor.obj.{u_1 u_1 u_1+1 u_1+1} UniformSpace.{u_1}
                        (@category_theory.bundled_hom.category.{u_1} uniform_space.{u_1}
                           (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β),
                              @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ))
                           (@category_theory.unbundled_hom.bundled_hom.{u_1}
                              (λ (α : Type u_1), uniform_space.{u_1} α)
                              uniform_continuous.{u_1 u_1}
                              UniformSpace.concrete_category_uniform_continuous.{u_1}))
                        CpltSepUniformSpace.{u_1}
                        (@category_theory.concrete_category.to_category.{u_1} CpltSepUniformSpace.{u_1}
                           CpltSepUniformSpace.concrete_category.{u_1})
                        UniformSpace.completion_functor.{u_1}
                        X))))
            (prod.{u_1 u_1}
               (@category_theory.bundled.α.{u_1 u_1} uniform_space.{u_1} (CpltSepUniformSpace.to_UniformSpace.{u_1} Y))
               (@category_theory.bundled.α.{u_1 u_1} uniform_space.{u_1}
                  (CpltSepUniformSpace.to_UniformSpace.{u_1} Y)))
            (λ
             (x_1 :
               prod.{u_1 u_1}
                 (@category_theory.bundled.α.{u_1 u_1} uniform_space.{u_1}
                    (CpltSepUniformSpace.to_UniformSpace.{u_1}
                       (@category_theory.functor.obj.{u_1 u_1 u_1+1 u_1+1} UniformSpace.{u_1}
                          (@category_theory.bundled_hom.category.{u_1} uniform_space.{u_1}
                             (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β),
                                @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ))
                             (@category_theory.unbundled_hom.bundled_hom.{u_1}
                                (λ (α : Type u_1), uniform_space.{u_1} α)
                                uniform_continuous.{u_1 u_1}
                                UniformSpace.concrete_category_uniform_continuous.{u_1}))
                          CpltSepUniformSpace.{u_1}
                          (@category_theory.concrete_category.to_category.{u_1} CpltSepUniformSpace.{u_1}
                             CpltSepUniformSpace.concrete_category.{u_1})
                          UniformSpace.completion_functor.{u_1}
                          X)))
                 (@category_theory.bundled.α.{u_1 u_1} uniform_space.{u_1}
                    (CpltSepUniformSpace.to_UniformSpace.{u_1}
                       (@category_theory.functor.obj.{u_1 u_1 u_1+1 u_1+1} UniformSpace.{u_1}
                          (@category_theory.bundled_hom.category.{u_1} uniform_space.{u_1}
                             (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β),
                                @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ))
                             (@category_theory.unbundled_hom.bundled_hom.{u_1}
                                (λ (α : Type u_1), uniform_space.{u_1} α)
                                uniform_continuous.{u_1 u_1}
                                UniformSpace.concrete_category_uniform_continuous.{u_1}))
                          CpltSepUniformSpace.{u_1}
                          (@category_theory.concrete_category.to_category.{u_1} CpltSepUniformSpace.{u_1}
                             CpltSepUniformSpace.concrete_category.{u_1})
                          UniformSpace.completion_functor.{u_1}
                          X)))),
               @prod.mk.{u_1 u_1}
                 (@category_theory.bundled.α.{u_1 u_1} uniform_space.{u_1}
                    (CpltSepUniformSpace.to_UniformSpace.{u_1} Y))
                 (@category_theory.bundled.α.{u_1 u_1} uniform_space.{u_1}
                    (CpltSepUniformSpace.to_UniformSpace.{u_1} Y))
                 (x
                    (@prod.fst.{u_1 u_1}
                       (@category_theory.bundled.α.{u_1 u_1} uniform_space.{u_1}
                          (CpltSepUniformSpace.to_UniformSpace.{u_1}
                             (@category_theory.functor.obj.{u_1 u_1 u_1+1 u_1+1} UniformSpace.{u_1}
                                (@category_theory.bundled_hom.category.{u_1} uniform_space.{u_1}
                                   (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β),
                                      @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ))
                                   (@category_theory.unbundled_hom.bundled_hom.{u_1}
                                      (λ (α : Type u_1), uniform_space.{u_1} α)
                                      uniform_continuous.{u_1 u_1}
                                      UniformSpace.concrete_category_uniform_continuous.{u_1}))
                                CpltSepUniformSpace.{u_1}
                                (@category_theory.concrete_category.to_category.{u_1} CpltSepUniformSpace.{u_1}
                                   CpltSepUniformSpace.concrete_category.{u_1})
                                UniformSpace.completion_functor.{u_1}
                                X)))
                       (@category_theory.bundled.α.{u_1 u_1} uniform_space.{u_1}
                          (CpltSepUniformSpace.to_UniformSpace.{u_1}
                             (@category_theory.functor.obj.{u_1 u_1 u_1+1 u_1+1} UniformSpace.{u_1}
                                (@category_theory.bundled_hom.category.{u_1} uniform_space.{u_1}
                                   (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β),
                                      @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ))
                                   (@category_theory.unbundled_hom.bundled_hom.{u_1}
                                      (λ (α : Type u_1), uniform_space.{u_1} α)
                                      uniform_continuous.{u_1 u_1}
                                      UniformSpace.concrete_category_uniform_continuous.{u_1}))
                                CpltSepUniformSpace.{u_1}
                                (@category_theory.concrete_category.to_category.{u_1} CpltSepUniformSpace.{u_1}
                                   CpltSepUniformSpace.concrete_category.{u_1})
                                UniformSpace.completion_functor.{u_1}
                                X)))
                       x_1))
                 (x
                    (@prod.snd.{u_1 u_1}
                       (@category_theory.bundled.α.{u_1 u_1} uniform_space.{u_1}
                          (CpltSepUniformSpace.to_UniformSpace.{u_1}
                             (@category_theory.functor.obj.{u_1 u_1 u_1+1 u_1+1} UniformSpace.{u_1}
                                (@category_theory.bundled_hom.category.{u_1} uniform_space.{u_1}
                                   (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β),
                                      @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ))
                                   (@category_theory.unbundled_hom.bundled_hom.{u_1}
                                      (λ (α : Type u_1), uniform_space.{u_1} α)
                                      uniform_continuous.{u_1 u_1}
                                      UniformSpace.concrete_category_uniform_continuous.{u_1}))
                                CpltSepUniformSpace.{u_1}
                                (@category_theory.concrete_category.to_category.{u_1} CpltSepUniformSpace.{u_1}
                                   CpltSepUniformSpace.concrete_category.{u_1})
                                UniformSpace.completion_functor.{u_1}
                                X)))
                       (@category_theory.bundled.α.{u_1 u_1} uniform_space.{u_1}
                          (CpltSepUniformSpace.to_UniformSpace.{u_1}
                             (@category_theory.functor.obj.{u_1 u_1 u_1+1 u_1+1} UniformSpace.{u_1}
                                (@category_theory.bundled_hom.category.{u_1} uniform_space.{u_1}
                                   (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β),
                                      @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ))
                                   (@category_theory.unbundled_hom.bundled_hom.{u_1}
                                      (λ (α : Type u_1), uniform_space.{u_1} α)
                                      uniform_continuous.{u_1 u_1}
                                      UniformSpace.concrete_category_uniform_continuous.{u_1}))
                                CpltSepUniformSpace.{u_1}
                                (@category_theory.concrete_category.to_category.{u_1} CpltSepUniformSpace.{u_1}
                                   CpltSepUniformSpace.concrete_category.{u_1})
                                UniformSpace.completion_functor.{u_1}
                                X)))
                       x_1)))
            (@uniformity.{u_1}
               (@category_theory.bundled.α.{u_1 u_1} uniform_space.{u_1}
                  (CpltSepUniformSpace.to_UniformSpace.{u_1}
                     (@category_theory.functor.obj.{u_1 u_1 u_1+1 u_1+1} UniformSpace.{u_1}
                        (@category_theory.bundled_hom.category.{u_1} uniform_space.{u_1}
                           (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β),
                              @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ))
                           (@category_theory.unbundled_hom.bundled_hom.{u_1}
                              (λ (α : Type u_1), uniform_space.{u_1} α)
                              uniform_continuous.{u_1 u_1}
                              UniformSpace.concrete_category_uniform_continuous.{u_1}))
                        CpltSepUniformSpace.{u_1}
                        (@category_theory.concrete_category.to_category.{u_1} CpltSepUniformSpace.{u_1}
                           CpltSepUniformSpace.concrete_category.{u_1})
                        UniformSpace.completion_functor.{u_1}
                        X)))
               (@category_theory.bundled.str.{u_1 u_1} uniform_space.{u_1}
                  (CpltSepUniformSpace.to_UniformSpace.{u_1}
                     (@category_theory.functor.obj.{u_1 u_1 u_1+1 u_1+1} UniformSpace.{u_1}
                        (@category_theory.bundled_hom.category.{u_1} uniform_space.{u_1}
                           (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β),
                              @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ))
                           (@category_theory.unbundled_hom.bundled_hom.{u_1}
                              (λ (α : Type u_1), uniform_space.{u_1} α)
                              uniform_continuous.{u_1 u_1}
                              UniformSpace.concrete_category_uniform_continuous.{u_1}))
                        CpltSepUniformSpace.{u_1}
                        (@category_theory.concrete_category.to_category.{u_1} CpltSepUniformSpace.{u_1}
                           CpltSepUniformSpace.concrete_category.{u_1})
                        UniformSpace.completion_functor.{u_1}
                        X))))
            (@uniformity.{u_1}
               (@category_theory.bundled.α.{u_1 u_1} uniform_space.{u_1} (CpltSepUniformSpace.to_UniformSpace.{u_1} Y))
               (@category_theory.bundled.str.{u_1 u_1} uniform_space.{u_1}
                  (CpltSepUniformSpace.to_UniformSpace.{u_1} Y))))
       (@UniformSpace.extension_hom.{u_1} X Y
          (@category_theory.category_struct.comp.{u_1 u_1+1} UniformSpace.{u_1}
             (@category_theory.category.to_category_struct.{u_1 u_1+1} UniformSpace.{u_1}
                (@category_theory.bundled_hom.category.{u_1} uniform_space.{u_1}
                   (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β),
                      @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ))
                   (@category_theory.unbundled_hom.bundled_hom.{u_1} (λ (α : Type u_1), uniform_space.{u_1} α)
                      uniform_continuous.{u_1 u_1}
                      UniformSpace.concrete_category_uniform_continuous.{u_1})))
             X
             (@category_theory.functor.obj.{u_1 u_1 u_1+1 u_1+1} CpltSepUniformSpace.{u_1}
                (@category_theory.concrete_category.to_category.{u_1} CpltSepUniformSpace.{u_1}
                   CpltSepUniformSpace.concrete_category.{u_1})
                UniformSpace.{u_1}
                (@category_theory.concrete_category.to_category.{u_1} UniformSpace.{u_1}
                   (@category_theory.bundled_hom.category_theory.concrete_category.{u_1} uniform_space.{u_1}
                      (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β),
                         @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ))
                      (@category_theory.unbundled_hom.bundled_hom.{u_1} (λ (α : Type u_1), uniform_space.{u_1} α)
                         uniform_continuous.{u_1 u_1}
                         UniformSpace.concrete_category_uniform_continuous.{u_1})))
                (@category_theory.forget₂.{u_1} CpltSepUniformSpace.{u_1} UniformSpace.{u_1}
                   CpltSepUniformSpace.concrete_category.{u_1}
                   (@category_theory.bundled_hom.category_theory.concrete_category.{u_1} uniform_space.{u_1}
                      (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β),
                         @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ))
                      (@category_theory.unbundled_hom.bundled_hom.{u_1} (λ (α : Type u_1), uniform_space.{u_1} α)
                         uniform_continuous.{u_1 u_1}
                         UniformSpace.concrete_category_uniform_continuous.{u_1}))
                   CpltSepUniformSpace.has_forget_to_UniformSpace.{u_1})
                (@category_theory.functor.obj.{u_1 u_1 u_1+1 u_1+1} UniformSpace.{u_1}
                   (@category_theory.bundled_hom.category.{u_1} uniform_space.{u_1}
                      (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β),
                         @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ))
                      (@category_theory.unbundled_hom.bundled_hom.{u_1} (λ (α : Type u_1), uniform_space.{u_1} α)
                         uniform_continuous.{u_1 u_1}
                         UniformSpace.concrete_category_uniform_continuous.{u_1}))
                   CpltSepUniformSpace.{u_1}
                   (@category_theory.concrete_category.to_category.{u_1} CpltSepUniformSpace.{u_1}
                      CpltSepUniformSpace.concrete_category.{u_1})
                   UniformSpace.completion_functor.{u_1}
                   X))
             (@category_theory.functor.obj.{u_1 u_1 u_1+1 u_1+1} CpltSepUniformSpace.{u_1}
                (@category_theory.concrete_category.to_category.{u_1} CpltSepUniformSpace.{u_1}
                   CpltSepUniformSpace.concrete_category.{u_1})
                UniformSpace.{u_1}
                (@category_theory.concrete_category.to_category.{u_1} UniformSpace.{u_1}
                   (@category_theory.bundled_hom.category_theory.concrete_category.{u_1} uniform_space.{u_1}
                      (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β),
                         @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ))
                      (@category_theory.unbundled_hom.bundled_hom.{u_1} (λ (α : Type u_1), uniform_space.{u_1} α)
                         uniform_continuous.{u_1 u_1}
                         UniformSpace.concrete_category_uniform_continuous.{u_1})))
                (@category_theory.forget₂.{u_1} CpltSepUniformSpace.{u_1} UniformSpace.{u_1}
                   CpltSepUniformSpace.concrete_category.{u_1}
                   (@category_theory.bundled_hom.category_theory.concrete_category.{u_1} uniform_space.{u_1}
                      (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β),
                         @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ))
                      (@category_theory.unbundled_hom.bundled_hom.{u_1} (λ (α : Type u_1), uniform_space.{u_1} α)
                         uniform_continuous.{u_1 u_1}
                         UniformSpace.concrete_category_uniform_continuous.{u_1}))
                   CpltSepUniformSpace.has_forget_to_UniformSpace.{u_1})
                Y)
             (UniformSpace.completion_hom.{u_1} X)
             f))
       x)
    (@subtype.val.{u_1+1}
       (@category_theory.bundled.α.{u_1 u_1} uniform_space.{u_1}
          (CpltSepUniformSpace.to_UniformSpace.{u_1}
             (@category_theory.functor.obj.{u_1 u_1 u_1+1 u_1+1} UniformSpace.{u_1}
                (@category_theory.bundled_hom.category.{u_1} uniform_space.{u_1}
                   (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β),
                      @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ))
                   (@category_theory.unbundled_hom.bundled_hom.{u_1} (λ (α : Type u_1), uniform_space.{u_1} α)
                      uniform_continuous.{u_1 u_1}
                      UniformSpace.concrete_category_uniform_continuous.{u_1}))
                CpltSepUniformSpace.{u_1}
                (@category_theory.concrete_category.to_category.{u_1} CpltSepUniformSpace.{u_1}
                   CpltSepUniformSpace.concrete_category.{u_1})
                UniformSpace.completion_functor.{u_1}
                X)) →
        @category_theory.bundled.α.{u_1 u_1} uniform_space.{u_1} (CpltSepUniformSpace.to_UniformSpace.{u_1} Y))
       (λ
        (x :
          @category_theory.bundled.α.{u_1 u_1} uniform_space.{u_1}
            (CpltSepUniformSpace.to_UniformSpace.{u_1}
               (@category_theory.functor.obj.{u_1 u_1 u_1+1 u_1+1} UniformSpace.{u_1}
                  (@category_theory.bundled_hom.category.{u_1} uniform_space.{u_1}
                     (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β),
                        @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ))
                     (@category_theory.unbundled_hom.bundled_hom.{u_1} (λ (α : Type u_1), uniform_space.{u_1} α)
                        uniform_continuous.{u_1 u_1}
                        UniformSpace.concrete_category_uniform_continuous.{u_1}))
                  CpltSepUniformSpace.{u_1}
                  (@category_theory.concrete_category.to_category.{u_1} CpltSepUniformSpace.{u_1}
                     CpltSepUniformSpace.concrete_category.{u_1})
                  UniformSpace.completion_functor.{u_1}
                  X)) →
          @category_theory.bundled.α.{u_1 u_1} uniform_space.{u_1} (CpltSepUniformSpace.to_UniformSpace.{u_1} Y)),
          @filter.tendsto.{u_1 u_1}
            (prod.{u_1 u_1}
               (@category_theory.bundled.α.{u_1 u_1} uniform_space.{u_1}
                  (CpltSepUniformSpace.to_UniformSpace.{u_1}
                     (@category_theory.functor.obj.{u_1 u_1 u_1+1 u_1+1} UniformSpace.{u_1}
                        (@category_theory.bundled_hom.category.{u_1} uniform_space.{u_1}
                           (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β),
                              @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ))
                           (@category_theory.unbundled_hom.bundled_hom.{u_1}
                              (λ (α : Type u_1), uniform_space.{u_1} α)
                              uniform_continuous.{u_1 u_1}
                              UniformSpace.concrete_category_uniform_continuous.{u_1}))
                        CpltSepUniformSpace.{u_1}
                        (@category_theory.concrete_category.to_category.{u_1} CpltSepUniformSpace.{u_1}
                           CpltSepUniformSpace.concrete_category.{u_1})
                        UniformSpace.completion_functor.{u_1}
                        X)))
               (@category_theory.bundled.α.{u_1 u_1} uniform_space.{u_1}
                  (CpltSepUniformSpace.to_UniformSpace.{u_1}
                     (@category_theory.functor.obj.{u_1 u_1 u_1+1 u_1+1} UniformSpace.{u_1}
                        (@category_theory.bundled_hom.category.{u_1} uniform_space.{u_1}
                           (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β),
                              @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ))
                           (@category_theory.unbundled_hom.bundled_hom.{u_1}
                              (λ (α : Type u_1), uniform_space.{u_1} α)
                              uniform_continuous.{u_1 u_1}
                              UniformSpace.concrete_category_uniform_continuous.{u_1}))
                        CpltSepUniformSpace.{u_1}
                        (@category_theory.concrete_category.to_category.{u_1} CpltSepUniformSpace.{u_1}
                           CpltSepUniformSpace.concrete_category.{u_1})
                        UniformSpace.completion_functor.{u_1}
                        X))))
            (prod.{u_1 u_1}
               (@category_theory.bundled.α.{u_1 u_1} uniform_space.{u_1} (CpltSepUniformSpace.to_UniformSpace.{u_1} Y))
               (@category_theory.bundled.α.{u_1 u_1} uniform_space.{u_1}
                  (CpltSepUniformSpace.to_UniformSpace.{u_1} Y)))
            (λ
             (x_1 :
               prod.{u_1 u_1}
                 (@category_theory.bundled.α.{u_1 u_1} uniform_space.{u_1}
                    (CpltSepUniformSpace.to_UniformSpace.{u_1}
                       (@category_theory.functor.obj.{u_1 u_1 u_1+1 u_1+1} UniformSpace.{u_1}
                          (@category_theory.bundled_hom.category.{u_1} uniform_space.{u_1}
                             (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β),
                                @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ))
                             (@category_theory.unbundled_hom.bundled_hom.{u_1}
                                (λ (α : Type u_1), uniform_space.{u_1} α)
                                uniform_continuous.{u_1 u_1}
                                UniformSpace.concrete_category_uniform_continuous.{u_1}))
                          CpltSepUniformSpace.{u_1}
                          (@category_theory.concrete_category.to_category.{u_1} CpltSepUniformSpace.{u_1}
                             CpltSepUniformSpace.concrete_category.{u_1})
                          UniformSpace.completion_functor.{u_1}
                          X)))
                 (@category_theory.bundled.α.{u_1 u_1} uniform_space.{u_1}
                    (CpltSepUniformSpace.to_UniformSpace.{u_1}
                       (@category_theory.functor.obj.{u_1 u_1 u_1+1 u_1+1} UniformSpace.{u_1}
                          (@category_theory.bundled_hom.category.{u_1} uniform_space.{u_1}
                             (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β),
                                @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ))
                             (@category_theory.unbundled_hom.bundled_hom.{u_1}
                                (λ (α : Type u_1), uniform_space.{u_1} α)
                                uniform_continuous.{u_1 u_1}
                                UniformSpace.concrete_category_uniform_continuous.{u_1}))
                          CpltSepUniformSpace.{u_1}
                          (@category_theory.concrete_category.to_category.{u_1} CpltSepUniformSpace.{u_1}
                             CpltSepUniformSpace.concrete_category.{u_1})
                          UniformSpace.completion_functor.{u_1}
                          X)))),
               @prod.mk.{u_1 u_1}
                 (@category_theory.bundled.α.{u_1 u_1} uniform_space.{u_1}
                    (CpltSepUniformSpace.to_UniformSpace.{u_1} Y))
                 (@category_theory.bundled.α.{u_1 u_1} uniform_space.{u_1}
                    (CpltSepUniformSpace.to_UniformSpace.{u_1} Y))
                 (x
                    (@prod.fst.{u_1 u_1}
                       (@category_theory.bundled.α.{u_1 u_1} uniform_space.{u_1}
                          (CpltSepUniformSpace.to_UniformSpace.{u_1}
                             (@category_theory.functor.obj.{u_1 u_1 u_1+1 u_1+1} UniformSpace.{u_1}
                                (@category_theory.bundled_hom.category.{u_1} uniform_space.{u_1}
                                   (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β),
                                      @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ))
                                   (@category_theory.unbundled_hom.bundled_hom.{u_1}
                                      (λ (α : Type u_1), uniform_space.{u_1} α)
                                      uniform_continuous.{u_1 u_1}
                                      UniformSpace.concrete_category_uniform_continuous.{u_1}))
                                CpltSepUniformSpace.{u_1}
                                (@category_theory.concrete_category.to_category.{u_1} CpltSepUniformSpace.{u_1}
                                   CpltSepUniformSpace.concrete_category.{u_1})
                                UniformSpace.completion_functor.{u_1}
                                X)))
                       (@category_theory.bundled.α.{u_1 u_1} uniform_space.{u_1}
                          (CpltSepUniformSpace.to_UniformSpace.{u_1}
                             (@category_theory.functor.obj.{u_1 u_1 u_1+1 u_1+1} UniformSpace.{u_1}
                                (@category_theory.bundled_hom.category.{u_1} uniform_space.{u_1}
                                   (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β),
                                      @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ))
                                   (@category_theory.unbundled_hom.bundled_hom.{u_1}
                                      (λ (α : Type u_1), uniform_space.{u_1} α)
                                      uniform_continuous.{u_1 u_1}
                                      UniformSpace.concrete_category_uniform_continuous.{u_1}))
                                CpltSepUniformSpace.{u_1}
                                (@category_theory.concrete_category.to_category.{u_1} CpltSepUniformSpace.{u_1}
                                   CpltSepUniformSpace.concrete_category.{u_1})
                                UniformSpace.completion_functor.{u_1}
                                X)))
                       x_1))
                 (x
                    (@prod.snd.{u_1 u_1}
                       (@category_theory.bundled.α.{u_1 u_1} uniform_space.{u_1}
                          (CpltSepUniformSpace.to_UniformSpace.{u_1}
                             (@category_theory.functor.obj.{u_1 u_1 u_1+1 u_1+1} UniformSpace.{u_1}
                                (@category_theory.bundled_hom.category.{u_1} uniform_space.{u_1}
                                   (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β),
                                      @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ))
                                   (@category_theory.unbundled_hom.bundled_hom.{u_1}
                                      (λ (α : Type u_1), uniform_space.{u_1} α)
                                      uniform_continuous.{u_1 u_1}
                                      UniformSpace.concrete_category_uniform_continuous.{u_1}))
                                CpltSepUniformSpace.{u_1}
                                (@category_theory.concrete_category.to_category.{u_1} CpltSepUniformSpace.{u_1}
                                   CpltSepUniformSpace.concrete_category.{u_1})
                                UniformSpace.completion_functor.{u_1}
                                X)))
                       (@category_theory.bundled.α.{u_1 u_1} uniform_space.{u_1}
                          (CpltSepUniformSpace.to_UniformSpace.{u_1}
                             (@category_theory.functor.obj.{u_1 u_1 u_1+1 u_1+1} UniformSpace.{u_1}
                                (@category_theory.bundled_hom.category.{u_1} uniform_space.{u_1}
                                   (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β),
                                      @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ))
                                   (@category_theory.unbundled_hom.bundled_hom.{u_1}
                                      (λ (α : Type u_1), uniform_space.{u_1} α)
                                      uniform_continuous.{u_1 u_1}
                                      UniformSpace.concrete_category_uniform_continuous.{u_1}))
                                CpltSepUniformSpace.{u_1}
                                (@category_theory.concrete_category.to_category.{u_1} CpltSepUniformSpace.{u_1}
                                   CpltSepUniformSpace.concrete_category.{u_1})
                                UniformSpace.completion_functor.{u_1}
                                X)))
                       x_1)))
            (@uniformity.{u_1}
               (@category_theory.bundled.α.{u_1 u_1} uniform_space.{u_1}
                  (CpltSepUniformSpace.to_UniformSpace.{u_1}
                     (@category_theory.functor.obj.{u_1 u_1 u_1+1 u_1+1} UniformSpace.{u_1}
                        (@category_theory.bundled_hom.category.{u_1} uniform_space.{u_1}
                           (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β),
                              @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ))
                           (@category_theory.unbundled_hom.bundled_hom.{u_1}
                              (λ (α : Type u_1), uniform_space.{u_1} α)
                              uniform_continuous.{u_1 u_1}
                              UniformSpace.concrete_category_uniform_continuous.{u_1}))
                        CpltSepUniformSpace.{u_1}
                        (@category_theory.concrete_category.to_category.{u_1} CpltSepUniformSpace.{u_1}
                           CpltSepUniformSpace.concrete_category.{u_1})
                        UniformSpace.completion_functor.{u_1}
                        X)))
               (@category_theory.bundled.str.{u_1 u_1} uniform_space.{u_1}
                  (CpltSepUniformSpace.to_UniformSpace.{u_1}
                     (@category_theory.functor.obj.{u_1 u_1 u_1+1 u_1+1} UniformSpace.{u_1}
                        (@category_theory.bundled_hom.category.{u_1} uniform_space.{u_1}
                           (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β),
                              @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ))
                           (@category_theory.unbundled_hom.bundled_hom.{u_1}
                              (λ (α : Type u_1), uniform_space.{u_1} α)
                              uniform_continuous.{u_1 u_1}
                              UniformSpace.concrete_category_uniform_continuous.{u_1}))
                        CpltSepUniformSpace.{u_1}
                        (@category_theory.concrete_category.to_category.{u_1} CpltSepUniformSpace.{u_1}
                           CpltSepUniformSpace.concrete_category.{u_1})
                        UniformSpace.completion_functor.{u_1}
                        X))))
            (@uniformity.{u_1}
               (@category_theory.bundled.α.{u_1 u_1} uniform_space.{u_1} (CpltSepUniformSpace.to_UniformSpace.{u_1} Y))
               (@category_theory.bundled.str.{u_1 u_1} uniform_space.{u_1}
                  (CpltSepUniformSpace.to_UniformSpace.{u_1} Y))))
       f
       x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>134  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>135  /-- The completion functor is left adjoint to the forgetful functor. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>136  noncomputable def adj : completion_functor ⊣ forget₂ CpltSepUniformSpace UniformSpace :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='blue'><a title='UniformSpace.completion_functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.adjunction'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.forget₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='CpltSepUniformSpace'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='UniformSpace'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='red'><a title='{&#x27;line&#x27;: 97, &#x27;column&#x27;: 18}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/adjunction/basic.lean&#x27;, &#x27;line&#x27;: 23, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/concrete_category/basic.lean&#x27;, &#x27;line&#x27;: 112, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 60, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 27, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='green'><a title='@category_theory.functor.{u_1 u_1 u_1+1 u_1+1} UniformSpace.{u_1} (@category_theory.bundled_hom.category.{u_1} uniform_space.{u_1} (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β), @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ)) (@category_theory.unbundled_hom.bundled_hom.{u_1} (λ (α : Type u_1), uniform_space.{u_1} α) uniform_continuous.{u_1 u_1} UniformSpace.concrete_category_uniform_continuous.{u_1})) CpltSepUniformSpace.{u_1} (@category_theory.concrete_category.to_category.{u_1} CpltSepUniformSpace.{u_1} CpltSepUniformSpace.concrete_category.{u_1})'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type (u_1+1)} [𝒞 : category_theory.category.{u_1 u_1+1} C] {D : Type (u_1+1)} [𝒟 : category_theory.category.{u_1 u_1+1} D], @category_theory.functor.{u_1 u_1 u_1+1 u_1+1} C 𝒞 D 𝒟 → @category_theory.functor.{u_1 u_1 u_1+1 u_1+1} D 𝒟 C 𝒞 → Type (u_1+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C D : Type (u+1)) [_inst_1 : category_theory.concrete_category.{u} C] [_inst_2 : category_theory.concrete_category.{u} D] [_inst_3 : @category_theory.has_forget₂.{u} C D _inst_1 _inst_2], @category_theory.functor.{u u u+1 u+1} C (@category_theory.concrete_category.to_category.{u} C _inst_1) D (@category_theory.concrete_category.to_category.{u} D _inst_2)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='orange'><a title='The functor turning uniform spaces into complete separated uniform spaces.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`F ⊣ G` represents the data of an adjunction between two functors
`F : C ⥤ D` and `G : D ⥤ C`. `F` is the left adjoint and `G` is the right adjoint.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title=' The forgetful functor `C ⥤ D` between concrete categories for which we have an instance
`has_forget₂ C `.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='A (bundled) complete separated uniform space.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='A (bundled) uniform spaces.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>137  adjunction.mk_of_hom_equiv</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.adjunction.mk_of_hom_equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/adjunction/basic.lean&#x27;, &#x27;line&#x27;: 150, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟} {G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞}, @category_theory.adjunction.core_hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G → @category_theory.adjunction.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>138  { hom_equiv := λ X Y,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='obviously'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='green'><a title='UniformSpace.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='CpltSepUniformSpace.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `obviously` tactic is a &quot;replaceable&quot; tactic, which means that its meaning is defined by tactics that are defined later with the `@[obviously]` attribute. It is intended for use with `auto_param`s for structure fields.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>139    { to_fun := λ f, completion_hom X ≫ f,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='UniformSpace.completion_hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='red'><a title='{&#x27;line&#x27;: 111, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='green'><a title='(λ (X Y : @category_theory.induced_category.{u_1 u_1+1 u_1+1} CpltSepUniformSpace.{u_1} UniformSpace.{u_1} (@category_theory.category.mk.{u_1 u_1+1} (category_theory.bundled.{u_1 u_1} uniform_space.{u_1}) (@category_theory.category.to_category_struct.{u_1 u_1+1} (category_theory.bundled.{u_1 u_1} uniform_space.{u_1}) (@category_theory.bundled_hom.category.{u_1} uniform_space.{u_1} (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β), @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ)) (@category_theory.unbundled_hom.bundled_hom.{u_1} (λ (α : Type u_1), uniform_space.{u_1} α) uniform_continuous.{u_1 u_1} UniformSpace.concrete_category_uniform_continuous.{u_1}))) (@category_theory.bundled_hom.category_theory.concrete_category._proof_1.{u_1} uniform_space.{u_1} (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β), @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ)) (@category_theory.unbundled_hom.bundled_hom.{u_1} (λ (α : Type u_1), uniform_space.{u_1} α) uniform_continuous.{u_1 u_1} UniformSpace.concrete_category_uniform_continuous.{u_1})) (@category_theory.bundled_hom.category_theory.concrete_category._proof_2.{u_1} uniform_space.{u_1} (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β), @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ)) (@category_theory.unbundled_hom.bundled_hom.{u_1} (λ (α : Type u_1), uniform_space.{u_1} α) uniform_continuous.{u_1 u_1} UniformSpace.concrete_category_uniform_continuous.{u_1})) (@category_theory.bundled_hom.category_theory.concrete_category._proof_3.{u_1} uniform_space.{u_1} (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β), @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ)) (@category_theory.unbundled_hom.bundled_hom.{u_1} (λ (α : Type u_1), uniform_space.{u_1} α) uniform_continuous.{u_1 u_1} UniformSpace.concrete_category_uniform_continuous.{u_1}))) CpltSepUniformSpace.to_UniformSpace.{u_1}), (λ (X Y : category_theory.bundled.{u_1 u_1} uniform_space.{u_1}), (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β), @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ)) (@category_theory.bundled.α.{u_1 u_1} uniform_space.{u_1} X) (@category_theory.bundled.α.{u_1 u_1} uniform_space.{u_1} Y) (@category_theory.bundled.str.{u_1 u_1} uniform_space.{u_1} X) (@category_theory.bundled.str.{u_1 u_1} uniform_space.{u_1} Y)) (CpltSepUniformSpace.to_UniformSpace.{u_1} X) (CpltSepUniformSpace.to_UniformSpace.{u_1} Y)) ((λ (X : UniformSpace.{u_1}), @CpltSepUniformSpace.of.{u_1} (@uniform_space.completion.{u_1} (@coe_sort.{u_1+2 u_1+2} UniformSpace.{u_1} (@category_theory.bundled.has_coe_to_sort.{u_1 u_1} uniform_space.{u_1}) X) (UniformSpace.uniform_space.{u_1} X)) (@uniform_space.completion.uniform_space.{u_1} (@coe_sort.{u_1+2 u_1+2} UniformSpace.{u_1} (@category_theory.bundled.has_coe_to_sort.{u_1 u_1} uniform_space.{u_1}) X) (UniformSpace.uniform_space.{u_1} X)) (UniformSpace.completion_functor._proof_1.{u_1} X) (UniformSpace.completion_functor._proof_2.{u_1} X)) X) Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (X : UniformSpace.{u_1}), @category_theory.has_hom.hom.{u_1 u_1+1} UniformSpace.{u_1} (@category_theory.category_struct.to_has_hom.{u_1 u_1+1} UniformSpace.{u_1} (@category_theory.category.to_category_struct.{u_1 u_1+1} UniformSpace.{u_1} (@category_theory.bundled_hom.category.{u_1} uniform_space.{u_1} (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β), @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ)) (@category_theory.unbundled_hom.bundled_hom.{u_1} (λ (α : Type u_1), uniform_space.{u_1} α) uniform_continuous.{u_1 u_1} UniformSpace.concrete_category_uniform_continuous.{u_1})))) X (@category_theory.functor.obj.{u_1 u_1 u_1+1 u_1+1} CpltSepUniformSpace.{u_1} (@category_theory.concrete_category.to_category.{u_1} CpltSepUniformSpace.{u_1} CpltSepUniformSpace.concrete_category.{u_1}) UniformSpace.{u_1} (@category_theory.concrete_category.to_category.{u_1} UniformSpace.{u_1} (@category_theory.bundled_hom.category_theory.concrete_category.{u_1} uniform_space.{u_1} (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β), @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ)) (@category_theory.unbundled_hom.bundled_hom.{u_1} (λ (α : Type u_1), uniform_space.{u_1} α) uniform_continuous.{u_1 u_1} UniformSpace.concrete_category_uniform_continuous.{u_1}))) (@category_theory.forget₂.{u_1} CpltSepUniformSpace.{u_1} UniformSpace.{u_1} CpltSepUniformSpace.concrete_category.{u_1} (@category_theory.bundled_hom.category_theory.concrete_category.{u_1} uniform_space.{u_1} (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β), @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ)) (@category_theory.unbundled_hom.bundled_hom.{u_1} (λ (α : Type u_1), uniform_space.{u_1} α) uniform_continuous.{u_1 u_1} UniformSpace.concrete_category_uniform_continuous.{u_1})) CpltSepUniformSpace.has_forget_to_UniformSpace.{u_1}) (@category_theory.functor.obj.{u_1 u_1 u_1+1 u_1+1} UniformSpace.{u_1} (@category_theory.bundled_hom.category.{u_1} uniform_space.{u_1} (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β), @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ)) (@category_theory.unbundled_hom.bundled_hom.{u_1} (λ (α : Type u_1), uniform_space.{u_1} α) uniform_continuous.{u_1 u_1} UniformSpace.concrete_category_uniform_continuous.{u_1})) CpltSepUniformSpace.{u_1} (@category_theory.concrete_category.to_category.{u_1} CpltSepUniformSpace.{u_1} CpltSepUniformSpace.concrete_category.{u_1}) UniformSpace.completion_functor.{u_1} X))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='UniformSpace.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type (u_1+1)} [c : category_theory.category_struct.{u_1 u_1+1} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{u_1 u_1+1} obj (@category_theory.category_struct.to_has_hom.{u_1 u_1+1} obj c) X Y → @category_theory.has_hom.hom.{u_1 u_1+1} obj (@category_theory.category_struct.to_has_hom.{u_1 u_1+1} obj c) Y Z → @category_theory.has_hom.hom.{u_1 u_1+1} obj (@category_theory.category_struct.to_has_hom.{u_1 u_1+1} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='(λ (X Y : @category_theory.induced_category.{u_1 u_1+1 u_1+1} CpltSepUniformSpace.{u_1} UniformSpace.{u_1} (@category_theory.category.mk.{u_1 u_1+1} (category_theory.bundled.{u_1 u_1} uniform_space.{u_1}) (@category_theory.category.to_category_struct.{u_1 u_1+1} (category_theory.bundled.{u_1 u_1} uniform_space.{u_1}) (@category_theory.bundled_hom.category.{u_1} uniform_space.{u_1} (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β), @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ)) (@category_theory.unbundled_hom.bundled_hom.{u_1} (λ (α : Type u_1), uniform_space.{u_1} α) uniform_continuous.{u_1 u_1} UniformSpace.concrete_category_uniform_continuous.{u_1}))) (@category_theory.bundled_hom.category_theory.concrete_category._proof_1.{u_1} uniform_space.{u_1} (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β), @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ)) (@category_theory.unbundled_hom.bundled_hom.{u_1} (λ (α : Type u_1), uniform_space.{u_1} α) uniform_continuous.{u_1 u_1} UniformSpace.concrete_category_uniform_continuous.{u_1})) (@category_theory.bundled_hom.category_theory.concrete_category._proof_2.{u_1} uniform_space.{u_1} (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β), @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ)) (@category_theory.unbundled_hom.bundled_hom.{u_1} (λ (α : Type u_1), uniform_space.{u_1} α) uniform_continuous.{u_1 u_1} UniformSpace.concrete_category_uniform_continuous.{u_1})) (@category_theory.bundled_hom.category_theory.concrete_category._proof_3.{u_1} uniform_space.{u_1} (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β), @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ)) (@category_theory.unbundled_hom.bundled_hom.{u_1} (λ (α : Type u_1), uniform_space.{u_1} α) uniform_continuous.{u_1 u_1} UniformSpace.concrete_category_uniform_continuous.{u_1}))) CpltSepUniformSpace.to_UniformSpace.{u_1}), (λ (X Y : category_theory.bundled.{u_1 u_1} uniform_space.{u_1}), (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β), @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ)) (@category_theory.bundled.α.{u_1 u_1} uniform_space.{u_1} X) (@category_theory.bundled.α.{u_1 u_1} uniform_space.{u_1} Y) (@category_theory.bundled.str.{u_1 u_1} uniform_space.{u_1} X) (@category_theory.bundled.str.{u_1 u_1} uniform_space.{u_1} Y)) (CpltSepUniformSpace.to_UniformSpace.{u_1} X) (CpltSepUniformSpace.to_UniformSpace.{u_1} Y)) ((λ (X : UniformSpace.{u_1}), @CpltSepUniformSpace.of.{u_1} (@uniform_space.completion.{u_1} (@coe_sort.{u_1+2 u_1+2} UniformSpace.{u_1} (@category_theory.bundled.has_coe_to_sort.{u_1 u_1} uniform_space.{u_1}) X) (UniformSpace.uniform_space.{u_1} X)) (@uniform_space.completion.uniform_space.{u_1} (@coe_sort.{u_1+2 u_1+2} UniformSpace.{u_1} (@category_theory.bundled.has_coe_to_sort.{u_1 u_1} uniform_space.{u_1}) X) (UniformSpace.uniform_space.{u_1} X)) (UniformSpace.completion_functor._proof_1.{u_1} X) (UniformSpace.completion_functor._proof_2.{u_1} X)) X) Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='The inclusion of any uniform spaces into its completion.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>140      inv_fun := λ f, extension_hom f,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='UniformSpace.extension_hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='red'><a title='{&#x27;line&#x27;: 120, &#x27;column&#x27;: 18}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='green'><a title='(λ (X Y : category_theory.bundled.{u_1 u_1} uniform_space.{u_1}), (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β), @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ)) (@category_theory.bundled.α.{u_1 u_1} uniform_space.{u_1} X) (@category_theory.bundled.α.{u_1 u_1} uniform_space.{u_1} Y) (@category_theory.bundled.str.{u_1 u_1} uniform_space.{u_1} X) (@category_theory.bundled.str.{u_1 u_1} uniform_space.{u_1} Y)) X (CpltSepUniformSpace.to_UniformSpace.{u_1} Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {X : UniformSpace.{u_1}} {Y : CpltSepUniformSpace.{u_1}}, @category_theory.has_hom.hom.{u_1 u_1+1} UniformSpace.{u_1} (@category_theory.category_struct.to_has_hom.{u_1 u_1+1} UniformSpace.{u_1} (@category_theory.category.to_category_struct.{u_1 u_1+1} UniformSpace.{u_1} (@category_theory.bundled_hom.category.{u_1} uniform_space.{u_1} (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β), @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ)) (@category_theory.unbundled_hom.bundled_hom.{u_1} (λ (α : Type u_1), uniform_space.{u_1} α) uniform_continuous.{u_1 u_1} UniformSpace.concrete_category_uniform_continuous.{u_1})))) X (@category_theory.functor.obj.{u_1 u_1 u_1+1 u_1+1} CpltSepUniformSpace.{u_1} (@category_theory.concrete_category.to_category.{u_1} CpltSepUniformSpace.{u_1} CpltSepUniformSpace.concrete_category.{u_1}) UniformSpace.{u_1} (@category_theory.concrete_category.to_category.{u_1} UniformSpace.{u_1} (@category_theory.bundled_hom.category_theory.concrete_category.{u_1} uniform_space.{u_1} (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β), @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ)) (@category_theory.unbundled_hom.bundled_hom.{u_1} (λ (α : Type u_1), uniform_space.{u_1} α) uniform_continuous.{u_1 u_1} UniformSpace.concrete_category_uniform_continuous.{u_1}))) (@category_theory.forget₂.{u_1} CpltSepUniformSpace.{u_1} UniformSpace.{u_1} CpltSepUniformSpace.concrete_category.{u_1} (@category_theory.bundled_hom.category_theory.concrete_category.{u_1} uniform_space.{u_1} (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β), @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ)) (@category_theory.unbundled_hom.bundled_hom.{u_1} (λ (α : Type u_1), uniform_space.{u_1} α) uniform_continuous.{u_1 u_1} UniformSpace.concrete_category_uniform_continuous.{u_1})) CpltSepUniformSpace.has_forget_to_UniformSpace.{u_1}) Y) → @category_theory.has_hom.hom.{u_1 u_1+1} CpltSepUniformSpace.{u_1} (@category_theory.category_struct.to_has_hom.{u_1 u_1+1} CpltSepUniformSpace.{u_1} (@category_theory.category.to_category_struct.{u_1 u_1+1} CpltSepUniformSpace.{u_1} (@category_theory.concrete_category.to_category.{u_1} CpltSepUniformSpace.{u_1} CpltSepUniformSpace.concrete_category.{u_1}))) (@category_theory.functor.obj.{u_1 u_1 u_1+1 u_1+1} UniformSpace.{u_1} (@category_theory.bundled_hom.category.{u_1} uniform_space.{u_1} (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β), @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ)) (@category_theory.unbundled_hom.bundled_hom.{u_1} (λ (α : Type u_1), uniform_space.{u_1} α) uniform_continuous.{u_1 u_1} UniformSpace.concrete_category_uniform_continuous.{u_1})) CpltSepUniformSpace.{u_1} (@category_theory.concrete_category.to_category.{u_1} CpltSepUniformSpace.{u_1} CpltSepUniformSpace.concrete_category.{u_1}) UniformSpace.completion_functor.{u_1} X) Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='(λ (X Y : category_theory.bundled.{u_1 u_1} uniform_space.{u_1}), (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β), @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ)) (@category_theory.bundled.α.{u_1 u_1} uniform_space.{u_1} X) (@category_theory.bundled.α.{u_1 u_1} uniform_space.{u_1} Y) (@category_theory.bundled.str.{u_1 u_1} uniform_space.{u_1} X) (@category_theory.bundled.str.{u_1 u_1} uniform_space.{u_1} Y)) X (CpltSepUniformSpace.to_UniformSpace.{u_1} Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title='The mate of a morphism from a `UniformSpace` to a `CpltSepUniformSpace`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>141      left_inv := λ f, by { dsimp, erw extension_comp_coe },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='blue'><a title='UniformSpace.extension_comp_coe'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1239, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 130, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='green'><a title='(λ (X Y : @category_theory.induced_category.{u_1 u_1+1 u_1+1} CpltSepUniformSpace.{u_1} UniformSpace.{u_1} (@category_theory.category.mk.{u_1 u_1+1} (category_theory.bundled.{u_1 u_1} uniform_space.{u_1}) (@category_theory.category.to_category_struct.{u_1 u_1+1} (category_theory.bundled.{u_1 u_1} uniform_space.{u_1}) (@category_theory.bundled_hom.category.{u_1} uniform_space.{u_1} (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β), @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ)) (@category_theory.unbundled_hom.bundled_hom.{u_1} (λ (α : Type u_1), uniform_space.{u_1} α) uniform_continuous.{u_1 u_1} UniformSpace.concrete_category_uniform_continuous.{u_1}))) (@category_theory.bundled_hom.category_theory.concrete_category._proof_1.{u_1} uniform_space.{u_1} (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β), @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ)) (@category_theory.unbundled_hom.bundled_hom.{u_1} (λ (α : Type u_1), uniform_space.{u_1} α) uniform_continuous.{u_1 u_1} UniformSpace.concrete_category_uniform_continuous.{u_1})) (@category_theory.bundled_hom.category_theory.concrete_category._proof_2.{u_1} uniform_space.{u_1} (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β), @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ)) (@category_theory.unbundled_hom.bundled_hom.{u_1} (λ (α : Type u_1), uniform_space.{u_1} α) uniform_continuous.{u_1 u_1} UniformSpace.concrete_category_uniform_continuous.{u_1})) (@category_theory.bundled_hom.category_theory.concrete_category._proof_3.{u_1} uniform_space.{u_1} (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β), @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ)) (@category_theory.unbundled_hom.bundled_hom.{u_1} (λ (α : Type u_1), uniform_space.{u_1} α) uniform_continuous.{u_1 u_1} UniformSpace.concrete_category_uniform_continuous.{u_1}))) CpltSepUniformSpace.to_UniformSpace.{u_1}), (λ (X Y : category_theory.bundled.{u_1 u_1} uniform_space.{u_1}), (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β), @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ)) (@category_theory.bundled.α.{u_1 u_1} uniform_space.{u_1} X) (@category_theory.bundled.α.{u_1 u_1} uniform_space.{u_1} Y) (@category_theory.bundled.str.{u_1 u_1} uniform_space.{u_1} X) (@category_theory.bundled.str.{u_1 u_1} uniform_space.{u_1} Y)) (CpltSepUniformSpace.to_UniformSpace.{u_1} X) (CpltSepUniformSpace.to_UniformSpace.{u_1} Y)) ((λ (X : UniformSpace.{u_1}), @CpltSepUniformSpace.of.{u_1} (@uniform_space.completion.{u_1} (@coe_sort.{u_1+2 u_1+2} UniformSpace.{u_1} (@category_theory.bundled.has_coe_to_sort.{u_1 u_1} uniform_space.{u_1}) X) (UniformSpace.uniform_space.{u_1} X)) (@uniform_space.completion.uniform_space.{u_1} (@coe_sort.{u_1+2 u_1+2} UniformSpace.{u_1} (@category_theory.bundled.has_coe_to_sort.{u_1 u_1} uniform_space.{u_1}) X) (UniformSpace.uniform_space.{u_1} X)) (UniformSpace.completion_functor._proof_1.{u_1} X) (UniformSpace.completion_functor._proof_2.{u_1} X)) X) Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {X : UniformSpace.{u_1}} {Y : CpltSepUniformSpace.{u_1}} (f : @category_theory.has_hom.hom.{u_1 u_1+1} UniformSpace.{u_1} (@category_theory.category_struct.to_has_hom.{u_1 u_1+1} UniformSpace.{u_1} (@category_theory.category.to_category_struct.{u_1 u_1+1} UniformSpace.{u_1} (@category_theory.bundled_hom.category.{u_1} uniform_space.{u_1} (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β), @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ)) (@category_theory.unbundled_hom.bundled_hom.{u_1} (λ (α : Type u_1), uniform_space.{u_1} α) uniform_continuous.{u_1 u_1} UniformSpace.concrete_category_uniform_continuous.{u_1})))) (CpltSepUniformSpace.to_UniformSpace.{u_1} (@CpltSepUniformSpace.of.{u_1} (@uniform_space.completion.{u_1} (@coe_sort.{u_1+2 u_1+2} UniformSpace.{u_1} (@category_theory.bundled.has_coe_to_sort.{u_1 u_1} uniform_space.{u_1}) X) (UniformSpace.uniform_space.{u_1} X)) (@uniform_space.completion.uniform_space.{u_1} (@coe_sort.{u_1+2 u_1+2} UniformSpace.{u_1} (@category_theory.bundled.has_coe_to_sort.{u_1 u_1} uniform_space.{u_1}) X) (UniformSpace.uniform_space.{u_1} X)) (@uniform_space.completion.complete_space.{u_1} (@coe_sort.{u_1+2 u_1+2} UniformSpace.{u_1} (@category_theory.bundled.has_coe_to_sort.{u_1 u_1} uniform_space.{u_1}) X) (UniformSpace.uniform_space.{u_1} X)) (@uniform_space.completion.separated.{u_1} (@coe_sort.{u_1+2 u_1+2} UniformSpace.{u_1} (@category_theory.bundled.has_coe_to_sort.{u_1 u_1} uniform_space.{u_1}) X) (UniformSpace.uniform_space.{u_1} X)))) (CpltSepUniformSpace.to_UniformSpace.{u_1} Y)), @eq.{u_1+1} (@category_theory.has_hom.hom.{u_1 u_1+1} CpltSepUniformSpace.{u_1} (@category_theory.category_struct.to_has_hom.{u_1 u_1+1} CpltSepUniformSpace.{u_1} (@category_theory.category.to_category_struct.{u_1 u_1+1} CpltSepUniformSpace.{u_1} (@category_theory.concrete_category.to_category.{u_1} CpltSepUniformSpace.{u_1} CpltSepUniformSpace.concrete_category.{u_1}))) (@category_theory.functor.obj.{u_1 u_1 u_1+1 u_1+1} UniformSpace.{u_1} (@category_theory.bundled_hom.category.{u_1} uniform_space.{u_1} (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β), @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ)) (@category_theory.unbundled_hom.bundled_hom.{u_1} (λ (α : Type u_1), uniform_space.{u_1} α) uniform_continuous.{u_1 u_1} UniformSpace.concrete_category_uniform_continuous.{u_1})) CpltSepUniformSpace.{u_1} (@category_theory.concrete_category.to_category.{u_1} CpltSepUniformSpace.{u_1} CpltSepUniformSpace.concrete_category.{u_1}) UniformSpace.completion_functor.{u_1} X) Y) (@UniformSpace.extension_hom.{u_1} X Y (@category_theory.category_struct.comp.{u_1 u_1+1} UniformSpace.{u_1} (@category_theory.category.to_category_struct.{u_1 u_1+1} UniformSpace.{u_1} (@category_theory.bundled_hom.category.{u_1} uniform_space.{u_1} (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β), @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ)) (@category_theory.unbundled_hom.bundled_hom.{u_1} (λ (α : Type u_1), uniform_space.{u_1} α) uniform_continuous.{u_1 u_1} UniformSpace.concrete_category_uniform_continuous.{u_1}))) X (@category_theory.functor.obj.{u_1 u_1 u_1+1 u_1+1} CpltSepUniformSpace.{u_1} (@category_theory.concrete_category.to_category.{u_1} CpltSepUniformSpace.{u_1} CpltSepUniformSpace.concrete_category.{u_1}) UniformSpace.{u_1} (@category_theory.concrete_category.to_category.{u_1} UniformSpace.{u_1} (@category_theory.bundled_hom.category_theory.concrete_category.{u_1} uniform_space.{u_1} (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β), @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ)) (@category_theory.unbundled_hom.bundled_hom.{u_1} (λ (α : Type u_1), uniform_space.{u_1} α) uniform_continuous.{u_1 u_1} UniformSpace.concrete_category_uniform_continuous.{u_1}))) (@category_theory.forget₂.{u_1} CpltSepUniformSpace.{u_1} UniformSpace.{u_1} CpltSepUniformSpace.concrete_category.{u_1} (@category_theory.bundled_hom.category_theory.concrete_category.{u_1} uniform_space.{u_1} (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β), @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ)) (@category_theory.unbundled_hom.bundled_hom.{u_1} (λ (α : Type u_1), uniform_space.{u_1} α) uniform_continuous.{u_1 u_1} UniformSpace.concrete_category_uniform_continuous.{u_1})) CpltSepUniformSpace.has_forget_to_UniformSpace.{u_1}) (@category_theory.functor.obj.{u_1 u_1 u_1+1 u_1+1} UniformSpace.{u_1} (@category_theory.bundled_hom.category.{u_1} uniform_space.{u_1} (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β), @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ)) (@category_theory.unbundled_hom.bundled_hom.{u_1} (λ (α : Type u_1), uniform_space.{u_1} α) uniform_continuous.{u_1 u_1} UniformSpace.concrete_category_uniform_continuous.{u_1})) CpltSepUniformSpace.{u_1} (@category_theory.concrete_category.to_category.{u_1} CpltSepUniformSpace.{u_1} CpltSepUniformSpace.concrete_category.{u_1}) UniformSpace.completion_functor.{u_1} X)) (@category_theory.functor.obj.{u_1 u_1 u_1+1 u_1+1} CpltSepUniformSpace.{u_1} (@category_theory.concrete_category.to_category.{u_1} CpltSepUniformSpace.{u_1} CpltSepUniformSpace.concrete_category.{u_1}) UniformSpace.{u_1} (@category_theory.concrete_category.to_category.{u_1} UniformSpace.{u_1} (@category_theory.bundled_hom.category_theory.concrete_category.{u_1} uniform_space.{u_1} (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β), @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ)) (@category_theory.unbundled_hom.bundled_hom.{u_1} (λ (α : Type u_1), uniform_space.{u_1} α) uniform_continuous.{u_1 u_1} UniformSpace.concrete_category_uniform_continuous.{u_1}))) (@category_theory.forget₂.{u_1} CpltSepUniformSpace.{u_1} UniformSpace.{u_1} CpltSepUniformSpace.concrete_category.{u_1} (@category_theory.bundled_hom.category_theory.concrete_category.{u_1} uniform_space.{u_1} (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β), @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ)) (@category_theory.unbundled_hom.bundled_hom.{u_1} (λ (α : Type u_1), uniform_space.{u_1} α) uniform_continuous.{u_1 u_1} UniformSpace.concrete_category_uniform_continuous.{u_1})) CpltSepUniformSpace.has_forget_to_UniformSpace.{u_1}) Y) (UniformSpace.completion_hom.{u_1} X) f)) f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='orange'><a title='`dsimp` is similar to `simp`, except that it only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='lime'><a title='X : UniformSpace.{?l_1},
Y : CpltSepUniformSpace.{?l_1},
f :
  (λ
   (X Y :
     @category_theory.induced_category.{?l_1 ?l_1+1 ?l_1+1} CpltSepUniformSpace.{?l_1} UniformSpace.{?l_1}
       (@category_theory.category.mk.{?l_1 ?l_1+1} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
          (@category_theory.category.to_category_struct.{?l_1 ?l_1+1}
             (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
             (@category_theory.bundled_hom.category.{?l_1} uniform_space.{?l_1}
                (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                   @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{?l_1} (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                   uniform_continuous.{?l_1 ?l_1}
                   UniformSpace.concrete_category_uniform_continuous.{?l_1})))
          (@category_theory.bundled_hom.category_theory.concrete_category._proof_1.{?l_1} uniform_space.{?l_1}
             (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{?l_1} (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                uniform_continuous.{?l_1 ?l_1}
                UniformSpace.concrete_category_uniform_continuous.{?l_1}))
          (@category_theory.bundled_hom.category_theory.concrete_category._proof_2.{?l_1} uniform_space.{?l_1}
             (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{?l_1} (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                uniform_continuous.{?l_1 ?l_1}
                UniformSpace.concrete_category_uniform_continuous.{?l_1}))
          (@category_theory.bundled_hom.category_theory.concrete_category._proof_3.{?l_1} uniform_space.{?l_1}
             (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{?l_1} (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                uniform_continuous.{?l_1 ?l_1}
                UniformSpace.concrete_category_uniform_continuous.{?l_1})))
       CpltSepUniformSpace.to_UniformSpace.{?l_1}),
     (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
        (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
           @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
          (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
          (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
          (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
          (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y))
       (CpltSepUniformSpace.to_UniformSpace.{?l_1} X)
       (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
    ((λ (X : UniformSpace.{?l_1}),
        @CpltSepUniformSpace.of.{?l_1}
          (@uniform_space.completion.{?l_1}
             (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                X)
             (UniformSpace.uniform_space.{?l_1} X))
          (@uniform_space.completion.uniform_space.{?l_1}
             (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                X)
             (UniformSpace.uniform_space.{?l_1} X))
          (UniformSpace.completion_functor._proof_1.{?l_1} X)
          (UniformSpace.completion_functor._proof_2.{?l_1} X))
       X)
    Y
⊢ @eq.{?l_1+1}
    ((λ
      (X Y :
        @category_theory.induced_category.{?l_1 ?l_1+1 ?l_1+1} CpltSepUniformSpace.{?l_1} UniformSpace.{?l_1}
          (@category_theory.category.mk.{?l_1 ?l_1+1} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
             (@category_theory.category.to_category_struct.{?l_1 ?l_1+1}
                (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                (@category_theory.bundled_hom.category.{?l_1} uniform_space.{?l_1}
                   (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                      @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                   (@category_theory.unbundled_hom.bundled_hom.{?l_1} (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                      uniform_continuous.{?l_1 ?l_1}
                      UniformSpace.concrete_category_uniform_continuous.{?l_1})))
             (@category_theory.bundled_hom.category_theory.concrete_category._proof_1.{?l_1} uniform_space.{?l_1}
                (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                   @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{?l_1} (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                   uniform_continuous.{?l_1 ?l_1}
                   UniformSpace.concrete_category_uniform_continuous.{?l_1}))
             (@category_theory.bundled_hom.category_theory.concrete_category._proof_2.{?l_1} uniform_space.{?l_1}
                (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                   @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{?l_1} (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                   uniform_continuous.{?l_1 ?l_1}
                   UniformSpace.concrete_category_uniform_continuous.{?l_1}))
             (@category_theory.bundled_hom.category_theory.concrete_category._proof_3.{?l_1} uniform_space.{?l_1}
                (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                   @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{?l_1} (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                   uniform_continuous.{?l_1 ?l_1}
                   UniformSpace.concrete_category_uniform_continuous.{?l_1})))
          CpltSepUniformSpace.to_UniformSpace.{?l_1}),
        (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
           (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
              @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
             (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
             (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
             (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
             (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y))
          (CpltSepUniformSpace.to_UniformSpace.{?l_1} X)
          (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
       ((λ (X : UniformSpace.{?l_1}),
           @CpltSepUniformSpace.of.{?l_1}
             (@uniform_space.completion.{?l_1}
                (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                   (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                   X)
                (UniformSpace.uniform_space.{?l_1} X))
             (@uniform_space.completion.uniform_space.{?l_1}
                (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                   (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                   X)
                (UniformSpace.uniform_space.{?l_1} X))
             (UniformSpace.completion_functor._proof_1.{?l_1} X)
             (UniformSpace.completion_functor._proof_2.{?l_1} X))
          X)
       Y)
    ((λ
      (f :
        (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
           (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
              @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
             (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
             (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
             (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
             (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y))
          X
          (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y)), @UniformSpace.extension_hom.{?l_1} X Y f)
       ((λ
         (f :
           (λ
            (X Y :
              @category_theory.induced_category.{?l_1 ?l_1+1 ?l_1+1} CpltSepUniformSpace.{?l_1} UniformSpace.{?l_1}
                (@category_theory.category.mk.{?l_1 ?l_1+1} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                   (@category_theory.category_struct.mk.{?l_1 ?l_1+1}
                      (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                      (@category_theory.has_hom.mk.{?l_1 ?l_1+1}
                         (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                         (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                            (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                               @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                              (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                              (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                              (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                              (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y)))
                      (λ (X : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                         @category_theory.bundled_hom.id.{?l_1} uniform_space.{?l_1}
                           (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                              @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                           (@category_theory.unbundled_hom.bundled_hom.{?l_1}
                              (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                              uniform_continuous.{?l_1 ?l_1}
                              UniformSpace.concrete_category_uniform_continuous.{?l_1})
                           (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                              (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                              X)
                           (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X))
                      (λ (X Y Z : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                       (f :
                         @category_theory.has_hom.hom.{?l_1 ?l_1+1}
                           (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                           (@category_theory.has_hom.mk.{?l_1 ?l_1+1}
                              (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                              (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                                 (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α)
                                  (Iβ : uniform_space.{?l_1} β),
                                    @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                                   (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                   (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                                   (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                   (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y)))
                           X
                           Y)
                       (g :
                         @category_theory.has_hom.hom.{?l_1 ?l_1+1}
                           (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                           (@category_theory.has_hom.mk.{?l_1 ?l_1+1}
                              (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                              (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                                 (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α)
                                  (Iβ : uniform_space.{?l_1} β),
                                    @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                                   (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                   (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                                   (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                   (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y)))
                           Y
                           Z),
                         @category_theory.bundled_hom.comp.{?l_1} uniform_space.{?l_1}
                           (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                              @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                           (@category_theory.unbundled_hom.bundled_hom.{?l_1}
                              (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                              uniform_continuous.{?l_1 ?l_1}
                              UniformSpace.concrete_category_uniform_continuous.{?l_1})
                           (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                              (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                              X)
                           (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                              (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                              Y)
                           (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                              (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                              Z)
                           (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                           (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                           (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Z)
                           g
                           f))
                   (@category_theory.bundled_hom.category_theory.concrete_category._proof_1.{?l_1} uniform_space.{?l_1}
                      (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                         @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                      (@category_theory.unbundled_hom.bundled_hom.{?l_1} (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                         uniform_continuous.{?l_1 ?l_1}
                         UniformSpace.concrete_category_uniform_continuous.{?l_1}))
                   (@category_theory.bundled_hom.category_theory.concrete_category._proof_2.{?l_1} uniform_space.{?l_1}
                      (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                         @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                      (@category_theory.unbundled_hom.bundled_hom.{?l_1} (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                         uniform_continuous.{?l_1 ?l_1}
                         UniformSpace.concrete_category_uniform_continuous.{?l_1}))
                   (@category_theory.bundled_hom.category_theory.concrete_category._proof_3.{?l_1} uniform_space.{?l_1}
                      (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                         @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                      (@category_theory.unbundled_hom.bundled_hom.{?l_1} (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                         uniform_continuous.{?l_1 ?l_1}
                         UniformSpace.concrete_category_uniform_continuous.{?l_1})))
                CpltSepUniformSpace.to_UniformSpace.{?l_1}),
              (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                 (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                    @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                   (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                   (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                   (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                   (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y))
                (CpltSepUniformSpace.to_UniformSpace.{?l_1} X)
                (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
             ((λ (X : UniformSpace.{?l_1}),
                 @CpltSepUniformSpace.of.{?l_1}
                   (@uniform_space.completion.{?l_1}
                      (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                         (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                         X)
                      (UniformSpace.uniform_space.{?l_1} X))
                   (@uniform_space.completion.uniform_space.{?l_1}
                      (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                         (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                         X)
                      (UniformSpace.uniform_space.{?l_1} X))
                   (UniformSpace.completion_functor._proof_1.{?l_1} X)
                   (UniformSpace.completion_functor._proof_2.{?l_1} X))
                X)
             Y),
           (λ (X Y Z : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
            (f :
              @category_theory.has_hom.hom.{?l_1 ?l_1+1} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                (@category_theory.has_hom.mk.{?l_1 ?l_1+1} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                   (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                      (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                         @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                        (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                        (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                        (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                        (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y)))
                X
                Y)
            (g :
              @category_theory.has_hom.hom.{?l_1 ?l_1+1} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                (@category_theory.has_hom.mk.{?l_1 ?l_1+1} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                   (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                      (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                         @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                        (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                        (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                        (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                        (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y)))
                Y
                Z),
              @category_theory.bundled_hom.comp.{?l_1} uniform_space.{?l_1}
                (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                   @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{?l_1} (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                   uniform_continuous.{?l_1 ?l_1}
                   UniformSpace.concrete_category_uniform_continuous.{?l_1})
                (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                   (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                   X)
                (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                   (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                   Y)
                (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                   (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                   Z)
                (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Z)
                g
                f)
             X
             (CpltSepUniformSpace.to_UniformSpace.{?l_1}
                ((λ (X : UniformSpace.{?l_1}),
                    @CpltSepUniformSpace.of.{?l_1}
                      (@uniform_space.completion.{?l_1}
                         (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                            (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                            X)
                         (UniformSpace.uniform_space.{?l_1} X))
                      (@uniform_space.completion.uniform_space.{?l_1}
                         (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                            (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                            X)
                         (UniformSpace.uniform_space.{?l_1} X))
                      (UniformSpace.completion_functor._proof_1.{?l_1} X)
                      (UniformSpace.completion_functor._proof_2.{?l_1} X))
                   X))
             (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y)
             (UniformSpace.completion_hom.{?l_1} X)
             f)
          f))
    f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='X : UniformSpace.{?l_1},
Y : CpltSepUniformSpace.{?l_1},
f :
  (λ
   (X Y :
     @category_theory.induced_category.{?l_1 ?l_1+1 ?l_1+1} CpltSepUniformSpace.{?l_1} UniformSpace.{?l_1}
       (@category_theory.category.mk.{?l_1 ?l_1+1} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
          (@category_theory.category.to_category_struct.{?l_1 ?l_1+1}
             (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
             (@category_theory.bundled_hom.category.{?l_1} uniform_space.{?l_1}
                (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                   @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{?l_1} (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                   uniform_continuous.{?l_1 ?l_1}
                   UniformSpace.concrete_category_uniform_continuous.{?l_1})))
          (@category_theory.bundled_hom.category_theory.concrete_category._proof_1.{?l_1} uniform_space.{?l_1}
             (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{?l_1} (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                uniform_continuous.{?l_1 ?l_1}
                UniformSpace.concrete_category_uniform_continuous.{?l_1}))
          (@category_theory.bundled_hom.category_theory.concrete_category._proof_2.{?l_1} uniform_space.{?l_1}
             (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{?l_1} (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                uniform_continuous.{?l_1 ?l_1}
                UniformSpace.concrete_category_uniform_continuous.{?l_1}))
          (@category_theory.bundled_hom.category_theory.concrete_category._proof_3.{?l_1} uniform_space.{?l_1}
             (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{?l_1} (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                uniform_continuous.{?l_1 ?l_1}
                UniformSpace.concrete_category_uniform_continuous.{?l_1})))
       CpltSepUniformSpace.to_UniformSpace.{?l_1}),
     (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
        (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
           @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
          (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
          (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
          (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
          (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y))
       (CpltSepUniformSpace.to_UniformSpace.{?l_1} X)
       (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
    ((λ (X : UniformSpace.{?l_1}),
        @CpltSepUniformSpace.of.{?l_1}
          (@uniform_space.completion.{?l_1}
             (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                X)
             (UniformSpace.uniform_space.{?l_1} X))
          (@uniform_space.completion.uniform_space.{?l_1}
             (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                X)
             (UniformSpace.uniform_space.{?l_1} X))
          (UniformSpace.completion_functor._proof_1.{?l_1} X)
          (UniformSpace.completion_functor._proof_2.{?l_1} X))
       X)
    Y
⊢ @eq.{?l_1+1}
    (@subtype.{?l_1+1}
       (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1}
          (CpltSepUniformSpace.to_UniformSpace.{?l_1}
             (@CpltSepUniformSpace.of.{?l_1}
                (@uniform_space.completion.{?l_1}
                   (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                      (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                      X)
                   (UniformSpace.uniform_space.{?l_1} X))
                (@uniform_space.completion.uniform_space.{?l_1}
                   (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                      (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                      X)
                   (UniformSpace.uniform_space.{?l_1} X))
                (UniformSpace.completion_functor._proof_1.{?l_1} X)
                (UniformSpace.completion_functor._proof_2.{?l_1} X))) →
        @category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
       (@uniform_continuous.{?l_1 ?l_1}
          (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1}
             (CpltSepUniformSpace.to_UniformSpace.{?l_1}
                (@CpltSepUniformSpace.of.{?l_1}
                   (@uniform_space.completion.{?l_1}
                      (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                         (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                         X)
                      (UniformSpace.uniform_space.{?l_1} X))
                   (@uniform_space.completion.uniform_space.{?l_1}
                      (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                         (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                         X)
                      (UniformSpace.uniform_space.{?l_1} X))
                   (UniformSpace.completion_functor._proof_1.{?l_1} X)
                   (UniformSpace.completion_functor._proof_2.{?l_1} X))))
          (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
          (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1}
             (CpltSepUniformSpace.to_UniformSpace.{?l_1}
                (@CpltSepUniformSpace.of.{?l_1}
                   (@uniform_space.completion.{?l_1}
                      (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                         (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                         X)
                      (UniformSpace.uniform_space.{?l_1} X))
                   (@uniform_space.completion.uniform_space.{?l_1}
                      (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                         (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                         X)
                      (UniformSpace.uniform_space.{?l_1} X))
                   (UniformSpace.completion_functor._proof_1.{?l_1} X)
                   (UniformSpace.completion_functor._proof_2.{?l_1} X))))
          (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1}
             (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))))
    (@UniformSpace.extension_hom.{?l_1} X Y
       (@category_theory.bundled_hom.comp.{?l_1} uniform_space.{?l_1}
          (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
             @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
          (@category_theory.unbundled_hom.bundled_hom.{?l_1} uniform_space.{?l_1} uniform_continuous.{?l_1 ?l_1}
             UniformSpace.concrete_category_uniform_continuous.{?l_1})
          (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
             (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
             X)
          (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
             (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
             (CpltSepUniformSpace.to_UniformSpace.{?l_1}
                (@CpltSepUniformSpace.of.{?l_1}
                   (@uniform_space.completion.{?l_1}
                      (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                         (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                         X)
                      (UniformSpace.uniform_space.{?l_1} X))
                   (@uniform_space.completion.uniform_space.{?l_1}
                      (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                         (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                         X)
                      (UniformSpace.uniform_space.{?l_1} X))
                   (UniformSpace.completion_functor._proof_1.{?l_1} X)
                   (UniformSpace.completion_functor._proof_2.{?l_1} X))))
          (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
             (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
             (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
          (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
          (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1}
             (CpltSepUniformSpace.to_UniformSpace.{?l_1}
                (@CpltSepUniformSpace.of.{?l_1}
                   (@uniform_space.completion.{?l_1}
                      (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                         (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                         X)
                      (UniformSpace.uniform_space.{?l_1} X))
                   (@uniform_space.completion.uniform_space.{?l_1}
                      (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                         (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                         X)
                      (UniformSpace.uniform_space.{?l_1} X))
                   (UniformSpace.completion_functor._proof_1.{?l_1} X)
                   (UniformSpace.completion_functor._proof_2.{?l_1} X))))
          (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
          f
          (UniformSpace.completion_hom.{?l_1} X)))
    f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>142      right_inv := λ f,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='green'><a title='(λ (X Y : category_theory.bundled.{u_1 u_1} uniform_space.{u_1}), (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β), @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ)) (@category_theory.bundled.α.{u_1 u_1} uniform_space.{u_1} X) (@category_theory.bundled.α.{u_1 u_1} uniform_space.{u_1} Y) (@category_theory.bundled.str.{u_1 u_1} uniform_space.{u_1} X) (@category_theory.bundled.str.{u_1 u_1} uniform_space.{u_1} Y)) X (CpltSepUniformSpace.to_UniformSpace.{u_1} Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>143      begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='lime'><a title='X : UniformSpace.{?l_1},
Y : CpltSepUniformSpace.{?l_1},
f :
  (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
     (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
        @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
       (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
       (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
       (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
       (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y))
    X
    (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y)
⊢ @eq.{?l_1+1}
    ((λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
        (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
           @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
          (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
          (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
          (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
          (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y))
       X
       (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
    ((λ
      (f :
        (λ
         (X Y :
           @category_theory.induced_category.{?l_1 ?l_1+1 ?l_1+1} CpltSepUniformSpace.{?l_1} UniformSpace.{?l_1}
             (@category_theory.category.mk.{?l_1 ?l_1+1} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                (@category_theory.category_struct.mk.{?l_1 ?l_1+1}
                   (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                   (@category_theory.has_hom.mk.{?l_1 ?l_1+1} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                      (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                         (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                            @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                           (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                           (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                           (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                           (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y)))
                   (λ (X : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                      @category_theory.bundled_hom.id.{?l_1} uniform_space.{?l_1}
                        (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                           @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                        (@category_theory.unbundled_hom.bundled_hom.{?l_1}
                           (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                           uniform_continuous.{?l_1 ?l_1}
                           UniformSpace.concrete_category_uniform_continuous.{?l_1})
                        (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                           (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                           X)
                        (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X))
                   (λ (X Y Z : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                    (f :
                      @category_theory.has_hom.hom.{?l_1 ?l_1+1}
                        (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                        (@category_theory.has_hom.mk.{?l_1 ?l_1+1}
                           (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                           (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                              (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                                 @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                                (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                                (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y)))
                        X
                        Y)
                    (g :
                      @category_theory.has_hom.hom.{?l_1 ?l_1+1}
                        (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                        (@category_theory.has_hom.mk.{?l_1 ?l_1+1}
                           (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                           (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                              (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                                 @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                                (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                                (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y)))
                        Y
                        Z),
                      @category_theory.bundled_hom.comp.{?l_1} uniform_space.{?l_1}
                        (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                           @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                        (@category_theory.unbundled_hom.bundled_hom.{?l_1}
                           (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                           uniform_continuous.{?l_1 ?l_1}
                           UniformSpace.concrete_category_uniform_continuous.{?l_1})
                        (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                           (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                           X)
                        (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                           (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                           Y)
                        (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                           (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                           Z)
                        (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                        (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                        (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Z)
                        g
                        f))
                (@category_theory.bundled_hom.category_theory.concrete_category._proof_1.{?l_1} uniform_space.{?l_1}
                   (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                      @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                   (@category_theory.unbundled_hom.bundled_hom.{?l_1} (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                      uniform_continuous.{?l_1 ?l_1}
                      UniformSpace.concrete_category_uniform_continuous.{?l_1}))
                (@category_theory.bundled_hom.category_theory.concrete_category._proof_2.{?l_1} uniform_space.{?l_1}
                   (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                      @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                   (@category_theory.unbundled_hom.bundled_hom.{?l_1} (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                      uniform_continuous.{?l_1 ?l_1}
                      UniformSpace.concrete_category_uniform_continuous.{?l_1}))
                (@category_theory.bundled_hom.category_theory.concrete_category._proof_3.{?l_1} uniform_space.{?l_1}
                   (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                      @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                   (@category_theory.unbundled_hom.bundled_hom.{?l_1} (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                      uniform_continuous.{?l_1 ?l_1}
                      UniformSpace.concrete_category_uniform_continuous.{?l_1})))
             CpltSepUniformSpace.to_UniformSpace.{?l_1}),
           (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
              (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                 @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y))
             (CpltSepUniformSpace.to_UniformSpace.{?l_1} X)
             (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
          ((λ (X : UniformSpace.{?l_1}),
              @CpltSepUniformSpace.of.{?l_1}
                (@uniform_space.completion.{?l_1}
                   (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                      (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                      X)
                   (UniformSpace.uniform_space.{?l_1} X))
                (@uniform_space.completion.uniform_space.{?l_1}
                   (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                      (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                      X)
                   (UniformSpace.uniform_space.{?l_1} X))
                (UniformSpace.completion_functor._proof_1.{?l_1} X)
                (UniformSpace.completion_functor._proof_2.{?l_1} X))
             X)
          Y),
        (λ (X Y Z : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
         (f :
           @category_theory.has_hom.hom.{?l_1 ?l_1+1} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
             (@category_theory.has_hom.mk.{?l_1 ?l_1+1} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                   (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                      @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                     (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                     (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                     (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                     (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y)))
             X
             Y)
         (g :
           @category_theory.has_hom.hom.{?l_1 ?l_1+1} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
             (@category_theory.has_hom.mk.{?l_1 ?l_1+1} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                   (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                      @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                     (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                     (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                     (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                     (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y)))
             Y
             Z),
           @category_theory.bundled_hom.comp.{?l_1} uniform_space.{?l_1}
             (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{?l_1} (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                uniform_continuous.{?l_1 ?l_1}
                UniformSpace.concrete_category_uniform_continuous.{?l_1})
             (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                X)
             (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                Y)
             (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                Z)
             (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
             (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y)
             (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Z)
             g
             f)
          X
          (CpltSepUniformSpace.to_UniformSpace.{?l_1}
             ((λ (X : UniformSpace.{?l_1}),
                 @CpltSepUniformSpace.of.{?l_1}
                   (@uniform_space.completion.{?l_1}
                      (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                         (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                         X)
                      (UniformSpace.uniform_space.{?l_1} X))
                   (@uniform_space.completion.uniform_space.{?l_1}
                      (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                         (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                         X)
                      (UniformSpace.uniform_space.{?l_1} X))
                   (UniformSpace.completion_functor._proof_1.{?l_1} X)
                   (UniformSpace.completion_functor._proof_2.{?l_1} X))
                X))
          (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y)
          (UniformSpace.completion_hom.{?l_1} X)
          f)
       ((λ
         (f :
           (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
              (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                 @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y))
             X
             (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y)), @UniformSpace.extension_hom.{?l_1} X Y f)
          f))
    f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>144        apply subtype.eq, funext x, cases f,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='subtype.eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/subtype/basic.lean&#x27;, &#x27;line&#x27;: 22, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1489, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {p : α → Prop} {a1 a2 : @subtype.{u_1+1} α (λ (x : α), p x)}, @eq.{u_1+1} α (@subtype.val.{u_1+1} α (λ (x : α), p x) a1) (@subtype.val.{u_1+1} α (λ (x : α), p x) a2) → @eq.{(max 1 (u_1+1))} (@subtype.{u_1+1} α (λ (x : α), p x)) a1 a2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='(λ (X Y : category_theory.bundled.{u_1 u_1} uniform_space.{u_1}), (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β), @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ)) (@category_theory.bundled.α.{u_1 u_1} uniform_space.{u_1} X) (@category_theory.bundled.α.{u_1 u_1} uniform_space.{u_1} Y) (@category_theory.bundled.str.{u_1 u_1} uniform_space.{u_1} X) (@category_theory.bundled.str.{u_1 u_1} uniform_space.{u_1} Y)) X (CpltSepUniformSpace.to_UniformSpace.{u_1} Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='Apply function extensionality and introduce new hypotheses.
The tactic `funext` will keep applying new the `funext` lemma until the goal target is not reducible to
```lean
  |-  ((fun x, ...) = (fun x, ...))
```
The variant `funext h₁ ... hₙ` applies `funext` `n` times, and uses the given identifiers to name the new hypotheses.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='funext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='X : UniformSpace.{?l_1},
Y : CpltSepUniformSpace.{?l_1},
f :
  (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
     (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
        @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
       (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
       (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
       (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
       (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y))
    X
    (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y)
⊢ @eq.{?l_1+1}
    ((λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
        (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
           @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
          (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
          (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
          (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
          (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y))
       X
       (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
    ((λ
      (f :
        (λ
         (X Y :
           @category_theory.induced_category.{?l_1 ?l_1+1 ?l_1+1} CpltSepUniformSpace.{?l_1} UniformSpace.{?l_1}
             (@category_theory.category.mk.{?l_1 ?l_1+1} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                (@category_theory.category_struct.mk.{?l_1 ?l_1+1}
                   (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                   (@category_theory.has_hom.mk.{?l_1 ?l_1+1} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                      (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                         (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                            @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                           (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                           (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                           (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                           (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y)))
                   (λ (X : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                      @category_theory.bundled_hom.id.{?l_1} uniform_space.{?l_1}
                        (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                           @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                        (@category_theory.unbundled_hom.bundled_hom.{?l_1}
                           (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                           uniform_continuous.{?l_1 ?l_1}
                           UniformSpace.concrete_category_uniform_continuous.{?l_1})
                        (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                           (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                           X)
                        (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X))
                   (λ (X Y Z : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                    (f :
                      @category_theory.has_hom.hom.{?l_1 ?l_1+1}
                        (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                        (@category_theory.has_hom.mk.{?l_1 ?l_1+1}
                           (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                           (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                              (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                                 @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                                (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                                (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y)))
                        X
                        Y)
                    (g :
                      @category_theory.has_hom.hom.{?l_1 ?l_1+1}
                        (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                        (@category_theory.has_hom.mk.{?l_1 ?l_1+1}
                           (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                           (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                              (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                                 @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                                (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                                (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y)))
                        Y
                        Z),
                      @category_theory.bundled_hom.comp.{?l_1} uniform_space.{?l_1}
                        (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                           @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                        (@category_theory.unbundled_hom.bundled_hom.{?l_1}
                           (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                           uniform_continuous.{?l_1 ?l_1}
                           UniformSpace.concrete_category_uniform_continuous.{?l_1})
                        (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                           (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                           X)
                        (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                           (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                           Y)
                        (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                           (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                           Z)
                        (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                        (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                        (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Z)
                        g
                        f))
                (@category_theory.bundled_hom.category_theory.concrete_category._proof_1.{?l_1} uniform_space.{?l_1}
                   (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                      @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                   (@category_theory.unbundled_hom.bundled_hom.{?l_1} (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                      uniform_continuous.{?l_1 ?l_1}
                      UniformSpace.concrete_category_uniform_continuous.{?l_1}))
                (@category_theory.bundled_hom.category_theory.concrete_category._proof_2.{?l_1} uniform_space.{?l_1}
                   (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                      @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                   (@category_theory.unbundled_hom.bundled_hom.{?l_1} (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                      uniform_continuous.{?l_1 ?l_1}
                      UniformSpace.concrete_category_uniform_continuous.{?l_1}))
                (@category_theory.bundled_hom.category_theory.concrete_category._proof_3.{?l_1} uniform_space.{?l_1}
                   (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                      @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                   (@category_theory.unbundled_hom.bundled_hom.{?l_1} (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                      uniform_continuous.{?l_1 ?l_1}
                      UniformSpace.concrete_category_uniform_continuous.{?l_1})))
             CpltSepUniformSpace.to_UniformSpace.{?l_1}),
           (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
              (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                 @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y))
             (CpltSepUniformSpace.to_UniformSpace.{?l_1} X)
             (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
          ((λ (X : UniformSpace.{?l_1}),
              @CpltSepUniformSpace.of.{?l_1}
                (@uniform_space.completion.{?l_1}
                   (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                      (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                      X)
                   (UniformSpace.uniform_space.{?l_1} X))
                (@uniform_space.completion.uniform_space.{?l_1}
                   (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                      (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                      X)
                   (UniformSpace.uniform_space.{?l_1} X))
                (UniformSpace.completion_functor._proof_1.{?l_1} X)
                (UniformSpace.completion_functor._proof_2.{?l_1} X))
             X)
          Y),
        (λ (X Y Z : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
         (f :
           @category_theory.has_hom.hom.{?l_1 ?l_1+1} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
             (@category_theory.has_hom.mk.{?l_1 ?l_1+1} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                   (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                      @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                     (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                     (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                     (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                     (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y)))
             X
             Y)
         (g :
           @category_theory.has_hom.hom.{?l_1 ?l_1+1} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
             (@category_theory.has_hom.mk.{?l_1 ?l_1+1} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                   (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                      @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                     (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                     (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                     (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                     (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y)))
             Y
             Z),
           @category_theory.bundled_hom.comp.{?l_1} uniform_space.{?l_1}
             (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{?l_1} (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                uniform_continuous.{?l_1 ?l_1}
                UniformSpace.concrete_category_uniform_continuous.{?l_1})
             (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                X)
             (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                Y)
             (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                Z)
             (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
             (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y)
             (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Z)
             g
             f)
          X
          (CpltSepUniformSpace.to_UniformSpace.{?l_1}
             ((λ (X : UniformSpace.{?l_1}),
                 @CpltSepUniformSpace.of.{?l_1}
                   (@uniform_space.completion.{?l_1}
                      (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                         (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                         X)
                      (UniformSpace.uniform_space.{?l_1} X))
                   (@uniform_space.completion.uniform_space.{?l_1}
                      (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                         (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                         X)
                      (UniformSpace.uniform_space.{?l_1} X))
                   (UniformSpace.completion_functor._proof_1.{?l_1} X)
                   (UniformSpace.completion_functor._proof_2.{?l_1} X))
                X))
          (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y)
          (UniformSpace.completion_hom.{?l_1} X)
          f)
       ((λ
         (f :
           (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
              (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                 @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y))
             X
             (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y)), @UniformSpace.extension_hom.{?l_1} X Y f)
          f))
    f'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='X : UniformSpace.{?l_1},
Y : CpltSepUniformSpace.{?l_1},
f :
  (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
     (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
        @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
       (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
       (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
       (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
       (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y))
    X
    (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y)
⊢ @eq.{?l_1+1}
    (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
       (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
       X →
     @coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
       (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
       (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
    (@subtype.val.{?l_1+1}
       (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
          (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
          X →
        @coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
          (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
          (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
       (λ
        (x :
          @coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
            (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
            X →
          @coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
            (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
            (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y)),
          @filter.tendsto.{?l_1 ?l_1}
            (prod.{?l_1 ?l_1}
               (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                  (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                  X)
               (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                  (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                  X))
            (prod.{?l_1 ?l_1}
               (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                  (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                  (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
               (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                  (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                  (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y)))
            (λ
             (x_1 :
               prod.{?l_1 ?l_1}
                 (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                    (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                    X)
                 (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                    (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                    X)),
               @prod.mk.{?l_1 ?l_1}
                 (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                    (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                    (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
                 (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                    (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                    (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
                 (x
                    (@prod.fst.{?l_1 ?l_1}
                       (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                          (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                          X)
                       (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                          (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                          X)
                       x_1))
                 (x
                    (@prod.snd.{?l_1 ?l_1}
                       (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                          (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                          X)
                       (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                          (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                          X)
                       x_1)))
            (@uniformity.{?l_1}
               (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                  (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                  X)
               (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X))
            (@uniformity.{?l_1}
               (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                  (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                  (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
               (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1}
                  (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))))
       ((λ
         (f :
           (λ
            (X Y :
              @category_theory.induced_category.{?l_1 ?l_1+1 ?l_1+1} CpltSepUniformSpace.{?l_1} UniformSpace.{?l_1}
                (@category_theory.category.mk.{?l_1 ?l_1+1} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                   (@category_theory.category_struct.mk.{?l_1 ?l_1+1}
                      (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                      (@category_theory.has_hom.mk.{?l_1 ?l_1+1}
                         (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                         (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                            (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                               @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                              (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                              (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                              (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                              (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y)))
                      (λ (X : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                         @category_theory.bundled_hom.id.{?l_1} uniform_space.{?l_1}
                           (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                              @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                           (@category_theory.unbundled_hom.bundled_hom.{?l_1}
                              (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                              uniform_continuous.{?l_1 ?l_1}
                              UniformSpace.concrete_category_uniform_continuous.{?l_1})
                           (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                              (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                              X)
                           (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X))
                      (λ (X Y Z : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                       (f :
                         @category_theory.has_hom.hom.{?l_1 ?l_1+1}
                           (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                           (@category_theory.has_hom.mk.{?l_1 ?l_1+1}
                              (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                              (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                                 (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α)
                                  (Iβ : uniform_space.{?l_1} β),
                                    @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                                   (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                   (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                                   (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                   (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y)))
                           X
                           Y)
                       (g :
                         @category_theory.has_hom.hom.{?l_1 ?l_1+1}
                           (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                           (@category_theory.has_hom.mk.{?l_1 ?l_1+1}
                              (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                              (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                                 (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α)
                                  (Iβ : uniform_space.{?l_1} β),
                                    @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                                   (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                   (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                                   (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                   (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y)))
                           Y
                           Z),
                         @category_theory.bundled_hom.comp.{?l_1} uniform_space.{?l_1}
                           (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                              @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                           (@category_theory.unbundled_hom.bundled_hom.{?l_1}
                              (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                              uniform_continuous.{?l_1 ?l_1}
                              UniformSpace.concrete_category_uniform_continuous.{?l_1})
                           (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                              (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                              X)
                           (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                              (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                              Y)
                           (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                              (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                              Z)
                           (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                           (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                           (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Z)
                           g
                           f))
                   (@category_theory.bundled_hom.category_theory.concrete_category._proof_1.{?l_1} uniform_space.{?l_1}
                      (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                         @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                      (@category_theory.unbundled_hom.bundled_hom.{?l_1} (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                         uniform_continuous.{?l_1 ?l_1}
                         UniformSpace.concrete_category_uniform_continuous.{?l_1}))
                   (@category_theory.bundled_hom.category_theory.concrete_category._proof_2.{?l_1} uniform_space.{?l_1}
                      (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                         @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                      (@category_theory.unbundled_hom.bundled_hom.{?l_1} (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                         uniform_continuous.{?l_1 ?l_1}
                         UniformSpace.concrete_category_uniform_continuous.{?l_1}))
                   (@category_theory.bundled_hom.category_theory.concrete_category._proof_3.{?l_1} uniform_space.{?l_1}
                      (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                         @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                      (@category_theory.unbundled_hom.bundled_hom.{?l_1} (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                         uniform_continuous.{?l_1 ?l_1}
                         UniformSpace.concrete_category_uniform_continuous.{?l_1})))
                CpltSepUniformSpace.to_UniformSpace.{?l_1}),
              (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                 (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                    @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                   (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                   (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                   (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                   (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y))
                (CpltSepUniformSpace.to_UniformSpace.{?l_1} X)
                (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
             ((λ (X : UniformSpace.{?l_1}),
                 @CpltSepUniformSpace.of.{?l_1}
                   (@uniform_space.completion.{?l_1}
                      (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                         (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                         X)
                      (UniformSpace.uniform_space.{?l_1} X))
                   (@uniform_space.completion.uniform_space.{?l_1}
                      (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                         (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                         X)
                      (UniformSpace.uniform_space.{?l_1} X))
                   (UniformSpace.completion_functor._proof_1.{?l_1} X)
                   (UniformSpace.completion_functor._proof_2.{?l_1} X))
                X)
             Y),
           (λ (X Y Z : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
            (f :
              @category_theory.has_hom.hom.{?l_1 ?l_1+1} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                (@category_theory.has_hom.mk.{?l_1 ?l_1+1} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                   (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                      (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                         @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                        (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                        (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                        (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                        (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y)))
                X
                Y)
            (g :
              @category_theory.has_hom.hom.{?l_1 ?l_1+1} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                (@category_theory.has_hom.mk.{?l_1 ?l_1+1} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                   (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                      (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                         @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                        (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                        (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                        (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                        (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y)))
                Y
                Z),
              @category_theory.bundled_hom.comp.{?l_1} uniform_space.{?l_1}
                (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                   @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{?l_1} (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                   uniform_continuous.{?l_1 ?l_1}
                   UniformSpace.concrete_category_uniform_continuous.{?l_1})
                (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                   (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                   X)
                (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                   (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                   Y)
                (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                   (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                   Z)
                (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Z)
                g
                f)
             X
             (CpltSepUniformSpace.to_UniformSpace.{?l_1}
                ((λ (X : UniformSpace.{?l_1}),
                    @CpltSepUniformSpace.of.{?l_1}
                      (@uniform_space.completion.{?l_1}
                         (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                            (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                            X)
                         (UniformSpace.uniform_space.{?l_1} X))
                      (@uniform_space.completion.uniform_space.{?l_1}
                         (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                            (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                            X)
                         (UniformSpace.uniform_space.{?l_1} X))
                      (UniformSpace.completion_functor._proof_1.{?l_1} X)
                      (UniformSpace.completion_functor._proof_2.{?l_1} X))
                   X))
             (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y)
             (UniformSpace.completion_hom.{?l_1} X)
             f)
          ((λ
            (f :
              (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                 (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                    @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                   (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                   (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                   (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                   (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y))
                X
                (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y)), @UniformSpace.extension_hom.{?l_1} X Y f)
             f)))
    (@subtype.val.{?l_1+1}
       (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
          (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
          X →
        @coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
          (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
          (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
       (λ
        (x :
          @coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
            (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
            X →
          @coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
            (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
            (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y)),
          @filter.tendsto.{?l_1 ?l_1}
            (prod.{?l_1 ?l_1}
               (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                  (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                  X)
               (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                  (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                  X))
            (prod.{?l_1 ?l_1}
               (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                  (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                  (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
               (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                  (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                  (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y)))
            (λ
             (x_1 :
               prod.{?l_1 ?l_1}
                 (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                    (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                    X)
                 (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                    (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                    X)),
               @prod.mk.{?l_1 ?l_1}
                 (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                    (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                    (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
                 (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                    (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                    (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
                 (x
                    (@prod.fst.{?l_1 ?l_1}
                       (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                          (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                          X)
                       (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                          (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                          X)
                       x_1))
                 (x
                    (@prod.snd.{?l_1 ?l_1}
                       (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                          (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                          X)
                       (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                          (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                          X)
                       x_1)))
            (@uniformity.{?l_1}
               (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                  (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                  X)
               (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X))
            (@uniformity.{?l_1}
               (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                  (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                  (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
               (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1}
                  (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))))
       f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='X : UniformSpace.{?l_1},
Y : CpltSepUniformSpace.{?l_1},
f :
  (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
     (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
        @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
       (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
       (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
       (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
       (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y))
    X
    (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y),
x :
  @coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
    (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
    X
⊢ @eq.{?l_1+1}
    (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
       (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
       (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
    (@subtype.val.{?l_1+1}
       (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
          (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
          X →
        @coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
          (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
          (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
       (λ
        (x :
          @coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
            (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
            X →
          @coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
            (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
            (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y)),
          @filter.tendsto.{?l_1 ?l_1}
            (prod.{?l_1 ?l_1}
               (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                  (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                  X)
               (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                  (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                  X))
            (prod.{?l_1 ?l_1}
               (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                  (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                  (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
               (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                  (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                  (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y)))
            (λ
             (x_1 :
               prod.{?l_1 ?l_1}
                 (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                    (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                    X)
                 (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                    (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                    X)),
               @prod.mk.{?l_1 ?l_1}
                 (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                    (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                    (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
                 (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                    (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                    (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
                 (x
                    (@prod.fst.{?l_1 ?l_1}
                       (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                          (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                          X)
                       (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                          (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                          X)
                       x_1))
                 (x
                    (@prod.snd.{?l_1 ?l_1}
                       (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                          (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                          X)
                       (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                          (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                          X)
                       x_1)))
            (@uniformity.{?l_1}
               (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                  (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                  X)
               (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X))
            (@uniformity.{?l_1}
               (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                  (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                  (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
               (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1}
                  (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))))
       ((λ
         (f :
           (λ
            (X Y :
              @category_theory.induced_category.{?l_1 ?l_1+1 ?l_1+1} CpltSepUniformSpace.{?l_1} UniformSpace.{?l_1}
                (@category_theory.category.mk.{?l_1 ?l_1+1} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                   (@category_theory.category_struct.mk.{?l_1 ?l_1+1}
                      (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                      (@category_theory.has_hom.mk.{?l_1 ?l_1+1}
                         (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                         (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                            (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                               @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                              (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                              (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                              (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                              (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y)))
                      (λ (X : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                         @category_theory.bundled_hom.id.{?l_1} uniform_space.{?l_1}
                           (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                              @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                           (@category_theory.unbundled_hom.bundled_hom.{?l_1}
                              (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                              uniform_continuous.{?l_1 ?l_1}
                              UniformSpace.concrete_category_uniform_continuous.{?l_1})
                           (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                              (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                              X)
                           (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X))
                      (λ (X Y Z : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                       (f :
                         @category_theory.has_hom.hom.{?l_1 ?l_1+1}
                           (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                           (@category_theory.has_hom.mk.{?l_1 ?l_1+1}
                              (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                              (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                                 (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α)
                                  (Iβ : uniform_space.{?l_1} β),
                                    @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                                   (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                   (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                                   (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                   (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y)))
                           X
                           Y)
                       (g :
                         @category_theory.has_hom.hom.{?l_1 ?l_1+1}
                           (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                           (@category_theory.has_hom.mk.{?l_1 ?l_1+1}
                              (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                              (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                                 (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α)
                                  (Iβ : uniform_space.{?l_1} β),
                                    @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                                   (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                   (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                                   (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                   (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y)))
                           Y
                           Z),
                         @category_theory.bundled_hom.comp.{?l_1} uniform_space.{?l_1}
                           (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                              @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                           (@category_theory.unbundled_hom.bundled_hom.{?l_1}
                              (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                              uniform_continuous.{?l_1 ?l_1}
                              UniformSpace.concrete_category_uniform_continuous.{?l_1})
                           (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                              (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                              X)
                           (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                              (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                              Y)
                           (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                              (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                              Z)
                           (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                           (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                           (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Z)
                           g
                           f))
                   (@category_theory.bundled_hom.category_theory.concrete_category._proof_1.{?l_1} uniform_space.{?l_1}
                      (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                         @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                      (@category_theory.unbundled_hom.bundled_hom.{?l_1} (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                         uniform_continuous.{?l_1 ?l_1}
                         UniformSpace.concrete_category_uniform_continuous.{?l_1}))
                   (@category_theory.bundled_hom.category_theory.concrete_category._proof_2.{?l_1} uniform_space.{?l_1}
                      (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                         @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                      (@category_theory.unbundled_hom.bundled_hom.{?l_1} (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                         uniform_continuous.{?l_1 ?l_1}
                         UniformSpace.concrete_category_uniform_continuous.{?l_1}))
                   (@category_theory.bundled_hom.category_theory.concrete_category._proof_3.{?l_1} uniform_space.{?l_1}
                      (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                         @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                      (@category_theory.unbundled_hom.bundled_hom.{?l_1} (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                         uniform_continuous.{?l_1 ?l_1}
                         UniformSpace.concrete_category_uniform_continuous.{?l_1})))
                CpltSepUniformSpace.to_UniformSpace.{?l_1}),
              (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                 (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                    @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                   (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                   (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                   (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                   (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y))
                (CpltSepUniformSpace.to_UniformSpace.{?l_1} X)
                (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
             ((λ (X : UniformSpace.{?l_1}),
                 @CpltSepUniformSpace.of.{?l_1}
                   (@uniform_space.completion.{?l_1}
                      (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                         (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                         X)
                      (UniformSpace.uniform_space.{?l_1} X))
                   (@uniform_space.completion.uniform_space.{?l_1}
                      (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                         (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                         X)
                      (UniformSpace.uniform_space.{?l_1} X))
                   (UniformSpace.completion_functor._proof_1.{?l_1} X)
                   (UniformSpace.completion_functor._proof_2.{?l_1} X))
                X)
             Y),
           (λ (X Y Z : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
            (f :
              @category_theory.has_hom.hom.{?l_1 ?l_1+1} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                (@category_theory.has_hom.mk.{?l_1 ?l_1+1} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                   (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                      (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                         @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                        (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                        (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                        (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                        (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y)))
                X
                Y)
            (g :
              @category_theory.has_hom.hom.{?l_1 ?l_1+1} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                (@category_theory.has_hom.mk.{?l_1 ?l_1+1} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                   (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                      (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                         @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                        (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                        (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                        (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                        (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y)))
                Y
                Z),
              @category_theory.bundled_hom.comp.{?l_1} uniform_space.{?l_1}
                (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                   @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{?l_1} (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                   uniform_continuous.{?l_1 ?l_1}
                   UniformSpace.concrete_category_uniform_continuous.{?l_1})
                (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                   (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                   X)
                (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                   (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                   Y)
                (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                   (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                   Z)
                (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Z)
                g
                f)
             X
             (CpltSepUniformSpace.to_UniformSpace.{?l_1}
                ((λ (X : UniformSpace.{?l_1}),
                    @CpltSepUniformSpace.of.{?l_1}
                      (@uniform_space.completion.{?l_1}
                         (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                            (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                            X)
                         (UniformSpace.uniform_space.{?l_1} X))
                      (@uniform_space.completion.uniform_space.{?l_1}
                         (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                            (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                            X)
                         (UniformSpace.uniform_space.{?l_1} X))
                      (UniformSpace.completion_functor._proof_1.{?l_1} X)
                      (UniformSpace.completion_functor._proof_2.{?l_1} X))
                   X))
             (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y)
             (UniformSpace.completion_hom.{?l_1} X)
             f)
          ((λ
            (f :
              (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                 (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                    @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                   (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                   (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                   (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                   (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y))
                X
                (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y)), @UniformSpace.extension_hom.{?l_1} X Y f)
             f))
       x)
    (@subtype.val.{?l_1+1}
       (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
          (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
          X →
        @coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
          (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
          (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
       (λ
        (x :
          @coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
            (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
            X →
          @coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
            (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
            (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y)),
          @filter.tendsto.{?l_1 ?l_1}
            (prod.{?l_1 ?l_1}
               (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                  (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                  X)
               (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                  (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                  X))
            (prod.{?l_1 ?l_1}
               (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                  (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                  (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
               (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                  (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                  (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y)))
            (λ
             (x_1 :
               prod.{?l_1 ?l_1}
                 (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                    (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                    X)
                 (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                    (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                    X)),
               @prod.mk.{?l_1 ?l_1}
                 (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                    (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                    (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
                 (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                    (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                    (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
                 (x
                    (@prod.fst.{?l_1 ?l_1}
                       (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                          (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                          X)
                       (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                          (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                          X)
                       x_1))
                 (x
                    (@prod.snd.{?l_1 ?l_1}
                       (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                          (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                          X)
                       (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                          (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                          X)
                       x_1)))
            (@uniformity.{?l_1}
               (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                  (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                  X)
               (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X))
            (@uniformity.{?l_1}
               (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                  (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                  (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
               (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1}
                  (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))))
       f
       x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='X : UniformSpace.{?l_1},
Y : CpltSepUniformSpace.{?l_1},
x :
  @coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
    (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
    X,
f_val :
  @category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X →
  @category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y),
f_property :
  @uniform_continuous.{?l_1 ?l_1} (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
    (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
    (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
    (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
    f_val
⊢ @eq.{?l_1+1}
    (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
       (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
       (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
    (@subtype.val.{?l_1+1}
       (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
          (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
          X →
        @coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
          (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
          (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
       (λ
        (x :
          @coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
            (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
            X →
          @coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
            (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
            (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y)),
          @filter.tendsto.{?l_1 ?l_1}
            (prod.{?l_1 ?l_1}
               (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                  (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                  X)
               (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                  (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                  X))
            (prod.{?l_1 ?l_1}
               (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                  (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                  (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
               (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                  (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                  (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y)))
            (λ
             (x_1 :
               prod.{?l_1 ?l_1}
                 (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                    (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                    X)
                 (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                    (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                    X)),
               @prod.mk.{?l_1 ?l_1}
                 (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                    (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                    (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
                 (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                    (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                    (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
                 (x
                    (@prod.fst.{?l_1 ?l_1}
                       (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                          (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                          X)
                       (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                          (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                          X)
                       x_1))
                 (x
                    (@prod.snd.{?l_1 ?l_1}
                       (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                          (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                          X)
                       (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                          (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                          X)
                       x_1)))
            (@uniformity.{?l_1}
               (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                  (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                  X)
               (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X))
            (@uniformity.{?l_1}
               (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                  (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                  (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
               (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1}
                  (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))))
       ((λ
         (f :
           (λ
            (X Y :
              @category_theory.induced_category.{?l_1 ?l_1+1 ?l_1+1} CpltSepUniformSpace.{?l_1} UniformSpace.{?l_1}
                (@category_theory.category.mk.{?l_1 ?l_1+1} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                   (@category_theory.category_struct.mk.{?l_1 ?l_1+1}
                      (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                      (@category_theory.has_hom.mk.{?l_1 ?l_1+1}
                         (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                         (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                            (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                               @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                              (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                              (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                              (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                              (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y)))
                      (λ (X : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                         @category_theory.bundled_hom.id.{?l_1} uniform_space.{?l_1}
                           (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                              @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                           (@category_theory.unbundled_hom.bundled_hom.{?l_1}
                              (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                              uniform_continuous.{?l_1 ?l_1}
                              UniformSpace.concrete_category_uniform_continuous.{?l_1})
                           (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                              (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                              X)
                           (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X))
                      (λ (X Y Z : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                       (f :
                         @category_theory.has_hom.hom.{?l_1 ?l_1+1}
                           (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                           (@category_theory.has_hom.mk.{?l_1 ?l_1+1}
                              (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                              (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                                 (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α)
                                  (Iβ : uniform_space.{?l_1} β),
                                    @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                                   (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                   (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                                   (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                   (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y)))
                           X
                           Y)
                       (g :
                         @category_theory.has_hom.hom.{?l_1 ?l_1+1}
                           (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                           (@category_theory.has_hom.mk.{?l_1 ?l_1+1}
                              (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                              (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                                 (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α)
                                  (Iβ : uniform_space.{?l_1} β),
                                    @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                                   (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                   (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                                   (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                   (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y)))
                           Y
                           Z),
                         @category_theory.bundled_hom.comp.{?l_1} uniform_space.{?l_1}
                           (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                              @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                           (@category_theory.unbundled_hom.bundled_hom.{?l_1}
                              (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                              uniform_continuous.{?l_1 ?l_1}
                              UniformSpace.concrete_category_uniform_continuous.{?l_1})
                           (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                              (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                              X)
                           (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                              (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                              Y)
                           (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                              (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                              Z)
                           (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                           (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                           (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Z)
                           g
                           f))
                   (@category_theory.bundled_hom.category_theory.concrete_category._proof_1.{?l_1} uniform_space.{?l_1}
                      (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                         @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                      (@category_theory.unbundled_hom.bundled_hom.{?l_1} (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                         uniform_continuous.{?l_1 ?l_1}
                         UniformSpace.concrete_category_uniform_continuous.{?l_1}))
                   (@category_theory.bundled_hom.category_theory.concrete_category._proof_2.{?l_1} uniform_space.{?l_1}
                      (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                         @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                      (@category_theory.unbundled_hom.bundled_hom.{?l_1} (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                         uniform_continuous.{?l_1 ?l_1}
                         UniformSpace.concrete_category_uniform_continuous.{?l_1}))
                   (@category_theory.bundled_hom.category_theory.concrete_category._proof_3.{?l_1} uniform_space.{?l_1}
                      (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                         @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                      (@category_theory.unbundled_hom.bundled_hom.{?l_1} (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                         uniform_continuous.{?l_1 ?l_1}
                         UniformSpace.concrete_category_uniform_continuous.{?l_1})))
                CpltSepUniformSpace.to_UniformSpace.{?l_1}),
              (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                 (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                    @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                   (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                   (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                   (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                   (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y))
                (CpltSepUniformSpace.to_UniformSpace.{?l_1} X)
                (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
             ((λ (X : UniformSpace.{?l_1}),
                 @CpltSepUniformSpace.of.{?l_1}
                   (@uniform_space.completion.{?l_1}
                      (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                         (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                         X)
                      (UniformSpace.uniform_space.{?l_1} X))
                   (@uniform_space.completion.uniform_space.{?l_1}
                      (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                         (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                         X)
                      (UniformSpace.uniform_space.{?l_1} X))
                   (UniformSpace.completion_functor._proof_1.{?l_1} X)
                   (UniformSpace.completion_functor._proof_2.{?l_1} X))
                X)
             Y),
           (λ (X Y Z : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
            (f :
              @category_theory.has_hom.hom.{?l_1 ?l_1+1} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                (@category_theory.has_hom.mk.{?l_1 ?l_1+1} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                   (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                      (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                         @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                        (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                        (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                        (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                        (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y)))
                X
                Y)
            (g :
              @category_theory.has_hom.hom.{?l_1 ?l_1+1} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                (@category_theory.has_hom.mk.{?l_1 ?l_1+1} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                   (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                      (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                         @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                        (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                        (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                        (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                        (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y)))
                Y
                Z),
              @category_theory.bundled_hom.comp.{?l_1} uniform_space.{?l_1}
                (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                   @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{?l_1} (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                   uniform_continuous.{?l_1 ?l_1}
                   UniformSpace.concrete_category_uniform_continuous.{?l_1})
                (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                   (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                   X)
                (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                   (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                   Y)
                (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                   (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                   Z)
                (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Z)
                g
                f)
             X
             (CpltSepUniformSpace.to_UniformSpace.{?l_1}
                ((λ (X : UniformSpace.{?l_1}),
                    @CpltSepUniformSpace.of.{?l_1}
                      (@uniform_space.completion.{?l_1}
                         (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                            (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                            X)
                         (UniformSpace.uniform_space.{?l_1} X))
                      (@uniform_space.completion.uniform_space.{?l_1}
                         (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                            (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                            X)
                         (UniformSpace.uniform_space.{?l_1} X))
                      (UniformSpace.completion_functor._proof_1.{?l_1} X)
                      (UniformSpace.completion_functor._proof_2.{?l_1} X))
                   X))
             (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y)
             (UniformSpace.completion_hom.{?l_1} X)
             f)
          ((λ
            (f :
              (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                 (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                    @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                   (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                   (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                   (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                   (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y))
                X
                (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y)), @UniformSpace.extension_hom.{?l_1} X Y f)
             (@subtype.mk.{?l_1+1}
                (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X →
                 @category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1}
                   (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
                (@uniform_continuous.{?l_1 ?l_1} (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                   (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1}
                      (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
                   (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                   (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1}
                      (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y)))
                f_val
                f_property)))
       x)
    (@subtype.val.{?l_1+1}
       (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
          (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
          X →
        @coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
          (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
          (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
       (λ
        (x :
          @coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
            (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
            X →
          @coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
            (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
            (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y)),
          @filter.tendsto.{?l_1 ?l_1}
            (prod.{?l_1 ?l_1}
               (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                  (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                  X)
               (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                  (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                  X))
            (prod.{?l_1 ?l_1}
               (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                  (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                  (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
               (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                  (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                  (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y)))
            (λ
             (x_1 :
               prod.{?l_1 ?l_1}
                 (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                    (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                    X)
                 (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                    (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                    X)),
               @prod.mk.{?l_1 ?l_1}
                 (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                    (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                    (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
                 (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                    (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                    (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
                 (x
                    (@prod.fst.{?l_1 ?l_1}
                       (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                          (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                          X)
                       (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                          (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                          X)
                       x_1))
                 (x
                    (@prod.snd.{?l_1 ?l_1}
                       (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                          (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                          X)
                       (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                          (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                          X)
                       x_1)))
            (@uniformity.{?l_1}
               (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                  (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                  X)
               (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X))
            (@uniformity.{?l_1}
               (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                  (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                  (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
               (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1}
                  (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))))
       (@subtype.mk.{?l_1+1}
          (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X →
           @category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
          (@uniform_continuous.{?l_1 ?l_1} (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
             (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1}
                (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
             (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
             (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1}
                (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y)))
          f_val
          f_property)
       x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>145        change completion.extension f_val _ = f_val x,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='uniform_space.completion.extension'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f_val'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/completion.lean&#x27;, &#x27;line&#x27;: 446, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : uniform_space.{u_1} α] {β : Type u_1} [_inst_2 : uniform_space.{u_1} β], (α → β) → @uniform_space.completion.{u_1} α _inst_1 → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@category_theory.bundled.α.{u_1 u_1} uniform_space.{u_1} X → @category_theory.bundled.α.{u_1 u_1} uniform_space.{u_1} (CpltSepUniformSpace.to_UniformSpace.{u_1} Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@coe_sort.{u_1+2 u_1+2} (category_theory.bundled.{u_1 u_1} uniform_space.{u_1}) (@category_theory.bundled.has_coe_to_sort.{u_1 u_1} uniform_space.{u_1}) X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title=' &quot;Extension&quot; to the completion. It is defined for any map `f` but
returns an arbitrary constant value if `f` is not uniformly continuous'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='X : UniformSpace.{?l_1},
Y : CpltSepUniformSpace.{?l_1},
x :
  @coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
    (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
    X,
f_val :
  @category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X →
  @category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y),
f_property :
  @uniform_continuous.{?l_1 ?l_1} (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
    (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
    (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
    (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
    f_val
⊢ @eq.{?l_1+1}
    (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
       (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
       (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
    (@subtype.val.{?l_1+1}
       (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
          (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
          X →
        @coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
          (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
          (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
       (λ
        (x :
          @coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
            (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
            X →
          @coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
            (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
            (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y)),
          @filter.tendsto.{?l_1 ?l_1}
            (prod.{?l_1 ?l_1}
               (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                  (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                  X)
               (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                  (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                  X))
            (prod.{?l_1 ?l_1}
               (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                  (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                  (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
               (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                  (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                  (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y)))
            (λ
             (x_1 :
               prod.{?l_1 ?l_1}
                 (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                    (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                    X)
                 (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                    (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                    X)),
               @prod.mk.{?l_1 ?l_1}
                 (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                    (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                    (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
                 (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                    (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                    (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
                 (x
                    (@prod.fst.{?l_1 ?l_1}
                       (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                          (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                          X)
                       (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                          (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                          X)
                       x_1))
                 (x
                    (@prod.snd.{?l_1 ?l_1}
                       (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                          (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                          X)
                       (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                          (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                          X)
                       x_1)))
            (@uniformity.{?l_1}
               (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                  (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                  X)
               (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X))
            (@uniformity.{?l_1}
               (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                  (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                  (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
               (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1}
                  (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))))
       ((λ
         (f :
           (λ
            (X Y :
              @category_theory.induced_category.{?l_1 ?l_1+1 ?l_1+1} CpltSepUniformSpace.{?l_1} UniformSpace.{?l_1}
                (@category_theory.category.mk.{?l_1 ?l_1+1} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                   (@category_theory.category_struct.mk.{?l_1 ?l_1+1}
                      (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                      (@category_theory.has_hom.mk.{?l_1 ?l_1+1}
                         (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                         (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                            (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                               @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                              (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                              (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                              (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                              (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y)))
                      (λ (X : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                         @category_theory.bundled_hom.id.{?l_1} uniform_space.{?l_1}
                           (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                              @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                           (@category_theory.unbundled_hom.bundled_hom.{?l_1}
                              (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                              uniform_continuous.{?l_1 ?l_1}
                              UniformSpace.concrete_category_uniform_continuous.{?l_1})
                           (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                              (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                              X)
                           (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X))
                      (λ (X Y Z : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                       (f :
                         @category_theory.has_hom.hom.{?l_1 ?l_1+1}
                           (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                           (@category_theory.has_hom.mk.{?l_1 ?l_1+1}
                              (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                              (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                                 (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α)
                                  (Iβ : uniform_space.{?l_1} β),
                                    @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                                   (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                   (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                                   (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                   (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y)))
                           X
                           Y)
                       (g :
                         @category_theory.has_hom.hom.{?l_1 ?l_1+1}
                           (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                           (@category_theory.has_hom.mk.{?l_1 ?l_1+1}
                              (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                              (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                                 (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α)
                                  (Iβ : uniform_space.{?l_1} β),
                                    @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                                   (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                   (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                                   (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                   (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y)))
                           Y
                           Z),
                         @category_theory.bundled_hom.comp.{?l_1} uniform_space.{?l_1}
                           (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                              @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                           (@category_theory.unbundled_hom.bundled_hom.{?l_1}
                              (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                              uniform_continuous.{?l_1 ?l_1}
                              UniformSpace.concrete_category_uniform_continuous.{?l_1})
                           (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                              (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                              X)
                           (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                              (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                              Y)
                           (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                              (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                              Z)
                           (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                           (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                           (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Z)
                           g
                           f))
                   (@category_theory.bundled_hom.category_theory.concrete_category._proof_1.{?l_1} uniform_space.{?l_1}
                      (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                         @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                      (@category_theory.unbundled_hom.bundled_hom.{?l_1} (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                         uniform_continuous.{?l_1 ?l_1}
                         UniformSpace.concrete_category_uniform_continuous.{?l_1}))
                   (@category_theory.bundled_hom.category_theory.concrete_category._proof_2.{?l_1} uniform_space.{?l_1}
                      (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                         @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                      (@category_theory.unbundled_hom.bundled_hom.{?l_1} (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                         uniform_continuous.{?l_1 ?l_1}
                         UniformSpace.concrete_category_uniform_continuous.{?l_1}))
                   (@category_theory.bundled_hom.category_theory.concrete_category._proof_3.{?l_1} uniform_space.{?l_1}
                      (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                         @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                      (@category_theory.unbundled_hom.bundled_hom.{?l_1} (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                         uniform_continuous.{?l_1 ?l_1}
                         UniformSpace.concrete_category_uniform_continuous.{?l_1})))
                CpltSepUniformSpace.to_UniformSpace.{?l_1}),
              (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                 (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                    @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                   (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                   (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                   (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                   (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y))
                (CpltSepUniformSpace.to_UniformSpace.{?l_1} X)
                (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
             ((λ (X : UniformSpace.{?l_1}),
                 @CpltSepUniformSpace.of.{?l_1}
                   (@uniform_space.completion.{?l_1}
                      (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                         (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                         X)
                      (UniformSpace.uniform_space.{?l_1} X))
                   (@uniform_space.completion.uniform_space.{?l_1}
                      (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                         (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                         X)
                      (UniformSpace.uniform_space.{?l_1} X))
                   (UniformSpace.completion_functor._proof_1.{?l_1} X)
                   (UniformSpace.completion_functor._proof_2.{?l_1} X))
                X)
             Y),
           (λ (X Y Z : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
            (f :
              @category_theory.has_hom.hom.{?l_1 ?l_1+1} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                (@category_theory.has_hom.mk.{?l_1 ?l_1+1} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                   (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                      (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                         @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                        (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                        (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                        (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                        (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y)))
                X
                Y)
            (g :
              @category_theory.has_hom.hom.{?l_1 ?l_1+1} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                (@category_theory.has_hom.mk.{?l_1 ?l_1+1} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                   (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                      (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                         @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                        (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                        (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                        (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                        (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y)))
                Y
                Z),
              @category_theory.bundled_hom.comp.{?l_1} uniform_space.{?l_1}
                (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                   @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{?l_1} (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                   uniform_continuous.{?l_1 ?l_1}
                   UniformSpace.concrete_category_uniform_continuous.{?l_1})
                (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                   (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                   X)
                (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                   (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                   Y)
                (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                   (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                   Z)
                (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Z)
                g
                f)
             X
             (CpltSepUniformSpace.to_UniformSpace.{?l_1}
                ((λ (X : UniformSpace.{?l_1}),
                    @CpltSepUniformSpace.of.{?l_1}
                      (@uniform_space.completion.{?l_1}
                         (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                            (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                            X)
                         (UniformSpace.uniform_space.{?l_1} X))
                      (@uniform_space.completion.uniform_space.{?l_1}
                         (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                            (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                            X)
                         (UniformSpace.uniform_space.{?l_1} X))
                      (UniformSpace.completion_functor._proof_1.{?l_1} X)
                      (UniformSpace.completion_functor._proof_2.{?l_1} X))
                   X))
             (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y)
             (UniformSpace.completion_hom.{?l_1} X)
             f)
          ((λ
            (f :
              (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                 (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                    @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                   (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                   (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                   (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                   (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y))
                X
                (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y)), @UniformSpace.extension_hom.{?l_1} X Y f)
             (@subtype.mk.{?l_1+1}
                (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X →
                 @category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1}
                   (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
                (@uniform_continuous.{?l_1 ?l_1} (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                   (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1}
                      (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
                   (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                   (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1}
                      (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y)))
                f_val
                f_property)))
       x)
    (@subtype.val.{?l_1+1}
       (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
          (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
          X →
        @coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
          (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
          (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
       (λ
        (x :
          @coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
            (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
            X →
          @coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
            (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
            (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y)),
          @filter.tendsto.{?l_1 ?l_1}
            (prod.{?l_1 ?l_1}
               (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                  (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                  X)
               (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                  (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                  X))
            (prod.{?l_1 ?l_1}
               (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                  (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                  (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
               (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                  (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                  (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y)))
            (λ
             (x_1 :
               prod.{?l_1 ?l_1}
                 (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                    (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                    X)
                 (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                    (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                    X)),
               @prod.mk.{?l_1 ?l_1}
                 (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                    (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                    (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
                 (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                    (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                    (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
                 (x
                    (@prod.fst.{?l_1 ?l_1}
                       (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                          (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                          X)
                       (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                          (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                          X)
                       x_1))
                 (x
                    (@prod.snd.{?l_1 ?l_1}
                       (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                          (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                          X)
                       (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                          (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                          X)
                       x_1)))
            (@uniformity.{?l_1}
               (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                  (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                  X)
               (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X))
            (@uniformity.{?l_1}
               (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                  (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                  (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
               (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1}
                  (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))))
       (@subtype.mk.{?l_1+1}
          (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X →
           @category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
          (@uniform_continuous.{?l_1 ?l_1} (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
             (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1}
                (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
             (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
             (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1}
                (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y)))
          f_val
          f_property)
       x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='X : UniformSpace.{?l_1},
Y : CpltSepUniformSpace.{?l_1},
x :
  @coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
    (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
    X,
f_val :
  @category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X →
  @category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y),
f_property :
  @uniform_continuous.{?l_1 ?l_1} (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
    (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
    (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
    (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
    f_val
⊢ @eq.{?l_1+1}
    (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
    (@uniform_space.completion.extension.{?l_1 ?l_1} (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
       (UniformSpace.uniform_space.{?l_1} X)
       (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
       (UniformSpace.uniform_space.{?l_1} (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
       f_val
       (@subtype.val.{?l_1+1}
          (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
             (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
             X →
           @coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
             (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
             (CpltSepUniformSpace.to_UniformSpace.{?l_1}
                ((λ (X : UniformSpace.{?l_1}),
                    @CpltSepUniformSpace.of.{?l_1}
                      (@uniform_space.completion.{?l_1}
                         (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                            (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                            X)
                         (UniformSpace.uniform_space.{?l_1} X))
                      (@uniform_space.completion.uniform_space.{?l_1}
                         (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                            (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                            X)
                         (UniformSpace.uniform_space.{?l_1} X))
                      (UniformSpace.completion_functor._proof_1.{?l_1} X)
                      (UniformSpace.completion_functor._proof_2.{?l_1} X))
                   X)))
          (@uniform_continuous.{?l_1 ?l_1}
             (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                X)
             (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                (CpltSepUniformSpace.to_UniformSpace.{?l_1}
                   ((λ (X : UniformSpace.{?l_1}),
                       @CpltSepUniformSpace.of.{?l_1}
                         (@uniform_space.completion.{?l_1}
                            (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                               (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                               X)
                            (UniformSpace.uniform_space.{?l_1} X))
                         (@uniform_space.completion.uniform_space.{?l_1}
                            (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                               (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                               X)
                            (UniformSpace.uniform_space.{?l_1} X))
                         (UniformSpace.completion_functor._proof_1.{?l_1} X)
                         (UniformSpace.completion_functor._proof_2.{?l_1} X))
                      X)))
             (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
             (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1}
                (CpltSepUniformSpace.to_UniformSpace.{?l_1}
                   ((λ (X : UniformSpace.{?l_1}),
                       @CpltSepUniformSpace.of.{?l_1}
                         (@uniform_space.completion.{?l_1}
                            (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                               (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                               X)
                            (UniformSpace.uniform_space.{?l_1} X))
                         (@uniform_space.completion.uniform_space.{?l_1}
                            (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                               (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                               X)
                            (UniformSpace.uniform_space.{?l_1} X))
                         (UniformSpace.completion_functor._proof_1.{?l_1} X)
                         (UniformSpace.completion_functor._proof_2.{?l_1} X))
                      X))))
          (UniformSpace.completion_hom.{?l_1} X)
          x))
    (f_val x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>146        erw completion.extension_coe, assumption</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='uniform_space.completion.extension_coe'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/completion.lean&#x27;, &#x27;line&#x27;: 451, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 227, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : uniform_space.{u_1} α] {β : Type u_1} [_inst_2 : uniform_space.{u_1} β] {f : α → β} [_inst_4 : @separated.{u_1} β _inst_2], @uniform_continuous.{u_1 u_1} α β _inst_1 _inst_2 f → ∀ (a : α), @eq.{u_1+1} β (@uniform_space.completion.extension.{u_1 u_1} α _inst_1 β _inst_2 f (@coe.{u_1+1 u_1+1} α (@uniform_space.completion.{u_1} α _inst_1) (@coe_to_lift.{u_1+1 u_1+1} α (@uniform_space.completion.{u_1} α _inst_1) (@uniform_space.completion.has_coe_t.{u_1} α _inst_1)) a)) (f a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='orange'><a title='This tactic looks in the local context for a hypothesis whose type is equal to the goal target. If it finds one, it uses it to prove the goal, and otherwise it fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='teal'><a title='assumption'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='X : UniformSpace.{?l_1},
Y : CpltSepUniformSpace.{?l_1},
x :
  @coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
    (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
    X,
f_val :
  @category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X →
  @category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y),
f_property :
  @uniform_continuous.{?l_1 ?l_1} (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
    (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
    (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
    (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
    f_val
⊢ @eq.{?l_1+1}
    (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
    (@uniform_space.completion.extension.{?l_1 ?l_1} (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
       (UniformSpace.uniform_space.{?l_1} X)
       (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
       (UniformSpace.uniform_space.{?l_1} (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
       f_val
       (@subtype.val.{?l_1+1}
          (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
             (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
             X →
           @coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
             (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
             (CpltSepUniformSpace.to_UniformSpace.{?l_1}
                ((λ (X : UniformSpace.{?l_1}),
                    @CpltSepUniformSpace.of.{?l_1}
                      (@uniform_space.completion.{?l_1}
                         (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                            (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                            X)
                         (UniformSpace.uniform_space.{?l_1} X))
                      (@uniform_space.completion.uniform_space.{?l_1}
                         (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                            (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                            X)
                         (UniformSpace.uniform_space.{?l_1} X))
                      (UniformSpace.completion_functor._proof_1.{?l_1} X)
                      (UniformSpace.completion_functor._proof_2.{?l_1} X))
                   X)))
          (@uniform_continuous.{?l_1 ?l_1}
             (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                X)
             (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                (CpltSepUniformSpace.to_UniformSpace.{?l_1}
                   ((λ (X : UniformSpace.{?l_1}),
                       @CpltSepUniformSpace.of.{?l_1}
                         (@uniform_space.completion.{?l_1}
                            (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                               (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                               X)
                            (UniformSpace.uniform_space.{?l_1} X))
                         (@uniform_space.completion.uniform_space.{?l_1}
                            (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                               (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                               X)
                            (UniformSpace.uniform_space.{?l_1} X))
                         (UniformSpace.completion_functor._proof_1.{?l_1} X)
                         (UniformSpace.completion_functor._proof_2.{?l_1} X))
                      X)))
             (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
             (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1}
                (CpltSepUniformSpace.to_UniformSpace.{?l_1}
                   ((λ (X : UniformSpace.{?l_1}),
                       @CpltSepUniformSpace.of.{?l_1}
                         (@uniform_space.completion.{?l_1}
                            (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                               (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                               X)
                            (UniformSpace.uniform_space.{?l_1} X))
                         (@uniform_space.completion.uniform_space.{?l_1}
                            (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                               (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                               X)
                            (UniformSpace.uniform_space.{?l_1} X))
                         (UniformSpace.completion_functor._proof_1.{?l_1} X)
                         (UniformSpace.completion_functor._proof_2.{?l_1} X))
                      X))))
          (UniformSpace.completion_hom.{?l_1} X)
          x))
    (f_val x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='X : UniformSpace.{?l_1},
Y : CpltSepUniformSpace.{?l_1},
x :
  @coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
    (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
    X,
f_val :
  @category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X →
  @category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y),
f_property :
  @uniform_continuous.{?l_1 ?l_1} (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
    (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
    (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
    (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
    f_val
⊢ @uniform_continuous.{?l_1 ?l_1} (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
    (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
    (UniformSpace.uniform_space.{?l_1} X)
    (UniformSpace.uniform_space.{?l_1} (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
    f_val'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>147      end },</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 227, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic looks in the local context for a hypothesis whose type is equal to the goal target. If it finds one, it uses it to prove the goal, and otherwise it fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='assumption'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='X : UniformSpace.{?l_1},
Y : CpltSepUniformSpace.{?l_1},
x :
  @coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
    (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
    X,
f_val :
  @category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X →
  @category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y),
f_property :
  @uniform_continuous.{?l_1 ?l_1} (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
    (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
    (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
    (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
    f_val
⊢ @uniform_continuous.{?l_1 ?l_1} (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
    (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
    (UniformSpace.uniform_space.{?l_1} X)
    (UniformSpace.uniform_space.{?l_1} (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
    f_val'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>148    hom_equiv_naturality_left_symm&#x27; := λ X X&#x27; Y f g,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='green'><a title='UniformSpace.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='UniformSpace.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='CpltSepUniformSpace.{u_1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='(λ (X Y : category_theory.bundled.{u_1 u_1} uniform_space.{u_1}), (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β), @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ)) (@category_theory.bundled.α.{u_1 u_1} uniform_space.{u_1} X) (@category_theory.bundled.α.{u_1 u_1} uniform_space.{u_1} Y) (@category_theory.bundled.str.{u_1 u_1} uniform_space.{u_1} X) (@category_theory.bundled.str.{u_1 u_1} uniform_space.{u_1} Y)) X X&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='(λ (X Y : category_theory.bundled.{u_1 u_1} uniform_space.{u_1}), (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β), @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ)) (@category_theory.bundled.α.{u_1 u_1} uniform_space.{u_1} X) (@category_theory.bundled.α.{u_1 u_1} uniform_space.{u_1} Y) (@category_theory.bundled.str.{u_1 u_1} uniform_space.{u_1} X) (@category_theory.bundled.str.{u_1 u_1} uniform_space.{u_1} Y)) X&#x27; (CpltSepUniformSpace.to_UniformSpace.{u_1} Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>149    begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='X X&#x27; : UniformSpace.{?l_1},
Y : CpltSepUniformSpace.{?l_1},
f :
  (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
     (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
        @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
       (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
       (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
       (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
       (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y))
    X
    X&#x27;,
g :
  (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
     (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
        @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
       (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
       (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
       (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
       (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y))
    X&#x27;
    (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y)
⊢ @eq.{?l_1+1}
    ((λ
      (X Y :
        @category_theory.induced_category.{?l_1 ?l_1+1 ?l_1+1} CpltSepUniformSpace.{?l_1} UniformSpace.{?l_1}
          (@category_theory.concrete_category.to_category.{?l_1} UniformSpace.{?l_1}
             (@category_theory.bundled_hom.category_theory.concrete_category.{?l_1} uniform_space.{?l_1}
                (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                   @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{?l_1} (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                   uniform_continuous.{?l_1 ?l_1}
                   UniformSpace.concrete_category_uniform_continuous.{?l_1})))
          CpltSepUniformSpace.to_UniformSpace.{?l_1}),
        @category_theory.has_hom.hom.{?l_1 ?l_1+1} UniformSpace.{?l_1}
          (@category_theory.category_struct.to_has_hom.{?l_1 ?l_1+1} UniformSpace.{?l_1}
             (@category_theory.category.to_category_struct.{?l_1 ?l_1+1} UniformSpace.{?l_1}
                (@category_theory.concrete_category.to_category.{?l_1} UniformSpace.{?l_1}
                   (@category_theory.bundled_hom.category_theory.concrete_category.{?l_1} uniform_space.{?l_1}
                      (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                         @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                      (@category_theory.unbundled_hom.bundled_hom.{?l_1} (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                         uniform_continuous.{?l_1 ?l_1}
                         UniformSpace.concrete_category_uniform_continuous.{?l_1})))))
          (CpltSepUniformSpace.to_UniformSpace.{?l_1} X)
          (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
       ((λ (X : UniformSpace.{?l_1}),
           @CpltSepUniformSpace.of.{?l_1}
             (@uniform_space.completion.{?l_1}
                (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                   (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                   X)
                (UniformSpace.uniform_space.{?l_1} X))
             (@uniform_space.completion.uniform_space.{?l_1}
                (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                   (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                   X)
                (UniformSpace.uniform_space.{?l_1} X))
             (UniformSpace.completion_functor._proof_1.{?l_1} X)
             (UniformSpace.completion_functor._proof_2.{?l_1} X))
          X)
       Y)
    (@coe_fn.{(max 1 (?l_1+1)) ?l_1+1}
       (equiv.{?l_1+1 ?l_1+1}
          ((λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
              (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                 @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y))
             X
             (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
          ((λ
            (X Y :
              @category_theory.induced_category.{?l_1 ?l_1+1 ?l_1+1} CpltSepUniformSpace.{?l_1} UniformSpace.{?l_1}
                (@category_theory.concrete_category.to_category.{?l_1} UniformSpace.{?l_1}
                   (@category_theory.bundled_hom.category_theory.concrete_category.{?l_1} uniform_space.{?l_1}
                      (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                         @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                      (@category_theory.unbundled_hom.bundled_hom.{?l_1} (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                         uniform_continuous.{?l_1 ?l_1}
                         UniformSpace.concrete_category_uniform_continuous.{?l_1})))
                CpltSepUniformSpace.to_UniformSpace.{?l_1}),
              @category_theory.has_hom.hom.{?l_1 ?l_1+1} UniformSpace.{?l_1}
                (@category_theory.category_struct.to_has_hom.{?l_1 ?l_1+1} UniformSpace.{?l_1}
                   (@category_theory.category.to_category_struct.{?l_1 ?l_1+1} UniformSpace.{?l_1}
                      (@category_theory.concrete_category.to_category.{?l_1} UniformSpace.{?l_1}
                         (@category_theory.bundled_hom.category_theory.concrete_category.{?l_1} uniform_space.{?l_1}
                            (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                               @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                            (@category_theory.unbundled_hom.bundled_hom.{?l_1}
                               (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                               uniform_continuous.{?l_1 ?l_1}
                               UniformSpace.concrete_category_uniform_continuous.{?l_1})))))
                (CpltSepUniformSpace.to_UniformSpace.{?l_1} X)
                (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
             ((λ (X : UniformSpace.{?l_1}),
                 @CpltSepUniformSpace.of.{?l_1}
                   (@uniform_space.completion.{?l_1}
                      (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                         (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                         X)
                      (UniformSpace.uniform_space.{?l_1} X))
                   (@uniform_space.completion.uniform_space.{?l_1}
                      (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                         (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                         X)
                      (UniformSpace.uniform_space.{?l_1} X))
                   (UniformSpace.completion_functor._proof_1.{?l_1} X)
                   (UniformSpace.completion_functor._proof_2.{?l_1} X))
                X)
             Y))
       (@equiv.has_coe_to_fun.{?l_1+1 ?l_1+1}
          ((λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
              (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                 @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y))
             X
             (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
          ((λ
            (X Y :
              @category_theory.induced_category.{?l_1 ?l_1+1 ?l_1+1} CpltSepUniformSpace.{?l_1} UniformSpace.{?l_1}
                (@category_theory.concrete_category.to_category.{?l_1} UniformSpace.{?l_1}
                   (@category_theory.bundled_hom.category_theory.concrete_category.{?l_1} uniform_space.{?l_1}
                      (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                         @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                      (@category_theory.unbundled_hom.bundled_hom.{?l_1} (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                         uniform_continuous.{?l_1 ?l_1}
                         UniformSpace.concrete_category_uniform_continuous.{?l_1})))
                CpltSepUniformSpace.to_UniformSpace.{?l_1}),
              @category_theory.has_hom.hom.{?l_1 ?l_1+1} UniformSpace.{?l_1}
                (@category_theory.category_struct.to_has_hom.{?l_1 ?l_1+1} UniformSpace.{?l_1}
                   (@category_theory.category.to_category_struct.{?l_1 ?l_1+1} UniformSpace.{?l_1}
                      (@category_theory.concrete_category.to_category.{?l_1} UniformSpace.{?l_1}
                         (@category_theory.bundled_hom.category_theory.concrete_category.{?l_1} uniform_space.{?l_1}
                            (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                               @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                            (@category_theory.unbundled_hom.bundled_hom.{?l_1}
                               (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                               uniform_continuous.{?l_1 ?l_1}
                               UniformSpace.concrete_category_uniform_continuous.{?l_1})))))
                (CpltSepUniformSpace.to_UniformSpace.{?l_1} X)
                (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
             ((λ (X : UniformSpace.{?l_1}),
                 @CpltSepUniformSpace.of.{?l_1}
                   (@uniform_space.completion.{?l_1}
                      (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                         (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                         X)
                      (UniformSpace.uniform_space.{?l_1} X))
                   (@uniform_space.completion.uniform_space.{?l_1}
                      (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                         (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                         X)
                      (UniformSpace.uniform_space.{?l_1} X))
                   (UniformSpace.completion_functor._proof_1.{?l_1} X)
                   (UniformSpace.completion_functor._proof_2.{?l_1} X))
                X)
             Y))
       (@equiv.symm.{?l_1+1 ?l_1+1}
          ((λ
            (X Y :
              @category_theory.induced_category.{?l_1 ?l_1+1 ?l_1+1} CpltSepUniformSpace.{?l_1} UniformSpace.{?l_1}
                (@category_theory.concrete_category.to_category.{?l_1} UniformSpace.{?l_1}
                   (@category_theory.bundled_hom.category_theory.concrete_category.{?l_1} uniform_space.{?l_1}
                      (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                         @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                      (@category_theory.unbundled_hom.bundled_hom.{?l_1} (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                         uniform_continuous.{?l_1 ?l_1}
                         UniformSpace.concrete_category_uniform_continuous.{?l_1})))
                CpltSepUniformSpace.to_UniformSpace.{?l_1}),
              @category_theory.has_hom.hom.{?l_1 ?l_1+1} UniformSpace.{?l_1}
                (@category_theory.category_struct.to_has_hom.{?l_1 ?l_1+1} UniformSpace.{?l_1}
                   (@category_theory.category.to_category_struct.{?l_1 ?l_1+1} UniformSpace.{?l_1}
                      (@category_theory.concrete_category.to_category.{?l_1} UniformSpace.{?l_1}
                         (@category_theory.bundled_hom.category_theory.concrete_category.{?l_1} uniform_space.{?l_1}
                            (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                               @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                            (@category_theory.unbundled_hom.bundled_hom.{?l_1}
                               (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                               uniform_continuous.{?l_1 ?l_1}
                               UniformSpace.concrete_category_uniform_continuous.{?l_1})))))
                (CpltSepUniformSpace.to_UniformSpace.{?l_1} X)
                (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
             ((λ (X : UniformSpace.{?l_1}),
                 @CpltSepUniformSpace.of.{?l_1}
                   (@uniform_space.completion.{?l_1}
                      (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                         (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                         X)
                      (UniformSpace.uniform_space.{?l_1} X))
                   (@uniform_space.completion.uniform_space.{?l_1}
                      (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                         (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                         X)
                      (UniformSpace.uniform_space.{?l_1} X))
                   (UniformSpace.completion_functor._proof_1.{?l_1} X)
                   (UniformSpace.completion_functor._proof_2.{?l_1} X))
                X)
             Y)
          ((λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
              (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                 @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y))
             X
             (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
          (@equiv.mk.{?l_1+1 ?l_1+1}
             ((λ
               (X Y :
                 @category_theory.induced_category.{?l_1 ?l_1+1 ?l_1+1} CpltSepUniformSpace.{?l_1} UniformSpace.{?l_1}
                   (@category_theory.category.mk.{?l_1 ?l_1+1}
                      (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                      (@category_theory.category.to_category_struct.{?l_1 ?l_1+1}
                         (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                         (@category_theory.bundled_hom.category.{?l_1} uniform_space.{?l_1}
                            (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                               @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                            (@category_theory.unbundled_hom.bundled_hom.{?l_1}
                               (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                               uniform_continuous.{?l_1 ?l_1}
                               UniformSpace.concrete_category_uniform_continuous.{?l_1})))
                      (@category_theory.bundled_hom.category_theory.concrete_category._proof_1.{?l_1}
                         uniform_space.{?l_1}
                         (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                            @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                         (@category_theory.unbundled_hom.bundled_hom.{?l_1}
                            (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                            uniform_continuous.{?l_1 ?l_1}
                            UniformSpace.concrete_category_uniform_continuous.{?l_1}))
                      (@category_theory.bundled_hom.category_theory.concrete_category._proof_2.{?l_1}
                         uniform_space.{?l_1}
                         (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                            @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                         (@category_theory.unbundled_hom.bundled_hom.{?l_1}
                            (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                            uniform_continuous.{?l_1 ?l_1}
                            UniformSpace.concrete_category_uniform_continuous.{?l_1}))
                      (@category_theory.bundled_hom.category_theory.concrete_category._proof_3.{?l_1}
                         uniform_space.{?l_1}
                         (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                            @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                         (@category_theory.unbundled_hom.bundled_hom.{?l_1}
                            (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                            uniform_continuous.{?l_1 ?l_1}
                            UniformSpace.concrete_category_uniform_continuous.{?l_1})))
                   CpltSepUniformSpace.to_UniformSpace.{?l_1}),
                 (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                    (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                       @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                      (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                      (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                      (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                      (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y))
                   (CpltSepUniformSpace.to_UniformSpace.{?l_1} X)
                   (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
                ((λ (X : UniformSpace.{?l_1}),
                    @CpltSepUniformSpace.of.{?l_1}
                      (@uniform_space.completion.{?l_1}
                         (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                            (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                            X)
                         (UniformSpace.uniform_space.{?l_1} X))
                      (@uniform_space.completion.uniform_space.{?l_1}
                         (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                            (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                            X)
                         (UniformSpace.uniform_space.{?l_1} X))
                      (UniformSpace.completion_functor._proof_1.{?l_1} X)
                      (UniformSpace.completion_functor._proof_2.{?l_1} X))
                   X)
                Y)
             ((λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                 (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                    @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                   (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                   (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                   (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                   (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y))
                X
                (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
             (λ
              (f :
                (λ
                 (X Y :
                   @category_theory.induced_category.{?l_1 ?l_1+1 ?l_1+1} CpltSepUniformSpace.{?l_1} UniformSpace.{?l_1}
                     (@category_theory.category.mk.{?l_1 ?l_1+1}
                        (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                        (@category_theory.category_struct.mk.{?l_1 ?l_1+1}
                           (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                           (@category_theory.has_hom.mk.{?l_1 ?l_1+1}
                              (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                              (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                                 (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α)
                                  (Iβ : uniform_space.{?l_1} β),
                                    @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                                   (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                   (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                                   (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                   (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y)))
                           (λ (X : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                              @category_theory.bundled_hom.id.{?l_1} uniform_space.{?l_1}
                                (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                                   @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                                (@category_theory.unbundled_hom.bundled_hom.{?l_1}
                                   (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                                   uniform_continuous.{?l_1 ?l_1}
                                   UniformSpace.concrete_category_uniform_continuous.{?l_1})
                                (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                   (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                   X)
                                (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X))
                           (λ (X Y Z : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                            (f :
                              @category_theory.has_hom.hom.{?l_1 ?l_1+1}
                                (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                (@category_theory.has_hom.mk.{?l_1 ?l_1+1}
                                   (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                   (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                                      (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α)
                                       (Iβ : uniform_space.{?l_1} β),
                                         @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                                        (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                        (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                                        (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                        (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y)))
                                X
                                Y)
                            (g :
                              @category_theory.has_hom.hom.{?l_1 ?l_1+1}
                                (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                (@category_theory.has_hom.mk.{?l_1 ?l_1+1}
                                   (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                   (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                                      (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α)
                                       (Iβ : uniform_space.{?l_1} β),
                                         @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                                        (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                        (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                                        (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                        (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y)))
                                Y
                                Z),
                              @category_theory.bundled_hom.comp.{?l_1} uniform_space.{?l_1}
                                (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                                   @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                                (@category_theory.unbundled_hom.bundled_hom.{?l_1}
                                   (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                                   uniform_continuous.{?l_1 ?l_1}
                                   UniformSpace.concrete_category_uniform_continuous.{?l_1})
                                (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                   (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                   X)
                                (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                   (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                   Y)
                                (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                   (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                   Z)
                                (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                                (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Z)
                                g
                                f))
                        (@category_theory.bundled_hom.category_theory.concrete_category._proof_1.{?l_1}
                           uniform_space.{?l_1}
                           (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                              @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                           (@category_theory.unbundled_hom.bundled_hom.{?l_1}
                              (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                              uniform_continuous.{?l_1 ?l_1}
                              UniformSpace.concrete_category_uniform_continuous.{?l_1}))
                        (@category_theory.bundled_hom.category_theory.concrete_category._proof_2.{?l_1}
                           uniform_space.{?l_1}
                           (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                              @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                           (@category_theory.unbundled_hom.bundled_hom.{?l_1}
                              (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                              uniform_continuous.{?l_1 ?l_1}
                              UniformSpace.concrete_category_uniform_continuous.{?l_1}))
                        (@category_theory.bundled_hom.category_theory.concrete_category._proof_3.{?l_1}
                           uniform_space.{?l_1}
                           (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                              @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                           (@category_theory.unbundled_hom.bundled_hom.{?l_1}
                              (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                              uniform_continuous.{?l_1 ?l_1}
                              UniformSpace.concrete_category_uniform_continuous.{?l_1})))
                     CpltSepUniformSpace.to_UniformSpace.{?l_1}),
                   (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                      (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                         @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                        (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                        (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                        (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                        (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y))
                     (CpltSepUniformSpace.to_UniformSpace.{?l_1} X)
                     (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
                  ((λ (X : UniformSpace.{?l_1}),
                      @CpltSepUniformSpace.of.{?l_1}
                        (@uniform_space.completion.{?l_1}
                           (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                              (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                              X)
                           (UniformSpace.uniform_space.{?l_1} X))
                        (@uniform_space.completion.uniform_space.{?l_1}
                           (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                              (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                              X)
                           (UniformSpace.uniform_space.{?l_1} X))
                        (UniformSpace.completion_functor._proof_1.{?l_1} X)
                        (UniformSpace.completion_functor._proof_2.{?l_1} X))
                     X)
                  Y),
                (λ (X Y Z : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                 (f :
                   @category_theory.has_hom.hom.{?l_1 ?l_1+1} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                     (@category_theory.has_hom.mk.{?l_1 ?l_1+1}
                        (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                        (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                           (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                              @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                             (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                             (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                             (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                             (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y)))
                     X
                     Y)
                 (g :
                   @category_theory.has_hom.hom.{?l_1 ?l_1+1} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                     (@category_theory.has_hom.mk.{?l_1 ?l_1+1}
                        (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                        (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                           (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                              @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                             (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                             (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                             (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                             (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y)))
                     Y
                     Z),
                   @category_theory.bundled_hom.comp.{?l_1} uniform_space.{?l_1}
                     (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                        @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                     (@category_theory.unbundled_hom.bundled_hom.{?l_1} (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                        uniform_continuous.{?l_1 ?l_1}
                        UniformSpace.concrete_category_uniform_continuous.{?l_1})
                     (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                        (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                        X)
                     (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                        (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                        Y)
                     (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                        (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                        Z)
                     (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                     (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                     (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Z)
                     g
                     f)
                  X
                  (CpltSepUniformSpace.to_UniformSpace.{?l_1}
                     ((λ (X : UniformSpace.{?l_1}),
                         @CpltSepUniformSpace.of.{?l_1}
                           (@uniform_space.completion.{?l_1}
                              (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                                 (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                 X)
                              (UniformSpace.uniform_space.{?l_1} X))
                           (@uniform_space.completion.uniform_space.{?l_1}
                              (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                                 (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                 X)
                              (UniformSpace.uniform_space.{?l_1} X))
                           (UniformSpace.completion_functor._proof_1.{?l_1} X)
                           (UniformSpace.completion_functor._proof_2.{?l_1} X))
                        X))
                  (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y)
                  (UniformSpace.completion_hom.{?l_1} X)
                  f)
             (λ
              (f :
                (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                   (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                      @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                     (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                     (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                     (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                     (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y))
                  X
                  (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y)), @UniformSpace.extension_hom.{?l_1} X Y f)
             (λ
              (f :
                (λ
                 (X Y :
                   @category_theory.induced_category.{?l_1 ?l_1+1 ?l_1+1} CpltSepUniformSpace.{?l_1} UniformSpace.{?l_1}
                     (@category_theory.category.mk.{?l_1 ?l_1+1}
                        (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                        (@category_theory.category_struct.mk.{?l_1 ?l_1+1}
                           (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                           (@category_theory.has_hom.mk.{?l_1 ?l_1+1}
                              (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                              (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                                 (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α)
                                  (Iβ : uniform_space.{?l_1} β),
                                    @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                                   (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                   (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                                   (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                   (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y)))
                           (λ (X : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                              @category_theory.bundled_hom.id.{?l_1} uniform_space.{?l_1}
                                (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                                   @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                                (@category_theory.unbundled_hom.bundled_hom.{?l_1}
                                   (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                                   uniform_continuous.{?l_1 ?l_1}
                                   UniformSpace.concrete_category_uniform_continuous.{?l_1})
                                (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                   (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                   X)
                                (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X))
                           (λ (X Y Z : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                            (f :
                              @category_theory.has_hom.hom.{?l_1 ?l_1+1}
                                (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                (@category_theory.has_hom.mk.{?l_1 ?l_1+1}
                                   (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                   (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                                      (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α)
                                       (Iβ : uniform_space.{?l_1} β),
                                         @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                                        (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                        (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                                        (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                        (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y)))
                                X
                                Y)
                            (g :
                              @category_theory.has_hom.hom.{?l_1 ?l_1+1}
                                (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                (@category_theory.has_hom.mk.{?l_1 ?l_1+1}
                                   (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                   (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                                      (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α)
                                       (Iβ : uniform_space.{?l_1} β),
                                         @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                                        (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                        (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                                        (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                        (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y)))
                                Y
                                Z),
                              @category_theory.bundled_hom.comp.{?l_1} uniform_space.{?l_1}
                                (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                                   @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                                (@category_theory.unbundled_hom.bundled_hom.{?l_1}
                                   (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                                   uniform_continuous.{?l_1 ?l_1}
                                   UniformSpace.concrete_category_uniform_continuous.{?l_1})
                                (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                   (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                   X)
                                (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                   (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                   Y)
                                (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                   (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                   Z)
                                (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                                (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Z)
                                g
                                f))
                        (@category_theory.bundled_hom.category_theory.concrete_category._proof_1.{?l_1}
                           uniform_space.{?l_1}
                           (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                              @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                           (@category_theory.unbundled_hom.bundled_hom.{?l_1}
                              (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                              uniform_continuous.{?l_1 ?l_1}
                              UniformSpace.concrete_category_uniform_continuous.{?l_1}))
                        (@category_theory.bundled_hom.category_theory.concrete_category._proof_2.{?l_1}
                           uniform_space.{?l_1}
                           (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                              @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                           (@category_theory.unbundled_hom.bundled_hom.{?l_1}
                              (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                              uniform_continuous.{?l_1 ?l_1}
                              UniformSpace.concrete_category_uniform_continuous.{?l_1}))
                        (@category_theory.bundled_hom.category_theory.concrete_category._proof_3.{?l_1}
                           uniform_space.{?l_1}
                           (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                              @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                           (@category_theory.unbundled_hom.bundled_hom.{?l_1}
                              (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                              uniform_continuous.{?l_1 ?l_1}
                              UniformSpace.concrete_category_uniform_continuous.{?l_1})))
                     CpltSepUniformSpace.to_UniformSpace.{?l_1}),
                   (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                      (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                         @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                        (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                        (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                        (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                        (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y))
                     (CpltSepUniformSpace.to_UniformSpace.{?l_1} X)
                     (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
                  ((λ (X : UniformSpace.{?l_1}),
                      @CpltSepUniformSpace.of.{?l_1}
                        (@uniform_space.completion.{?l_1}
                           (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                              (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                              X)
                           (UniformSpace.uniform_space.{?l_1} X))
                        (@uniform_space.completion.uniform_space.{?l_1}
                           (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                              (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                              X)
                           (UniformSpace.uniform_space.{?l_1} X))
                        (UniformSpace.completion_functor._proof_1.{?l_1} X)
                        (UniformSpace.completion_functor._proof_2.{?l_1} X))
                     X)
                  Y),
                @id.{0}
                  (@eq.{?l_1+1}
                     ((λ
                       (X Y :
                         @category_theory.induced_category.{?l_1 ?l_1+1 ?l_1+1} CpltSepUniformSpace.{?l_1}
                           UniformSpace.{?l_1}
                           (@category_theory.category.mk.{?l_1 ?l_1+1}
                              (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                              (@category_theory.category_struct.mk.{?l_1 ?l_1+1}
                                 (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                 (@category_theory.has_hom.mk.{?l_1 ?l_1+1}
                                    (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                    (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                                       (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α)
                                        (Iβ : uniform_space.{?l_1} β),
                                          @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                                         (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                         (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                                         (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                         (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y)))
                                 (λ (X : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                                    @category_theory.bundled_hom.id.{?l_1} uniform_space.{?l_1}
                                      (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α)
                                       (Iβ : uniform_space.{?l_1} β),
                                         @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                                      (@category_theory.unbundled_hom.bundled_hom.{?l_1}
                                         (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                                         uniform_continuous.{?l_1 ?l_1}
                                         UniformSpace.concrete_category_uniform_continuous.{?l_1})
                                      (@coe_sort.{?l_1+2 ?l_1+2}
                                         (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                         (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                         X)
                                      (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X))
                                 (λ (X Y Z : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                  (f :
                                    @category_theory.has_hom.hom.{?l_1 ?l_1+1}
                                      (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                      (@category_theory.has_hom.mk.{?l_1 ?l_1+1}
                                         (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                         (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                                            (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α)
                                             (Iβ : uniform_space.{?l_1} β),
                                               @subtype.{?l_1+1} (α → β)
                                                 (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                                              (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                              (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                                              (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                              (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y)))
                                      X
                                      Y)
                                  (g :
                                    @category_theory.has_hom.hom.{?l_1 ?l_1+1}
                                      (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                      (@category_theory.has_hom.mk.{?l_1 ?l_1+1}
                                         (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                         (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                                            (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α)
                                             (Iβ : uniform_space.{?l_1} β),
                                               @subtype.{?l_1+1} (α → β)
                                                 (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                                              (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                              (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                                              (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                              (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y)))
                                      Y
                                      Z),
                                    @category_theory.bundled_hom.comp.{?l_1} uniform_space.{?l_1}
                                      (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α)
                                       (Iβ : uniform_space.{?l_1} β),
                                         @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                                      (@category_theory.unbundled_hom.bundled_hom.{?l_1}
                                         (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                                         uniform_continuous.{?l_1 ?l_1}
                                         UniformSpace.concrete_category_uniform_continuous.{?l_1})
                                      (@coe_sort.{?l_1+2 ?l_1+2}
                                         (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                         (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                         X)
                                      (@coe_sort.{?l_1+2 ?l_1+2}
                                         (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                         (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                         Y)
                                      (@coe_sort.{?l_1+2 ?l_1+2}
                                         (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                         (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                         Z)
                                      (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                      (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                                      (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Z)
                                      g
                                      f))
                              (@category_theory.bundled_hom.category_theory.concrete_category._proof_1.{?l_1}
                                 uniform_space.{?l_1}
                                 (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α)
                                  (Iβ : uniform_space.{?l_1} β),
                                    @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                                 (@category_theory.unbundled_hom.bundled_hom.{?l_1}
                                    (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                                    uniform_continuous.{?l_1 ?l_1}
                                    UniformSpace.concrete_category_uniform_continuous.{?l_1}))
                              (@category_theory.bundled_hom.category_theory.concrete_category._proof_2.{?l_1}
                                 uniform_space.{?l_1}
                                 (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α)
                                  (Iβ : uniform_space.{?l_1} β),
                                    @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                                 (@category_theory.unbundled_hom.bundled_hom.{?l_1}
                                    (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                                    uniform_continuous.{?l_1 ?l_1}
                                    UniformSpace.concrete_category_uniform_continuous.{?l_1}))
                              (@category_theory.bundled_hom.category_theory.concrete_category._proof_3.{?l_1}
                                 uniform_space.{?l_1}
                                 (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α)
                                  (Iβ : uniform_space.{?l_1} β),
                                    @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                                 (@category_theory.unbundled_hom.bundled_hom.{?l_1}
                                    (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                                    uniform_continuous.{?l_1 ?l_1}
                                    UniformSpace.concrete_category_uniform_continuous.{?l_1})))
                           CpltSepUniformSpace.to_UniformSpace.{?l_1}),
                         (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                            (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                               @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                              (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                              (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                              (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                              (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y))
                           (CpltSepUniformSpace.to_UniformSpace.{?l_1} X)
                           (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
                        ((λ (X : UniformSpace.{?l_1}),
                            @CpltSepUniformSpace.of.{?l_1}
                              (@uniform_space.completion.{?l_1}
                                 (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                                    (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                    X)
                                 (UniformSpace.uniform_space.{?l_1} X))
                              (@uniform_space.completion.uniform_space.{?l_1}
                                 (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                                    (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                    X)
                                 (UniformSpace.uniform_space.{?l_1} X))
                              (UniformSpace.completion_functor._proof_1.{?l_1} X)
                              (UniformSpace.completion_functor._proof_2.{?l_1} X))
                           X)
                        Y)
                     ((λ
                       (f :
                         (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                            (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                               @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                              (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                              (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                              (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                              (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y))
                           X
                           (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y)), @UniformSpace.extension_hom.{?l_1} X Y f)
                        ((λ
                          (f :
                            (λ
                             (X Y :
                               @category_theory.induced_category.{?l_1 ?l_1+1 ?l_1+1} CpltSepUniformSpace.{?l_1}
                                 UniformSpace.{?l_1}
                                 (@category_theory.category.mk.{?l_1 ?l_1+1}
                                    (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                    (@category_theory.category_struct.mk.{?l_1 ?l_1+1}
                                       (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                       (@category_theory.has_hom.mk.{?l_1 ?l_1+1}
                                          (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                          (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                                             (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α)
                                              (Iβ : uniform_space.{?l_1} β),
                                                @subtype.{?l_1+1} (α → β)
                                                  (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                                               (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                               (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                                               (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                               (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y)))
                                       (λ (X : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                                          (λ (α : Type ?l_1)
                                           (Iα : (λ (α : Type ?l_1), uniform_space.{?l_1} α) α),
                                             @subtype.mk.{?l_1+1} (α → α)
                                               (@uniform_continuous.{?l_1 ?l_1} α α Iα Iα)
                                               (@id.{?l_1+1} α)
                                               (@category_theory.unbundled_hom.bundled_hom._proof_1.{?l_1}
                                                  (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                                                  uniform_continuous.{?l_1 ?l_1}
                                                  UniformSpace.concrete_category_uniform_continuous.{?l_1}
                                                  α
                                                  Iα))
                                            (@coe_sort.{?l_1+2 ?l_1+2}
                                               (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                               (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1}
                                                  uniform_space.{?l_1})
                                               X)
                                            (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X))
                                       (λ (X Y Z : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                        (f :
                                          (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                                             (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α)
                                              (Iβ : uniform_space.{?l_1} β),
                                                @subtype.{?l_1+1} (α → β)
                                                  (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                                               (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                               (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                                               (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                               (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y))
                                            X
                                            Y)
                                        (g :
                                          (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                                             (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α)
                                              (Iβ : uniform_space.{?l_1} β),
                                                @subtype.{?l_1+1} (α → β)
                                                  (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                                               (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                               (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                                               (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                               (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y))
                                            Y
                                            Z),
                                          (λ (_x _x_1 _x_2 : Type ?l_1)
                                           (_x_3 : (λ (α : Type ?l_1), uniform_space.{?l_1} α) _x)
                                           (_x_4 : (λ (α : Type ?l_1), uniform_space.{?l_1} α) _x_1)
                                           (_x_5 : (λ (α : Type ?l_1), uniform_space.{?l_1} α) _x_2)
                                           (g :
                                             @subtype.{?l_1+1} (_x_1 → _x_2)
                                               (@uniform_continuous.{?l_1 ?l_1} _x_1 _x_2 _x_4 _x_5))
                                           (f :
                                             @subtype.{?l_1+1} (_x → _x_1)
                                               (@uniform_continuous.{?l_1 ?l_1} _x _x_1 _x_3 _x_4)),
                                             @subtype.mk.{?l_1+1} (_x → _x_2)
                                               (@uniform_continuous.{?l_1 ?l_1} _x _x_2 _x_3 _x_5)
                                               (@function.comp.{?l_1+1 ?l_1+1 ?l_1+1} _x _x_1 _x_2
                                                  (@subtype.val.{?l_1+1} (_x_1 → _x_2)
                                                     (@uniform_continuous.{?l_1 ?l_1} _x_1 _x_2 _x_4 _x_5)
                                                     g)
                                                  (@subtype.val.{?l_1+1} (_x → _x_1)
                                                     (@uniform_continuous.{?l_1 ?l_1} _x _x_1 _x_3 _x_4)
                                                     f))
                                               (@category_theory.unbundled_hom.bundled_hom._proof_2.{?l_1}
                                                  (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                                                  uniform_continuous.{?l_1 ?l_1}
                                                  UniformSpace.concrete_category_uniform_continuous.{?l_1}
                                                  _x
                                                  _x_1
                                                  _x_2
                                                  _x_3
                                                  _x_4
                                                  _x_5
                                                  g
                                                  f))
                                            (@coe_sort.{?l_1+2 ?l_1+2}
                                               (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                               (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1}
                                                  uniform_space.{?l_1})
                                               X)
                                            (@coe_sort.{?l_1+2 ?l_1+2}
                                               (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                               (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1}
                                                  uniform_space.{?l_1})
                                               Y)
                                            (@coe_sort.{?l_1+2 ?l_1+2}
                                               (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                               (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1}
                                                  uniform_space.{?l_1})
                                               Z)
                                            (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                            (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                                            (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Z)
                                            g
                                            f))
                                    (@category_theory.bundled_hom.category_theory.concrete_category._proof_1.{?l_1}
                                       uniform_space.{?l_1}
                                       (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α)
                                        (Iβ : uniform_space.{?l_1} β),
                                          @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                                       (@category_theory.unbundled_hom.bundled_hom.{?l_1}
                                          (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                                          uniform_continuous.{?l_1 ?l_1}
                                          UniformSpace.concrete_category_uniform_continuous.{?l_1}))
                                    (@category_theory.bundled_hom.category_theory.concrete_category._proof_2.{?l_1}
                                       uniform_space.{?l_1}
                                       (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α)
                                        (Iβ : uniform_space.{?l_1} β),
                                          @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                                       (@category_theory.unbundled_hom.bundled_hom.{?l_1}
                                          (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                                          uniform_continuous.{?l_1 ?l_1}
                                          UniformSpace.concrete_category_uniform_continuous.{?l_1}))
                                    (@category_theory.bundled_hom.category_theory.concrete_category._proof_3.{?l_1}
                                       uniform_space.{?l_1}
                                       (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α)
                                        (Iβ : uniform_space.{?l_1} β),
                                          @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                                       (@category_theory.unbundled_hom.bundled_hom.{?l_1}
                                          (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                                          uniform_continuous.{?l_1 ?l_1}
                                          UniformSpace.concrete_category_uniform_continuous.{?l_1})))
                                 CpltSepUniformSpace.to_UniformSpace.{?l_1}),
                               (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                                  (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α)
                                   (Iβ : uniform_space.{?l_1} β),
                                     @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                                    (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                    (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                                    (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                    (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y))
                                 (CpltSepUniformSpace.to_UniformSpace.{?l_1} X)
                                 (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
                              ((λ (X : UniformSpace.{?l_1}),
                                  @CpltSepUniformSpace.of.{?l_1}
                                    (@uniform_space.completion.{?l_1}
                                       (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                                          (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                          X)
                                       (UniformSpace.uniform_space.{?l_1} X))
                                    (@uniform_space.completion.uniform_space.{?l_1}
                                       (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                                          (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                          X)
                                       (UniformSpace.uniform_space.{?l_1} X))
                                    (UniformSpace.completion_functor._proof_1.{?l_1} X)
                                    (UniformSpace.completion_functor._proof_2.{?l_1} X))
                                 X)
                              Y),
                            (λ (X Y Z : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                             (f :
                               (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                                  (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α)
                                   (Iβ : uniform_space.{?l_1} β),
                                     @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                                    (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                    (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                                    (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                    (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y))
                                 X
                                 Y)
                             (g :
                               (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                                  (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α)
                                   (Iβ : uniform_space.{?l_1} β),
                                     @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                                    (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                    (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                                    (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                    (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y))
                                 Y
                                 Z),
                               (λ (_x _x_1 _x_2 : Type ?l_1) (_x_3 : (λ (α : Type ?l_1), uniform_space.{?l_1} α) _x)
                                (_x_4 : (λ (α : Type ?l_1), uniform_space.{?l_1} α) _x_1)
                                (_x_5 : (λ (α : Type ?l_1), uniform_space.{?l_1} α) _x_2)
                                (g :
                                  @subtype.{?l_1+1} (_x_1 → _x_2)
                                    (@uniform_continuous.{?l_1 ?l_1} _x_1 _x_2 _x_4 _x_5))
                                (f :
                                  @subtype.{?l_1+1} (_x → _x_1) (@uniform_continuous.{?l_1 ?l_1} _x _x_1 _x_3 _x_4)),
                                  @subtype.mk.{?l_1+1} (_x → _x_2) (@uniform_continuous.{?l_1 ?l_1} _x _x_2 _x_3 _x_5)
                                    (@function.comp.{?l_1+1 ?l_1+1 ?l_1+1} _x _x_1 _x_2
                                       (@subtype.val.{?l_1+1} (_x_1 → _x_2)
                                          (@uniform_continuous.{?l_1 ?l_1} _x_1 _x_2 _x_4 _x_5)
                                          g)
                                       (@subtype.val.{?l_1+1} (_x → _x_1)
                                          (@uniform_continuous.{?l_1 ?l_1} _x _x_1 _x_3 _x_4)
                                          f))
                                    (@category_theory.unbundled_hom.bundled_hom._proof_2.{?l_1}
                                       (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                                       uniform_continuous.{?l_1 ?l_1}
                                       UniformSpace.concrete_category_uniform_continuous.{?l_1}
                                       _x
                                       _x_1
                                       _x_2
                                       _x_3
                                       _x_4
                                       _x_5
                                       g
                                       f))
                                 (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                    (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                    X)
                                 (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                    (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                    Y)
                                 (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                    (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                    Z)
                                 (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                 (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                                 (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Z)
                                 g
                                 f)
                              X
                              (CpltSepUniformSpace.to_UniformSpace.{?l_1}
                                 ((λ (X : UniformSpace.{?l_1}),
                                     @CpltSepUniformSpace.of.{?l_1}
                                       (@uniform_space.completion.{?l_1}
                                          (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                                             (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                             X)
                                          (UniformSpace.uniform_space.{?l_1} X))
                                       (@uniform_space.completion.uniform_space.{?l_1}
                                          (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                                             (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                             X)
                                          (UniformSpace.uniform_space.{?l_1} X))
                                       (UniformSpace.completion_functor._proof_1.{?l_1} X)
                                       (UniformSpace.completion_functor._proof_2.{?l_1} X))
                                    X))
                              (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y)
                              (UniformSpace.completion_hom.{?l_1} X)
                              f)
                           f))
                     f)
                  (@eq.mpr.{0}
                     (@eq.{?l_1+1}
                        (@subtype.{?l_1+1}
                           (@coe_sort.{?l_1+2 ?l_1+2} CpltSepUniformSpace.{?l_1}
                              CpltSepUniformSpace.has_coe_to_sort.{?l_1}
                              (@CpltSepUniformSpace.of.{?l_1}
                                 (@uniform_space.completion.{?l_1}
                                    (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                                       (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                       X)
                                    (UniformSpace.uniform_space.{?l_1} X))
                                 (@uniform_space.completion.uniform_space.{?l_1}
                                    (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                                       (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                       X)
                                    (UniformSpace.uniform_space.{?l_1} X))
                                 (UniformSpace.completion_functor._proof_1.{?l_1} X)
                                 (UniformSpace.completion_functor._proof_2.{?l_1} X)) →
                            @coe_sort.{?l_1+2 ?l_1+2} CpltSepUniformSpace.{?l_1}
                              CpltSepUniformSpace.has_coe_to_sort.{?l_1}
                              Y)
                           (@uniform_continuous.{?l_1 ?l_1}
                              (@coe_sort.{?l_1+2 ?l_1+2} CpltSepUniformSpace.{?l_1}
                                 CpltSepUniformSpace.has_coe_to_sort.{?l_1}
                                 (@CpltSepUniformSpace.of.{?l_1}
                                    (@uniform_space.completion.{?l_1}
                                       (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                                          (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                          X)
                                       (UniformSpace.uniform_space.{?l_1} X))
                                    (@uniform_space.completion.uniform_space.{?l_1}
                                       (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                                          (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                          X)
                                       (UniformSpace.uniform_space.{?l_1} X))
                                    (UniformSpace.completion_functor._proof_1.{?l_1} X)
                                    (UniformSpace.completion_functor._proof_2.{?l_1} X)))
                              (@coe_sort.{?l_1+2 ?l_1+2} CpltSepUniformSpace.{?l_1}
                                 CpltSepUniformSpace.has_coe_to_sort.{?l_1}
                                 Y)
                              ((@CpltSepUniformSpace.of.{?l_1}
                                  (@uniform_space.completion.{?l_1}
                                     (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                                        (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                        X)
                                     (UniformSpace.uniform_space.{?l_1} X))
                                  (@uniform_space.completion.uniform_space.{?l_1}
                                     (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                                        (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                        X)
                                     (UniformSpace.uniform_space.{?l_1} X))
                                  (UniformSpace.completion_functor._proof_1.{?l_1} X)
                                  (UniformSpace.completion_functor._proof_2.{?l_1} X)).is_uniform_space)
                              (Y.is_uniform_space)))
                        (@UniformSpace.extension_hom.{?l_1} X Y
                           ((λ (_x _x_1 _x_2 : Type ?l_1) (_x_3 : uniform_space.{?l_1} _x)
                             (_x_4 : uniform_space.{?l_1} _x_1) (_x_5 : uniform_space.{?l_1} _x_2)
                             (g :
                               @subtype.{?l_1+1} (_x_1 → _x_2) (@uniform_continuous.{?l_1 ?l_1} _x_1 _x_2 _x_4 _x_5))
                             (f : @subtype.{?l_1+1} (_x → _x_1) (@uniform_continuous.{?l_1 ?l_1} _x _x_1 _x_3 _x_4)),
                               @subtype.mk.{?l_1+1} (_x → _x_2) (@uniform_continuous.{?l_1 ?l_1} _x _x_2 _x_3 _x_5)
                                 (@function.comp.{?l_1+1 ?l_1+1 ?l_1+1} _x _x_1 _x_2
                                    (@subtype.val.{?l_1+1} (_x_1 → _x_2)
                                       (@uniform_continuous.{?l_1 ?l_1} _x_1 _x_2 _x_4 _x_5)
                                       g)
                                    (@subtype.val.{?l_1+1} (_x → _x_1)
                                       (@uniform_continuous.{?l_1 ?l_1} _x _x_1 _x_3 _x_4)
                                       f))
                                 (@category_theory.unbundled_hom.bundled_hom._proof_2.{?l_1} uniform_space.{?l_1}
                                    uniform_continuous.{?l_1 ?l_1}
                                    UniformSpace.concrete_category_uniform_continuous.{?l_1}
                                    _x
                                    _x_1
                                    _x_2
                                    _x_3
                                    _x_4
                                    _x_5
                                    g
                                    f))
                              (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                 (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                 X)
                              (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                 (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                 (CpltSepUniformSpace.to_UniformSpace.{?l_1}
                                    (@CpltSepUniformSpace.of.{?l_1}
                                       (@uniform_space.completion.{?l_1}
                                          (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                                             (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                             X)
                                          (UniformSpace.uniform_space.{?l_1} X))
                                       (@uniform_space.completion.uniform_space.{?l_1}
                                          (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                                             (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                             X)
                                          (UniformSpace.uniform_space.{?l_1} X))
                                       (UniformSpace.completion_functor._proof_1.{?l_1} X)
                                       (UniformSpace.completion_functor._proof_2.{?l_1} X))))
                              (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                 (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                 (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
                              (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                              ((@CpltSepUniformSpace.of.{?l_1}
                                  (@uniform_space.completion.{?l_1}
                                     (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                                        (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                        X)
                                     (UniformSpace.uniform_space.{?l_1} X))
                                  (@uniform_space.completion.uniform_space.{?l_1}
                                     (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                                        (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                        X)
                                     (UniformSpace.uniform_space.{?l_1} X))
                                  (UniformSpace.completion_functor._proof_1.{?l_1} X)
                                  (UniformSpace.completion_functor._proof_2.{?l_1} X)).is_uniform_space)
                              (Y.is_uniform_space)
                              f
                              (UniformSpace.completion_hom.{?l_1} X)))
                        f)
                     (@eq.{?l_1+1}
                        (@subtype.{?l_1+1}
                           (@coe_sort.{?l_1+2 ?l_1+2} CpltSepUniformSpace.{?l_1}
                              CpltSepUniformSpace.has_coe_to_sort.{?l_1}
                              (@CpltSepUniformSpace.of.{?l_1}
                                 (@uniform_space.completion.{?l_1}
                                    (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                                       (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                       X)
                                    (UniformSpace.uniform_space.{?l_1} X))
                                 (@uniform_space.completion.uniform_space.{?l_1}
                                    (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                                       (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                       X)
                                    (UniformSpace.uniform_space.{?l_1} X))
                                 (UniformSpace.completion_functor._proof_1.{?l_1} X)
                                 (UniformSpace.completion_functor._proof_2.{?l_1} X)) →
                            @coe_sort.{?l_1+2 ?l_1+2} CpltSepUniformSpace.{?l_1}
                              CpltSepUniformSpace.has_coe_to_sort.{?l_1}
                              Y)
                           (… … …))
                        f
                        f)
                     …
                     …))
             …))
       …)
    …'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>150      apply hom_ext, funext x, dsimp,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='UniformSpace.hom_ext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 49, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1489, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1239, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {X Y : UniformSpace.{u_1}} {f g : @category_theory.has_hom.hom.{u_1 u_1+1} UniformSpace.{u_1} (@category_theory.category_struct.to_has_hom.{u_1 u_1+1} UniformSpace.{u_1} (@category_theory.category.to_category_struct.{u_1 u_1+1} UniformSpace.{u_1} (@category_theory.bundled_hom.category.{u_1} uniform_space.{u_1} (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β), @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ)) (@category_theory.unbundled_hom.bundled_hom.{u_1} (λ (α : Type u_1), uniform_space.{u_1} α) uniform_continuous.{u_1 u_1} UniformSpace.concrete_category_uniform_continuous.{u_1})))) X Y}, @eq.{u_1+1} (@has_coe_to_fun.F.{u_1+1 u_1+1} (@category_theory.has_hom.hom.{u_1 u_1+1} UniformSpace.{u_1} (@category_theory.category_struct.to_has_hom.{u_1 u_1+1} UniformSpace.{u_1} (@category_theory.category.to_category_struct.{u_1 u_1+1} UniformSpace.{u_1} (@category_theory.bundled_hom.category.{u_1} uniform_space.{u_1} (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β), @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ)) (@category_theory.unbundled_hom.bundled_hom.{u_1} (λ (α : Type u_1), uniform_space.{u_1} α) uniform_continuous.{u_1 u_1} UniformSpace.concrete_category_uniform_continuous.{u_1})))) X Y) (UniformSpace.has_coe_to_fun.{u_1} X Y) f) (@coe_fn.{u_1+1 u_1+1} (@category_theory.has_hom.hom.{u_1 u_1+1} UniformSpace.{u_1} (@category_theory.category_struct.to_has_hom.{u_1 u_1+1} UniformSpace.{u_1} (@category_theory.category.to_category_struct.{u_1 u_1+1} UniformSpace.{u_1} (@category_theory.bundled_hom.category.{u_1} uniform_space.{u_1} (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β), @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ)) (@category_theory.unbundled_hom.bundled_hom.{u_1} (λ (α : Type u_1), uniform_space.{u_1} α) uniform_continuous.{u_1 u_1} UniformSpace.concrete_category_uniform_continuous.{u_1})))) X Y) (UniformSpace.has_coe_to_fun.{u_1} X Y) f) (@coe_fn.{u_1+1 u_1+1} (@category_theory.has_hom.hom.{u_1 u_1+1} UniformSpace.{u_1} (@category_theory.category_struct.to_has_hom.{u_1 u_1+1} UniformSpace.{u_1} (@category_theory.category.to_category_struct.{u_1 u_1+1} UniformSpace.{u_1} (@category_theory.bundled_hom.category.{u_1} uniform_space.{u_1} (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β), @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ)) (@category_theory.unbundled_hom.bundled_hom.{u_1} (λ (α : Type u_1), uniform_space.{u_1} α) uniform_continuous.{u_1 u_1} UniformSpace.concrete_category_uniform_continuous.{u_1})))) X Y) (UniformSpace.has_coe_to_fun.{u_1} X Y) g) → @eq.{u_1+1} (@category_theory.has_hom.hom.{u_1 u_1+1} UniformSpace.{u_1} (@category_theory.category_struct.to_has_hom.{u_1 u_1+1} UniformSpace.{u_1} (@category_theory.category.to_category_struct.{u_1 u_1+1} UniformSpace.{u_1} (@category_theory.bundled_hom.category.{u_1} uniform_space.{u_1} (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β), @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ)) (@category_theory.unbundled_hom.bundled_hom.{u_1} (λ (α : Type u_1), uniform_space.{u_1} α) uniform_continuous.{u_1 u_1} UniformSpace.concrete_category_uniform_continuous.{u_1})))) X Y) f g'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='Apply function extensionality and introduce new hypotheses.
The tactic `funext` will keep applying new the `funext` lemma until the goal target is not reducible to
```lean
  |-  ((fun x, ...) = (fun x, ...))
```
The variant `funext h₁ ... hₙ` applies `funext` `n` times, and uses the given identifiers to name the new hypotheses.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`dsimp` is similar to `simp`, except that it only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='funext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='X X&#x27; : UniformSpace.{?l_1},
Y : CpltSepUniformSpace.{?l_1},
f :
  (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
     (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
        @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
       (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
       (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
       (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
       (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y))
    X
    X&#x27;,
g :
  (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
     (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
        @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
       (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
       (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
       (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
       (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y))
    X&#x27;
    (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y)
⊢ @eq.{?l_1+1}
    ((λ
      (X Y :
        @category_theory.induced_category.{?l_1 ?l_1+1 ?l_1+1} CpltSepUniformSpace.{?l_1} UniformSpace.{?l_1}
          (@category_theory.concrete_category.to_category.{?l_1} UniformSpace.{?l_1}
             (@category_theory.bundled_hom.category_theory.concrete_category.{?l_1} uniform_space.{?l_1}
                (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                   @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                (@category_theory.unbundled_hom.bundled_hom.{?l_1} (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                   uniform_continuous.{?l_1 ?l_1}
                   UniformSpace.concrete_category_uniform_continuous.{?l_1})))
          CpltSepUniformSpace.to_UniformSpace.{?l_1}),
        @category_theory.has_hom.hom.{?l_1 ?l_1+1} UniformSpace.{?l_1}
          (@category_theory.category_struct.to_has_hom.{?l_1 ?l_1+1} UniformSpace.{?l_1}
             (@category_theory.category.to_category_struct.{?l_1 ?l_1+1} UniformSpace.{?l_1}
                (@category_theory.concrete_category.to_category.{?l_1} UniformSpace.{?l_1}
                   (@category_theory.bundled_hom.category_theory.concrete_category.{?l_1} uniform_space.{?l_1}
                      (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                         @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                      (@category_theory.unbundled_hom.bundled_hom.{?l_1} (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                         uniform_continuous.{?l_1 ?l_1}
                         UniformSpace.concrete_category_uniform_continuous.{?l_1})))))
          (CpltSepUniformSpace.to_UniformSpace.{?l_1} X)
          (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
       ((λ (X : UniformSpace.{?l_1}),
           @CpltSepUniformSpace.of.{?l_1}
             (@uniform_space.completion.{?l_1}
                (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                   (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                   X)
                (UniformSpace.uniform_space.{?l_1} X))
             (@uniform_space.completion.uniform_space.{?l_1}
                (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                   (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                   X)
                (UniformSpace.uniform_space.{?l_1} X))
             (UniformSpace.completion_functor._proof_1.{?l_1} X)
             (UniformSpace.completion_functor._proof_2.{?l_1} X))
          X)
       Y)
    (@coe_fn.{(max 1 (?l_1+1)) ?l_1+1}
       (equiv.{?l_1+1 ?l_1+1}
          ((λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
              (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                 @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y))
             X
             (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
          ((λ
            (X Y :
              @category_theory.induced_category.{?l_1 ?l_1+1 ?l_1+1} CpltSepUniformSpace.{?l_1} UniformSpace.{?l_1}
                (@category_theory.concrete_category.to_category.{?l_1} UniformSpace.{?l_1}
                   (@category_theory.bundled_hom.category_theory.concrete_category.{?l_1} uniform_space.{?l_1}
                      (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                         @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                      (@category_theory.unbundled_hom.bundled_hom.{?l_1} (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                         uniform_continuous.{?l_1 ?l_1}
                         UniformSpace.concrete_category_uniform_continuous.{?l_1})))
                CpltSepUniformSpace.to_UniformSpace.{?l_1}),
              @category_theory.has_hom.hom.{?l_1 ?l_1+1} UniformSpace.{?l_1}
                (@category_theory.category_struct.to_has_hom.{?l_1 ?l_1+1} UniformSpace.{?l_1}
                   (@category_theory.category.to_category_struct.{?l_1 ?l_1+1} UniformSpace.{?l_1}
                      (@category_theory.concrete_category.to_category.{?l_1} UniformSpace.{?l_1}
                         (@category_theory.bundled_hom.category_theory.concrete_category.{?l_1} uniform_space.{?l_1}
                            (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                               @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                            (@category_theory.unbundled_hom.bundled_hom.{?l_1}
                               (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                               uniform_continuous.{?l_1 ?l_1}
                               UniformSpace.concrete_category_uniform_continuous.{?l_1})))))
                (CpltSepUniformSpace.to_UniformSpace.{?l_1} X)
                (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
             ((λ (X : UniformSpace.{?l_1}),
                 @CpltSepUniformSpace.of.{?l_1}
                   (@uniform_space.completion.{?l_1}
                      (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                         (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                         X)
                      (UniformSpace.uniform_space.{?l_1} X))
                   (@uniform_space.completion.uniform_space.{?l_1}
                      (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                         (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                         X)
                      (UniformSpace.uniform_space.{?l_1} X))
                   (UniformSpace.completion_functor._proof_1.{?l_1} X)
                   (UniformSpace.completion_functor._proof_2.{?l_1} X))
                X)
             Y))
       (@equiv.has_coe_to_fun.{?l_1+1 ?l_1+1}
          ((λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
              (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                 @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y))
             X
             (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
          ((λ
            (X Y :
              @category_theory.induced_category.{?l_1 ?l_1+1 ?l_1+1} CpltSepUniformSpace.{?l_1} UniformSpace.{?l_1}
                (@category_theory.concrete_category.to_category.{?l_1} UniformSpace.{?l_1}
                   (@category_theory.bundled_hom.category_theory.concrete_category.{?l_1} uniform_space.{?l_1}
                      (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                         @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                      (@category_theory.unbundled_hom.bundled_hom.{?l_1} (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                         uniform_continuous.{?l_1 ?l_1}
                         UniformSpace.concrete_category_uniform_continuous.{?l_1})))
                CpltSepUniformSpace.to_UniformSpace.{?l_1}),
              @category_theory.has_hom.hom.{?l_1 ?l_1+1} UniformSpace.{?l_1}
                (@category_theory.category_struct.to_has_hom.{?l_1 ?l_1+1} UniformSpace.{?l_1}
                   (@category_theory.category.to_category_struct.{?l_1 ?l_1+1} UniformSpace.{?l_1}
                      (@category_theory.concrete_category.to_category.{?l_1} UniformSpace.{?l_1}
                         (@category_theory.bundled_hom.category_theory.concrete_category.{?l_1} uniform_space.{?l_1}
                            (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                               @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                            (@category_theory.unbundled_hom.bundled_hom.{?l_1}
                               (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                               uniform_continuous.{?l_1 ?l_1}
                               UniformSpace.concrete_category_uniform_continuous.{?l_1})))))
                (CpltSepUniformSpace.to_UniformSpace.{?l_1} X)
                (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
             ((λ (X : UniformSpace.{?l_1}),
                 @CpltSepUniformSpace.of.{?l_1}
                   (@uniform_space.completion.{?l_1}
                      (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                         (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                         X)
                      (UniformSpace.uniform_space.{?l_1} X))
                   (@uniform_space.completion.uniform_space.{?l_1}
                      (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                         (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                         X)
                      (UniformSpace.uniform_space.{?l_1} X))
                   (UniformSpace.completion_functor._proof_1.{?l_1} X)
                   (UniformSpace.completion_functor._proof_2.{?l_1} X))
                X)
             Y))
       (@equiv.symm.{?l_1+1 ?l_1+1}
          ((λ
            (X Y :
              @category_theory.induced_category.{?l_1 ?l_1+1 ?l_1+1} CpltSepUniformSpace.{?l_1} UniformSpace.{?l_1}
                (@category_theory.concrete_category.to_category.{?l_1} UniformSpace.{?l_1}
                   (@category_theory.bundled_hom.category_theory.concrete_category.{?l_1} uniform_space.{?l_1}
                      (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                         @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                      (@category_theory.unbundled_hom.bundled_hom.{?l_1} (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                         uniform_continuous.{?l_1 ?l_1}
                         UniformSpace.concrete_category_uniform_continuous.{?l_1})))
                CpltSepUniformSpace.to_UniformSpace.{?l_1}),
              @category_theory.has_hom.hom.{?l_1 ?l_1+1} UniformSpace.{?l_1}
                (@category_theory.category_struct.to_has_hom.{?l_1 ?l_1+1} UniformSpace.{?l_1}
                   (@category_theory.category.to_category_struct.{?l_1 ?l_1+1} UniformSpace.{?l_1}
                      (@category_theory.concrete_category.to_category.{?l_1} UniformSpace.{?l_1}
                         (@category_theory.bundled_hom.category_theory.concrete_category.{?l_1} uniform_space.{?l_1}
                            (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                               @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                            (@category_theory.unbundled_hom.bundled_hom.{?l_1}
                               (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                               uniform_continuous.{?l_1 ?l_1}
                               UniformSpace.concrete_category_uniform_continuous.{?l_1})))))
                (CpltSepUniformSpace.to_UniformSpace.{?l_1} X)
                (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
             ((λ (X : UniformSpace.{?l_1}),
                 @CpltSepUniformSpace.of.{?l_1}
                   (@uniform_space.completion.{?l_1}
                      (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                         (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                         X)
                      (UniformSpace.uniform_space.{?l_1} X))
                   (@uniform_space.completion.uniform_space.{?l_1}
                      (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                         (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                         X)
                      (UniformSpace.uniform_space.{?l_1} X))
                   (UniformSpace.completion_functor._proof_1.{?l_1} X)
                   (UniformSpace.completion_functor._proof_2.{?l_1} X))
                X)
             Y)
          ((λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
              (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                 @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y))
             X
             (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
          (@equiv.mk.{?l_1+1 ?l_1+1}
             ((λ
               (X Y :
                 @category_theory.induced_category.{?l_1 ?l_1+1 ?l_1+1} CpltSepUniformSpace.{?l_1} UniformSpace.{?l_1}
                   (@category_theory.category.mk.{?l_1 ?l_1+1}
                      (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                      (@category_theory.category.to_category_struct.{?l_1 ?l_1+1}
                         (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                         (@category_theory.bundled_hom.category.{?l_1} uniform_space.{?l_1}
                            (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                               @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                            (@category_theory.unbundled_hom.bundled_hom.{?l_1}
                               (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                               uniform_continuous.{?l_1 ?l_1}
                               UniformSpace.concrete_category_uniform_continuous.{?l_1})))
                      (@category_theory.bundled_hom.category_theory.concrete_category._proof_1.{?l_1}
                         uniform_space.{?l_1}
                         (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                            @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                         (@category_theory.unbundled_hom.bundled_hom.{?l_1}
                            (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                            uniform_continuous.{?l_1 ?l_1}
                            UniformSpace.concrete_category_uniform_continuous.{?l_1}))
                      (@category_theory.bundled_hom.category_theory.concrete_category._proof_2.{?l_1}
                         uniform_space.{?l_1}
                         (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                            @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                         (@category_theory.unbundled_hom.bundled_hom.{?l_1}
                            (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                            uniform_continuous.{?l_1 ?l_1}
                            UniformSpace.concrete_category_uniform_continuous.{?l_1}))
                      (@category_theory.bundled_hom.category_theory.concrete_category._proof_3.{?l_1}
                         uniform_space.{?l_1}
                         (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                            @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                         (@category_theory.unbundled_hom.bundled_hom.{?l_1}
                            (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                            uniform_continuous.{?l_1 ?l_1}
                            UniformSpace.concrete_category_uniform_continuous.{?l_1})))
                   CpltSepUniformSpace.to_UniformSpace.{?l_1}),
                 (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                    (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                       @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                      (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                      (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                      (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                      (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y))
                   (CpltSepUniformSpace.to_UniformSpace.{?l_1} X)
                   (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
                ((λ (X : UniformSpace.{?l_1}),
                    @CpltSepUniformSpace.of.{?l_1}
                      (@uniform_space.completion.{?l_1}
                         (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                            (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                            X)
                         (UniformSpace.uniform_space.{?l_1} X))
                      (@uniform_space.completion.uniform_space.{?l_1}
                         (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                            (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                            X)
                         (UniformSpace.uniform_space.{?l_1} X))
                      (UniformSpace.completion_functor._proof_1.{?l_1} X)
                      (UniformSpace.completion_functor._proof_2.{?l_1} X))
                   X)
                Y)
             ((λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                 (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                    @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                   (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                   (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                   (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                   (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y))
                X
                (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
             (λ
              (f :
                (λ
                 (X Y :
                   @category_theory.induced_category.{?l_1 ?l_1+1 ?l_1+1} CpltSepUniformSpace.{?l_1} UniformSpace.{?l_1}
                     (@category_theory.category.mk.{?l_1 ?l_1+1}
                        (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                        (@category_theory.category_struct.mk.{?l_1 ?l_1+1}
                           (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                           (@category_theory.has_hom.mk.{?l_1 ?l_1+1}
                              (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                              (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                                 (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α)
                                  (Iβ : uniform_space.{?l_1} β),
                                    @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                                   (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                   (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                                   (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                   (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y)))
                           (λ (X : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                              @category_theory.bundled_hom.id.{?l_1} uniform_space.{?l_1}
                                (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                                   @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                                (@category_theory.unbundled_hom.bundled_hom.{?l_1}
                                   (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                                   uniform_continuous.{?l_1 ?l_1}
                                   UniformSpace.concrete_category_uniform_continuous.{?l_1})
                                (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                   (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                   X)
                                (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X))
                           (λ (X Y Z : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                            (f :
                              @category_theory.has_hom.hom.{?l_1 ?l_1+1}
                                (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                (@category_theory.has_hom.mk.{?l_1 ?l_1+1}
                                   (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                   (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                                      (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α)
                                       (Iβ : uniform_space.{?l_1} β),
                                         @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                                        (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                        (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                                        (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                        (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y)))
                                X
                                Y)
                            (g :
                              @category_theory.has_hom.hom.{?l_1 ?l_1+1}
                                (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                (@category_theory.has_hom.mk.{?l_1 ?l_1+1}
                                   (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                   (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                                      (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α)
                                       (Iβ : uniform_space.{?l_1} β),
                                         @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                                        (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                        (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                                        (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                        (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y)))
                                Y
                                Z),
                              @category_theory.bundled_hom.comp.{?l_1} uniform_space.{?l_1}
                                (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                                   @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                                (@category_theory.unbundled_hom.bundled_hom.{?l_1}
                                   (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                                   uniform_continuous.{?l_1 ?l_1}
                                   UniformSpace.concrete_category_uniform_continuous.{?l_1})
                                (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                   (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                   X)
                                (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                   (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                   Y)
                                (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                   (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                   Z)
                                (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                                (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Z)
                                g
                                f))
                        (@category_theory.bundled_hom.category_theory.concrete_category._proof_1.{?l_1}
                           uniform_space.{?l_1}
                           (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                              @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                           (@category_theory.unbundled_hom.bundled_hom.{?l_1}
                              (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                              uniform_continuous.{?l_1 ?l_1}
                              UniformSpace.concrete_category_uniform_continuous.{?l_1}))
                        (@category_theory.bundled_hom.category_theory.concrete_category._proof_2.{?l_1}
                           uniform_space.{?l_1}
                           (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                              @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                           (@category_theory.unbundled_hom.bundled_hom.{?l_1}
                              (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                              uniform_continuous.{?l_1 ?l_1}
                              UniformSpace.concrete_category_uniform_continuous.{?l_1}))
                        (@category_theory.bundled_hom.category_theory.concrete_category._proof_3.{?l_1}
                           uniform_space.{?l_1}
                           (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                              @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                           (@category_theory.unbundled_hom.bundled_hom.{?l_1}
                              (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                              uniform_continuous.{?l_1 ?l_1}
                              UniformSpace.concrete_category_uniform_continuous.{?l_1})))
                     CpltSepUniformSpace.to_UniformSpace.{?l_1}),
                   (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                      (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                         @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                        (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                        (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                        (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                        (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y))
                     (CpltSepUniformSpace.to_UniformSpace.{?l_1} X)
                     (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
                  ((λ (X : UniformSpace.{?l_1}),
                      @CpltSepUniformSpace.of.{?l_1}
                        (@uniform_space.completion.{?l_1}
                           (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                              (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                              X)
                           (UniformSpace.uniform_space.{?l_1} X))
                        (@uniform_space.completion.uniform_space.{?l_1}
                           (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                              (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                              X)
                           (UniformSpace.uniform_space.{?l_1} X))
                        (UniformSpace.completion_functor._proof_1.{?l_1} X)
                        (UniformSpace.completion_functor._proof_2.{?l_1} X))
                     X)
                  Y),
                (λ (X Y Z : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                 (f :
                   @category_theory.has_hom.hom.{?l_1 ?l_1+1} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                     (@category_theory.has_hom.mk.{?l_1 ?l_1+1}
                        (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                        (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                           (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                              @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                             (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                             (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                             (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                             (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y)))
                     X
                     Y)
                 (g :
                   @category_theory.has_hom.hom.{?l_1 ?l_1+1} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                     (@category_theory.has_hom.mk.{?l_1 ?l_1+1}
                        (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                        (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                           (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                              @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                             (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                             (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                             (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                             (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y)))
                     Y
                     Z),
                   @category_theory.bundled_hom.comp.{?l_1} uniform_space.{?l_1}
                     (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                        @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                     (@category_theory.unbundled_hom.bundled_hom.{?l_1} (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                        uniform_continuous.{?l_1 ?l_1}
                        UniformSpace.concrete_category_uniform_continuous.{?l_1})
                     (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                        (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                        X)
                     (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                        (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                        Y)
                     (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                        (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                        Z)
                     (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                     (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                     (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Z)
                     g
                     f)
                  X
                  (CpltSepUniformSpace.to_UniformSpace.{?l_1}
                     ((λ (X : UniformSpace.{?l_1}),
                         @CpltSepUniformSpace.of.{?l_1}
                           (@uniform_space.completion.{?l_1}
                              (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                                 (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                 X)
                              (UniformSpace.uniform_space.{?l_1} X))
                           (@uniform_space.completion.uniform_space.{?l_1}
                              (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                                 (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                 X)
                              (UniformSpace.uniform_space.{?l_1} X))
                           (UniformSpace.completion_functor._proof_1.{?l_1} X)
                           (UniformSpace.completion_functor._proof_2.{?l_1} X))
                        X))
                  (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y)
                  (UniformSpace.completion_hom.{?l_1} X)
                  f)
             (λ
              (f :
                (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                   (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                      @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                     (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                     (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                     (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                     (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y))
                  X
                  (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y)), @UniformSpace.extension_hom.{?l_1} X Y f)
             (λ
              (f :
                (λ
                 (X Y :
                   @category_theory.induced_category.{?l_1 ?l_1+1 ?l_1+1} CpltSepUniformSpace.{?l_1} UniformSpace.{?l_1}
                     (@category_theory.category.mk.{?l_1 ?l_1+1}
                        (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                        (@category_theory.category_struct.mk.{?l_1 ?l_1+1}
                           (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                           (@category_theory.has_hom.mk.{?l_1 ?l_1+1}
                              (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                              (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                                 (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α)
                                  (Iβ : uniform_space.{?l_1} β),
                                    @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                                   (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                   (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                                   (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                   (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y)))
                           (λ (X : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                              @category_theory.bundled_hom.id.{?l_1} uniform_space.{?l_1}
                                (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                                   @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                                (@category_theory.unbundled_hom.bundled_hom.{?l_1}
                                   (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                                   uniform_continuous.{?l_1 ?l_1}
                                   UniformSpace.concrete_category_uniform_continuous.{?l_1})
                                (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                   (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                   X)
                                (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X))
                           (λ (X Y Z : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                            (f :
                              @category_theory.has_hom.hom.{?l_1 ?l_1+1}
                                (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                (@category_theory.has_hom.mk.{?l_1 ?l_1+1}
                                   (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                   (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                                      (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α)
                                       (Iβ : uniform_space.{?l_1} β),
                                         @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                                        (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                        (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                                        (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                        (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y)))
                                X
                                Y)
                            (g :
                              @category_theory.has_hom.hom.{?l_1 ?l_1+1}
                                (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                (@category_theory.has_hom.mk.{?l_1 ?l_1+1}
                                   (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                   (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                                      (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α)
                                       (Iβ : uniform_space.{?l_1} β),
                                         @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                                        (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                        (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                                        (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                        (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y)))
                                Y
                                Z),
                              @category_theory.bundled_hom.comp.{?l_1} uniform_space.{?l_1}
                                (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                                   @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                                (@category_theory.unbundled_hom.bundled_hom.{?l_1}
                                   (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                                   uniform_continuous.{?l_1 ?l_1}
                                   UniformSpace.concrete_category_uniform_continuous.{?l_1})
                                (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                   (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                   X)
                                (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                   (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                   Y)
                                (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                   (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                   Z)
                                (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                                (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Z)
                                g
                                f))
                        (@category_theory.bundled_hom.category_theory.concrete_category._proof_1.{?l_1}
                           uniform_space.{?l_1}
                           (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                              @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                           (@category_theory.unbundled_hom.bundled_hom.{?l_1}
                              (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                              uniform_continuous.{?l_1 ?l_1}
                              UniformSpace.concrete_category_uniform_continuous.{?l_1}))
                        (@category_theory.bundled_hom.category_theory.concrete_category._proof_2.{?l_1}
                           uniform_space.{?l_1}
                           (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                              @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                           (@category_theory.unbundled_hom.bundled_hom.{?l_1}
                              (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                              uniform_continuous.{?l_1 ?l_1}
                              UniformSpace.concrete_category_uniform_continuous.{?l_1}))
                        (@category_theory.bundled_hom.category_theory.concrete_category._proof_3.{?l_1}
                           uniform_space.{?l_1}
                           (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                              @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                           (@category_theory.unbundled_hom.bundled_hom.{?l_1}
                              (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                              uniform_continuous.{?l_1 ?l_1}
                              UniformSpace.concrete_category_uniform_continuous.{?l_1})))
                     CpltSepUniformSpace.to_UniformSpace.{?l_1}),
                   (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                      (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                         @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                        (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                        (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                        (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                        (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y))
                     (CpltSepUniformSpace.to_UniformSpace.{?l_1} X)
                     (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
                  ((λ (X : UniformSpace.{?l_1}),
                      @CpltSepUniformSpace.of.{?l_1}
                        (@uniform_space.completion.{?l_1}
                           (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                              (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                              X)
                           (UniformSpace.uniform_space.{?l_1} X))
                        (@uniform_space.completion.uniform_space.{?l_1}
                           (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                              (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                              X)
                           (UniformSpace.uniform_space.{?l_1} X))
                        (UniformSpace.completion_functor._proof_1.{?l_1} X)
                        (UniformSpace.completion_functor._proof_2.{?l_1} X))
                     X)
                  Y),
                @id.{0}
                  (@eq.{?l_1+1}
                     ((λ
                       (X Y :
                         @category_theory.induced_category.{?l_1 ?l_1+1 ?l_1+1} CpltSepUniformSpace.{?l_1}
                           UniformSpace.{?l_1}
                           (@category_theory.category.mk.{?l_1 ?l_1+1}
                              (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                              (@category_theory.category_struct.mk.{?l_1 ?l_1+1}
                                 (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                 (@category_theory.has_hom.mk.{?l_1 ?l_1+1}
                                    (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                    (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                                       (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α)
                                        (Iβ : uniform_space.{?l_1} β),
                                          @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                                         (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                         (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                                         (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                         (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y)))
                                 (λ (X : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                                    @category_theory.bundled_hom.id.{?l_1} uniform_space.{?l_1}
                                      (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α)
                                       (Iβ : uniform_space.{?l_1} β),
                                         @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                                      (@category_theory.unbundled_hom.bundled_hom.{?l_1}
                                         (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                                         uniform_continuous.{?l_1 ?l_1}
                                         UniformSpace.concrete_category_uniform_continuous.{?l_1})
                                      (@coe_sort.{?l_1+2 ?l_1+2}
                                         (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                         (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                         X)
                                      (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X))
                                 (λ (X Y Z : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                  (f :
                                    @category_theory.has_hom.hom.{?l_1 ?l_1+1}
                                      (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                      (@category_theory.has_hom.mk.{?l_1 ?l_1+1}
                                         (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                         (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                                            (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α)
                                             (Iβ : uniform_space.{?l_1} β),
                                               @subtype.{?l_1+1} (α → β)
                                                 (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                                              (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                              (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                                              (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                              (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y)))
                                      X
                                      Y)
                                  (g :
                                    @category_theory.has_hom.hom.{?l_1 ?l_1+1}
                                      (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                      (@category_theory.has_hom.mk.{?l_1 ?l_1+1}
                                         (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                         (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                                            (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α)
                                             (Iβ : uniform_space.{?l_1} β),
                                               @subtype.{?l_1+1} (α → β)
                                                 (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                                              (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                              (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                                              (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                              (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y)))
                                      Y
                                      Z),
                                    @category_theory.bundled_hom.comp.{?l_1} uniform_space.{?l_1}
                                      (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α)
                                       (Iβ : uniform_space.{?l_1} β),
                                         @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                                      (@category_theory.unbundled_hom.bundled_hom.{?l_1}
                                         (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                                         uniform_continuous.{?l_1 ?l_1}
                                         UniformSpace.concrete_category_uniform_continuous.{?l_1})
                                      (@coe_sort.{?l_1+2 ?l_1+2}
                                         (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                         (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                         X)
                                      (@coe_sort.{?l_1+2 ?l_1+2}
                                         (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                         (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                         Y)
                                      (@coe_sort.{?l_1+2 ?l_1+2}
                                         (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                         (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                         Z)
                                      (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                      (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                                      (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Z)
                                      g
                                      f))
                              (@category_theory.bundled_hom.category_theory.concrete_category._proof_1.{?l_1}
                                 uniform_space.{?l_1}
                                 (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α)
                                  (Iβ : uniform_space.{?l_1} β),
                                    @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                                 (@category_theory.unbundled_hom.bundled_hom.{?l_1}
                                    (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                                    uniform_continuous.{?l_1 ?l_1}
                                    UniformSpace.concrete_category_uniform_continuous.{?l_1}))
                              (@category_theory.bundled_hom.category_theory.concrete_category._proof_2.{?l_1}
                                 uniform_space.{?l_1}
                                 (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α)
                                  (Iβ : uniform_space.{?l_1} β),
                                    @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                                 (@category_theory.unbundled_hom.bundled_hom.{?l_1}
                                    (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                                    uniform_continuous.{?l_1 ?l_1}
                                    UniformSpace.concrete_category_uniform_continuous.{?l_1}))
                              (@category_theory.bundled_hom.category_theory.concrete_category._proof_3.{?l_1}
                                 uniform_space.{?l_1}
                                 (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α)
                                  (Iβ : uniform_space.{?l_1} β),
                                    @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                                 (@category_theory.unbundled_hom.bundled_hom.{?l_1}
                                    (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                                    uniform_continuous.{?l_1 ?l_1}
                                    UniformSpace.concrete_category_uniform_continuous.{?l_1})))
                           CpltSepUniformSpace.to_UniformSpace.{?l_1}),
                         (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                            (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                               @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                              (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                              (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                              (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                              (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y))
                           (CpltSepUniformSpace.to_UniformSpace.{?l_1} X)
                           (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
                        ((λ (X : UniformSpace.{?l_1}),
                            @CpltSepUniformSpace.of.{?l_1}
                              (@uniform_space.completion.{?l_1}
                                 (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                                    (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                    X)
                                 (UniformSpace.uniform_space.{?l_1} X))
                              (@uniform_space.completion.uniform_space.{?l_1}
                                 (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                                    (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                    X)
                                 (UniformSpace.uniform_space.{?l_1} X))
                              (UniformSpace.completion_functor._proof_1.{?l_1} X)
                              (UniformSpace.completion_functor._proof_2.{?l_1} X))
                           X)
                        Y)
                     ((λ
                       (f :
                         (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                            (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                               @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                              (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                              (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                              (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                              (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y))
                           X
                           (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y)), @UniformSpace.extension_hom.{?l_1} X Y f)
                        ((λ
                          (f :
                            (λ
                             (X Y :
                               @category_theory.induced_category.{?l_1 ?l_1+1 ?l_1+1} CpltSepUniformSpace.{?l_1}
                                 UniformSpace.{?l_1}
                                 (@category_theory.category.mk.{?l_1 ?l_1+1}
                                    (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                    (@category_theory.category_struct.mk.{?l_1 ?l_1+1}
                                       (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                       (@category_theory.has_hom.mk.{?l_1 ?l_1+1}
                                          (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                          (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                                             (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α)
                                              (Iβ : uniform_space.{?l_1} β),
                                                @subtype.{?l_1+1} (α → β)
                                                  (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                                               (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                               (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                                               (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                               (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y)))
                                       (λ (X : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                                          (λ (α : Type ?l_1)
                                           (Iα : (λ (α : Type ?l_1), uniform_space.{?l_1} α) α),
                                             @subtype.mk.{?l_1+1} (α → α)
                                               (@uniform_continuous.{?l_1 ?l_1} α α Iα Iα)
                                               (@id.{?l_1+1} α)
                                               (@category_theory.unbundled_hom.bundled_hom._proof_1.{?l_1}
                                                  (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                                                  uniform_continuous.{?l_1 ?l_1}
                                                  UniformSpace.concrete_category_uniform_continuous.{?l_1}
                                                  α
                                                  Iα))
                                            (@coe_sort.{?l_1+2 ?l_1+2}
                                               (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                               (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1}
                                                  uniform_space.{?l_1})
                                               X)
                                            (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X))
                                       (λ (X Y Z : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                        (f :
                                          (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                                             (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α)
                                              (Iβ : uniform_space.{?l_1} β),
                                                @subtype.{?l_1+1} (α → β)
                                                  (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                                               (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                               (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                                               (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                               (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y))
                                            X
                                            Y)
                                        (g :
                                          (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                                             (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α)
                                              (Iβ : uniform_space.{?l_1} β),
                                                @subtype.{?l_1+1} (α → β)
                                                  (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                                               (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                               (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                                               (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                               (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y))
                                            Y
                                            Z),
                                          (λ (_x _x_1 _x_2 : Type ?l_1)
                                           (_x_3 : (λ (α : Type ?l_1), uniform_space.{?l_1} α) _x)
                                           (_x_4 : (λ (α : Type ?l_1), uniform_space.{?l_1} α) _x_1)
                                           (_x_5 : (λ (α : Type ?l_1), uniform_space.{?l_1} α) _x_2)
                                           (g :
                                             @subtype.{?l_1+1} (_x_1 → _x_2)
                                               (@uniform_continuous.{?l_1 ?l_1} _x_1 _x_2 _x_4 _x_5))
                                           (f :
                                             @subtype.{?l_1+1} (_x → _x_1)
                                               (@uniform_continuous.{?l_1 ?l_1} _x _x_1 _x_3 _x_4)),
                                             @subtype.mk.{?l_1+1} (_x → _x_2)
                                               (@uniform_continuous.{?l_1 ?l_1} _x _x_2 _x_3 _x_5)
                                               (@function.comp.{?l_1+1 ?l_1+1 ?l_1+1} _x _x_1 _x_2
                                                  (@subtype.val.{?l_1+1} (_x_1 → _x_2)
                                                     (@uniform_continuous.{?l_1 ?l_1} _x_1 _x_2 _x_4 _x_5)
                                                     g)
                                                  (@subtype.val.{?l_1+1} (_x → _x_1)
                                                     (@uniform_continuous.{?l_1 ?l_1} _x _x_1 _x_3 _x_4)
                                                     f))
                                               (@category_theory.unbundled_hom.bundled_hom._proof_2.{?l_1}
                                                  (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                                                  uniform_continuous.{?l_1 ?l_1}
                                                  UniformSpace.concrete_category_uniform_continuous.{?l_1}
                                                  _x
                                                  _x_1
                                                  _x_2
                                                  _x_3
                                                  _x_4
                                                  _x_5
                                                  g
                                                  f))
                                            (@coe_sort.{?l_1+2 ?l_1+2}
                                               (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                               (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1}
                                                  uniform_space.{?l_1})
                                               X)
                                            (@coe_sort.{?l_1+2 ?l_1+2}
                                               (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                               (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1}
                                                  uniform_space.{?l_1})
                                               Y)
                                            (@coe_sort.{?l_1+2 ?l_1+2}
                                               (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                               (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1}
                                                  uniform_space.{?l_1})
                                               Z)
                                            (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                            (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                                            (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Z)
                                            g
                                            f))
                                    (@category_theory.bundled_hom.category_theory.concrete_category._proof_1.{?l_1}
                                       uniform_space.{?l_1}
                                       (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α)
                                        (Iβ : uniform_space.{?l_1} β),
                                          @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                                       (@category_theory.unbundled_hom.bundled_hom.{?l_1}
                                          (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                                          uniform_continuous.{?l_1 ?l_1}
                                          UniformSpace.concrete_category_uniform_continuous.{?l_1}))
                                    (@category_theory.bundled_hom.category_theory.concrete_category._proof_2.{?l_1}
                                       uniform_space.{?l_1}
                                       (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α)
                                        (Iβ : uniform_space.{?l_1} β),
                                          @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                                       (@category_theory.unbundled_hom.bundled_hom.{?l_1}
                                          (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                                          uniform_continuous.{?l_1 ?l_1}
                                          UniformSpace.concrete_category_uniform_continuous.{?l_1}))
                                    (@category_theory.bundled_hom.category_theory.concrete_category._proof_3.{?l_1}
                                       uniform_space.{?l_1}
                                       (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α)
                                        (Iβ : uniform_space.{?l_1} β),
                                          @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                                       (@category_theory.unbundled_hom.bundled_hom.{?l_1}
                                          (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                                          uniform_continuous.{?l_1 ?l_1}
                                          UniformSpace.concrete_category_uniform_continuous.{?l_1})))
                                 CpltSepUniformSpace.to_UniformSpace.{?l_1}),
                               (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                                  (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α)
                                   (Iβ : uniform_space.{?l_1} β),
                                     @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                                    (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                    (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                                    (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                    (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y))
                                 (CpltSepUniformSpace.to_UniformSpace.{?l_1} X)
                                 (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
                              ((λ (X : UniformSpace.{?l_1}),
                                  @CpltSepUniformSpace.of.{?l_1}
                                    (@uniform_space.completion.{?l_1}
                                       (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                                          (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                          X)
                                       (UniformSpace.uniform_space.{?l_1} X))
                                    (@uniform_space.completion.uniform_space.{?l_1}
                                       (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                                          (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                          X)
                                       (UniformSpace.uniform_space.{?l_1} X))
                                    (UniformSpace.completion_functor._proof_1.{?l_1} X)
                                    (UniformSpace.completion_functor._proof_2.{?l_1} X))
                                 X)
                              Y),
                            (λ (X Y Z : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                             (f :
                               (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                                  (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α)
                                   (Iβ : uniform_space.{?l_1} β),
                                     @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                                    (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                    (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                                    (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                    (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y))
                                 X
                                 Y)
                             (g :
                               (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                                  (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α)
                                   (Iβ : uniform_space.{?l_1} β),
                                     @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                                    (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                    (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                                    (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                    (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y))
                                 Y
                                 Z),
                               (λ (_x _x_1 _x_2 : Type ?l_1) (_x_3 : (λ (α : Type ?l_1), uniform_space.{?l_1} α) _x)
                                (_x_4 : (λ (α : Type ?l_1), uniform_space.{?l_1} α) _x_1)
                                (_x_5 : (λ (α : Type ?l_1), uniform_space.{?l_1} α) _x_2)
                                (g :
                                  @subtype.{?l_1+1} (_x_1 → _x_2)
                                    (@uniform_continuous.{?l_1 ?l_1} _x_1 _x_2 _x_4 _x_5))
                                (f :
                                  @subtype.{?l_1+1} (_x → _x_1) (@uniform_continuous.{?l_1 ?l_1} _x _x_1 _x_3 _x_4)),
                                  @subtype.mk.{?l_1+1} (_x → _x_2) (@uniform_continuous.{?l_1 ?l_1} _x _x_2 _x_3 _x_5)
                                    (@function.comp.{?l_1+1 ?l_1+1 ?l_1+1} _x _x_1 _x_2
                                       (@subtype.val.{?l_1+1} (_x_1 → _x_2)
                                          (@uniform_continuous.{?l_1 ?l_1} _x_1 _x_2 _x_4 _x_5)
                                          g)
                                       (@subtype.val.{?l_1+1} (_x → _x_1)
                                          (@uniform_continuous.{?l_1 ?l_1} _x _x_1 _x_3 _x_4)
                                          f))
                                    (@category_theory.unbundled_hom.bundled_hom._proof_2.{?l_1}
                                       (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                                       uniform_continuous.{?l_1 ?l_1}
                                       UniformSpace.concrete_category_uniform_continuous.{?l_1}
                                       _x
                                       _x_1
                                       _x_2
                                       _x_3
                                       _x_4
                                       _x_5
                                       g
                                       f))
                                 (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                    (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                    X)
                                 (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                    (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                    Y)
                                 (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                    (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                    Z)
                                 (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                 (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                                 (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Z)
                                 g
                                 f)
                              X
                              (CpltSepUniformSpace.to_UniformSpace.{?l_1}
                                 ((λ (X : UniformSpace.{?l_1}),
                                     @CpltSepUniformSpace.of.{?l_1}
                                       (@uniform_space.completion.{?l_1}
                                          (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                                             (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                             X)
                                          (UniformSpace.uniform_space.{?l_1} X))
                                       (@uniform_space.completion.uniform_space.{?l_1}
                                          (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                                             (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                             X)
                                          (UniformSpace.uniform_space.{?l_1} X))
                                       (UniformSpace.completion_functor._proof_1.{?l_1} X)
                                       (UniformSpace.completion_functor._proof_2.{?l_1} X))
                                    X))
                              (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y)
                              (UniformSpace.completion_hom.{?l_1} X)
                              f)
                           f))
                     f)
                  (@eq.mpr.{0}
                     (@eq.{?l_1+1}
                        (@subtype.{?l_1+1}
                           (@coe_sort.{?l_1+2 ?l_1+2} CpltSepUniformSpace.{?l_1}
                              CpltSepUniformSpace.has_coe_to_sort.{?l_1}
                              (@CpltSepUniformSpace.of.{?l_1}
                                 (@uniform_space.completion.{?l_1}
                                    (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                                       (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                       X)
                                    (UniformSpace.uniform_space.{?l_1} X))
                                 (@uniform_space.completion.uniform_space.{?l_1}
                                    (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                                       (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                       X)
                                    (UniformSpace.uniform_space.{?l_1} X))
                                 (UniformSpace.completion_functor._proof_1.{?l_1} X)
                                 (UniformSpace.completion_functor._proof_2.{?l_1} X)) →
                            @coe_sort.{?l_1+2 ?l_1+2} CpltSepUniformSpace.{?l_1}
                              CpltSepUniformSpace.has_coe_to_sort.{?l_1}
                              Y)
                           (@uniform_continuous.{?l_1 ?l_1}
                              (@coe_sort.{?l_1+2 ?l_1+2} CpltSepUniformSpace.{?l_1}
                                 CpltSepUniformSpace.has_coe_to_sort.{?l_1}
                                 (@CpltSepUniformSpace.of.{?l_1}
                                    (@uniform_space.completion.{?l_1}
                                       (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                                          (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                          X)
                                       (UniformSpace.uniform_space.{?l_1} X))
                                    (@uniform_space.completion.uniform_space.{?l_1}
                                       (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                                          (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                          X)
                                       (UniformSpace.uniform_space.{?l_1} X))
                                    (UniformSpace.completion_functor._proof_1.{?l_1} X)
                                    (UniformSpace.completion_functor._proof_2.{?l_1} X)))
                              (@coe_sort.{?l_1+2 ?l_1+2} CpltSepUniformSpace.{?l_1}
                                 CpltSepUniformSpace.has_coe_to_sort.{?l_1}
                                 Y)
                              ((@CpltSepUniformSpace.of.{?l_1}
                                  (@uniform_space.completion.{?l_1}
                                     (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                                        (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                        X)
                                     (UniformSpace.uniform_space.{?l_1} X))
                                  (@uniform_space.completion.uniform_space.{?l_1}
                                     (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                                        (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                        X)
                                     (UniformSpace.uniform_space.{?l_1} X))
                                  (UniformSpace.completion_functor._proof_1.{?l_1} X)
                                  (UniformSpace.completion_functor._proof_2.{?l_1} X)).is_uniform_space)
                              (Y.is_uniform_space)))
                        (@UniformSpace.extension_hom.{?l_1} X Y
                           ((λ (_x _x_1 _x_2 : Type ?l_1) (_x_3 : uniform_space.{?l_1} _x)
                             (_x_4 : uniform_space.{?l_1} _x_1) (_x_5 : uniform_space.{?l_1} _x_2)
                             (g :
                               @subtype.{?l_1+1} (_x_1 → _x_2) (@uniform_continuous.{?l_1 ?l_1} _x_1 _x_2 _x_4 _x_5))
                             (f : @subtype.{?l_1+1} (_x → _x_1) (@uniform_continuous.{?l_1 ?l_1} _x _x_1 _x_3 _x_4)),
                               @subtype.mk.{?l_1+1} (_x → _x_2) (@uniform_continuous.{?l_1 ?l_1} _x _x_2 _x_3 _x_5)
                                 (@function.comp.{?l_1+1 ?l_1+1 ?l_1+1} _x _x_1 _x_2
                                    (@subtype.val.{?l_1+1} (_x_1 → _x_2)
                                       (@uniform_continuous.{?l_1 ?l_1} _x_1 _x_2 _x_4 _x_5)
                                       g)
                                    (@subtype.val.{?l_1+1} (_x → _x_1)
                                       (@uniform_continuous.{?l_1 ?l_1} _x _x_1 _x_3 _x_4)
                                       f))
                                 (@category_theory.unbundled_hom.bundled_hom._proof_2.{?l_1} uniform_space.{?l_1}
                                    uniform_continuous.{?l_1 ?l_1}
                                    UniformSpace.concrete_category_uniform_continuous.{?l_1}
                                    _x
                                    _x_1
                                    _x_2
                                    _x_3
                                    _x_4
                                    _x_5
                                    g
                                    f))
                              (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                 (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                 X)
                              (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                 (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                 (CpltSepUniformSpace.to_UniformSpace.{?l_1}
                                    (@CpltSepUniformSpace.of.{?l_1}
                                       (@uniform_space.completion.{?l_1}
                                          (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                                             (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                             X)
                                          (UniformSpace.uniform_space.{?l_1} X))
                                       (@uniform_space.completion.uniform_space.{?l_1}
                                          (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                                             (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                             X)
                                          (UniformSpace.uniform_space.{?l_1} X))
                                       (UniformSpace.completion_functor._proof_1.{?l_1} X)
                                       (UniformSpace.completion_functor._proof_2.{?l_1} X))))
                              (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                 (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                 (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
                              (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                              ((@CpltSepUniformSpace.of.{?l_1}
                                  (@uniform_space.completion.{?l_1}
                                     (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                                        (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                        X)
                                     (UniformSpace.uniform_space.{?l_1} X))
                                  (@uniform_space.completion.uniform_space.{?l_1}
                                     (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                                        (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                        X)
                                     (UniformSpace.uniform_space.{?l_1} X))
                                  (UniformSpace.completion_functor._proof_1.{?l_1} X)
                                  (UniformSpace.completion_functor._proof_2.{?l_1} X)).is_uniform_space)
                              (Y.is_uniform_space)
                              f
                              (UniformSpace.completion_hom.{?l_1} X)))
                        f)
                     (@eq.{?l_1+1}
                        (@subtype.{?l_1+1}
                           (@coe_sort.{?l_1+2 ?l_1+2} CpltSepUniformSpace.{?l_1}
                              CpltSepUniformSpace.has_coe_to_sort.{?l_1}
                              (@CpltSepUniformSpace.of.{?l_1}
                                 (@uniform_space.completion.{?l_1}
                                    (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                                       (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                       X)
                                    (UniformSpace.uniform_space.{?l_1} X))
                                 (@uniform_space.completion.uniform_space.{?l_1}
                                    (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                                       (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                       X)
                                    (UniformSpace.uniform_space.{?l_1} X))
                                 (UniformSpace.completion_functor._proof_1.{?l_1} X)
                                 (UniformSpace.completion_functor._proof_2.{?l_1} X)) →
                            @coe_sort.{?l_1+2 ?l_1+2} CpltSepUniformSpace.{?l_1}
                              CpltSepUniformSpace.has_coe_to_sort.{?l_1}
                              Y)
                           (… … …))
                        f
                        f)
                     …
                     …))
             …))
       …)
    …'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='X X&#x27; : UniformSpace.{?l_1},
Y : CpltSepUniformSpace.{?l_1},
f :
  (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
     (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
        @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
       (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
       (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
       (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
       (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y))
    X
    X&#x27;,
g :
  (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
     (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
        @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
       (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
       (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
       (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
       (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y))
    X&#x27;
    (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y)
⊢ @eq.{?l_1+1}
    (@has_coe_to_fun.F.{?l_1+1 ?l_1+1}
       (@category_theory.has_hom.hom.{?l_1 ?l_1+1} UniformSpace.{?l_1}
          (@category_theory.category_struct.to_has_hom.{?l_1 ?l_1+1} UniformSpace.{?l_1}
             (@category_theory.category.to_category_struct.{?l_1 ?l_1+1} UniformSpace.{?l_1}
                (@category_theory.bundled_hom.category.{?l_1} uniform_space.{?l_1}
                   (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                      @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                   (@category_theory.unbundled_hom.bundled_hom.{?l_1} (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                      uniform_continuous.{?l_1 ?l_1}
                      UniformSpace.concrete_category_uniform_continuous.{?l_1}))))
          (CpltSepUniformSpace.to_UniformSpace.{?l_1}
             ((λ (X : UniformSpace.{?l_1}),
                 @CpltSepUniformSpace.of.{?l_1}
                   (@uniform_space.completion.{?l_1}
                      (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                         (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                         X)
                      (UniformSpace.uniform_space.{?l_1} X))
                   (@uniform_space.completion.uniform_space.{?l_1}
                      (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                         (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                         X)
                      (UniformSpace.uniform_space.{?l_1} X))
                   (UniformSpace.completion_functor._proof_1.{?l_1} X)
                   (UniformSpace.completion_functor._proof_2.{?l_1} X))
                X))
          (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
       (UniformSpace.has_coe_to_fun.{?l_1}
          (CpltSepUniformSpace.to_UniformSpace.{?l_1}
             ((λ (X : UniformSpace.{?l_1}),
                 @CpltSepUniformSpace.of.{?l_1}
                   (@uniform_space.completion.{?l_1}
                      (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                         (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                         X)
                      (UniformSpace.uniform_space.{?l_1} X))
                   (@uniform_space.completion.uniform_space.{?l_1}
                      (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                         (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                         X)
                      (UniformSpace.uniform_space.{?l_1} X))
                   (UniformSpace.completion_functor._proof_1.{?l_1} X)
                   (UniformSpace.completion_functor._proof_2.{?l_1} X))
                X))
          (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
       (@coe_fn.{(max 1 (?l_1+1)) ?l_1+1}
          (equiv.{?l_1+1 ?l_1+1}
             ((λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                 (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                    @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                   (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                   (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                   (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                   (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y))
                X
                (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
             ((λ
               (X Y :
                 @category_theory.induced_category.{?l_1 ?l_1+1 ?l_1+1} CpltSepUniformSpace.{?l_1} UniformSpace.{?l_1}
                   (@category_theory.concrete_category.to_category.{?l_1} UniformSpace.{?l_1}
                      (@category_theory.bundled_hom.category_theory.concrete_category.{?l_1} uniform_space.{?l_1}
                         (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                            @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                         (@category_theory.unbundled_hom.bundled_hom.{?l_1}
                            (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                            uniform_continuous.{?l_1 ?l_1}
                            UniformSpace.concrete_category_uniform_continuous.{?l_1})))
                   CpltSepUniformSpace.to_UniformSpace.{?l_1}),
                 @category_theory.has_hom.hom.{?l_1 ?l_1+1} UniformSpace.{?l_1}
                   (@category_theory.category_struct.to_has_hom.{?l_1 ?l_1+1} UniformSpace.{?l_1}
                      (@category_theory.category.to_category_struct.{?l_1 ?l_1+1} UniformSpace.{?l_1}
                         (@category_theory.concrete_category.to_category.{?l_1} UniformSpace.{?l_1}
                            (@category_theory.bundled_hom.category_theory.concrete_category.{?l_1} uniform_space.{?l_1}
                               (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                                  @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                               (@category_theory.unbundled_hom.bundled_hom.{?l_1}
                                  (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                                  uniform_continuous.{?l_1 ?l_1}
                                  UniformSpace.concrete_category_uniform_continuous.{?l_1})))))
                   (CpltSepUniformSpace.to_UniformSpace.{?l_1} X)
                   (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
                ((λ (X : UniformSpace.{?l_1}),
                    @CpltSepUniformSpace.of.{?l_1}
                      (@uniform_space.completion.{?l_1}
                         (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                            (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                            X)
                         (UniformSpace.uniform_space.{?l_1} X))
                      (@uniform_space.completion.uniform_space.{?l_1}
                         (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                            (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                            X)
                         (UniformSpace.uniform_space.{?l_1} X))
                      (UniformSpace.completion_functor._proof_1.{?l_1} X)
                      (UniformSpace.completion_functor._proof_2.{?l_1} X))
                   X)
                Y))
          (@equiv.has_coe_to_fun.{?l_1+1 ?l_1+1}
             ((λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                 (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                    @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                   (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                   (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                   (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                   (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y))
                X
                (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
             ((λ
               (X Y :
                 @category_theory.induced_category.{?l_1 ?l_1+1 ?l_1+1} CpltSepUniformSpace.{?l_1} UniformSpace.{?l_1}
                   (@category_theory.concrete_category.to_category.{?l_1} UniformSpace.{?l_1}
                      (@category_theory.bundled_hom.category_theory.concrete_category.{?l_1} uniform_space.{?l_1}
                         (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                            @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                         (@category_theory.unbundled_hom.bundled_hom.{?l_1}
                            (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                            uniform_continuous.{?l_1 ?l_1}
                            UniformSpace.concrete_category_uniform_continuous.{?l_1})))
                   CpltSepUniformSpace.to_UniformSpace.{?l_1}),
                 @category_theory.has_hom.hom.{?l_1 ?l_1+1} UniformSpace.{?l_1}
                   (@category_theory.category_struct.to_has_hom.{?l_1 ?l_1+1} UniformSpace.{?l_1}
                      (@category_theory.category.to_category_struct.{?l_1 ?l_1+1} UniformSpace.{?l_1}
                         (@category_theory.concrete_category.to_category.{?l_1} UniformSpace.{?l_1}
                            (@category_theory.bundled_hom.category_theory.concrete_category.{?l_1} uniform_space.{?l_1}
                               (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                                  @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                               (@category_theory.unbundled_hom.bundled_hom.{?l_1}
                                  (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                                  uniform_continuous.{?l_1 ?l_1}
                                  UniformSpace.concrete_category_uniform_continuous.{?l_1})))))
                   (CpltSepUniformSpace.to_UniformSpace.{?l_1} X)
                   (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
                ((λ (X : UniformSpace.{?l_1}),
                    @CpltSepUniformSpace.of.{?l_1}
                      (@uniform_space.completion.{?l_1}
                         (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                            (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                            X)
                         (UniformSpace.uniform_space.{?l_1} X))
                      (@uniform_space.completion.uniform_space.{?l_1}
                         (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                            (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                            X)
                         (UniformSpace.uniform_space.{?l_1} X))
                      (UniformSpace.completion_functor._proof_1.{?l_1} X)
                      (UniformSpace.completion_functor._proof_2.{?l_1} X))
                   X)
                Y))
          (@equiv.symm.{?l_1+1 ?l_1+1}
             ((λ
               (X Y :
                 @category_theory.induced_category.{?l_1 ?l_1+1 ?l_1+1} CpltSepUniformSpace.{?l_1} UniformSpace.{?l_1}
                   (@category_theory.concrete_category.to_category.{?l_1} UniformSpace.{?l_1}
                      (@category_theory.bundled_hom.category_theory.concrete_category.{?l_1} uniform_space.{?l_1}
                         (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                            @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                         (@category_theory.unbundled_hom.bundled_hom.{?l_1}
                            (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                            uniform_continuous.{?l_1 ?l_1}
                            UniformSpace.concrete_category_uniform_continuous.{?l_1})))
                   CpltSepUniformSpace.to_UniformSpace.{?l_1}),
                 @category_theory.has_hom.hom.{?l_1 ?l_1+1} UniformSpace.{?l_1}
                   (@category_theory.category_struct.to_has_hom.{?l_1 ?l_1+1} UniformSpace.{?l_1}
                      (@category_theory.category.to_category_struct.{?l_1 ?l_1+1} UniformSpace.{?l_1}
                         (@category_theory.concrete_category.to_category.{?l_1} UniformSpace.{?l_1}
                            (@category_theory.bundled_hom.category_theory.concrete_category.{?l_1} uniform_space.{?l_1}
                               (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                                  @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                               (@category_theory.unbundled_hom.bundled_hom.{?l_1}
                                  (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                                  uniform_continuous.{?l_1 ?l_1}
                                  UniformSpace.concrete_category_uniform_continuous.{?l_1})))))
                   (CpltSepUniformSpace.to_UniformSpace.{?l_1} X)
                   (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
                ((λ (X : UniformSpace.{?l_1}),
                    @CpltSepUniformSpace.of.{?l_1}
                      (@uniform_space.completion.{?l_1}
                         (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                            (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                            X)
                         (UniformSpace.uniform_space.{?l_1} X))
                      (@uniform_space.completion.uniform_space.{?l_1}
                         (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                            (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                            X)
                         (UniformSpace.uniform_space.{?l_1} X))
                      (UniformSpace.completion_functor._proof_1.{?l_1} X)
                      (UniformSpace.completion_functor._proof_2.{?l_1} X))
                   X)
                Y)
             ((λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                 (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                    @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                   (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                   (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                   (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                   (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y))
                X
                (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
             (@equiv.mk.{?l_1+1 ?l_1+1}
                ((λ
                  (X Y :
                    @category_theory.induced_category.{?l_1 ?l_1+1 ?l_1+1} CpltSepUniformSpace.{?l_1}
                      UniformSpace.{?l_1}
                      (@category_theory.category.mk.{?l_1 ?l_1+1}
                         (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                         (@category_theory.category.to_category_struct.{?l_1 ?l_1+1}
                            (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                            (@category_theory.bundled_hom.category.{?l_1} uniform_space.{?l_1}
                               (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                                  @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                               (@category_theory.unbundled_hom.bundled_hom.{?l_1}
                                  (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                                  uniform_continuous.{?l_1 ?l_1}
                                  UniformSpace.concrete_category_uniform_continuous.{?l_1})))
                         (@category_theory.bundled_hom.category_theory.concrete_category._proof_1.{?l_1}
                            uniform_space.{?l_1}
                            (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                               @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                            (@category_theory.unbundled_hom.bundled_hom.{?l_1}
                               (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                               uniform_continuous.{?l_1 ?l_1}
                               UniformSpace.concrete_category_uniform_continuous.{?l_1}))
                         (@category_theory.bundled_hom.category_theory.concrete_category._proof_2.{?l_1}
                            uniform_space.{?l_1}
                            (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                               @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                            (@category_theory.unbundled_hom.bundled_hom.{?l_1}
                               (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                               uniform_continuous.{?l_1 ?l_1}
                               UniformSpace.concrete_category_uniform_continuous.{?l_1}))
                         (@category_theory.bundled_hom.category_theory.concrete_category._proof_3.{?l_1}
                            uniform_space.{?l_1}
                            (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                               @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                            (@category_theory.unbundled_hom.bundled_hom.{?l_1}
                               (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                               uniform_continuous.{?l_1 ?l_1}
                               UniformSpace.concrete_category_uniform_continuous.{?l_1})))
                      CpltSepUniformSpace.to_UniformSpace.{?l_1}),
                    (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                       (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                          @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                         (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                         (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                         (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                         (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y))
                      (CpltSepUniformSpace.to_UniformSpace.{?l_1} X)
                      (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
                   ((λ (X : UniformSpace.{?l_1}),
                       @CpltSepUniformSpace.of.{?l_1}
                         (@uniform_space.completion.{?l_1}
                            (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                               (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                               X)
                            (UniformSpace.uniform_space.{?l_1} X))
                         (@uniform_space.completion.uniform_space.{?l_1}
                            (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                               (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                               X)
                            (UniformSpace.uniform_space.{?l_1} X))
                         (UniformSpace.completion_functor._proof_1.{?l_1} X)
                         (UniformSpace.completion_functor._proof_2.{?l_1} X))
                      X)
                   Y)
                ((λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                    (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                       @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                      (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                      (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                      (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                      (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y))
                   X
                   (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
                (λ
                 (f :
                   (λ
                    (X Y :
                      @category_theory.induced_category.{?l_1 ?l_1+1 ?l_1+1} CpltSepUniformSpace.{?l_1}
                        UniformSpace.{?l_1}
                        (@category_theory.category.mk.{?l_1 ?l_1+1}
                           (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                           (@category_theory.category_struct.mk.{?l_1 ?l_1+1}
                              (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                              (@category_theory.has_hom.mk.{?l_1 ?l_1+1}
                                 (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                 (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                                    (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α)
                                     (Iβ : uniform_space.{?l_1} β),
                                       @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                                      (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                      (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                                      (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                      (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y)))
                              (λ (X : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                                 @category_theory.bundled_hom.id.{?l_1} uniform_space.{?l_1}
                                   (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α)
                                    (Iβ : uniform_space.{?l_1} β),
                                      @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                                   (@category_theory.unbundled_hom.bundled_hom.{?l_1}
                                      (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                                      uniform_continuous.{?l_1 ?l_1}
                                      UniformSpace.concrete_category_uniform_continuous.{?l_1})
                                   (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                      (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                      X)
                                   (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X))
                              (λ (X Y Z : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                               (f :
                                 @category_theory.has_hom.hom.{?l_1 ?l_1+1}
                                   (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                   (@category_theory.has_hom.mk.{?l_1 ?l_1+1}
                                      (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                      (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                                         (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α)
                                          (Iβ : uniform_space.{?l_1} β),
                                            @subtype.{?l_1+1} (α → β)
                                              (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                                           (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                           (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                                           (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                           (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y)))
                                   X
                                   Y)
                               (g :
                                 @category_theory.has_hom.hom.{?l_1 ?l_1+1}
                                   (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                   (@category_theory.has_hom.mk.{?l_1 ?l_1+1}
                                      (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                      (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                                         (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α)
                                          (Iβ : uniform_space.{?l_1} β),
                                            @subtype.{?l_1+1} (α → β)
                                              (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                                           (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                           (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                                           (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                           (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y)))
                                   Y
                                   Z),
                                 @category_theory.bundled_hom.comp.{?l_1} uniform_space.{?l_1}
                                   (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α)
                                    (Iβ : uniform_space.{?l_1} β),
                                      @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                                   (@category_theory.unbundled_hom.bundled_hom.{?l_1}
                                      (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                                      uniform_continuous.{?l_1 ?l_1}
                                      UniformSpace.concrete_category_uniform_continuous.{?l_1})
                                   (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                      (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                      X)
                                   (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                      (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                      Y)
                                   (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                      (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                      Z)
                                   (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                   (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                                   (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Z)
                                   g
                                   f))
                           (@category_theory.bundled_hom.category_theory.concrete_category._proof_1.{?l_1}
                              uniform_space.{?l_1}
                              (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                                 @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                              (@category_theory.unbundled_hom.bundled_hom.{?l_1}
                                 (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                                 uniform_continuous.{?l_1 ?l_1}
                                 UniformSpace.concrete_category_uniform_continuous.{?l_1}))
                           (@category_theory.bundled_hom.category_theory.concrete_category._proof_2.{?l_1}
                              uniform_space.{?l_1}
                              (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                                 @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                              (@category_theory.unbundled_hom.bundled_hom.{?l_1}
                                 (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                                 uniform_continuous.{?l_1 ?l_1}
                                 UniformSpace.concrete_category_uniform_continuous.{?l_1}))
                           (@category_theory.bundled_hom.category_theory.concrete_category._proof_3.{?l_1}
                              uniform_space.{?l_1}
                              (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                                 @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                              (@category_theory.unbundled_hom.bundled_hom.{?l_1}
                                 (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                                 uniform_continuous.{?l_1 ?l_1}
                                 UniformSpace.concrete_category_uniform_continuous.{?l_1})))
                        CpltSepUniformSpace.to_UniformSpace.{?l_1}),
                      (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                         (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                            @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                           (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                           (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                           (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                           (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y))
                        (CpltSepUniformSpace.to_UniformSpace.{?l_1} X)
                        (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
                     ((λ (X : UniformSpace.{?l_1}),
                         @CpltSepUniformSpace.of.{?l_1}
                           (@uniform_space.completion.{?l_1}
                              (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                                 (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                 X)
                              (UniformSpace.uniform_space.{?l_1} X))
                           (@uniform_space.completion.uniform_space.{?l_1}
                              (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                                 (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                 X)
                              (UniformSpace.uniform_space.{?l_1} X))
                           (UniformSpace.completion_functor._proof_1.{?l_1} X)
                           (UniformSpace.completion_functor._proof_2.{?l_1} X))
                        X)
                     Y),
                   (λ (X Y Z : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                    (f :
                      @category_theory.has_hom.hom.{?l_1 ?l_1+1}
                        (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                        (@category_theory.has_hom.mk.{?l_1 ?l_1+1}
                           (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                           (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                              (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                                 @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                                (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                                (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y)))
                        X
                        Y)
                    (g :
                      @category_theory.has_hom.hom.{?l_1 ?l_1+1}
                        (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                        (@category_theory.has_hom.mk.{?l_1 ?l_1+1}
                           (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                           (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                              (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                                 @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                                (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                                (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y)))
                        Y
                        Z),
                      @category_theory.bundled_hom.comp.{?l_1} uniform_space.{?l_1}
                        (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                           @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                        (@category_theory.unbundled_hom.bundled_hom.{?l_1}
                           (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                           uniform_continuous.{?l_1 ?l_1}
                           UniformSpace.concrete_category_uniform_continuous.{?l_1})
                        (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                           (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                           X)
                        (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                           (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                           Y)
                        (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                           (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                           Z)
                        (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                        (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                        (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Z)
                        g
                        f)
                     X
                     (CpltSepUniformSpace.to_UniformSpace.{?l_1}
                        ((λ (X : UniformSpace.{?l_1}),
                            @CpltSepUniformSpace.of.{?l_1}
                              (@uniform_space.completion.{?l_1}
                                 (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                                    (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                    X)
                                 (UniformSpace.uniform_space.{?l_1} X))
                              (@uniform_space.completion.uniform_space.{?l_1}
                                 (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                                    (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                    X)
                                 (UniformSpace.uniform_space.{?l_1} X))
                              (UniformSpace.completion_functor._proof_1.{?l_1} X)
                              (UniformSpace.completion_functor._proof_2.{?l_1} X))
                           X))
                     (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y)
                     (UniformSpace.completion_hom.{?l_1} X)
                     f)
                (λ
                 (f :
                   (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                      (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                         @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                        (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                        (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                        (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                        (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y))
                     X
                     (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y)), @UniformSpace.extension_hom.{?l_1} X Y f)
                (λ
                 (f :
                   (λ
                    (X Y :
                      @category_theory.induced_category.{?l_1 ?l_1+1 ?l_1+1} CpltSepUniformSpace.{?l_1}
                        UniformSpace.{?l_1}
                        (@category_theory.category.mk.{?l_1 ?l_1+1}
                           (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                           (@category_theory.category_struct.mk.{?l_1 ?l_1+1}
                              (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                              (@category_theory.has_hom.mk.{?l_1 ?l_1+1}
                                 (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                 (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                                    (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α)
                                     (Iβ : uniform_space.{?l_1} β),
                                       @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                                      (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                      (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                                      (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                      (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y)))
                              (λ (X : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                                 @category_theory.bundled_hom.id.{?l_1} uniform_space.{?l_1}
                                   (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α)
                                    (Iβ : uniform_space.{?l_1} β),
                                      @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                                   (@category_theory.unbundled_hom.bundled_hom.{?l_1}
                                      (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                                      uniform_continuous.{?l_1 ?l_1}
                                      UniformSpace.concrete_category_uniform_continuous.{?l_1})
                                   (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                      (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                      X)
                                   (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X))
                              (λ (X Y Z : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                               (f :
                                 @category_theory.has_hom.hom.{?l_1 ?l_1+1}
                                   (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                   (@category_theory.has_hom.mk.{?l_1 ?l_1+1}
                                      (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                      (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                                         (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α)
                                          (Iβ : uniform_space.{?l_1} β),
                                            @subtype.{?l_1+1} (α → β)
                                              (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                                           (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                           (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                                           (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                           (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y)))
                                   X
                                   Y)
                               (g :
                                 @category_theory.has_hom.hom.{?l_1 ?l_1+1}
                                   (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                   (@category_theory.has_hom.mk.{?l_1 ?l_1+1}
                                      (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                      (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                                         (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α)
                                          (Iβ : uniform_space.{?l_1} β),
                                            @subtype.{?l_1+1} (α → β)
                                              (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                                           (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                           (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                                           (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                           (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y)))
                                   Y
                                   Z),
                                 @category_theory.bundled_hom.comp.{?l_1} uniform_space.{?l_1}
                                   (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α)
                                    (Iβ : uniform_space.{?l_1} β),
                                      @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                                   (@category_theory.unbundled_hom.bundled_hom.{?l_1}
                                      (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                                      uniform_continuous.{?l_1 ?l_1}
                                      UniformSpace.concrete_category_uniform_continuous.{?l_1})
                                   (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                      (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                      X)
                                   (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                      (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                      Y)
                                   (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                      (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                      Z)
                                   (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                   (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                                   (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Z)
                                   g
                                   f))
                           (@category_theory.bundled_hom.category_theory.concrete_category._proof_1.{?l_1}
                              uniform_space.{?l_1}
                              (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                                 @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                              (@category_theory.unbundled_hom.bundled_hom.{?l_1}
                                 (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                                 uniform_continuous.{?l_1 ?l_1}
                                 UniformSpace.concrete_category_uniform_continuous.{?l_1}))
                           (@category_theory.bundled_hom.category_theory.concrete_category._proof_2.{?l_1}
                              uniform_space.{?l_1}
                              (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                                 @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                              (@category_theory.unbundled_hom.bundled_hom.{?l_1}
                                 (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                                 uniform_continuous.{?l_1 ?l_1}
                                 UniformSpace.concrete_category_uniform_continuous.{?l_1}))
                           (@category_theory.bundled_hom.category_theory.concrete_category._proof_3.{?l_1}
                              uniform_space.{?l_1}
                              (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                                 @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                              (@category_theory.unbundled_hom.bundled_hom.{?l_1}
                                 (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                                 uniform_continuous.{?l_1 ?l_1}
                                 UniformSpace.concrete_category_uniform_continuous.{?l_1})))
                        CpltSepUniformSpace.to_UniformSpace.{?l_1}),
                      (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                         (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                            @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                           (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                           (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                           (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                           (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y))
                        (CpltSepUniformSpace.to_UniformSpace.{?l_1} X)
                        (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
                     ((λ (X : UniformSpace.{?l_1}),
                         @CpltSepUniformSpace.of.{?l_1}
                           (@uniform_space.completion.{?l_1}
                              (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                                 (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                 X)
                              (UniformSpace.uniform_space.{?l_1} X))
                           (@uniform_space.completion.uniform_space.{?l_1}
                              (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                                 (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                 X)
                              (UniformSpace.uniform_space.{?l_1} X))
                           (UniformSpace.completion_functor._proof_1.{?l_1} X)
                           (UniformSpace.completion_functor._proof_2.{?l_1} X))
                        X)
                     Y),
                   @id.{0}
                     (@eq.{?l_1+1}
                        ((λ
                          (X Y :
                            @category_theory.induced_category.{?l_1 ?l_1+1 ?l_1+1} CpltSepUniformSpace.{?l_1}
                              UniformSpace.{?l_1}
                              (@category_theory.category.mk.{?l_1 ?l_1+1}
                                 (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                 (@category_theory.category_struct.mk.{?l_1 ?l_1+1}
                                    (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                    (@category_theory.has_hom.mk.{?l_1 ?l_1+1}
                                       (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                       (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                                          (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α)
                                           (Iβ : uniform_space.{?l_1} β),
                                             @subtype.{?l_1+1} (α → β)
                                               (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                                            (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                            (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                                            (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                            (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y)))
                                    (λ (X : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                                       @category_theory.bundled_hom.id.{?l_1} uniform_space.{?l_1}
                                         (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α)
                                          (Iβ : uniform_space.{?l_1} β),
                                            @subtype.{?l_1+1} (α → β)
                                              (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                                         (@category_theory.unbundled_hom.bundled_hom.{?l_1}
                                            (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                                            uniform_continuous.{?l_1 ?l_1}
                                            UniformSpace.concrete_category_uniform_continuous.{?l_1})
                                         (@coe_sort.{?l_1+2 ?l_1+2}
                                            (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                            (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                            X)
                                         (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X))
                                    (λ (X Y Z : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                     (f :
                                       @category_theory.has_hom.hom.{?l_1 ?l_1+1}
                                         (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                         (@category_theory.has_hom.mk.{?l_1 ?l_1+1}
                                            (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                            (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                                               (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α)
                                                (Iβ : uniform_space.{?l_1} β),
                                                  @subtype.{?l_1+1} (α → β)
                                                    (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                                                 (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                                 (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                                                 (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                                 (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y)))
                                         X
                                         Y)
                                     (g :
                                       @category_theory.has_hom.hom.{?l_1 ?l_1+1}
                                         (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                         (@category_theory.has_hom.mk.{?l_1 ?l_1+1}
                                            (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                            (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                                               (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α)
                                                (Iβ : uniform_space.{?l_1} β),
                                                  @subtype.{?l_1+1} (α → β)
                                                    (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                                                 (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                                 (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                                                 (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                                 (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y)))
                                         Y
                                         Z),
                                       @category_theory.bundled_hom.comp.{?l_1} uniform_space.{?l_1}
                                         (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α)
                                          (Iβ : uniform_space.{?l_1} β),
                                            @subtype.{?l_1+1} (α → β)
                                              (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                                         (@category_theory.unbundled_hom.bundled_hom.{?l_1}
                                            (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                                            uniform_continuous.{?l_1 ?l_1}
                                            UniformSpace.concrete_category_uniform_continuous.{?l_1})
                                         (@coe_sort.{?l_1+2 ?l_1+2}
                                            (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                            (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                            X)
                                         (@coe_sort.{?l_1+2 ?l_1+2}
                                            (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                            (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                            Y)
                                         (@coe_sort.{?l_1+2 ?l_1+2}
                                            (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                            (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                            Z)
                                         (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                         (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                                         (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Z)
                                         g
                                         f))
                                 (@category_theory.bundled_hom.category_theory.concrete_category._proof_1.{?l_1}
                                    uniform_space.{?l_1}
                                    (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α)
                                     (Iβ : uniform_space.{?l_1} β),
                                       @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                                    (@category_theory.unbundled_hom.bundled_hom.{?l_1}
                                       (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                                       uniform_continuous.{?l_1 ?l_1}
                                       UniformSpace.concrete_category_uniform_continuous.{?l_1}))
                                 (@category_theory.bundled_hom.category_theory.concrete_category._proof_2.{?l_1}
                                    uniform_space.{?l_1}
                                    (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α)
                                     (Iβ : uniform_space.{?l_1} β),
                                       @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                                    (@category_theory.unbundled_hom.bundled_hom.{?l_1}
                                       (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                                       uniform_continuous.{?l_1 ?l_1}
                                       UniformSpace.concrete_category_uniform_continuous.{?l_1}))
                                 (@category_theory.bundled_hom.category_theory.concrete_category._proof_3.{?l_1}
                                    uniform_space.{?l_1}
                                    (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α)
                                     (Iβ : uniform_space.{?l_1} β),
                                       @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                                    (@category_theory.unbundled_hom.bundled_hom.{?l_1}
                                       (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                                       uniform_continuous.{?l_1 ?l_1}
                                       UniformSpace.concrete_category_uniform_continuous.{?l_1})))
                              CpltSepUniformSpace.to_UniformSpace.{?l_1}),
                            (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                               (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                                  @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                                 (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                 (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                                 (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                 (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y))
                              (CpltSepUniformSpace.to_UniformSpace.{?l_1} X)
                              (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
                           ((λ (X : UniformSpace.{?l_1}),
                               @CpltSepUniformSpace.of.{?l_1}
                                 (@uniform_space.completion.{?l_1}
                                    (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                                       (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                       X)
                                    (UniformSpace.uniform_space.{?l_1} X))
                                 (@uniform_space.completion.uniform_space.{?l_1}
                                    (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                                       (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                       X)
                                    (UniformSpace.uniform_space.{?l_1} X))
                                 (UniformSpace.completion_functor._proof_1.{?l_1} X)
                                 (UniformSpace.completion_functor._proof_2.{?l_1} X))
                              X)
                           Y)
                        ((λ
                          (f :
                            (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                               (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                                  @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                                 (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                 (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                                 (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                 (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y))
                              X
                              (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y)), @UniformSpace.extension_hom.{?l_1} X Y f)
                           ((λ
                             (f :
                               (λ
                                (X Y :
                                  @category_theory.induced_category.{?l_1 ?l_1+1 ?l_1+1} CpltSepUniformSpace.{?l_1}
                                    UniformSpace.{?l_1}
                                    (@category_theory.category.mk.{?l_1 ?l_1+1}
                                       (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                       (@category_theory.category_struct.mk.{?l_1 ?l_1+1}
                                          (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                          (@category_theory.has_hom.mk.{?l_1 ?l_1+1}
                                             (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                             (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                                                (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α)
                                                 (Iβ : uniform_space.{?l_1} β),
                                                   @subtype.{?l_1+1} (α → β)
                                                     (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                                                  (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                                  (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                                                  (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                                  (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y)))
                                          (λ (X : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                                             (λ (α : Type ?l_1)
                                              (Iα : (λ (α : Type ?l_1), uniform_space.{?l_1} α) α),
                                                @subtype.mk.{?l_1+1} (α → α)
                                                  (@uniform_continuous.{?l_1 ?l_1} α α Iα Iα)
                                                  (@id.{?l_1+1} α)
                                                  (@category_theory.unbundled_hom.bundled_hom._proof_1.{?l_1}
                                                     (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                                                     uniform_continuous.{?l_1 ?l_1}
                                                     UniformSpace.concrete_category_uniform_continuous.{?l_1}
                                                     α
                                                     Iα))
                                               (@coe_sort.{?l_1+2 ?l_1+2}
                                                  (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                                  (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1}
                                                     uniform_space.{?l_1})
                                                  X)
                                               (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X))
                                          (λ (X Y Z : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                           (f :
                                             (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                                                (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α)
                                                 (Iβ : uniform_space.{?l_1} β),
                                                   @subtype.{?l_1+1} (α → β)
                                                     (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                                                  (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                                  (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                                                  (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                                  (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y))
                                               X
                                               Y)
                                           (g :
                                             (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                                                (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α)
                                                 (Iβ : uniform_space.{?l_1} β),
                                                   @subtype.{?l_1+1} (α → β)
                                                     (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                                                  (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                                  (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                                                  (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                                  (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y))
                                               Y
                                               Z),
                                             (λ (_x _x_1 _x_2 : Type ?l_1)
                                              (_x_3 : (λ (α : Type ?l_1), uniform_space.{?l_1} α) _x)
                                              (_x_4 : (λ (α : Type ?l_1), uniform_space.{?l_1} α) _x_1)
                                              (_x_5 : (λ (α : Type ?l_1), uniform_space.{?l_1} α) _x_2)
                                              (g :
                                                @subtype.{?l_1+1} (_x_1 → _x_2)
                                                  (@uniform_continuous.{?l_1 ?l_1} _x_1 _x_2 _x_4 _x_5))
                                              (f :
                                                @subtype.{?l_1+1} (_x → _x_1)
                                                  (@uniform_continuous.{?l_1 ?l_1} _x _x_1 _x_3 _x_4)),
                                                @subtype.mk.{?l_1+1} (_x → _x_2)
                                                  (@uniform_continuous.{?l_1 ?l_1} _x _x_2 _x_3 _x_5)
                                                  (@function.comp.{?l_1+1 ?l_1+1 ?l_1+1} _x _x_1 _x_2
                                                     (@subtype.val.{?l_1+1} (_x_1 → _x_2)
                                                        (@uniform_continuous.{?l_1 ?l_1} _x_1 _x_2 _x_4 _x_5)
                                                        g)
                                                     (@subtype.val.{?l_1+1} (_x → _x_1)
                                                        (@uniform_continuous.{?l_1 ?l_1} _x _x_1 _x_3 _x_4)
                                                        f))
                                                  (@category_theory.unbundled_hom.bundled_hom._proof_2.{?l_1}
                                                     (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                                                     uniform_continuous.{?l_1 ?l_1}
                                                     UniformSpace.concrete_category_uniform_continuous.{?l_1}
                                                     _x
                                                     _x_1
                                                     _x_2
                                                     _x_3
                                                     _x_4
                                                     _x_5
                                                     g
                                                     f))
                                               (@coe_sort.{?l_1+2 ?l_1+2}
                                                  (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                                  (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1}
                                                     uniform_space.{?l_1})
                                                  X)
                                               (@coe_sort.{?l_1+2 ?l_1+2}
                                                  (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                                  (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1}
                                                     uniform_space.{?l_1})
                                                  Y)
                                               (@coe_sort.{?l_1+2 ?l_1+2}
                                                  (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                                  (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1}
                                                     uniform_space.{?l_1})
                                                  Z)
                                               (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                               (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                                               (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Z)
                                               g
                                               f))
                                       (@category_theory.bundled_hom.category_theory.concrete_category._proof_1.{?l_1}
                                          uniform_space.{?l_1}
                                          (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α)
                                           (Iβ : uniform_space.{?l_1} β),
                                             @subtype.{?l_1+1} (α → β)
                                               (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                                          (@category_theory.unbundled_hom.bundled_hom.{?l_1}
                                             (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                                             uniform_continuous.{?l_1 ?l_1}
                                             UniformSpace.concrete_category_uniform_continuous.{?l_1}))
                                       (@category_theory.bundled_hom.category_theory.concrete_category._proof_2.{?l_1}
                                          uniform_space.{?l_1}
                                          (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α)
                                           (Iβ : uniform_space.{?l_1} β),
                                             @subtype.{?l_1+1} (α → β)
                                               (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                                          (@category_theory.unbundled_hom.bundled_hom.{?l_1}
                                             (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                                             uniform_continuous.{?l_1 ?l_1}
                                             UniformSpace.concrete_category_uniform_continuous.{?l_1}))
                                       (@category_theory.bundled_hom.category_theory.concrete_category._proof_3.{?l_1}
                                          uniform_space.{?l_1}
                                          (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α)
                                           (Iβ : uniform_space.{?l_1} β),
                                             @subtype.{?l_1+1} (α → β)
                                               (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                                          (@category_theory.unbundled_hom.bundled_hom.{?l_1}
                                             (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                                             uniform_continuous.{?l_1 ?l_1}
                                             UniformSpace.concrete_category_uniform_continuous.{?l_1})))
                                    CpltSepUniformSpace.to_UniformSpace.{?l_1}),
                                  (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                                     (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α)
                                      (Iβ : uniform_space.{?l_1} β),
                                        @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                                       (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                       (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                                       (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                       (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y))
                                    (CpltSepUniformSpace.to_UniformSpace.{?l_1} X)
                                    (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
                                 ((λ (X : UniformSpace.{?l_1}),
                                     @CpltSepUniformSpace.of.{?l_1}
                                       (@uniform_space.completion.{?l_1}
                                          (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                                             (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                             X)
                                          (UniformSpace.uniform_space.{?l_1} X))
                                       (@uniform_space.completion.uniform_space.{?l_1}
                                          (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                                             (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                             X)
                                          (UniformSpace.uniform_space.{?l_1} X))
                                       (UniformSpace.completion_functor._proof_1.{?l_1} X)
                                       (UniformSpace.completion_functor._proof_2.{?l_1} X))
                                    X)
                                 Y),
                               (λ (X Y Z : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                (f :
                                  (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                                     (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α)
                                      (Iβ : uniform_space.{?l_1} β),
                                        @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                                       (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                       (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                                       (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                       (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y))
                                    X
                                    Y)
                                (g :
                                  (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                                     (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α)
                                      (Iβ : uniform_space.{?l_1} β),
                                        @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                                       (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                       (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                                       (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                       (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y))
                                    Y
                                    Z),
                                  (λ (_x _x_1 _x_2 : Type ?l_1)
                                   (_x_3 : (λ (α : Type ?l_1), uniform_space.{?l_1} α) _x)
                                   (_x_4 : (λ (α : Type ?l_1), uniform_space.{?l_1} α) _x_1)
                                   (_x_5 : (λ (α : Type ?l_1), uniform_space.{?l_1} α) _x_2)
                                   (g :
                                     @subtype.{?l_1+1} (_x_1 → _x_2)
                                       (@uniform_continuous.{?l_1 ?l_1} _x_1 _x_2 _x_4 _x_5))
                                   (f :
                                     @subtype.{?l_1+1} (_x → _x_1)
                                       (@uniform_continuous.{?l_1 ?l_1} _x _x_1 _x_3 _x_4)),
                                     @subtype.mk.{?l_1+1} (_x → _x_2)
                                       (@uniform_continuous.{?l_1 ?l_1} _x _x_2 _x_3 _x_5)
                                       (@function.comp.{?l_1+1 ?l_1+1 ?l_1+1} _x _x_1 _x_2
                                          (@subtype.val.{?l_1+1} (_x_1 → _x_2)
                                             (@uniform_continuous.{?l_1 ?l_1} _x_1 _x_2 _x_4 _x_5)
                                             g)
                                          (@subtype.val.{?l_1+1} (_x → _x_1)
                                             (@uniform_continuous.{?l_1 ?l_1} _x _x_1 _x_3 _x_4)
                                             f))
                                       (@category_theory.unbundled_hom.bundled_hom._proof_2.{?l_1}
                                          (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                                          uniform_continuous.{?l_1 ?l_1}
                                          UniformSpace.concrete_category_uniform_continuous.{?l_1}
                                          _x
                                          _x_1
                                          _x_2
                                          _x_3
                                          _x_4
                                          _x_5
                                          g
                                          f))
                                    (@coe_sort.{?l_1+2 ?l_1+2}
                                       (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                       (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                       X)
                                    (@coe_sort.{?l_1+2 ?l_1+2}
                                       (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                       (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                       Y)
                                    (@coe_sort.{?l_1+2 ?l_1+2}
                                       (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                       (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                       Z)
                                    (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                    (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                                    (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Z)
                                    g
                                    f)
                                 X
                                 (CpltSepUniformSpace.to_UniformSpace.{?l_1}
                                    ((λ (X : UniformSpace.{?l_1}),
                                        @CpltSepUniformSpace.of.{?l_1}
                                          (@uniform_space.completion.{?l_1}
                                             (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                                                (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1}
                                                   uniform_space.{?l_1})
                                                X)
                                             (UniformSpace.uniform_space.{?l_1} X))
                                          (@uniform_space.completion.uniform_space.{?l_1}
                                             (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                                                (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1}
                                                   uniform_space.{?l_1})
                                                X)
                                             (UniformSpace.uniform_space.{?l_1} X))
                                          (UniformSpace.completion_functor._proof_1.{?l_1} X)
                                          (UniformSpace.completion_functor._proof_2.{?l_1} X))
                                       X))
                                 (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y)
                                 (UniformSpace.completion_hom.{?l_1} X)
                                 f)
                              f))
                        f)
                     (@eq.mpr.{0}
                        (@eq.{?l_1+1}
                           (@subtype.{?l_1+1}
                              (@coe_sort.{?l_1+2 ?l_1+2} CpltSepUniformSpace.{?l_1}
                                 CpltSepUniformSpace.has_coe_to_sort.{?l_1}
                                 (@CpltSepUniformSpace.of.{?l_1}
                                    (@uniform_space.completion.{?l_1}
                                       (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                                          (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                          X)
                                       (UniformSpace.uniform_space.{?l_1} X))
                                    (@uniform_space.completion.uniform_space.{?l_1}
                                       (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                                          (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                          X)
                                       (UniformSpace.uniform_space.{?l_1} X))
                                    (UniformSpace.completion_functor._proof_1.{?l_1} X)
                                    (UniformSpace.completion_functor._proof_2.{?l_1} X)) →
                               @coe_sort.{?l_1+2 ?l_1+2} CpltSepUniformSpace.{?l_1}
                                 CpltSepUniformSpace.has_coe_to_sort.{?l_1}
                                 Y)
                              (@uniform_continuous.{?l_1 ?l_1}
                                 (@coe_sort.{?l_1+2 ?l_1+2} CpltSepUniformSpace.{?l_1}
                                    CpltSepUniformSpace.has_coe_to_sort.{?l_1}
                                    (@CpltSepUniformSpace.of.{?l_1}
                                       (@uniform_space.completion.{?l_1}
                                          (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                                             (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                             X)
                                          (UniformSpace.uniform_space.{?l_1} X))
                                       (@uniform_space.completion.uniform_space.{?l_1}
                                          (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                                             (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                             X)
                                          (UniformSpace.uniform_space.{?l_1} X))
                                       (UniformSpace.completion_functor._proof_1.{?l_1} X)
                                       (UniformSpace.completion_functor._proof_2.{?l_1} X)))
                                 (@coe_sort.{?l_1+2 ?l_1+2} CpltSepUniformSpace.{?l_1}
                                    CpltSepUniformSpace.has_coe_to_sort.{?l_1}
                                    Y)
                                 ((@CpltSepUniformSpace.of.{?l_1}
                                     (@uniform_space.completion.{?l_1}
                                        (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                                           (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                           X)
                                        (UniformSpace.uniform_space.{?l_1} X))
                                     (@uniform_space.completion.uniform_space.{?l_1}
                                        (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                                           (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                           X)
                                        (UniformSpace.uniform_space.{?l_1} X))
                                     (UniformSpace.completion_functor._proof_1.{?l_1} X)
                                     (UniformSpace.completion_functor._proof_2.{?l_1} X)).is_uniform_space)
                                 (Y.is_uniform_space)))
                           (@UniformSpace.extension_hom.{?l_1} X Y
                              ((λ (_x _x_1 _x_2 : Type ?l_1) (_x_3 : uniform_space.{?l_1} _x)
                                (_x_4 : uniform_space.{?l_1} _x_1) (_x_5 : uniform_space.{?l_1} _x_2)
                                (g :
                                  @subtype.{?l_1+1} (_x_1 → _x_2)
                                    (@uniform_continuous.{?l_1 ?l_1} _x_1 _x_2 _x_4 _x_5))
                                (f :
                                  @subtype.{?l_1+1} (_x → _x_1) (@uniform_continuous.{?l_1 ?l_1} _x _x_1 _x_3 _x_4)),
                                  @subtype.mk.{?l_1+1} (_x → _x_2) (@uniform_continuous.{?l_1 ?l_1} _x _x_2 _x_3 _x_5)
                                    (@function.comp.{?l_1+1 ?l_1+1 ?l_1+1} _x _x_1 _x_2
                                       (@subtype.val.{?l_1+1} (_x_1 → _x_2)
                                          (@uniform_continuous.{?l_1 ?l_1} _x_1 _x_2 _x_4 _x_5)
                                          g)
                                       (@subtype.val.{?l_1+1} (_x → _x_1)
                                          (@uniform_continuous.{?l_1 ?l_1} _x _x_1 _x_3 _x_4)
                                          f))
                                    (@category_theory.unbundled_hom.bundled_hom._proof_2.{?l_1} uniform_space.{?l_1}
                                       uniform_continuous.{?l_1 ?l_1}
                                       UniformSpace.concrete_category_uniform_continuous.{?l_1}
                                       _x
                                       _x_1
                                       _x_2
                                       _x_3
                                       _x_4
                                       _x_5
                                       g
                                       f))
                                 (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                    (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                    X)
                                 (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                    (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                    (CpltSepUniformSpace.to_UniformSpace.{?l_1}
                                       (@CpltSepUniformSpace.of.{?l_1}
                                          (@uniform_space.completion.{?l_1}
                                             (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                                                (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1}
                                                   uniform_space.{?l_1})
                                                X)
                                             (UniformSpace.uniform_space.{?l_1} X))
                                          (@uniform_space.completion.uniform_space.{?l_1}
                                             (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                                                (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1}
                                                   uniform_space.{?l_1})
                                                X)
                                             (UniformSpace.uniform_space.{?l_1} X))
                                          (UniformSpace.completion_functor._proof_1.{?l_1} X)
                                          (UniformSpace.completion_functor._proof_2.{?l_1} X))))
                                 (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                    (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                    (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
                                 (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                 ((@CpltSepUniformSpace.of.{?l_1}
                                     (@uniform_space.completion.{?l_1}
                                        (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                                           (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                           X)
                                        (UniformSpace.uniform_space.{?l_1} X))
                                     (@uniform_space.completion.uniform_space.{?l_1}
                                        (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                                           (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                           X)
                                        (UniformSpace.uniform_space.{?l_1} X))
                                     (UniformSpace.completion_functor._proof_1.{?l_1} X)
                                     (UniformSpace.completion_functor._proof_2.{?l_1} X)).is_uniform_space)
                                 (Y.is_uniform_space)
                                 f
                                 (UniformSpace.completion_hom.{?l_1} X)))
                           f)
                        (@eq.{?l_1+1}
                           (@subtype.{?l_1+1}
                              (@coe_sort.{?l_1+2 ?l_1+2} CpltSepUniformSpace.{?l_1}
                                 CpltSepUniformSpace.has_coe_to_sort.{?l_1}
                                 (@CpltSepUniformSpace.of.{?l_1}
                                    (@uniform_space.completion.{?l_1}
                                       (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                                          (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                          X)
                                       (UniformSpace.uniform_space.{?l_1} X))
                                    (@uniform_space.completion.uniform_space.{?l_1}
                                       (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                                          (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                          X)
                                       (UniformSpace.uniform_space.{?l_1} X))
                                    (UniformSpace.completion_functor._proof_1.{?l_1} X)
                                    (UniformSpace.completion_functor._proof_2.{?l_1} X)) →
                               @coe_sort.{?l_1+2 ?l_1+2} CpltSepUniformSpace.{?l_1}
                                 CpltSepUniformSpace.has_coe_to_sort.{?l_1}
                                 Y)
                              (@uniform_continuous.{?l_1 ?l_1} … … … …))
                           f
                           f)
                        …
                        …))
                …))
          …))
    …
    …'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='X X&#x27; : UniformSpace.{?l_1},
Y : CpltSepUniformSpace.{?l_1},
f :
  (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
     (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
        @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
       (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
       (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
       (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
       (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y))
    X
    X&#x27;,
g :
  (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
     (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
        @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
       (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
       (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
       (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
       (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y))
    X&#x27;
    (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y),
x :
  @coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
    (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
    (CpltSepUniformSpace.to_UniformSpace.{?l_1}
       ((λ (X : UniformSpace.{?l_1}),
           @CpltSepUniformSpace.of.{?l_1}
             (@uniform_space.completion.{?l_1}
                (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                   (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                   X)
                (UniformSpace.uniform_space.{?l_1} X))
             (@uniform_space.completion.uniform_space.{?l_1}
                (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                   (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                   X)
                (UniformSpace.uniform_space.{?l_1} X))
             (UniformSpace.completion_functor._proof_1.{?l_1} X)
             (UniformSpace.completion_functor._proof_2.{?l_1} X))
          X))
⊢ @eq.{?l_1+1}
    (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
       (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
       (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
    (@coe_fn.{?l_1+1 ?l_1+1}
       (@category_theory.has_hom.hom.{?l_1 ?l_1+1} UniformSpace.{?l_1}
          (@category_theory.category_struct.to_has_hom.{?l_1 ?l_1+1} UniformSpace.{?l_1}
             (@category_theory.category.to_category_struct.{?l_1 ?l_1+1} UniformSpace.{?l_1}
                (@category_theory.bundled_hom.category.{?l_1} uniform_space.{?l_1}
                   (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                      @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                   (@category_theory.unbundled_hom.bundled_hom.{?l_1} (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                      uniform_continuous.{?l_1 ?l_1}
                      UniformSpace.concrete_category_uniform_continuous.{?l_1}))))
          (CpltSepUniformSpace.to_UniformSpace.{?l_1}
             ((λ (X : UniformSpace.{?l_1}),
                 @CpltSepUniformSpace.of.{?l_1}
                   (@uniform_space.completion.{?l_1}
                      (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                         (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                         X)
                      (UniformSpace.uniform_space.{?l_1} X))
                   (@uniform_space.completion.uniform_space.{?l_1}
                      (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                         (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                         X)
                      (UniformSpace.uniform_space.{?l_1} X))
                   (UniformSpace.completion_functor._proof_1.{?l_1} X)
                   (UniformSpace.completion_functor._proof_2.{?l_1} X))
                X))
          (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
       (UniformSpace.has_coe_to_fun.{?l_1}
          (CpltSepUniformSpace.to_UniformSpace.{?l_1}
             ((λ (X : UniformSpace.{?l_1}),
                 @CpltSepUniformSpace.of.{?l_1}
                   (@uniform_space.completion.{?l_1}
                      (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                         (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                         X)
                      (UniformSpace.uniform_space.{?l_1} X))
                   (@uniform_space.completion.uniform_space.{?l_1}
                      (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                         (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                         X)
                      (UniformSpace.uniform_space.{?l_1} X))
                   (UniformSpace.completion_functor._proof_1.{?l_1} X)
                   (UniformSpace.completion_functor._proof_2.{?l_1} X))
                X))
          (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
       (@coe_fn.{(max 1 (?l_1+1)) ?l_1+1}
          (equiv.{?l_1+1 ?l_1+1}
             ((λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                 (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                    @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                   (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                   (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                   (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                   (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y))
                X
                (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
             ((λ
               (X Y :
                 @category_theory.induced_category.{?l_1 ?l_1+1 ?l_1+1} CpltSepUniformSpace.{?l_1} UniformSpace.{?l_1}
                   (@category_theory.concrete_category.to_category.{?l_1} UniformSpace.{?l_1}
                      (@category_theory.bundled_hom.category_theory.concrete_category.{?l_1} uniform_space.{?l_1}
                         (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                            @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                         (@category_theory.unbundled_hom.bundled_hom.{?l_1}
                            (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                            uniform_continuous.{?l_1 ?l_1}
                            UniformSpace.concrete_category_uniform_continuous.{?l_1})))
                   CpltSepUniformSpace.to_UniformSpace.{?l_1}),
                 @category_theory.has_hom.hom.{?l_1 ?l_1+1} UniformSpace.{?l_1}
                   (@category_theory.category_struct.to_has_hom.{?l_1 ?l_1+1} UniformSpace.{?l_1}
                      (@category_theory.category.to_category_struct.{?l_1 ?l_1+1} UniformSpace.{?l_1}
                         (@category_theory.concrete_category.to_category.{?l_1} UniformSpace.{?l_1}
                            (@category_theory.bundled_hom.category_theory.concrete_category.{?l_1} uniform_space.{?l_1}
                               (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                                  @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                               (@category_theory.unbundled_hom.bundled_hom.{?l_1}
                                  (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                                  uniform_continuous.{?l_1 ?l_1}
                                  UniformSpace.concrete_category_uniform_continuous.{?l_1})))))
                   (CpltSepUniformSpace.to_UniformSpace.{?l_1} X)
                   (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
                ((λ (X : UniformSpace.{?l_1}),
                    @CpltSepUniformSpace.of.{?l_1}
                      (@uniform_space.completion.{?l_1}
                         (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                            (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                            X)
                         (UniformSpace.uniform_space.{?l_1} X))
                      (@uniform_space.completion.uniform_space.{?l_1}
                         (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                            (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                            X)
                         (UniformSpace.uniform_space.{?l_1} X))
                      (UniformSpace.completion_functor._proof_1.{?l_1} X)
                      (UniformSpace.completion_functor._proof_2.{?l_1} X))
                   X)
                Y))
          (@equiv.has_coe_to_fun.{?l_1+1 ?l_1+1}
             ((λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                 (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                    @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                   (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                   (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                   (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                   (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y))
                X
                (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
             ((λ
               (X Y :
                 @category_theory.induced_category.{?l_1 ?l_1+1 ?l_1+1} CpltSepUniformSpace.{?l_1} UniformSpace.{?l_1}
                   (@category_theory.concrete_category.to_category.{?l_1} UniformSpace.{?l_1}
                      (@category_theory.bundled_hom.category_theory.concrete_category.{?l_1} uniform_space.{?l_1}
                         (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                            @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                         (@category_theory.unbundled_hom.bundled_hom.{?l_1}
                            (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                            uniform_continuous.{?l_1 ?l_1}
                            UniformSpace.concrete_category_uniform_continuous.{?l_1})))
                   CpltSepUniformSpace.to_UniformSpace.{?l_1}),
                 @category_theory.has_hom.hom.{?l_1 ?l_1+1} UniformSpace.{?l_1}
                   (@category_theory.category_struct.to_has_hom.{?l_1 ?l_1+1} UniformSpace.{?l_1}
                      (@category_theory.category.to_category_struct.{?l_1 ?l_1+1} UniformSpace.{?l_1}
                         (@category_theory.concrete_category.to_category.{?l_1} UniformSpace.{?l_1}
                            (@category_theory.bundled_hom.category_theory.concrete_category.{?l_1} uniform_space.{?l_1}
                               (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                                  @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                               (@category_theory.unbundled_hom.bundled_hom.{?l_1}
                                  (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                                  uniform_continuous.{?l_1 ?l_1}
                                  UniformSpace.concrete_category_uniform_continuous.{?l_1})))))
                   (CpltSepUniformSpace.to_UniformSpace.{?l_1} X)
                   (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
                ((λ (X : UniformSpace.{?l_1}),
                    @CpltSepUniformSpace.of.{?l_1}
                      (@uniform_space.completion.{?l_1}
                         (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                            (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                            X)
                         (UniformSpace.uniform_space.{?l_1} X))
                      (@uniform_space.completion.uniform_space.{?l_1}
                         (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                            (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                            X)
                         (UniformSpace.uniform_space.{?l_1} X))
                      (UniformSpace.completion_functor._proof_1.{?l_1} X)
                      (UniformSpace.completion_functor._proof_2.{?l_1} X))
                   X)
                Y))
          (@equiv.symm.{?l_1+1 ?l_1+1}
             ((λ
               (X Y :
                 @category_theory.induced_category.{?l_1 ?l_1+1 ?l_1+1} CpltSepUniformSpace.{?l_1} UniformSpace.{?l_1}
                   (@category_theory.concrete_category.to_category.{?l_1} UniformSpace.{?l_1}
                      (@category_theory.bundled_hom.category_theory.concrete_category.{?l_1} uniform_space.{?l_1}
                         (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                            @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                         (@category_theory.unbundled_hom.bundled_hom.{?l_1}
                            (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                            uniform_continuous.{?l_1 ?l_1}
                            UniformSpace.concrete_category_uniform_continuous.{?l_1})))
                   CpltSepUniformSpace.to_UniformSpace.{?l_1}),
                 @category_theory.has_hom.hom.{?l_1 ?l_1+1} UniformSpace.{?l_1}
                   (@category_theory.category_struct.to_has_hom.{?l_1 ?l_1+1} UniformSpace.{?l_1}
                      (@category_theory.category.to_category_struct.{?l_1 ?l_1+1} UniformSpace.{?l_1}
                         (@category_theory.concrete_category.to_category.{?l_1} UniformSpace.{?l_1}
                            (@category_theory.bundled_hom.category_theory.concrete_category.{?l_1} uniform_space.{?l_1}
                               (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                                  @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                               (@category_theory.unbundled_hom.bundled_hom.{?l_1}
                                  (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                                  uniform_continuous.{?l_1 ?l_1}
                                  UniformSpace.concrete_category_uniform_continuous.{?l_1})))))
                   (CpltSepUniformSpace.to_UniformSpace.{?l_1} X)
                   (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
                ((λ (X : UniformSpace.{?l_1}),
                    @CpltSepUniformSpace.of.{?l_1}
                      (@uniform_space.completion.{?l_1}
                         (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                            (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                            X)
                         (UniformSpace.uniform_space.{?l_1} X))
                      (@uniform_space.completion.uniform_space.{?l_1}
                         (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                            (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                            X)
                         (UniformSpace.uniform_space.{?l_1} X))
                      (UniformSpace.completion_functor._proof_1.{?l_1} X)
                      (UniformSpace.completion_functor._proof_2.{?l_1} X))
                   X)
                Y)
             ((λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                 (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                    @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                   (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                   (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                   (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                   (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y))
                X
                (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
             (@equiv.mk.{?l_1+1 ?l_1+1}
                ((λ
                  (X Y :
                    @category_theory.induced_category.{?l_1 ?l_1+1 ?l_1+1} CpltSepUniformSpace.{?l_1}
                      UniformSpace.{?l_1}
                      (@category_theory.category.mk.{?l_1 ?l_1+1}
                         (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                         (@category_theory.category.to_category_struct.{?l_1 ?l_1+1}
                            (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                            (@category_theory.bundled_hom.category.{?l_1} uniform_space.{?l_1}
                               (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                                  @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                               (@category_theory.unbundled_hom.bundled_hom.{?l_1}
                                  (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                                  uniform_continuous.{?l_1 ?l_1}
                                  UniformSpace.concrete_category_uniform_continuous.{?l_1})))
                         (@category_theory.bundled_hom.category_theory.concrete_category._proof_1.{?l_1}
                            uniform_space.{?l_1}
                            (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                               @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                            (@category_theory.unbundled_hom.bundled_hom.{?l_1}
                               (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                               uniform_continuous.{?l_1 ?l_1}
                               UniformSpace.concrete_category_uniform_continuous.{?l_1}))
                         (@category_theory.bundled_hom.category_theory.concrete_category._proof_2.{?l_1}
                            uniform_space.{?l_1}
                            (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                               @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                            (@category_theory.unbundled_hom.bundled_hom.{?l_1}
                               (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                               uniform_continuous.{?l_1 ?l_1}
                               UniformSpace.concrete_category_uniform_continuous.{?l_1}))
                         (@category_theory.bundled_hom.category_theory.concrete_category._proof_3.{?l_1}
                            uniform_space.{?l_1}
                            (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                               @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                            (@category_theory.unbundled_hom.bundled_hom.{?l_1}
                               (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                               uniform_continuous.{?l_1 ?l_1}
                               UniformSpace.concrete_category_uniform_continuous.{?l_1})))
                      CpltSepUniformSpace.to_UniformSpace.{?l_1}),
                    (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                       (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                          @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                         (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                         (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                         (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                         (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y))
                      (CpltSepUniformSpace.to_UniformSpace.{?l_1} X)
                      (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
                   ((λ (X : UniformSpace.{?l_1}),
                       @CpltSepUniformSpace.of.{?l_1}
                         (@uniform_space.completion.{?l_1}
                            (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                               (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                               X)
                            (UniformSpace.uniform_space.{?l_1} X))
                         (@uniform_space.completion.uniform_space.{?l_1}
                            (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                               (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                               X)
                            (UniformSpace.uniform_space.{?l_1} X))
                         (UniformSpace.completion_functor._proof_1.{?l_1} X)
                         (UniformSpace.completion_functor._proof_2.{?l_1} X))
                      X)
                   Y)
                ((λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                    (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                       @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                      (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                      (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                      (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                      (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y))
                   X
                   (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
                (λ
                 (f :
                   (λ
                    (X Y :
                      @category_theory.induced_category.{?l_1 ?l_1+1 ?l_1+1} CpltSepUniformSpace.{?l_1}
                        UniformSpace.{?l_1}
                        (@category_theory.category.mk.{?l_1 ?l_1+1}
                           (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                           (@category_theory.category_struct.mk.{?l_1 ?l_1+1}
                              (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                              (@category_theory.has_hom.mk.{?l_1 ?l_1+1}
                                 (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                 (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                                    (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α)
                                     (Iβ : uniform_space.{?l_1} β),
                                       @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                                      (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                      (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                                      (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                      (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y)))
                              (λ (X : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                                 @category_theory.bundled_hom.id.{?l_1} uniform_space.{?l_1}
                                   (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α)
                                    (Iβ : uniform_space.{?l_1} β),
                                      @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                                   (@category_theory.unbundled_hom.bundled_hom.{?l_1}
                                      (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                                      uniform_continuous.{?l_1 ?l_1}
                                      UniformSpace.concrete_category_uniform_continuous.{?l_1})
                                   (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                      (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                      X)
                                   (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X))
                              (λ (X Y Z : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                               (f :
                                 @category_theory.has_hom.hom.{?l_1 ?l_1+1}
                                   (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                   (@category_theory.has_hom.mk.{?l_1 ?l_1+1}
                                      (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                      (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                                         (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α)
                                          (Iβ : uniform_space.{?l_1} β),
                                            @subtype.{?l_1+1} (α → β)
                                              (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                                           (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                           (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                                           (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                           (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y)))
                                   X
                                   Y)
                               (g :
                                 @category_theory.has_hom.hom.{?l_1 ?l_1+1}
                                   (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                   (@category_theory.has_hom.mk.{?l_1 ?l_1+1}
                                      (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                      (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                                         (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α)
                                          (Iβ : uniform_space.{?l_1} β),
                                            @subtype.{?l_1+1} (α → β)
                                              (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                                           (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                           (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                                           (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                           (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y)))
                                   Y
                                   Z),
                                 @category_theory.bundled_hom.comp.{?l_1} uniform_space.{?l_1}
                                   (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α)
                                    (Iβ : uniform_space.{?l_1} β),
                                      @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                                   (@category_theory.unbundled_hom.bundled_hom.{?l_1}
                                      (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                                      uniform_continuous.{?l_1 ?l_1}
                                      UniformSpace.concrete_category_uniform_continuous.{?l_1})
                                   (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                      (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                      X)
                                   (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                      (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                      Y)
                                   (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                      (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                      Z)
                                   (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                   (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                                   (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Z)
                                   g
                                   f))
                           (@category_theory.bundled_hom.category_theory.concrete_category._proof_1.{?l_1}
                              uniform_space.{?l_1}
                              (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                                 @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                              (@category_theory.unbundled_hom.bundled_hom.{?l_1}
                                 (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                                 uniform_continuous.{?l_1 ?l_1}
                                 UniformSpace.concrete_category_uniform_continuous.{?l_1}))
                           (@category_theory.bundled_hom.category_theory.concrete_category._proof_2.{?l_1}
                              uniform_space.{?l_1}
                              (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                                 @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                              (@category_theory.unbundled_hom.bundled_hom.{?l_1}
                                 (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                                 uniform_continuous.{?l_1 ?l_1}
                                 UniformSpace.concrete_category_uniform_continuous.{?l_1}))
                           (@category_theory.bundled_hom.category_theory.concrete_category._proof_3.{?l_1}
                              uniform_space.{?l_1}
                              (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                                 @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                              (@category_theory.unbundled_hom.bundled_hom.{?l_1}
                                 (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                                 uniform_continuous.{?l_1 ?l_1}
                                 UniformSpace.concrete_category_uniform_continuous.{?l_1})))
                        CpltSepUniformSpace.to_UniformSpace.{?l_1}),
                      (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                         (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                            @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                           (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                           (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                           (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                           (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y))
                        (CpltSepUniformSpace.to_UniformSpace.{?l_1} X)
                        (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
                     ((λ (X : UniformSpace.{?l_1}),
                         @CpltSepUniformSpace.of.{?l_1}
                           (@uniform_space.completion.{?l_1}
                              (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                                 (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                 X)
                              (UniformSpace.uniform_space.{?l_1} X))
                           (@uniform_space.completion.uniform_space.{?l_1}
                              (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                                 (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                 X)
                              (UniformSpace.uniform_space.{?l_1} X))
                           (UniformSpace.completion_functor._proof_1.{?l_1} X)
                           (UniformSpace.completion_functor._proof_2.{?l_1} X))
                        X)
                     Y),
                   (λ (X Y Z : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                    (f :
                      @category_theory.has_hom.hom.{?l_1 ?l_1+1}
                        (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                        (@category_theory.has_hom.mk.{?l_1 ?l_1+1}
                           (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                           (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                              (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                                 @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                                (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                                (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y)))
                        X
                        Y)
                    (g :
                      @category_theory.has_hom.hom.{?l_1 ?l_1+1}
                        (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                        (@category_theory.has_hom.mk.{?l_1 ?l_1+1}
                           (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                           (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                              (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                                 @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                                (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                                (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y)))
                        Y
                        Z),
                      @category_theory.bundled_hom.comp.{?l_1} uniform_space.{?l_1}
                        (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                           @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                        (@category_theory.unbundled_hom.bundled_hom.{?l_1}
                           (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                           uniform_continuous.{?l_1 ?l_1}
                           UniformSpace.concrete_category_uniform_continuous.{?l_1})
                        (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                           (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                           X)
                        (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                           (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                           Y)
                        (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                           (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                           Z)
                        (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                        (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                        (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Z)
                        g
                        f)
                     X
                     (CpltSepUniformSpace.to_UniformSpace.{?l_1}
                        ((λ (X : UniformSpace.{?l_1}),
                            @CpltSepUniformSpace.of.{?l_1}
                              (@uniform_space.completion.{?l_1}
                                 (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                                    (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                    X)
                                 (UniformSpace.uniform_space.{?l_1} X))
                              (@uniform_space.completion.uniform_space.{?l_1}
                                 (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                                    (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                    X)
                                 (UniformSpace.uniform_space.{?l_1} X))
                              (UniformSpace.completion_functor._proof_1.{?l_1} X)
                              (UniformSpace.completion_functor._proof_2.{?l_1} X))
                           X))
                     (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y)
                     (UniformSpace.completion_hom.{?l_1} X)
                     f)
                (λ
                 (f :
                   (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                      (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                         @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                        (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                        (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                        (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                        (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y))
                     X
                     (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y)), @UniformSpace.extension_hom.{?l_1} X Y f)
                (λ
                 (f :
                   (λ
                    (X Y :
                      @category_theory.induced_category.{?l_1 ?l_1+1 ?l_1+1} CpltSepUniformSpace.{?l_1}
                        UniformSpace.{?l_1}
                        (@category_theory.category.mk.{?l_1 ?l_1+1}
                           (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                           (@category_theory.category_struct.mk.{?l_1 ?l_1+1}
                              (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                              (@category_theory.has_hom.mk.{?l_1 ?l_1+1}
                                 (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                 (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                                    (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α)
                                     (Iβ : uniform_space.{?l_1} β),
                                       @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                                      (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                      (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                                      (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                      (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y)))
                              (λ (X : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                                 @category_theory.bundled_hom.id.{?l_1} uniform_space.{?l_1}
                                   (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α)
                                    (Iβ : uniform_space.{?l_1} β),
                                      @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                                   (@category_theory.unbundled_hom.bundled_hom.{?l_1}
                                      (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                                      uniform_continuous.{?l_1 ?l_1}
                                      UniformSpace.concrete_category_uniform_continuous.{?l_1})
                                   (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                      (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                      X)
                                   (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X))
                              (λ (X Y Z : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                               (f :
                                 @category_theory.has_hom.hom.{?l_1 ?l_1+1}
                                   (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                   (@category_theory.has_hom.mk.{?l_1 ?l_1+1}
                                      (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                      (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                                         (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α)
                                          (Iβ : uniform_space.{?l_1} β),
                                            @subtype.{?l_1+1} (α → β)
                                              (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                                           (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                           (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                                           (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                           (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y)))
                                   X
                                   Y)
                               (g :
                                 @category_theory.has_hom.hom.{?l_1 ?l_1+1}
                                   (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                   (@category_theory.has_hom.mk.{?l_1 ?l_1+1}
                                      (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                      (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                                         (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α)
                                          (Iβ : uniform_space.{?l_1} β),
                                            @subtype.{?l_1+1} (α → β)
                                              (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                                           (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                           (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                                           (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                           (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y)))
                                   Y
                                   Z),
                                 @category_theory.bundled_hom.comp.{?l_1} uniform_space.{?l_1}
                                   (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α)
                                    (Iβ : uniform_space.{?l_1} β),
                                      @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                                   (@category_theory.unbundled_hom.bundled_hom.{?l_1}
                                      (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                                      uniform_continuous.{?l_1 ?l_1}
                                      UniformSpace.concrete_category_uniform_continuous.{?l_1})
                                   (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                      (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                      X)
                                   (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                      (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                      Y)
                                   (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                      (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                      Z)
                                   (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                   (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                                   (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Z)
                                   g
                                   f))
                           (@category_theory.bundled_hom.category_theory.concrete_category._proof_1.{?l_1}
                              uniform_space.{?l_1}
                              (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                                 @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                              (@category_theory.unbundled_hom.bundled_hom.{?l_1}
                                 (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                                 uniform_continuous.{?l_1 ?l_1}
                                 UniformSpace.concrete_category_uniform_continuous.{?l_1}))
                           (@category_theory.bundled_hom.category_theory.concrete_category._proof_2.{?l_1}
                              uniform_space.{?l_1}
                              (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                                 @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                              (@category_theory.unbundled_hom.bundled_hom.{?l_1}
                                 (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                                 uniform_continuous.{?l_1 ?l_1}
                                 UniformSpace.concrete_category_uniform_continuous.{?l_1}))
                           (@category_theory.bundled_hom.category_theory.concrete_category._proof_3.{?l_1}
                              uniform_space.{?l_1}
                              (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                                 @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                              (@category_theory.unbundled_hom.bundled_hom.{?l_1}
                                 (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                                 uniform_continuous.{?l_1 ?l_1}
                                 UniformSpace.concrete_category_uniform_continuous.{?l_1})))
                        CpltSepUniformSpace.to_UniformSpace.{?l_1}),
                      (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                         (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                            @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                           (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                           (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                           (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                           (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y))
                        (CpltSepUniformSpace.to_UniformSpace.{?l_1} X)
                        (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
                     ((λ (X : UniformSpace.{?l_1}),
                         @CpltSepUniformSpace.of.{?l_1}
                           (@uniform_space.completion.{?l_1}
                              (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                                 (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                 X)
                              (UniformSpace.uniform_space.{?l_1} X))
                           (@uniform_space.completion.uniform_space.{?l_1}
                              (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                                 (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                 X)
                              (UniformSpace.uniform_space.{?l_1} X))
                           (UniformSpace.completion_functor._proof_1.{?l_1} X)
                           (UniformSpace.completion_functor._proof_2.{?l_1} X))
                        X)
                     Y),
                   @id.{0}
                     (@eq.{?l_1+1}
                        ((λ
                          (X Y :
                            @category_theory.induced_category.{?l_1 ?l_1+1 ?l_1+1} CpltSepUniformSpace.{?l_1}
                              UniformSpace.{?l_1}
                              (@category_theory.category.mk.{?l_1 ?l_1+1}
                                 (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                 (@category_theory.category_struct.mk.{?l_1 ?l_1+1}
                                    (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                    (@category_theory.has_hom.mk.{?l_1 ?l_1+1}
                                       (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                       (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                                          (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α)
                                           (Iβ : uniform_space.{?l_1} β),
                                             @subtype.{?l_1+1} (α → β)
                                               (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                                            (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                            (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                                            (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                            (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y)))
                                    (λ (X : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                                       @category_theory.bundled_hom.id.{?l_1} uniform_space.{?l_1}
                                         (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α)
                                          (Iβ : uniform_space.{?l_1} β),
                                            @subtype.{?l_1+1} (α → β)
                                              (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                                         (@category_theory.unbundled_hom.bundled_hom.{?l_1}
                                            (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                                            uniform_continuous.{?l_1 ?l_1}
                                            UniformSpace.concrete_category_uniform_continuous.{?l_1})
                                         (@coe_sort.{?l_1+2 ?l_1+2}
                                            (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                            (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                            X)
                                         (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X))
                                    (λ (X Y Z : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                     (f :
                                       @category_theory.has_hom.hom.{?l_1 ?l_1+1}
                                         (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                         (@category_theory.has_hom.mk.{?l_1 ?l_1+1}
                                            (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                            (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                                               (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α)
                                                (Iβ : uniform_space.{?l_1} β),
                                                  @subtype.{?l_1+1} (α → β)
                                                    (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                                                 (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                                 (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                                                 (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                                 (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y)))
                                         X
                                         Y)
                                     (g :
                                       @category_theory.has_hom.hom.{?l_1 ?l_1+1}
                                         (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                         (@category_theory.has_hom.mk.{?l_1 ?l_1+1}
                                            (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                            (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                                               (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α)
                                                (Iβ : uniform_space.{?l_1} β),
                                                  @subtype.{?l_1+1} (α → β)
                                                    (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                                                 (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                                 (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                                                 (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                                 (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y)))
                                         Y
                                         Z),
                                       @category_theory.bundled_hom.comp.{?l_1} uniform_space.{?l_1}
                                         (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α)
                                          (Iβ : uniform_space.{?l_1} β),
                                            @subtype.{?l_1+1} (α → β)
                                              (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                                         (@category_theory.unbundled_hom.bundled_hom.{?l_1}
                                            (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                                            uniform_continuous.{?l_1 ?l_1}
                                            UniformSpace.concrete_category_uniform_continuous.{?l_1})
                                         (@coe_sort.{?l_1+2 ?l_1+2}
                                            (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                            (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                            X)
                                         (@coe_sort.{?l_1+2 ?l_1+2}
                                            (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                            (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                            Y)
                                         (@coe_sort.{?l_1+2 ?l_1+2}
                                            (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                            (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                            Z)
                                         (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                         (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                                         (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Z)
                                         g
                                         f))
                                 (@category_theory.bundled_hom.category_theory.concrete_category._proof_1.{?l_1}
                                    uniform_space.{?l_1}
                                    (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α)
                                     (Iβ : uniform_space.{?l_1} β),
                                       @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                                    (@category_theory.unbundled_hom.bundled_hom.{?l_1}
                                       (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                                       uniform_continuous.{?l_1 ?l_1}
                                       UniformSpace.concrete_category_uniform_continuous.{?l_1}))
                                 (@category_theory.bundled_hom.category_theory.concrete_category._proof_2.{?l_1}
                                    uniform_space.{?l_1}
                                    (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α)
                                     (Iβ : uniform_space.{?l_1} β),
                                       @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                                    (@category_theory.unbundled_hom.bundled_hom.{?l_1}
                                       (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                                       uniform_continuous.{?l_1 ?l_1}
                                       UniformSpace.concrete_category_uniform_continuous.{?l_1}))
                                 (@category_theory.bundled_hom.category_theory.concrete_category._proof_3.{?l_1}
                                    uniform_space.{?l_1}
                                    (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α)
                                     (Iβ : uniform_space.{?l_1} β),
                                       @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                                    (@category_theory.unbundled_hom.bundled_hom.{?l_1}
                                       (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                                       uniform_continuous.{?l_1 ?l_1}
                                       UniformSpace.concrete_category_uniform_continuous.{?l_1})))
                              CpltSepUniformSpace.to_UniformSpace.{?l_1}),
                            (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                               (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                                  @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                                 (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                 (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                                 (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                 (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y))
                              (CpltSepUniformSpace.to_UniformSpace.{?l_1} X)
                              (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
                           ((λ (X : UniformSpace.{?l_1}),
                               @CpltSepUniformSpace.of.{?l_1}
                                 (@uniform_space.completion.{?l_1}
                                    (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                                       (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                       X)
                                    (UniformSpace.uniform_space.{?l_1} X))
                                 (@uniform_space.completion.uniform_space.{?l_1}
                                    (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                                       (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                       X)
                                    (UniformSpace.uniform_space.{?l_1} X))
                                 (UniformSpace.completion_functor._proof_1.{?l_1} X)
                                 (UniformSpace.completion_functor._proof_2.{?l_1} X))
                              X)
                           Y)
                        ((λ
                          (f :
                            (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                               (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                                  @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                                 (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                 (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                                 (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                 (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y))
                              X
                              (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y)), @UniformSpace.extension_hom.{?l_1} X Y f)
                           ((λ
                             (f :
                               (λ
                                (X Y :
                                  @category_theory.induced_category.{?l_1 ?l_1+1 ?l_1+1} CpltSepUniformSpace.{?l_1}
                                    UniformSpace.{?l_1}
                                    (@category_theory.category.mk.{?l_1 ?l_1+1}
                                       (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                       (@category_theory.category_struct.mk.{?l_1 ?l_1+1}
                                          (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                          (@category_theory.has_hom.mk.{?l_1 ?l_1+1}
                                             (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                             (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                                                (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α)
                                                 (Iβ : uniform_space.{?l_1} β),
                                                   @subtype.{?l_1+1} (α → β)
                                                     (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                                                  (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                                  (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                                                  (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                                  (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y)))
                                          (λ (X : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                                             (λ (α : Type ?l_1)
                                              (Iα : (λ (α : Type ?l_1), uniform_space.{?l_1} α) α),
                                                @subtype.mk.{?l_1+1} (α → α)
                                                  (@uniform_continuous.{?l_1 ?l_1} α α Iα Iα)
                                                  (@id.{?l_1+1} α)
                                                  (@category_theory.unbundled_hom.bundled_hom._proof_1.{?l_1}
                                                     (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                                                     uniform_continuous.{?l_1 ?l_1}
                                                     UniformSpace.concrete_category_uniform_continuous.{?l_1}
                                                     α
                                                     Iα))
                                               (@coe_sort.{?l_1+2 ?l_1+2}
                                                  (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                                  (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1}
                                                     uniform_space.{?l_1})
                                                  X)
                                               (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X))
                                          (λ (X Y Z : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                           (f :
                                             (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                                                (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α)
                                                 (Iβ : uniform_space.{?l_1} β),
                                                   @subtype.{?l_1+1} (α → β)
                                                     (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                                                  (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                                  (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                                                  (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                                  (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y))
                                               X
                                               Y)
                                           (g :
                                             (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                                                (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α)
                                                 (Iβ : uniform_space.{?l_1} β),
                                                   @subtype.{?l_1+1} (α → β)
                                                     (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                                                  (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                                  (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                                                  (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                                  (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y))
                                               Y
                                               Z),
                                             (λ (_x _x_1 _x_2 : Type ?l_1)
                                              (_x_3 : (λ (α : Type ?l_1), uniform_space.{?l_1} α) _x)
                                              (_x_4 : (λ (α : Type ?l_1), uniform_space.{?l_1} α) _x_1)
                                              (_x_5 : (λ (α : Type ?l_1), uniform_space.{?l_1} α) _x_2)
                                              (g :
                                                @subtype.{?l_1+1} (_x_1 → _x_2)
                                                  (@uniform_continuous.{?l_1 ?l_1} _x_1 _x_2 _x_4 _x_5))
                                              (f :
                                                @subtype.{?l_1+1} (_x → _x_1)
                                                  (@uniform_continuous.{?l_1 ?l_1} _x _x_1 _x_3 _x_4)),
                                                @subtype.mk.{?l_1+1} (_x → _x_2)
                                                  (@uniform_continuous.{?l_1 ?l_1} _x _x_2 _x_3 _x_5)
                                                  (@function.comp.{?l_1+1 ?l_1+1 ?l_1+1} _x _x_1 _x_2
                                                     (@subtype.val.{?l_1+1} (_x_1 → _x_2)
                                                        (@uniform_continuous.{?l_1 ?l_1} _x_1 _x_2 _x_4 _x_5)
                                                        g)
                                                     (@subtype.val.{?l_1+1} (_x → _x_1)
                                                        (@uniform_continuous.{?l_1 ?l_1} _x _x_1 _x_3 _x_4)
                                                        f))
                                                  (@category_theory.unbundled_hom.bundled_hom._proof_2.{?l_1}
                                                     (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                                                     uniform_continuous.{?l_1 ?l_1}
                                                     UniformSpace.concrete_category_uniform_continuous.{?l_1}
                                                     _x
                                                     _x_1
                                                     _x_2
                                                     _x_3
                                                     _x_4
                                                     _x_5
                                                     g
                                                     f))
                                               (@coe_sort.{?l_1+2 ?l_1+2}
                                                  (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                                  (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1}
                                                     uniform_space.{?l_1})
                                                  X)
                                               (@coe_sort.{?l_1+2 ?l_1+2}
                                                  (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                                  (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1}
                                                     uniform_space.{?l_1})
                                                  Y)
                                               (@coe_sort.{?l_1+2 ?l_1+2}
                                                  (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                                  (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1}
                                                     uniform_space.{?l_1})
                                                  Z)
                                               (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                               (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                                               (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Z)
                                               g
                                               f))
                                       (@category_theory.bundled_hom.category_theory.concrete_category._proof_1.{?l_1}
                                          uniform_space.{?l_1}
                                          (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α)
                                           (Iβ : uniform_space.{?l_1} β),
                                             @subtype.{?l_1+1} (α → β)
                                               (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                                          (@category_theory.unbundled_hom.bundled_hom.{?l_1}
                                             (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                                             uniform_continuous.{?l_1 ?l_1}
                                             UniformSpace.concrete_category_uniform_continuous.{?l_1}))
                                       (@category_theory.bundled_hom.category_theory.concrete_category._proof_2.{?l_1}
                                          uniform_space.{?l_1}
                                          (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α)
                                           (Iβ : uniform_space.{?l_1} β),
                                             @subtype.{?l_1+1} (α → β)
                                               (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                                          (@category_theory.unbundled_hom.bundled_hom.{?l_1}
                                             (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                                             uniform_continuous.{?l_1 ?l_1}
                                             UniformSpace.concrete_category_uniform_continuous.{?l_1}))
                                       (@category_theory.bundled_hom.category_theory.concrete_category._proof_3.{?l_1}
                                          uniform_space.{?l_1}
                                          (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α)
                                           (Iβ : uniform_space.{?l_1} β),
                                             @subtype.{?l_1+1} (α → β)
                                               (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                                          (@category_theory.unbundled_hom.bundled_hom.{?l_1}
                                             (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                                             uniform_continuous.{?l_1 ?l_1}
                                             UniformSpace.concrete_category_uniform_continuous.{?l_1})))
                                    CpltSepUniformSpace.to_UniformSpace.{?l_1}),
                                  (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                                     (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α)
                                      (Iβ : uniform_space.{?l_1} β),
                                        @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                                       (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                       (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                                       (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                       (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y))
                                    (CpltSepUniformSpace.to_UniformSpace.{?l_1} X)
                                    (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
                                 ((λ (X : UniformSpace.{?l_1}),
                                     @CpltSepUniformSpace.of.{?l_1}
                                       (@uniform_space.completion.{?l_1}
                                          (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                                             (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                             X)
                                          (UniformSpace.uniform_space.{?l_1} X))
                                       (@uniform_space.completion.uniform_space.{?l_1}
                                          (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                                             (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                             X)
                                          (UniformSpace.uniform_space.{?l_1} X))
                                       (UniformSpace.completion_functor._proof_1.{?l_1} X)
                                       (UniformSpace.completion_functor._proof_2.{?l_1} X))
                                    X)
                                 Y),
                               (λ (X Y Z : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                (f :
                                  (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                                     (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α)
                                      (Iβ : uniform_space.{?l_1} β),
                                        @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                                       (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                       (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                                       (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                       (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y))
                                    X
                                    Y)
                                (g :
                                  (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
                                     (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α)
                                      (Iβ : uniform_space.{?l_1} β),
                                        @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                                       (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                       (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                                       (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                       (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y))
                                    Y
                                    Z),
                                  (λ (_x _x_1 _x_2 : Type ?l_1)
                                   (_x_3 : (λ (α : Type ?l_1), uniform_space.{?l_1} α) _x)
                                   (_x_4 : (λ (α : Type ?l_1), uniform_space.{?l_1} α) _x_1)
                                   (_x_5 : (λ (α : Type ?l_1), uniform_space.{?l_1} α) _x_2)
                                   (g :
                                     @subtype.{?l_1+1} (_x_1 → _x_2)
                                       (@uniform_continuous.{?l_1 ?l_1} _x_1 _x_2 _x_4 _x_5))
                                   (f :
                                     @subtype.{?l_1+1} (_x → _x_1)
                                       (@uniform_continuous.{?l_1 ?l_1} _x _x_1 _x_3 _x_4)),
                                     @subtype.mk.{?l_1+1} (_x → _x_2)
                                       (@uniform_continuous.{?l_1 ?l_1} _x _x_2 _x_3 _x_5)
                                       (@function.comp.{?l_1+1 ?l_1+1 ?l_1+1} _x _x_1 _x_2
                                          (@subtype.val.{?l_1+1} (_x_1 → _x_2)
                                             (@uniform_continuous.{?l_1 ?l_1} _x_1 _x_2 _x_4 _x_5)
                                             g)
                                          (@subtype.val.{?l_1+1} (_x → _x_1)
                                             (@uniform_continuous.{?l_1 ?l_1} _x _x_1 _x_3 _x_4)
                                             f))
                                       (@category_theory.unbundled_hom.bundled_hom._proof_2.{?l_1}
                                          (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                                          uniform_continuous.{?l_1 ?l_1}
                                          UniformSpace.concrete_category_uniform_continuous.{?l_1}
                                          _x
                                          _x_1
                                          _x_2
                                          _x_3
                                          _x_4
                                          _x_5
                                          g
                                          f))
                                    (@coe_sort.{?l_1+2 ?l_1+2}
                                       (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                       (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                       X)
                                    (@coe_sort.{?l_1+2 ?l_1+2}
                                       (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                       (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                       Y)
                                    (@coe_sort.{?l_1+2 ?l_1+2}
                                       (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                       (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                       Z)
                                    (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                    (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y)
                                    (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Z)
                                    g
                                    f)
                                 X
                                 (CpltSepUniformSpace.to_UniformSpace.{?l_1}
                                    ((λ (X : UniformSpace.{?l_1}),
                                        @CpltSepUniformSpace.of.{?l_1}
                                          (@uniform_space.completion.{?l_1}
                                             (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                                                (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1}
                                                   uniform_space.{?l_1})
                                                X)
                                             (UniformSpace.uniform_space.{?l_1} X))
                                          (@uniform_space.completion.uniform_space.{?l_1}
                                             (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                                                (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1}
                                                   uniform_space.{?l_1})
                                                X)
                                             (UniformSpace.uniform_space.{?l_1} X))
                                          (UniformSpace.completion_functor._proof_1.{?l_1} X)
                                          (UniformSpace.completion_functor._proof_2.{?l_1} X))
                                       X))
                                 (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y)
                                 (UniformSpace.completion_hom.{?l_1} X)
                                 f)
                              f))
                        f)
                     (@eq.mpr.{0}
                        (@eq.{?l_1+1}
                           (@subtype.{?l_1+1}
                              (@coe_sort.{?l_1+2 ?l_1+2} CpltSepUniformSpace.{?l_1}
                                 CpltSepUniformSpace.has_coe_to_sort.{?l_1}
                                 (@CpltSepUniformSpace.of.{?l_1}
                                    (@uniform_space.completion.{?l_1}
                                       (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                                          (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                          X)
                                       (UniformSpace.uniform_space.{?l_1} X))
                                    (@uniform_space.completion.uniform_space.{?l_1}
                                       (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                                          (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                          X)
                                       (UniformSpace.uniform_space.{?l_1} X))
                                    (UniformSpace.completion_functor._proof_1.{?l_1} X)
                                    (UniformSpace.completion_functor._proof_2.{?l_1} X)) →
                               @coe_sort.{?l_1+2 ?l_1+2} CpltSepUniformSpace.{?l_1}
                                 CpltSepUniformSpace.has_coe_to_sort.{?l_1}
                                 Y)
                              (@uniform_continuous.{?l_1 ?l_1}
                                 (@coe_sort.{?l_1+2 ?l_1+2} CpltSepUniformSpace.{?l_1}
                                    CpltSepUniformSpace.has_coe_to_sort.{?l_1}
                                    (@CpltSepUniformSpace.of.{?l_1}
                                       (@uniform_space.completion.{?l_1}
                                          (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                                             (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                             X)
                                          (UniformSpace.uniform_space.{?l_1} X))
                                       (@uniform_space.completion.uniform_space.{?l_1}
                                          (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                                             (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                             X)
                                          (UniformSpace.uniform_space.{?l_1} X))
                                       (UniformSpace.completion_functor._proof_1.{?l_1} X)
                                       (UniformSpace.completion_functor._proof_2.{?l_1} X)))
                                 (@coe_sort.{?l_1+2 ?l_1+2} CpltSepUniformSpace.{?l_1}
                                    CpltSepUniformSpace.has_coe_to_sort.{?l_1}
                                    Y)
                                 ((@CpltSepUniformSpace.of.{?l_1}
                                     (@uniform_space.completion.{?l_1}
                                        (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                                           (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                           X)
                                        (UniformSpace.uniform_space.{?l_1} X))
                                     (@uniform_space.completion.uniform_space.{?l_1}
                                        (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                                           (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                           X)
                                        (UniformSpace.uniform_space.{?l_1} X))
                                     (UniformSpace.completion_functor._proof_1.{?l_1} X)
                                     (UniformSpace.completion_functor._proof_2.{?l_1} X)).is_uniform_space)
                                 (Y.is_uniform_space)))
                           (@UniformSpace.extension_hom.{?l_1} X Y
                              ((λ (_x _x_1 _x_2 : Type ?l_1) (_x_3 : uniform_space.{?l_1} _x)
                                (_x_4 : uniform_space.{?l_1} _x_1) (_x_5 : uniform_space.{?l_1} _x_2)
                                (g :
                                  @subtype.{?l_1+1} (_x_1 → _x_2)
                                    (@uniform_continuous.{?l_1 ?l_1} _x_1 _x_2 _x_4 _x_5))
                                (f :
                                  @subtype.{?l_1+1} (_x → _x_1) (@uniform_continuous.{?l_1 ?l_1} _x _x_1 _x_3 _x_4)),
                                  @subtype.mk.{?l_1+1} (_x → _x_2) (@uniform_continuous.{?l_1 ?l_1} _x _x_2 _x_3 _x_5)
                                    (@function.comp.{?l_1+1 ?l_1+1 ?l_1+1} _x _x_1 _x_2
                                       (@subtype.val.{?l_1+1} (_x_1 → _x_2)
                                          (@uniform_continuous.{?l_1 ?l_1} _x_1 _x_2 _x_4 _x_5)
                                          g)
                                       (@subtype.val.{?l_1+1} (_x → _x_1)
                                          (@uniform_continuous.{?l_1 ?l_1} _x _x_1 _x_3 _x_4)
                                          f))
                                    (@category_theory.unbundled_hom.bundled_hom._proof_2.{?l_1} uniform_space.{?l_1}
                                       uniform_continuous.{?l_1 ?l_1}
                                       UniformSpace.concrete_category_uniform_continuous.{?l_1}
                                       _x
                                       _x_1
                                       _x_2
                                       _x_3
                                       _x_4
                                       _x_5
                                       g
                                       f))
                                 (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                    (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                    X)
                                 (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                    (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                    (CpltSepUniformSpace.to_UniformSpace.{?l_1}
                                       (@CpltSepUniformSpace.of.{?l_1}
                                          (@uniform_space.completion.{?l_1}
                                             (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                                                (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1}
                                                   uniform_space.{?l_1})
                                                X)
                                             (UniformSpace.uniform_space.{?l_1} X))
                                          (@uniform_space.completion.uniform_space.{?l_1}
                                             (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                                                (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1}
                                                   uniform_space.{?l_1})
                                                X)
                                             (UniformSpace.uniform_space.{?l_1} X))
                                          (UniformSpace.completion_functor._proof_1.{?l_1} X)
                                          (UniformSpace.completion_functor._proof_2.{?l_1} X))))
                                 (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                                    (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                    (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
                                 (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                                 ((@CpltSepUniformSpace.of.{?l_1}
                                     (@uniform_space.completion.{?l_1}
                                        (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                                           (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                           X)
                                        (UniformSpace.uniform_space.{?l_1} X))
                                     (@uniform_space.completion.uniform_space.{?l_1}
                                        (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                                           (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                           X)
                                        (UniformSpace.uniform_space.{?l_1} X))
                                     (UniformSpace.completion_functor._proof_1.{?l_1} X)
                                     (UniformSpace.completion_functor._proof_2.{?l_1} X)).is_uniform_space)
                                 (Y.is_uniform_space)
                                 f
                                 (UniformSpace.completion_hom.{?l_1} X)))
                           f)
                        (@eq.{?l_1+1}
                           (@subtype.{?l_1+1}
                              (@coe_sort.{?l_1+2 ?l_1+2} CpltSepUniformSpace.{?l_1}
                                 CpltSepUniformSpace.has_coe_to_sort.{?l_1}
                                 (@CpltSepUniformSpace.of.{?l_1}
                                    (@uniform_space.completion.{?l_1}
                                       (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                                          (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                          X)
                                       (UniformSpace.uniform_space.{?l_1} X))
                                    (@uniform_space.completion.uniform_space.{?l_1}
                                       (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                                          (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                                          X)
                                       (UniformSpace.uniform_space.{?l_1} X))
                                    (UniformSpace.completion_functor._proof_1.{?l_1} X)
                                    (UniformSpace.completion_functor._proof_2.{?l_1} X)) →
                               …)
                              …)
                           f
                           f)
                        …
                        …))
                …))
          …)
       x)
    …'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='X X&#x27; : UniformSpace.{?l_1},
Y : CpltSepUniformSpace.{?l_1},
f :
  (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
     (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
        @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
       (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
       (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
       (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
       (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y))
    X
    X&#x27;,
g :
  (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
     (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
        @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
       (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
       (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
       (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
       (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y))
    X&#x27;
    (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y),
x :
  @coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
    (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
    (CpltSepUniformSpace.to_UniformSpace.{?l_1}
       ((λ (X : UniformSpace.{?l_1}),
           @CpltSepUniformSpace.of.{?l_1}
             (@uniform_space.completion.{?l_1}
                (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                   (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                   X)
                (UniformSpace.uniform_space.{?l_1} X))
             (@uniform_space.completion.uniform_space.{?l_1}
                (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                   (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                   X)
                (UniformSpace.uniform_space.{?l_1} X))
             (UniformSpace.completion_functor._proof_1.{?l_1} X)
             (UniformSpace.completion_functor._proof_2.{?l_1} X))
          X))
⊢ @eq.{?l_1+1}
    (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
       (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
       (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
    (@uniform_space.completion.extension.{?l_1 ?l_1}
       (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
          (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
          X)
       (UniformSpace.uniform_space.{?l_1} X)
       (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
          (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
          (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
       (UniformSpace.uniform_space.{?l_1} (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
       (@coe_fn.{?l_1+1 ?l_1+1}
          (@category_theory.has_hom.hom.{?l_1 ?l_1+1} UniformSpace.{?l_1}
             (@category_theory.category_struct.to_has_hom.{?l_1 ?l_1+1} UniformSpace.{?l_1}
                (@category_theory.category.to_category_struct.{?l_1 ?l_1+1} UniformSpace.{?l_1}
                   (@category_theory.bundled_hom.category.{?l_1} uniform_space.{?l_1}
                      (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                         @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                      (@category_theory.unbundled_hom.bundled_hom.{?l_1} uniform_space.{?l_1}
                         uniform_continuous.{?l_1 ?l_1}
                         UniformSpace.concrete_category_uniform_continuous.{?l_1}))))
             X
             (@category_theory.functor.obj.{?l_1 ?l_1 ?l_1+1 ?l_1+1} CpltSepUniformSpace.{?l_1}
                (@category_theory.concrete_category.to_category.{?l_1} CpltSepUniformSpace.{?l_1}
                   CpltSepUniformSpace.concrete_category.{?l_1})
                UniformSpace.{?l_1}
                (@category_theory.concrete_category.to_category.{?l_1} UniformSpace.{?l_1}
                   (@category_theory.bundled_hom.category_theory.concrete_category.{?l_1} uniform_space.{?l_1}
                      (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                         @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                      (@category_theory.unbundled_hom.bundled_hom.{?l_1} uniform_space.{?l_1}
                         uniform_continuous.{?l_1 ?l_1}
                         UniformSpace.concrete_category_uniform_continuous.{?l_1})))
                (@category_theory.forget₂.{?l_1} CpltSepUniformSpace.{?l_1} UniformSpace.{?l_1}
                   CpltSepUniformSpace.concrete_category.{?l_1}
                   (@category_theory.bundled_hom.category_theory.concrete_category.{?l_1} uniform_space.{?l_1}
                      (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                         @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                      (@category_theory.unbundled_hom.bundled_hom.{?l_1} uniform_space.{?l_1}
                         uniform_continuous.{?l_1 ?l_1}
                         UniformSpace.concrete_category_uniform_continuous.{?l_1}))
                   CpltSepUniformSpace.has_forget_to_UniformSpace.{?l_1})
                Y))
          (UniformSpace.has_coe_to_fun.{?l_1} X
             (@category_theory.functor.obj.{?l_1 ?l_1 ?l_1+1 ?l_1+1} CpltSepUniformSpace.{?l_1}
                (@category_theory.concrete_category.to_category.{?l_1} CpltSepUniformSpace.{?l_1}
                   CpltSepUniformSpace.concrete_category.{?l_1})
                UniformSpace.{?l_1}
                (@category_theory.concrete_category.to_category.{?l_1} UniformSpace.{?l_1}
                   (@category_theory.bundled_hom.category_theory.concrete_category.{?l_1} uniform_space.{?l_1}
                      (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                         @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                      (@category_theory.unbundled_hom.bundled_hom.{?l_1} uniform_space.{?l_1}
                         uniform_continuous.{?l_1 ?l_1}
                         UniformSpace.concrete_category_uniform_continuous.{?l_1})))
                (@category_theory.forget₂.{?l_1} CpltSepUniformSpace.{?l_1} UniformSpace.{?l_1}
                   CpltSepUniformSpace.concrete_category.{?l_1}
                   (@category_theory.bundled_hom.category_theory.concrete_category.{?l_1} uniform_space.{?l_1}
                      (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                         @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                      (@category_theory.unbundled_hom.bundled_hom.{?l_1} uniform_space.{?l_1}
                         uniform_continuous.{?l_1 ?l_1}
                         UniformSpace.concrete_category_uniform_continuous.{?l_1}))
                   CpltSepUniformSpace.has_forget_to_UniformSpace.{?l_1})
                Y))
          (@category_theory.bundled_hom.comp.{?l_1} uniform_space.{?l_1}
             (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{?l_1} uniform_space.{?l_1} uniform_continuous.{?l_1 ?l_1}
                UniformSpace.concrete_category_uniform_continuous.{?l_1})
             (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                X)
             (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                X&#x27;)
             (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
             (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
             (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X&#x27;)
             (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1}
                (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
             g
             f))
       x)
    (@uniform_space.completion.extension.{?l_1 ?l_1}
       (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
          (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
          X&#x27;)
       (UniformSpace.uniform_space.{?l_1} X&#x27;)
       (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
          (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
          (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
       (UniformSpace.uniform_space.{?l_1} (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
       (@coe_fn.{?l_1+1 ?l_1+1}
          (@category_theory.has_hom.hom.{?l_1 ?l_1+1} UniformSpace.{?l_1}
             (@category_theory.category_struct.to_has_hom.{?l_1 ?l_1+1} UniformSpace.{?l_1}
                (@category_theory.category.to_category_struct.{?l_1 ?l_1+1} UniformSpace.{?l_1}
                   (@category_theory.bundled_hom.category.{?l_1} uniform_space.{?l_1}
                      (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                         @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                      (@category_theory.unbundled_hom.bundled_hom.{?l_1} uniform_space.{?l_1}
                         uniform_continuous.{?l_1 ?l_1}
                         UniformSpace.concrete_category_uniform_continuous.{?l_1}))))
             X&#x27;
             (@category_theory.functor.obj.{?l_1 ?l_1 ?l_1+1 ?l_1+1} CpltSepUniformSpace.{?l_1}
                (@category_theory.concrete_category.to_category.{?l_1} CpltSepUniformSpace.{?l_1}
                   CpltSepUniformSpace.concrete_category.{?l_1})
                UniformSpace.{?l_1}
                (@category_theory.concrete_category.to_category.{?l_1} UniformSpace.{?l_1}
                   (@category_theory.bundled_hom.category_theory.concrete_category.{?l_1} uniform_space.{?l_1}
                      (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                         @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                      (@category_theory.unbundled_hom.bundled_hom.{?l_1} uniform_space.{?l_1}
                         uniform_continuous.{?l_1 ?l_1}
                         UniformSpace.concrete_category_uniform_continuous.{?l_1})))
                (@category_theory.forget₂.{?l_1} CpltSepUniformSpace.{?l_1} UniformSpace.{?l_1}
                   CpltSepUniformSpace.concrete_category.{?l_1}
                   (@category_theory.bundled_hom.category_theory.concrete_category.{?l_1} uniform_space.{?l_1}
                      (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                         @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                      (@category_theory.unbundled_hom.bundled_hom.{?l_1} uniform_space.{?l_1}
                         uniform_continuous.{?l_1 ?l_1}
                         UniformSpace.concrete_category_uniform_continuous.{?l_1}))
                   CpltSepUniformSpace.has_forget_to_UniformSpace.{?l_1})
                Y))
          (UniformSpace.has_coe_to_fun.{?l_1} X&#x27;
             (@category_theory.functor.obj.{?l_1 ?l_1 ?l_1+1 ?l_1+1} CpltSepUniformSpace.{?l_1}
                (@category_theory.concrete_category.to_category.{?l_1} CpltSepUniformSpace.{?l_1}
                   CpltSepUniformSpace.concrete_category.{?l_1})
                UniformSpace.{?l_1}
                (@category_theory.concrete_category.to_category.{?l_1} UniformSpace.{?l_1}
                   (@category_theory.bundled_hom.category_theory.concrete_category.{?l_1} uniform_space.{?l_1}
                      (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                         @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                      (@category_theory.unbundled_hom.bundled_hom.{?l_1} uniform_space.{?l_1}
                         uniform_continuous.{?l_1 ?l_1}
                         UniformSpace.concrete_category_uniform_continuous.{?l_1})))
                (@category_theory.forget₂.{?l_1} CpltSepUniformSpace.{?l_1} UniformSpace.{?l_1}
                   CpltSepUniformSpace.concrete_category.{?l_1}
                   (@category_theory.bundled_hom.category_theory.concrete_category.{?l_1} uniform_space.{?l_1}
                      (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                         @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                      (@category_theory.unbundled_hom.bundled_hom.{?l_1} uniform_space.{?l_1}
                         uniform_continuous.{?l_1 ?l_1}
                         UniformSpace.concrete_category_uniform_continuous.{?l_1}))
                   CpltSepUniformSpace.has_forget_to_UniformSpace.{?l_1})
                Y))
          g)
       (@coe_fn.{?l_1+1 ?l_1+1}
          (@category_theory.has_hom.hom.{?l_1 ?l_1+1} UniformSpace.{?l_1}
             (@category_theory.category_struct.to_has_hom.{?l_1 ?l_1+1} UniformSpace.{?l_1}
                (@category_theory.category.to_category_struct.{?l_1 ?l_1+1} UniformSpace.{?l_1}
                   (@category_theory.bundled_hom.category.{?l_1} uniform_space.{?l_1}
                      (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                         @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                      (@category_theory.unbundled_hom.bundled_hom.{?l_1} uniform_space.{?l_1}
                         uniform_continuous.{?l_1 ?l_1}
                         UniformSpace.concrete_category_uniform_continuous.{?l_1}))))
             (CpltSepUniformSpace.to_UniformSpace.{?l_1}
                (@CpltSepUniformSpace.of.{?l_1}
                   (@uniform_space.completion.{?l_1}
                      (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                         (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                         X)
                      (UniformSpace.uniform_space.{?l_1} X))
                   (@uniform_space.completion.uniform_space.{?l_1}
                      (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                         (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                         X)
                      (UniformSpace.uniform_space.{?l_1} X))
                   (UniformSpace.completion_functor._proof_1.{?l_1} X)
                   (UniformSpace.completion_functor._proof_2.{?l_1} X)))
             (CpltSepUniformSpace.to_UniformSpace.{?l_1}
                (@CpltSepUniformSpace.of.{?l_1}
                   (@uniform_space.completion.{?l_1}
                      (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                         (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                         X&#x27;)
                      (UniformSpace.uniform_space.{?l_1} X&#x27;))
                   (@uniform_space.completion.uniform_space.{?l_1}
                      (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                         (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                         X&#x27;)
                      (UniformSpace.uniform_space.{?l_1} X&#x27;))
                   (UniformSpace.completion_functor._proof_1.{?l_1} X&#x27;)
                   (UniformSpace.completion_functor._proof_2.{?l_1} X&#x27;))))
          (UniformSpace.has_coe_to_fun.{?l_1}
             (CpltSepUniformSpace.to_UniformSpace.{?l_1}
                (@CpltSepUniformSpace.of.{?l_1}
                   (@uniform_space.completion.{?l_1}
                      (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                         (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                         X)
                      (UniformSpace.uniform_space.{?l_1} X))
                   (@uniform_space.completion.uniform_space.{?l_1}
                      (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                         (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                         X)
                      (UniformSpace.uniform_space.{?l_1} X))
                   (UniformSpace.completion_functor._proof_1.{?l_1} X)
                   (UniformSpace.completion_functor._proof_2.{?l_1} X)))
             (CpltSepUniformSpace.to_UniformSpace.{?l_1}
                (@CpltSepUniformSpace.of.{?l_1}
                   (@uniform_space.completion.{?l_1}
                      (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                         (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                         X&#x27;)
                      (UniformSpace.uniform_space.{?l_1} X&#x27;))
                   (@uniform_space.completion.uniform_space.{?l_1}
                      (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                         (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                         X&#x27;)
                      (UniformSpace.uniform_space.{?l_1} X&#x27;))
                   (UniformSpace.completion_functor._proof_1.{?l_1} X&#x27;)
                   (UniformSpace.completion_functor._proof_2.{?l_1} X&#x27;))))
          (@subtype.mk.{?l_1+1}
             (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1}
                (CpltSepUniformSpace.to_UniformSpace.{?l_1}
                   (@CpltSepUniformSpace.of.{?l_1}
                      (@uniform_space.completion.{?l_1}
                         (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                            (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                            X)
                         (UniformSpace.uniform_space.{?l_1} X))
                      (@uniform_space.completion.uniform_space.{?l_1}
                         (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                            (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                            X)
                         (UniformSpace.uniform_space.{?l_1} X))
                      (UniformSpace.completion_functor._proof_3.{?l_1} X)
                      (UniformSpace.completion_functor._proof_4.{?l_1} X))) →
              @category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1}
                (CpltSepUniformSpace.to_UniformSpace.{?l_1}
                   (@CpltSepUniformSpace.of.{?l_1}
                      (@uniform_space.completion.{?l_1}
                         (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                            (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                            X&#x27;)
                         (UniformSpace.uniform_space.{?l_1} X&#x27;))
                      (@uniform_space.completion.uniform_space.{?l_1}
                         (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                            (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                            X&#x27;)
                         (UniformSpace.uniform_space.{?l_1} X&#x27;))
                      (UniformSpace.completion_functor._proof_5.{?l_1} X&#x27;)
                      (UniformSpace.completion_functor._proof_6.{?l_1} X&#x27;))))
             (@uniform_continuous.{?l_1 ?l_1}
                (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1}
                   (CpltSepUniformSpace.to_UniformSpace.{?l_1}
                      (@CpltSepUniformSpace.of.{?l_1}
                         (@uniform_space.completion.{?l_1}
                            (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                               (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                               X)
                            (UniformSpace.uniform_space.{?l_1} X))
                         (@uniform_space.completion.uniform_space.{?l_1}
                            (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                               (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                               X)
                            (UniformSpace.uniform_space.{?l_1} X))
                         (UniformSpace.completion_functor._proof_3.{?l_1} X)
                         (UniformSpace.completion_functor._proof_4.{?l_1} X))))
                (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1}
                   (CpltSepUniformSpace.to_UniformSpace.{?l_1}
                      (@CpltSepUniformSpace.of.{?l_1}
                         (@uniform_space.completion.{?l_1}
                            (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                               (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                               X&#x27;)
                            (UniformSpace.uniform_space.{?l_1} X&#x27;))
                         (@uniform_space.completion.uniform_space.{?l_1}
                            (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                               (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                               X&#x27;)
                            (UniformSpace.uniform_space.{?l_1} X&#x27;))
                         (UniformSpace.completion_functor._proof_5.{?l_1} X&#x27;)
                         (UniformSpace.completion_functor._proof_6.{?l_1} X&#x27;))))
                (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1}
                   (CpltSepUniformSpace.to_UniformSpace.{?l_1}
                      (@CpltSepUniformSpace.of.{?l_1}
                         (@uniform_space.completion.{?l_1}
                            (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                               (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                               X)
                            (UniformSpace.uniform_space.{?l_1} X))
                         (@uniform_space.completion.uniform_space.{?l_1}
                            (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                               (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                               X)
                            (UniformSpace.uniform_space.{?l_1} X))
                         (UniformSpace.completion_functor._proof_3.{?l_1} X)
                         (UniformSpace.completion_functor._proof_4.{?l_1} X))))
                (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1}
                   (CpltSepUniformSpace.to_UniformSpace.{?l_1}
                      (@CpltSepUniformSpace.of.{?l_1}
                         (@uniform_space.completion.{?l_1}
                            (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                               (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                               X&#x27;)
                            (UniformSpace.uniform_space.{?l_1} X&#x27;))
                         (@uniform_space.completion.uniform_space.{?l_1}
                            (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                               (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                               X&#x27;)
                            (UniformSpace.uniform_space.{?l_1} X&#x27;))
                         (UniformSpace.completion_functor._proof_5.{?l_1} X&#x27;)
                         (UniformSpace.completion_functor._proof_6.{?l_1} X&#x27;)))))
             (@uniform_space.completion.map.{?l_1 ?l_1}
                (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                   (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                   X)
                (UniformSpace.uniform_space.{?l_1} X)
                (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                   (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                   X&#x27;)
                (UniformSpace.uniform_space.{?l_1} X&#x27;)
                (@subtype.val.{?l_1+1}
                   (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X →
                    @category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X&#x27;)
                   (@uniform_continuous.{?l_1 ?l_1} (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                      (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X&#x27;)
                      (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                      (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X&#x27;))
                   f))
             (@UniformSpace.completion_functor._proof_7.{?l_1} X X&#x27; f))
          x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>151      erw [coe_comp, ←completion.extension_map],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='UniformSpace.coe_comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='uniform_space.completion.extension_map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 43, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/completion.lean&#x27;, &#x27;line&#x27;: 494, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {X Y Z : UniformSpace.{u_1}} (f : @category_theory.has_hom.hom.{u_1 u_1+1} UniformSpace.{u_1} (@category_theory.category_struct.to_has_hom.{u_1 u_1+1} UniformSpace.{u_1} (@category_theory.category.to_category_struct.{u_1 u_1+1} UniformSpace.{u_1} (@category_theory.bundled_hom.category.{u_1} uniform_space.{u_1} (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β), @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ)) (@category_theory.unbundled_hom.bundled_hom.{u_1} (λ (α : Type u_1), uniform_space.{u_1} α) uniform_continuous.{u_1 u_1} UniformSpace.concrete_category_uniform_continuous.{u_1})))) X Y) (g : @category_theory.has_hom.hom.{u_1 u_1+1} UniformSpace.{u_1} (@category_theory.category_struct.to_has_hom.{u_1 u_1+1} UniformSpace.{u_1} (@category_theory.category.to_category_struct.{u_1 u_1+1} UniformSpace.{u_1} (@category_theory.bundled_hom.category.{u_1} uniform_space.{u_1} (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β), @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ)) (@category_theory.unbundled_hom.bundled_hom.{u_1} (λ (α : Type u_1), uniform_space.{u_1} α) uniform_continuous.{u_1 u_1} UniformSpace.concrete_category_uniform_continuous.{u_1})))) Y Z), @eq.{u_1+1} (@has_coe_to_fun.F.{u_1+1 u_1+1} (@category_theory.has_hom.hom.{u_1 u_1+1} UniformSpace.{u_1} (@category_theory.category_struct.to_has_hom.{u_1 u_1+1} UniformSpace.{u_1} (@category_theory.category.to_category_struct.{u_1 u_1+1} UniformSpace.{u_1} (@category_theory.bundled_hom.category.{u_1} uniform_space.{u_1} (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β), @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ)) (@category_theory.unbundled_hom.bundled_hom.{u_1} (λ (α : Type u_1), uniform_space.{u_1} α) uniform_continuous.{u_1 u_1} UniformSpace.concrete_category_uniform_continuous.{u_1})))) X Z) (UniformSpace.has_coe_to_fun.{u_1} X Z) (@category_theory.category_struct.comp.{u_1 u_1+1} UniformSpace.{u_1} (@category_theory.category.to_category_struct.{u_1 u_1+1} UniformSpace.{u_1} (@category_theory.bundled_hom.category.{u_1} uniform_space.{u_1} (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β), @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ)) (@category_theory.unbundled_hom.bundled_hom.{u_1} (λ (α : Type u_1), uniform_space.{u_1} α) uniform_continuous.{u_1 u_1} UniformSpace.concrete_category_uniform_continuous.{u_1}))) X Y Z f g)) (@coe_fn.{u_1+1 u_1+1} (@category_theory.has_hom.hom.{u_1 u_1+1} UniformSpace.{u_1} (@category_theory.category_struct.to_has_hom.{u_1 u_1+1} UniformSpace.{u_1} (@category_theory.category.to_category_struct.{u_1 u_1+1} UniformSpace.{u_1} (@category_theory.bundled_hom.category.{u_1} uniform_space.{u_1} (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β), @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ)) (@category_theory.unbundled_hom.bundled_hom.{u_1} (λ (α : Type u_1), uniform_space.{u_1} α) uniform_continuous.{u_1 u_1} UniformSpace.concrete_category_uniform_continuous.{u_1})))) X Z) (UniformSpace.has_coe_to_fun.{u_1} X Z) (@category_theory.category_struct.comp.{u_1 u_1+1} UniformSpace.{u_1} (@category_theory.category.to_category_struct.{u_1 u_1+1} UniformSpace.{u_1} (@category_theory.bundled_hom.category.{u_1} uniform_space.{u_1} (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β), @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ)) (@category_theory.unbundled_hom.bundled_hom.{u_1} (λ (α : Type u_1), uniform_space.{u_1} α) uniform_continuous.{u_1 u_1} UniformSpace.concrete_category_uniform_continuous.{u_1}))) X Y Z f g)) (@function.comp.{u_1+1 u_1+1 u_1+1} (@coe_sort.{u_1+2 u_1+2} UniformSpace.{u_1} (@category_theory.bundled.has_coe_to_sort.{u_1 u_1} uniform_space.{u_1}) X) (@coe_sort.{u_1+2 u_1+2} UniformSpace.{u_1} (@category_theory.bundled.has_coe_to_sort.{u_1 u_1} uniform_space.{u_1}) Y) (@coe_sort.{u_1+2 u_1+2} UniformSpace.{u_1} (@category_theory.bundled.has_coe_to_sort.{u_1 u_1} uniform_space.{u_1}) Z) (@coe_fn.{u_1+1 u_1+1} (@category_theory.has_hom.hom.{u_1 u_1+1} UniformSpace.{u_1} (@category_theory.category_struct.to_has_hom.{u_1 u_1+1} UniformSpace.{u_1} (@category_theory.category.to_category_struct.{u_1 u_1+1} UniformSpace.{u_1} (@category_theory.bundled_hom.category.{u_1} uniform_space.{u_1} (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β), @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ)) (@category_theory.unbundled_hom.bundled_hom.{u_1} (λ (α : Type u_1), uniform_space.{u_1} α) uniform_continuous.{u_1 u_1} UniformSpace.concrete_category_uniform_continuous.{u_1})))) Y Z) (UniformSpace.has_coe_to_fun.{u_1} Y Z) g) (@coe_fn.{u_1+1 u_1+1} (@category_theory.has_hom.hom.{u_1 u_1+1} UniformSpace.{u_1} (@category_theory.category_struct.to_has_hom.{u_1 u_1+1} UniformSpace.{u_1} (@category_theory.category.to_category_struct.{u_1 u_1+1} UniformSpace.{u_1} (@category_theory.bundled_hom.category.{u_1} uniform_space.{u_1} (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β), @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ)) (@category_theory.unbundled_hom.bundled_hom.{u_1} (λ (α : Type u_1), uniform_space.{u_1} α) uniform_continuous.{u_1 u_1} UniformSpace.concrete_category_uniform_continuous.{u_1})))) X Y) (UniformSpace.has_coe_to_fun.{u_1} X Y) f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : uniform_space.{u_1} α] {β : Type u_1} [_inst_2 : uniform_space.{u_1} β] {γ : Type u_1} [_inst_3 : uniform_space.{u_1} γ] [_inst_4 : @complete_space.{u_1} γ _inst_3] [_inst_5 : @separated.{u_1} γ _inst_3] {f : β → γ} {g : α → β}, @uniform_continuous.{u_1 u_1} β γ _inst_2 _inst_3 f → @uniform_continuous.{u_1 u_1} α β _inst_1 _inst_2 g → @eq.{u_1+1} (@uniform_space.completion.{u_1} α _inst_1 → γ) (@function.comp.{u_1+1 u_1+1 u_1+1} (@uniform_space.completion.{u_1} α _inst_1) (@uniform_space.completion.{u_1} β _inst_2) γ (@uniform_space.completion.extension.{u_1 u_1} β _inst_2 γ _inst_3 f) (@uniform_space.completion.map.{u_1 u_1} α _inst_1 β _inst_2 g)) (@uniform_space.completion.extension.{u_1 u_1} α _inst_1 γ _inst_3 (@function.comp.{u_1+1 u_1+1 u_1+1} α β γ f g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='X X&#x27; : UniformSpace.{?l_1},
Y : CpltSepUniformSpace.{?l_1},
f :
  (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
     (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
        @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
       (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
       (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
       (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
       (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y))
    X
    X&#x27;,
g :
  (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
     (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
        @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
       (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
       (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
       (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
       (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y))
    X&#x27;
    (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y),
x :
  @coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
    (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
    (CpltSepUniformSpace.to_UniformSpace.{?l_1}
       ((λ (X : UniformSpace.{?l_1}),
           @CpltSepUniformSpace.of.{?l_1}
             (@uniform_space.completion.{?l_1}
                (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                   (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                   X)
                (UniformSpace.uniform_space.{?l_1} X))
             (@uniform_space.completion.uniform_space.{?l_1}
                (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                   (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                   X)
                (UniformSpace.uniform_space.{?l_1} X))
             (UniformSpace.completion_functor._proof_1.{?l_1} X)
             (UniformSpace.completion_functor._proof_2.{?l_1} X))
          X))
⊢ @eq.{?l_1+1}
    (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
       (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
       (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
    (@uniform_space.completion.extension.{?l_1 ?l_1}
       (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
          (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
          X)
       (UniformSpace.uniform_space.{?l_1} X)
       (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
          (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
          (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
       (UniformSpace.uniform_space.{?l_1} (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
       (@coe_fn.{?l_1+1 ?l_1+1}
          (@category_theory.has_hom.hom.{?l_1 ?l_1+1} UniformSpace.{?l_1}
             (@category_theory.category_struct.to_has_hom.{?l_1 ?l_1+1} UniformSpace.{?l_1}
                (@category_theory.category.to_category_struct.{?l_1 ?l_1+1} UniformSpace.{?l_1}
                   (@category_theory.bundled_hom.category.{?l_1} uniform_space.{?l_1}
                      (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                         @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                      (@category_theory.unbundled_hom.bundled_hom.{?l_1} uniform_space.{?l_1}
                         uniform_continuous.{?l_1 ?l_1}
                         UniformSpace.concrete_category_uniform_continuous.{?l_1}))))
             X
             (@category_theory.functor.obj.{?l_1 ?l_1 ?l_1+1 ?l_1+1} CpltSepUniformSpace.{?l_1}
                (@category_theory.concrete_category.to_category.{?l_1} CpltSepUniformSpace.{?l_1}
                   CpltSepUniformSpace.concrete_category.{?l_1})
                UniformSpace.{?l_1}
                (@category_theory.concrete_category.to_category.{?l_1} UniformSpace.{?l_1}
                   (@category_theory.bundled_hom.category_theory.concrete_category.{?l_1} uniform_space.{?l_1}
                      (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                         @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                      (@category_theory.unbundled_hom.bundled_hom.{?l_1} uniform_space.{?l_1}
                         uniform_continuous.{?l_1 ?l_1}
                         UniformSpace.concrete_category_uniform_continuous.{?l_1})))
                (@category_theory.forget₂.{?l_1} CpltSepUniformSpace.{?l_1} UniformSpace.{?l_1}
                   CpltSepUniformSpace.concrete_category.{?l_1}
                   (@category_theory.bundled_hom.category_theory.concrete_category.{?l_1} uniform_space.{?l_1}
                      (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                         @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                      (@category_theory.unbundled_hom.bundled_hom.{?l_1} uniform_space.{?l_1}
                         uniform_continuous.{?l_1 ?l_1}
                         UniformSpace.concrete_category_uniform_continuous.{?l_1}))
                   CpltSepUniformSpace.has_forget_to_UniformSpace.{?l_1})
                Y))
          (UniformSpace.has_coe_to_fun.{?l_1} X
             (@category_theory.functor.obj.{?l_1 ?l_1 ?l_1+1 ?l_1+1} CpltSepUniformSpace.{?l_1}
                (@category_theory.concrete_category.to_category.{?l_1} CpltSepUniformSpace.{?l_1}
                   CpltSepUniformSpace.concrete_category.{?l_1})
                UniformSpace.{?l_1}
                (@category_theory.concrete_category.to_category.{?l_1} UniformSpace.{?l_1}
                   (@category_theory.bundled_hom.category_theory.concrete_category.{?l_1} uniform_space.{?l_1}
                      (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                         @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                      (@category_theory.unbundled_hom.bundled_hom.{?l_1} uniform_space.{?l_1}
                         uniform_continuous.{?l_1 ?l_1}
                         UniformSpace.concrete_category_uniform_continuous.{?l_1})))
                (@category_theory.forget₂.{?l_1} CpltSepUniformSpace.{?l_1} UniformSpace.{?l_1}
                   CpltSepUniformSpace.concrete_category.{?l_1}
                   (@category_theory.bundled_hom.category_theory.concrete_category.{?l_1} uniform_space.{?l_1}
                      (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                         @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                      (@category_theory.unbundled_hom.bundled_hom.{?l_1} uniform_space.{?l_1}
                         uniform_continuous.{?l_1 ?l_1}
                         UniformSpace.concrete_category_uniform_continuous.{?l_1}))
                   CpltSepUniformSpace.has_forget_to_UniformSpace.{?l_1})
                Y))
          (@category_theory.bundled_hom.comp.{?l_1} uniform_space.{?l_1}
             (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
             (@category_theory.unbundled_hom.bundled_hom.{?l_1} uniform_space.{?l_1} uniform_continuous.{?l_1 ?l_1}
                UniformSpace.concrete_category_uniform_continuous.{?l_1})
             (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                X)
             (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                X&#x27;)
             (@coe_sort.{?l_1+2 ?l_1+2} (category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1})
                (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
             (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
             (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X&#x27;)
             (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1}
                (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
             g
             f))
       x)
    (@uniform_space.completion.extension.{?l_1 ?l_1}
       (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
          (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
          X&#x27;)
       (UniformSpace.uniform_space.{?l_1} X&#x27;)
       (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
          (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
          (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
       (UniformSpace.uniform_space.{?l_1} (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
       (@coe_fn.{?l_1+1 ?l_1+1}
          (@category_theory.has_hom.hom.{?l_1 ?l_1+1} UniformSpace.{?l_1}
             (@category_theory.category_struct.to_has_hom.{?l_1 ?l_1+1} UniformSpace.{?l_1}
                (@category_theory.category.to_category_struct.{?l_1 ?l_1+1} UniformSpace.{?l_1}
                   (@category_theory.bundled_hom.category.{?l_1} uniform_space.{?l_1}
                      (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                         @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                      (@category_theory.unbundled_hom.bundled_hom.{?l_1} uniform_space.{?l_1}
                         uniform_continuous.{?l_1 ?l_1}
                         UniformSpace.concrete_category_uniform_continuous.{?l_1}))))
             X&#x27;
             (@category_theory.functor.obj.{?l_1 ?l_1 ?l_1+1 ?l_1+1} CpltSepUniformSpace.{?l_1}
                (@category_theory.concrete_category.to_category.{?l_1} CpltSepUniformSpace.{?l_1}
                   CpltSepUniformSpace.concrete_category.{?l_1})
                UniformSpace.{?l_1}
                (@category_theory.concrete_category.to_category.{?l_1} UniformSpace.{?l_1}
                   (@category_theory.bundled_hom.category_theory.concrete_category.{?l_1} uniform_space.{?l_1}
                      (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                         @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                      (@category_theory.unbundled_hom.bundled_hom.{?l_1} uniform_space.{?l_1}
                         uniform_continuous.{?l_1 ?l_1}
                         UniformSpace.concrete_category_uniform_continuous.{?l_1})))
                (@category_theory.forget₂.{?l_1} CpltSepUniformSpace.{?l_1} UniformSpace.{?l_1}
                   CpltSepUniformSpace.concrete_category.{?l_1}
                   (@category_theory.bundled_hom.category_theory.concrete_category.{?l_1} uniform_space.{?l_1}
                      (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                         @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                      (@category_theory.unbundled_hom.bundled_hom.{?l_1} uniform_space.{?l_1}
                         uniform_continuous.{?l_1 ?l_1}
                         UniformSpace.concrete_category_uniform_continuous.{?l_1}))
                   CpltSepUniformSpace.has_forget_to_UniformSpace.{?l_1})
                Y))
          (UniformSpace.has_coe_to_fun.{?l_1} X&#x27;
             (@category_theory.functor.obj.{?l_1 ?l_1 ?l_1+1 ?l_1+1} CpltSepUniformSpace.{?l_1}
                (@category_theory.concrete_category.to_category.{?l_1} CpltSepUniformSpace.{?l_1}
                   CpltSepUniformSpace.concrete_category.{?l_1})
                UniformSpace.{?l_1}
                (@category_theory.concrete_category.to_category.{?l_1} UniformSpace.{?l_1}
                   (@category_theory.bundled_hom.category_theory.concrete_category.{?l_1} uniform_space.{?l_1}
                      (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                         @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                      (@category_theory.unbundled_hom.bundled_hom.{?l_1} uniform_space.{?l_1}
                         uniform_continuous.{?l_1 ?l_1}
                         UniformSpace.concrete_category_uniform_continuous.{?l_1})))
                (@category_theory.forget₂.{?l_1} CpltSepUniformSpace.{?l_1} UniformSpace.{?l_1}
                   CpltSepUniformSpace.concrete_category.{?l_1}
                   (@category_theory.bundled_hom.category_theory.concrete_category.{?l_1} uniform_space.{?l_1}
                      (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                         @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                      (@category_theory.unbundled_hom.bundled_hom.{?l_1} uniform_space.{?l_1}
                         uniform_continuous.{?l_1 ?l_1}
                         UniformSpace.concrete_category_uniform_continuous.{?l_1}))
                   CpltSepUniformSpace.has_forget_to_UniformSpace.{?l_1})
                Y))
          g)
       (@coe_fn.{?l_1+1 ?l_1+1}
          (@category_theory.has_hom.hom.{?l_1 ?l_1+1} UniformSpace.{?l_1}
             (@category_theory.category_struct.to_has_hom.{?l_1 ?l_1+1} UniformSpace.{?l_1}
                (@category_theory.category.to_category_struct.{?l_1 ?l_1+1} UniformSpace.{?l_1}
                   (@category_theory.bundled_hom.category.{?l_1} uniform_space.{?l_1}
                      (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                         @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                      (@category_theory.unbundled_hom.bundled_hom.{?l_1} uniform_space.{?l_1}
                         uniform_continuous.{?l_1 ?l_1}
                         UniformSpace.concrete_category_uniform_continuous.{?l_1}))))
             (CpltSepUniformSpace.to_UniformSpace.{?l_1}
                (@CpltSepUniformSpace.of.{?l_1}
                   (@uniform_space.completion.{?l_1}
                      (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                         (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                         X)
                      (UniformSpace.uniform_space.{?l_1} X))
                   (@uniform_space.completion.uniform_space.{?l_1}
                      (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                         (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                         X)
                      (UniformSpace.uniform_space.{?l_1} X))
                   (UniformSpace.completion_functor._proof_1.{?l_1} X)
                   (UniformSpace.completion_functor._proof_2.{?l_1} X)))
             (CpltSepUniformSpace.to_UniformSpace.{?l_1}
                (@CpltSepUniformSpace.of.{?l_1}
                   (@uniform_space.completion.{?l_1}
                      (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                         (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                         X&#x27;)
                      (UniformSpace.uniform_space.{?l_1} X&#x27;))
                   (@uniform_space.completion.uniform_space.{?l_1}
                      (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                         (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                         X&#x27;)
                      (UniformSpace.uniform_space.{?l_1} X&#x27;))
                   (UniformSpace.completion_functor._proof_1.{?l_1} X&#x27;)
                   (UniformSpace.completion_functor._proof_2.{?l_1} X&#x27;))))
          (UniformSpace.has_coe_to_fun.{?l_1}
             (CpltSepUniformSpace.to_UniformSpace.{?l_1}
                (@CpltSepUniformSpace.of.{?l_1}
                   (@uniform_space.completion.{?l_1}
                      (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                         (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                         X)
                      (UniformSpace.uniform_space.{?l_1} X))
                   (@uniform_space.completion.uniform_space.{?l_1}
                      (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                         (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                         X)
                      (UniformSpace.uniform_space.{?l_1} X))
                   (UniformSpace.completion_functor._proof_1.{?l_1} X)
                   (UniformSpace.completion_functor._proof_2.{?l_1} X)))
             (CpltSepUniformSpace.to_UniformSpace.{?l_1}
                (@CpltSepUniformSpace.of.{?l_1}
                   (@uniform_space.completion.{?l_1}
                      (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                         (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                         X&#x27;)
                      (UniformSpace.uniform_space.{?l_1} X&#x27;))
                   (@uniform_space.completion.uniform_space.{?l_1}
                      (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                         (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                         X&#x27;)
                      (UniformSpace.uniform_space.{?l_1} X&#x27;))
                   (UniformSpace.completion_functor._proof_1.{?l_1} X&#x27;)
                   (UniformSpace.completion_functor._proof_2.{?l_1} X&#x27;))))
          (@subtype.mk.{?l_1+1}
             (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1}
                (CpltSepUniformSpace.to_UniformSpace.{?l_1}
                   (@CpltSepUniformSpace.of.{?l_1}
                      (@uniform_space.completion.{?l_1}
                         (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                            (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                            X)
                         (UniformSpace.uniform_space.{?l_1} X))
                      (@uniform_space.completion.uniform_space.{?l_1}
                         (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                            (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                            X)
                         (UniformSpace.uniform_space.{?l_1} X))
                      (UniformSpace.completion_functor._proof_3.{?l_1} X)
                      (UniformSpace.completion_functor._proof_4.{?l_1} X))) →
              @category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1}
                (CpltSepUniformSpace.to_UniformSpace.{?l_1}
                   (@CpltSepUniformSpace.of.{?l_1}
                      (@uniform_space.completion.{?l_1}
                         (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                            (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                            X&#x27;)
                         (UniformSpace.uniform_space.{?l_1} X&#x27;))
                      (@uniform_space.completion.uniform_space.{?l_1}
                         (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                            (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                            X&#x27;)
                         (UniformSpace.uniform_space.{?l_1} X&#x27;))
                      (UniformSpace.completion_functor._proof_5.{?l_1} X&#x27;)
                      (UniformSpace.completion_functor._proof_6.{?l_1} X&#x27;))))
             (@uniform_continuous.{?l_1 ?l_1}
                (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1}
                   (CpltSepUniformSpace.to_UniformSpace.{?l_1}
                      (@CpltSepUniformSpace.of.{?l_1}
                         (@uniform_space.completion.{?l_1}
                            (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                               (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                               X)
                            (UniformSpace.uniform_space.{?l_1} X))
                         (@uniform_space.completion.uniform_space.{?l_1}
                            (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                               (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                               X)
                            (UniformSpace.uniform_space.{?l_1} X))
                         (UniformSpace.completion_functor._proof_3.{?l_1} X)
                         (UniformSpace.completion_functor._proof_4.{?l_1} X))))
                (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1}
                   (CpltSepUniformSpace.to_UniformSpace.{?l_1}
                      (@CpltSepUniformSpace.of.{?l_1}
                         (@uniform_space.completion.{?l_1}
                            (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                               (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                               X&#x27;)
                            (UniformSpace.uniform_space.{?l_1} X&#x27;))
                         (@uniform_space.completion.uniform_space.{?l_1}
                            (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                               (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                               X&#x27;)
                            (UniformSpace.uniform_space.{?l_1} X&#x27;))
                         (UniformSpace.completion_functor._proof_5.{?l_1} X&#x27;)
                         (UniformSpace.completion_functor._proof_6.{?l_1} X&#x27;))))
                (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1}
                   (CpltSepUniformSpace.to_UniformSpace.{?l_1}
                      (@CpltSepUniformSpace.of.{?l_1}
                         (@uniform_space.completion.{?l_1}
                            (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                               (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                               X)
                            (UniformSpace.uniform_space.{?l_1} X))
                         (@uniform_space.completion.uniform_space.{?l_1}
                            (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                               (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                               X)
                            (UniformSpace.uniform_space.{?l_1} X))
                         (UniformSpace.completion_functor._proof_3.{?l_1} X)
                         (UniformSpace.completion_functor._proof_4.{?l_1} X))))
                (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1}
                   (CpltSepUniformSpace.to_UniformSpace.{?l_1}
                      (@CpltSepUniformSpace.of.{?l_1}
                         (@uniform_space.completion.{?l_1}
                            (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                               (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                               X&#x27;)
                            (UniformSpace.uniform_space.{?l_1} X&#x27;))
                         (@uniform_space.completion.uniform_space.{?l_1}
                            (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                               (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                               X&#x27;)
                            (UniformSpace.uniform_space.{?l_1} X&#x27;))
                         (UniformSpace.completion_functor._proof_5.{?l_1} X&#x27;)
                         (UniformSpace.completion_functor._proof_6.{?l_1} X&#x27;)))))
             (@uniform_space.completion.map.{?l_1 ?l_1}
                (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                   (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                   X)
                (UniformSpace.uniform_space.{?l_1} X)
                (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                   (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                   X&#x27;)
                (UniformSpace.uniform_space.{?l_1} X&#x27;)
                (@subtype.val.{?l_1+1}
                   (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X →
                    @category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X&#x27;)
                   (@uniform_continuous.{?l_1 ?l_1} (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                      (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X&#x27;)
                      (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                      (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X&#x27;))
                   f))
             (@UniformSpace.completion_functor._proof_7.{?l_1} X X&#x27; f))
          x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='X X&#x27; : UniformSpace.{?l_1},
Y : CpltSepUniformSpace.{?l_1},
f :
  (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
     (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
        @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
       (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
       (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
       (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
       (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y))
    X
    X&#x27;,
g :
  (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
     (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
        @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
       (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
       (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
       (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
       (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y))
    X&#x27;
    (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y),
x :
  @coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
    (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
    (CpltSepUniformSpace.to_UniformSpace.{?l_1}
       ((λ (X : UniformSpace.{?l_1}),
           @CpltSepUniformSpace.of.{?l_1}
             (@uniform_space.completion.{?l_1}
                (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                   (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                   X)
                (UniformSpace.uniform_space.{?l_1} X))
             (@uniform_space.completion.uniform_space.{?l_1}
                (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                   (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                   X)
                (UniformSpace.uniform_space.{?l_1} X))
             (UniformSpace.completion_functor._proof_1.{?l_1} X)
             (UniformSpace.completion_functor._proof_2.{?l_1} X))
          X))
⊢ @eq.{?l_1+1}
    (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
       (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
       (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
    (@uniform_space.completion.extension.{?l_1 ?l_1}
       (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
          (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
          X)
       (UniformSpace.uniform_space.{?l_1} X)
       (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
          (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
          (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
       (UniformSpace.uniform_space.{?l_1} (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
       (@function.comp.{?l_1+1 ?l_1+1 ?l_1+1}
          (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
             (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
             X)
          (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
             (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
             X&#x27;)
          (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
             (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
             (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
          (@coe_fn.{?l_1+1 ?l_1+1}
             (@category_theory.has_hom.hom.{?l_1 ?l_1+1} UniformSpace.{?l_1}
                (@category_theory.category_struct.to_has_hom.{?l_1 ?l_1+1} UniformSpace.{?l_1}
                   (@category_theory.category.to_category_struct.{?l_1 ?l_1+1} UniformSpace.{?l_1}
                      (@category_theory.bundled_hom.category.{?l_1} uniform_space.{?l_1}
                         (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                            @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                         (@category_theory.unbundled_hom.bundled_hom.{?l_1}
                            (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                            uniform_continuous.{?l_1 ?l_1}
                            UniformSpace.concrete_category_uniform_continuous.{?l_1}))))
                X&#x27;
                (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
             (UniformSpace.has_coe_to_fun.{?l_1} X&#x27; (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
             g)
          (@coe_fn.{?l_1+1 ?l_1+1}
             (@category_theory.has_hom.hom.{?l_1 ?l_1+1} UniformSpace.{?l_1}
                (@category_theory.category_struct.to_has_hom.{?l_1 ?l_1+1} UniformSpace.{?l_1}
                   (@category_theory.category.to_category_struct.{?l_1 ?l_1+1} UniformSpace.{?l_1}
                      (@category_theory.bundled_hom.category.{?l_1} uniform_space.{?l_1}
                         (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                            @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                         (@category_theory.unbundled_hom.bundled_hom.{?l_1}
                            (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                            uniform_continuous.{?l_1 ?l_1}
                            UniformSpace.concrete_category_uniform_continuous.{?l_1}))))
                X
                X&#x27;)
             (UniformSpace.has_coe_to_fun.{?l_1} X X&#x27;)
             f))
       x)
    (@uniform_space.completion.extension.{?l_1 ?l_1}
       (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
          (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
          X&#x27;)
       (UniformSpace.uniform_space.{?l_1} X&#x27;)
       (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
          (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
          (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
       (UniformSpace.uniform_space.{?l_1} (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
       (@coe_fn.{?l_1+1 ?l_1+1}
          (@category_theory.has_hom.hom.{?l_1 ?l_1+1} UniformSpace.{?l_1}
             (@category_theory.category_struct.to_has_hom.{?l_1 ?l_1+1} UniformSpace.{?l_1}
                (@category_theory.category.to_category_struct.{?l_1 ?l_1+1} UniformSpace.{?l_1}
                   (@category_theory.bundled_hom.category.{?l_1} uniform_space.{?l_1}
                      (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                         @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                      (@category_theory.unbundled_hom.bundled_hom.{?l_1} uniform_space.{?l_1}
                         uniform_continuous.{?l_1 ?l_1}
                         UniformSpace.concrete_category_uniform_continuous.{?l_1}))))
             X&#x27;
             (@category_theory.functor.obj.{?l_1 ?l_1 ?l_1+1 ?l_1+1} CpltSepUniformSpace.{?l_1}
                (@category_theory.concrete_category.to_category.{?l_1} CpltSepUniformSpace.{?l_1}
                   CpltSepUniformSpace.concrete_category.{?l_1})
                UniformSpace.{?l_1}
                (@category_theory.concrete_category.to_category.{?l_1} UniformSpace.{?l_1}
                   (@category_theory.bundled_hom.category_theory.concrete_category.{?l_1} uniform_space.{?l_1}
                      (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                         @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                      (@category_theory.unbundled_hom.bundled_hom.{?l_1} uniform_space.{?l_1}
                         uniform_continuous.{?l_1 ?l_1}
                         UniformSpace.concrete_category_uniform_continuous.{?l_1})))
                (@category_theory.forget₂.{?l_1} CpltSepUniformSpace.{?l_1} UniformSpace.{?l_1}
                   CpltSepUniformSpace.concrete_category.{?l_1}
                   (@category_theory.bundled_hom.category_theory.concrete_category.{?l_1} uniform_space.{?l_1}
                      (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                         @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                      (@category_theory.unbundled_hom.bundled_hom.{?l_1} uniform_space.{?l_1}
                         uniform_continuous.{?l_1 ?l_1}
                         UniformSpace.concrete_category_uniform_continuous.{?l_1}))
                   CpltSepUniformSpace.has_forget_to_UniformSpace.{?l_1})
                Y))
          (UniformSpace.has_coe_to_fun.{?l_1} X&#x27;
             (@category_theory.functor.obj.{?l_1 ?l_1 ?l_1+1 ?l_1+1} CpltSepUniformSpace.{?l_1}
                (@category_theory.concrete_category.to_category.{?l_1} CpltSepUniformSpace.{?l_1}
                   CpltSepUniformSpace.concrete_category.{?l_1})
                UniformSpace.{?l_1}
                (@category_theory.concrete_category.to_category.{?l_1} UniformSpace.{?l_1}
                   (@category_theory.bundled_hom.category_theory.concrete_category.{?l_1} uniform_space.{?l_1}
                      (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                         @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                      (@category_theory.unbundled_hom.bundled_hom.{?l_1} uniform_space.{?l_1}
                         uniform_continuous.{?l_1 ?l_1}
                         UniformSpace.concrete_category_uniform_continuous.{?l_1})))
                (@category_theory.forget₂.{?l_1} CpltSepUniformSpace.{?l_1} UniformSpace.{?l_1}
                   CpltSepUniformSpace.concrete_category.{?l_1}
                   (@category_theory.bundled_hom.category_theory.concrete_category.{?l_1} uniform_space.{?l_1}
                      (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                         @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                      (@category_theory.unbundled_hom.bundled_hom.{?l_1} uniform_space.{?l_1}
                         uniform_continuous.{?l_1 ?l_1}
                         UniformSpace.concrete_category_uniform_continuous.{?l_1}))
                   CpltSepUniformSpace.has_forget_to_UniformSpace.{?l_1})
                Y))
          g)
       (@coe_fn.{?l_1+1 ?l_1+1}
          (@category_theory.has_hom.hom.{?l_1 ?l_1+1} UniformSpace.{?l_1}
             (@category_theory.category_struct.to_has_hom.{?l_1 ?l_1+1} UniformSpace.{?l_1}
                (@category_theory.category.to_category_struct.{?l_1 ?l_1+1} UniformSpace.{?l_1}
                   (@category_theory.bundled_hom.category.{?l_1} uniform_space.{?l_1}
                      (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                         @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                      (@category_theory.unbundled_hom.bundled_hom.{?l_1} uniform_space.{?l_1}
                         uniform_continuous.{?l_1 ?l_1}
                         UniformSpace.concrete_category_uniform_continuous.{?l_1}))))
             (CpltSepUniformSpace.to_UniformSpace.{?l_1}
                (@CpltSepUniformSpace.of.{?l_1}
                   (@uniform_space.completion.{?l_1}
                      (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                         (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                         X)
                      (UniformSpace.uniform_space.{?l_1} X))
                   (@uniform_space.completion.uniform_space.{?l_1}
                      (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                         (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                         X)
                      (UniformSpace.uniform_space.{?l_1} X))
                   (UniformSpace.completion_functor._proof_1.{?l_1} X)
                   (UniformSpace.completion_functor._proof_2.{?l_1} X)))
             (CpltSepUniformSpace.to_UniformSpace.{?l_1}
                (@CpltSepUniformSpace.of.{?l_1}
                   (@uniform_space.completion.{?l_1}
                      (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                         (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                         X&#x27;)
                      (UniformSpace.uniform_space.{?l_1} X&#x27;))
                   (@uniform_space.completion.uniform_space.{?l_1}
                      (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                         (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                         X&#x27;)
                      (UniformSpace.uniform_space.{?l_1} X&#x27;))
                   (UniformSpace.completion_functor._proof_1.{?l_1} X&#x27;)
                   (UniformSpace.completion_functor._proof_2.{?l_1} X&#x27;))))
          (UniformSpace.has_coe_to_fun.{?l_1}
             (CpltSepUniformSpace.to_UniformSpace.{?l_1}
                (@CpltSepUniformSpace.of.{?l_1}
                   (@uniform_space.completion.{?l_1}
                      (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                         (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                         X)
                      (UniformSpace.uniform_space.{?l_1} X))
                   (@uniform_space.completion.uniform_space.{?l_1}
                      (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                         (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                         X)
                      (UniformSpace.uniform_space.{?l_1} X))
                   (UniformSpace.completion_functor._proof_1.{?l_1} X)
                   (UniformSpace.completion_functor._proof_2.{?l_1} X)))
             (CpltSepUniformSpace.to_UniformSpace.{?l_1}
                (@CpltSepUniformSpace.of.{?l_1}
                   (@uniform_space.completion.{?l_1}
                      (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                         (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                         X&#x27;)
                      (UniformSpace.uniform_space.{?l_1} X&#x27;))
                   (@uniform_space.completion.uniform_space.{?l_1}
                      (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                         (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                         X&#x27;)
                      (UniformSpace.uniform_space.{?l_1} X&#x27;))
                   (UniformSpace.completion_functor._proof_1.{?l_1} X&#x27;)
                   (UniformSpace.completion_functor._proof_2.{?l_1} X&#x27;))))
          (@subtype.mk.{?l_1+1}
             (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1}
                (CpltSepUniformSpace.to_UniformSpace.{?l_1}
                   (@CpltSepUniformSpace.of.{?l_1}
                      (@uniform_space.completion.{?l_1}
                         (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                            (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                            X)
                         (UniformSpace.uniform_space.{?l_1} X))
                      (@uniform_space.completion.uniform_space.{?l_1}
                         (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                            (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                            X)
                         (UniformSpace.uniform_space.{?l_1} X))
                      (UniformSpace.completion_functor._proof_3.{?l_1} X)
                      (UniformSpace.completion_functor._proof_4.{?l_1} X))) →
              @category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1}
                (CpltSepUniformSpace.to_UniformSpace.{?l_1}
                   (@CpltSepUniformSpace.of.{?l_1}
                      (@uniform_space.completion.{?l_1}
                         (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                            (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                            X&#x27;)
                         (UniformSpace.uniform_space.{?l_1} X&#x27;))
                      (@uniform_space.completion.uniform_space.{?l_1}
                         (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                            (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                            X&#x27;)
                         (UniformSpace.uniform_space.{?l_1} X&#x27;))
                      (UniformSpace.completion_functor._proof_5.{?l_1} X&#x27;)
                      (UniformSpace.completion_functor._proof_6.{?l_1} X&#x27;))))
             (@uniform_continuous.{?l_1 ?l_1}
                (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1}
                   (CpltSepUniformSpace.to_UniformSpace.{?l_1}
                      (@CpltSepUniformSpace.of.{?l_1}
                         (@uniform_space.completion.{?l_1}
                            (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                               (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                               X)
                            (UniformSpace.uniform_space.{?l_1} X))
                         (@uniform_space.completion.uniform_space.{?l_1}
                            (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                               (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                               X)
                            (UniformSpace.uniform_space.{?l_1} X))
                         (UniformSpace.completion_functor._proof_3.{?l_1} X)
                         (UniformSpace.completion_functor._proof_4.{?l_1} X))))
                (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1}
                   (CpltSepUniformSpace.to_UniformSpace.{?l_1}
                      (@CpltSepUniformSpace.of.{?l_1}
                         (@uniform_space.completion.{?l_1}
                            (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                               (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                               X&#x27;)
                            (UniformSpace.uniform_space.{?l_1} X&#x27;))
                         (@uniform_space.completion.uniform_space.{?l_1}
                            (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                               (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                               X&#x27;)
                            (UniformSpace.uniform_space.{?l_1} X&#x27;))
                         (UniformSpace.completion_functor._proof_5.{?l_1} X&#x27;)
                         (UniformSpace.completion_functor._proof_6.{?l_1} X&#x27;))))
                (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1}
                   (CpltSepUniformSpace.to_UniformSpace.{?l_1}
                      (@CpltSepUniformSpace.of.{?l_1}
                         (@uniform_space.completion.{?l_1}
                            (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                               (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                               X)
                            (UniformSpace.uniform_space.{?l_1} X))
                         (@uniform_space.completion.uniform_space.{?l_1}
                            (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                               (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                               X)
                            (UniformSpace.uniform_space.{?l_1} X))
                         (UniformSpace.completion_functor._proof_3.{?l_1} X)
                         (UniformSpace.completion_functor._proof_4.{?l_1} X))))
                (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1}
                   (CpltSepUniformSpace.to_UniformSpace.{?l_1}
                      (@CpltSepUniformSpace.of.{?l_1}
                         (@uniform_space.completion.{?l_1}
                            (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                               (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                               X&#x27;)
                            (UniformSpace.uniform_space.{?l_1} X&#x27;))
                         (@uniform_space.completion.uniform_space.{?l_1}
                            (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                               (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                               X&#x27;)
                            (UniformSpace.uniform_space.{?l_1} X&#x27;))
                         (UniformSpace.completion_functor._proof_5.{?l_1} X&#x27;)
                         (UniformSpace.completion_functor._proof_6.{?l_1} X&#x27;)))))
             (@uniform_space.completion.map.{?l_1 ?l_1}
                (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                   (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                   X)
                (UniformSpace.uniform_space.{?l_1} X)
                (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                   (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                   X&#x27;)
                (UniformSpace.uniform_space.{?l_1} X&#x27;)
                (@subtype.val.{?l_1+1}
                   (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X →
                    @category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X&#x27;)
                   (@uniform_continuous.{?l_1 ?l_1} (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                      (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X&#x27;)
                      (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                      (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X&#x27;))
                   f))
             (@UniformSpace.completion_functor._proof_7.{?l_1} X X&#x27; f))
          x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
X X&#x27; : UniformSpace.{?l_1},
Y : CpltSepUniformSpace.{?l_1},
f :
  (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
     (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
        @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
       (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
       (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
       (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
       (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y))
    X
    X&#x27;,
g :
  (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
     (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
        @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
       (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
       (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
       (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
       (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y))
    X&#x27;
    (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y),
x :
  @coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
    (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
    (CpltSepUniformSpace.to_UniformSpace.{?l_1}
       ((λ (X : UniformSpace.{?l_1}),
           @CpltSepUniformSpace.of.{?l_1}
             (@uniform_space.completion.{?l_1}
                (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                   (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                   X)
                (UniformSpace.uniform_space.{?l_1} X))
             (@uniform_space.completion.uniform_space.{?l_1}
                (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                   (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                   X)
                (UniformSpace.uniform_space.{?l_1} X))
             (UniformSpace.completion_functor._proof_1.{?l_1} X)
             (UniformSpace.completion_functor._proof_2.{?l_1} X))
          X))
⊢ @eq.{?l_1+1}
    (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
       (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
       (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
    (@function.comp.{?l_1+1 ?l_1+1 ?l_1+1}
       (@uniform_space.completion.{?l_1}
          (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
             (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
             X)
          (UniformSpace.uniform_space.{?l_1} X))
       (@uniform_space.completion.{?l_1}
          (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
             (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
             X&#x27;)
          (UniformSpace.uniform_space.{?l_1} X&#x27;))
       (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
          (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
          (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
       (@uniform_space.completion.extension.{?l_1 ?l_1}
          (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
             (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
             X&#x27;)
          (UniformSpace.uniform_space.{?l_1} X&#x27;)
          (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
             (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
             (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
          (UniformSpace.uniform_space.{?l_1} (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
          (@coe_fn.{?l_1+1 ?l_1+1}
             (@category_theory.has_hom.hom.{?l_1 ?l_1+1} UniformSpace.{?l_1}
                (@category_theory.category_struct.to_has_hom.{?l_1 ?l_1+1} UniformSpace.{?l_1}
                   (@category_theory.category.to_category_struct.{?l_1 ?l_1+1} UniformSpace.{?l_1}
                      (@category_theory.bundled_hom.category.{?l_1} uniform_space.{?l_1}
                         (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                            @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                         (@category_theory.unbundled_hom.bundled_hom.{?l_1}
                            (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                            uniform_continuous.{?l_1 ?l_1}
                            UniformSpace.concrete_category_uniform_continuous.{?l_1}))))
                X&#x27;
                (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
             (UniformSpace.has_coe_to_fun.{?l_1} X&#x27; (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
             g))
       (@uniform_space.completion.map.{?l_1 ?l_1}
          (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
             (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
             X)
          (UniformSpace.uniform_space.{?l_1} X)
          (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
             (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
             X&#x27;)
          (UniformSpace.uniform_space.{?l_1} X&#x27;)
          (@coe_fn.{?l_1+1 ?l_1+1}
             (@category_theory.has_hom.hom.{?l_1 ?l_1+1} UniformSpace.{?l_1}
                (@category_theory.category_struct.to_has_hom.{?l_1 ?l_1+1} UniformSpace.{?l_1}
                   (@category_theory.category.to_category_struct.{?l_1 ?l_1+1} UniformSpace.{?l_1}
                      (@category_theory.bundled_hom.category.{?l_1} uniform_space.{?l_1}
                         (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                            @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                         (@category_theory.unbundled_hom.bundled_hom.{?l_1}
                            (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                            uniform_continuous.{?l_1 ?l_1}
                            UniformSpace.concrete_category_uniform_continuous.{?l_1}))))
                X
                X&#x27;)
             (UniformSpace.has_coe_to_fun.{?l_1} X X&#x27;)
             f))
       x)
    (@uniform_space.completion.extension.{?l_1 ?l_1}
       (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
          (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
          X&#x27;)
       (UniformSpace.uniform_space.{?l_1} X&#x27;)
       (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
          (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
          (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
       (UniformSpace.uniform_space.{?l_1} (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
       (@coe_fn.{?l_1+1 ?l_1+1}
          (@category_theory.has_hom.hom.{?l_1 ?l_1+1} UniformSpace.{?l_1}
             (@category_theory.category_struct.to_has_hom.{?l_1 ?l_1+1} UniformSpace.{?l_1}
                (@category_theory.category.to_category_struct.{?l_1 ?l_1+1} UniformSpace.{?l_1}
                   (@category_theory.bundled_hom.category.{?l_1} uniform_space.{?l_1}
                      (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                         @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                      (@category_theory.unbundled_hom.bundled_hom.{?l_1} uniform_space.{?l_1}
                         uniform_continuous.{?l_1 ?l_1}
                         UniformSpace.concrete_category_uniform_continuous.{?l_1}))))
             X&#x27;
             (@category_theory.functor.obj.{?l_1 ?l_1 ?l_1+1 ?l_1+1} CpltSepUniformSpace.{?l_1}
                (@category_theory.concrete_category.to_category.{?l_1} CpltSepUniformSpace.{?l_1}
                   CpltSepUniformSpace.concrete_category.{?l_1})
                UniformSpace.{?l_1}
                (@category_theory.concrete_category.to_category.{?l_1} UniformSpace.{?l_1}
                   (@category_theory.bundled_hom.category_theory.concrete_category.{?l_1} uniform_space.{?l_1}
                      (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                         @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                      (@category_theory.unbundled_hom.bundled_hom.{?l_1} uniform_space.{?l_1}
                         uniform_continuous.{?l_1 ?l_1}
                         UniformSpace.concrete_category_uniform_continuous.{?l_1})))
                (@category_theory.forget₂.{?l_1} CpltSepUniformSpace.{?l_1} UniformSpace.{?l_1}
                   CpltSepUniformSpace.concrete_category.{?l_1}
                   (@category_theory.bundled_hom.category_theory.concrete_category.{?l_1} uniform_space.{?l_1}
                      (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                         @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                      (@category_theory.unbundled_hom.bundled_hom.{?l_1} uniform_space.{?l_1}
                         uniform_continuous.{?l_1 ?l_1}
                         UniformSpace.concrete_category_uniform_continuous.{?l_1}))
                   CpltSepUniformSpace.has_forget_to_UniformSpace.{?l_1})
                Y))
          (UniformSpace.has_coe_to_fun.{?l_1} X&#x27;
             (@category_theory.functor.obj.{?l_1 ?l_1 ?l_1+1 ?l_1+1} CpltSepUniformSpace.{?l_1}
                (@category_theory.concrete_category.to_category.{?l_1} CpltSepUniformSpace.{?l_1}
                   CpltSepUniformSpace.concrete_category.{?l_1})
                UniformSpace.{?l_1}
                (@category_theory.concrete_category.to_category.{?l_1} UniformSpace.{?l_1}
                   (@category_theory.bundled_hom.category_theory.concrete_category.{?l_1} uniform_space.{?l_1}
                      (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                         @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                      (@category_theory.unbundled_hom.bundled_hom.{?l_1} uniform_space.{?l_1}
                         uniform_continuous.{?l_1 ?l_1}
                         UniformSpace.concrete_category_uniform_continuous.{?l_1})))
                (@category_theory.forget₂.{?l_1} CpltSepUniformSpace.{?l_1} UniformSpace.{?l_1}
                   CpltSepUniformSpace.concrete_category.{?l_1}
                   (@category_theory.bundled_hom.category_theory.concrete_category.{?l_1} uniform_space.{?l_1}
                      (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                         @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                      (@category_theory.unbundled_hom.bundled_hom.{?l_1} uniform_space.{?l_1}
                         uniform_continuous.{?l_1 ?l_1}
                         UniformSpace.concrete_category_uniform_continuous.{?l_1}))
                   CpltSepUniformSpace.has_forget_to_UniformSpace.{?l_1})
                Y))
          g)
       (@coe_fn.{?l_1+1 ?l_1+1}
          (@category_theory.has_hom.hom.{?l_1 ?l_1+1} UniformSpace.{?l_1}
             (@category_theory.category_struct.to_has_hom.{?l_1 ?l_1+1} UniformSpace.{?l_1}
                (@category_theory.category.to_category_struct.{?l_1 ?l_1+1} UniformSpace.{?l_1}
                   (@category_theory.bundled_hom.category.{?l_1} uniform_space.{?l_1}
                      (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                         @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                      (@category_theory.unbundled_hom.bundled_hom.{?l_1} uniform_space.{?l_1}
                         uniform_continuous.{?l_1 ?l_1}
                         UniformSpace.concrete_category_uniform_continuous.{?l_1}))))
             (CpltSepUniformSpace.to_UniformSpace.{?l_1}
                (@CpltSepUniformSpace.of.{?l_1}
                   (@uniform_space.completion.{?l_1}
                      (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                         (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                         X)
                      (UniformSpace.uniform_space.{?l_1} X))
                   (@uniform_space.completion.uniform_space.{?l_1}
                      (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                         (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                         X)
                      (UniformSpace.uniform_space.{?l_1} X))
                   (UniformSpace.completion_functor._proof_1.{?l_1} X)
                   (UniformSpace.completion_functor._proof_2.{?l_1} X)))
             (CpltSepUniformSpace.to_UniformSpace.{?l_1}
                (@CpltSepUniformSpace.of.{?l_1}
                   (@uniform_space.completion.{?l_1}
                      (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                         (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                         X&#x27;)
                      (UniformSpace.uniform_space.{?l_1} X&#x27;))
                   (@uniform_space.completion.uniform_space.{?l_1}
                      (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                         (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                         X&#x27;)
                      (UniformSpace.uniform_space.{?l_1} X&#x27;))
                   (UniformSpace.completion_functor._proof_1.{?l_1} X&#x27;)
                   (UniformSpace.completion_functor._proof_2.{?l_1} X&#x27;))))
          (UniformSpace.has_coe_to_fun.{?l_1}
             (CpltSepUniformSpace.to_UniformSpace.{?l_1}
                (@CpltSepUniformSpace.of.{?l_1}
                   (@uniform_space.completion.{?l_1}
                      (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                         (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                         X)
                      (UniformSpace.uniform_space.{?l_1} X))
                   (@uniform_space.completion.uniform_space.{?l_1}
                      (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                         (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                         X)
                      (UniformSpace.uniform_space.{?l_1} X))
                   (UniformSpace.completion_functor._proof_1.{?l_1} X)
                   (UniformSpace.completion_functor._proof_2.{?l_1} X)))
             (CpltSepUniformSpace.to_UniformSpace.{?l_1}
                (@CpltSepUniformSpace.of.{?l_1}
                   (@uniform_space.completion.{?l_1}
                      (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                         (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                         X&#x27;)
                      (UniformSpace.uniform_space.{?l_1} X&#x27;))
                   (@uniform_space.completion.uniform_space.{?l_1}
                      (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                         (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                         X&#x27;)
                      (UniformSpace.uniform_space.{?l_1} X&#x27;))
                   (UniformSpace.completion_functor._proof_1.{?l_1} X&#x27;)
                   (UniformSpace.completion_functor._proof_2.{?l_1} X&#x27;))))
          (@subtype.mk.{?l_1+1}
             (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1}
                (CpltSepUniformSpace.to_UniformSpace.{?l_1}
                   (@CpltSepUniformSpace.of.{?l_1}
                      (@uniform_space.completion.{?l_1}
                         (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                            (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                            X)
                         (UniformSpace.uniform_space.{?l_1} X))
                      (@uniform_space.completion.uniform_space.{?l_1}
                         (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                            (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                            X)
                         (UniformSpace.uniform_space.{?l_1} X))
                      (UniformSpace.completion_functor._proof_3.{?l_1} X)
                      (UniformSpace.completion_functor._proof_4.{?l_1} X))) →
              @category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1}
                (CpltSepUniformSpace.to_UniformSpace.{?l_1}
                   (@CpltSepUniformSpace.of.{?l_1}
                      (@uniform_space.completion.{?l_1}
                         (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                            (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                            X&#x27;)
                         (UniformSpace.uniform_space.{?l_1} X&#x27;))
                      (@uniform_space.completion.uniform_space.{?l_1}
                         (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                            (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                            X&#x27;)
                         (UniformSpace.uniform_space.{?l_1} X&#x27;))
                      (UniformSpace.completion_functor._proof_5.{?l_1} X&#x27;)
                      (UniformSpace.completion_functor._proof_6.{?l_1} X&#x27;))))
             (@uniform_continuous.{?l_1 ?l_1}
                (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1}
                   (CpltSepUniformSpace.to_UniformSpace.{?l_1}
                      (@CpltSepUniformSpace.of.{?l_1}
                         (@uniform_space.completion.{?l_1}
                            (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                               (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                               X)
                            (UniformSpace.uniform_space.{?l_1} X))
                         (@uniform_space.completion.uniform_space.{?l_1}
                            (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                               (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                               X)
                            (UniformSpace.uniform_space.{?l_1} X))
                         (UniformSpace.completion_functor._proof_3.{?l_1} X)
                         (UniformSpace.completion_functor._proof_4.{?l_1} X))))
                (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1}
                   (CpltSepUniformSpace.to_UniformSpace.{?l_1}
                      (@CpltSepUniformSpace.of.{?l_1}
                         (@uniform_space.completion.{?l_1}
                            (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                               (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                               X&#x27;)
                            (UniformSpace.uniform_space.{?l_1} X&#x27;))
                         (@uniform_space.completion.uniform_space.{?l_1}
                            (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                               (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                               X&#x27;)
                            (UniformSpace.uniform_space.{?l_1} X&#x27;))
                         (UniformSpace.completion_functor._proof_5.{?l_1} X&#x27;)
                         (UniformSpace.completion_functor._proof_6.{?l_1} X&#x27;))))
                (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1}
                   (CpltSepUniformSpace.to_UniformSpace.{?l_1}
                      (@CpltSepUniformSpace.of.{?l_1}
                         (@uniform_space.completion.{?l_1}
                            (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                               (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                               X)
                            (UniformSpace.uniform_space.{?l_1} X))
                         (@uniform_space.completion.uniform_space.{?l_1}
                            (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                               (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                               X)
                            (UniformSpace.uniform_space.{?l_1} X))
                         (UniformSpace.completion_functor._proof_3.{?l_1} X)
                         (UniformSpace.completion_functor._proof_4.{?l_1} X))))
                (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1}
                   (CpltSepUniformSpace.to_UniformSpace.{?l_1}
                      (@CpltSepUniformSpace.of.{?l_1}
                         (@uniform_space.completion.{?l_1}
                            (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                               (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                               X&#x27;)
                            (UniformSpace.uniform_space.{?l_1} X&#x27;))
                         (@uniform_space.completion.uniform_space.{?l_1}
                            (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                               (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                               X&#x27;)
                            (UniformSpace.uniform_space.{?l_1} X&#x27;))
                         (UniformSpace.completion_functor._proof_5.{?l_1} X&#x27;)
                         (UniformSpace.completion_functor._proof_6.{?l_1} X&#x27;)))))
             (@uniform_space.completion.map.{?l_1 ?l_1}
                (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                   (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                   X)
                (UniformSpace.uniform_space.{?l_1} X)
                (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                   (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                   X&#x27;)
                (UniformSpace.uniform_space.{?l_1} X&#x27;)
                (@subtype.val.{?l_1+1}
                   (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X →
                    @category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X&#x27;)
                   (@uniform_continuous.{?l_1 ?l_1} (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                      (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X&#x27;)
                      (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                      (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X&#x27;))
                   f))
             (@UniformSpace.completion_functor._proof_7.{?l_1} X X&#x27; f))
          x))

X X&#x27; : UniformSpace.{?l_1},
Y : CpltSepUniformSpace.{?l_1},
f :
  (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
     (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
        @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
       (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
       (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
       (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
       (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y))
    X
    X&#x27;,
g :
  (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
     (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
        @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
       (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
       (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
       (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
       (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y))
    X&#x27;
    (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y),
x :
  @coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
    (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
    (CpltSepUniformSpace.to_UniformSpace.{?l_1}
       ((λ (X : UniformSpace.{?l_1}),
           @CpltSepUniformSpace.of.{?l_1}
             (@uniform_space.completion.{?l_1}
                (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                   (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                   X)
                (UniformSpace.uniform_space.{?l_1} X))
             (@uniform_space.completion.uniform_space.{?l_1}
                (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                   (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                   X)
                (UniformSpace.uniform_space.{?l_1} X))
             (UniformSpace.completion_functor._proof_1.{?l_1} X)
             (UniformSpace.completion_functor._proof_2.{?l_1} X))
          X))
⊢ @uniform_continuous.{?l_1 ?l_1}
    (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
       (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
       X&#x27;)
    (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
       (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
       (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
    (UniformSpace.uniform_space.{?l_1} X&#x27;)
    (UniformSpace.uniform_space.{?l_1} (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
    (@coe_fn.{?l_1+1 ?l_1+1}
       (@category_theory.has_hom.hom.{?l_1 ?l_1+1} UniformSpace.{?l_1}
          (@category_theory.category_struct.to_has_hom.{?l_1 ?l_1+1} UniformSpace.{?l_1}
             (@category_theory.category.to_category_struct.{?l_1 ?l_1+1} UniformSpace.{?l_1}
                (@category_theory.bundled_hom.category.{?l_1} uniform_space.{?l_1}
                   (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                      @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                   (@category_theory.unbundled_hom.bundled_hom.{?l_1} (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                      uniform_continuous.{?l_1 ?l_1}
                      UniformSpace.concrete_category_uniform_continuous.{?l_1}))))
          X&#x27;
          (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
       (UniformSpace.has_coe_to_fun.{?l_1} X&#x27; (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
       g)

X X&#x27; : UniformSpace.{?l_1},
Y : CpltSepUniformSpace.{?l_1},
f :
  (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
     (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
        @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
       (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
       (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
       (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
       (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y))
    X
    X&#x27;,
g :
  (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
     (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
        @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
       (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
       (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
       (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
       (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y))
    X&#x27;
    (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y),
x :
  @coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
    (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
    (CpltSepUniformSpace.to_UniformSpace.{?l_1}
       ((λ (X : UniformSpace.{?l_1}),
           @CpltSepUniformSpace.of.{?l_1}
             (@uniform_space.completion.{?l_1}
                (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                   (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                   X)
                (UniformSpace.uniform_space.{?l_1} X))
             (@uniform_space.completion.uniform_space.{?l_1}
                (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                   (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                   X)
                (UniformSpace.uniform_space.{?l_1} X))
             (UniformSpace.completion_functor._proof_1.{?l_1} X)
             (UniformSpace.completion_functor._proof_2.{?l_1} X))
          X))
⊢ @uniform_continuous.{?l_1 ?l_1}
    (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
       (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
       X)
    (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
       (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
       X&#x27;)
    (UniformSpace.uniform_space.{?l_1} X)
    (UniformSpace.uniform_space.{?l_1} X&#x27;)
    (@coe_fn.{?l_1+1 ?l_1+1}
       (@category_theory.has_hom.hom.{?l_1 ?l_1+1} UniformSpace.{?l_1}
          (@category_theory.category_struct.to_has_hom.{?l_1 ?l_1+1} UniformSpace.{?l_1}
             (@category_theory.category.to_category_struct.{?l_1 ?l_1+1} UniformSpace.{?l_1}
                (@category_theory.bundled_hom.category.{?l_1} uniform_space.{?l_1}
                   (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                      @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                   (@category_theory.unbundled_hom.bundled_hom.{?l_1} (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                      uniform_continuous.{?l_1 ?l_1}
                      UniformSpace.concrete_category_uniform_continuous.{?l_1}))))
          X
          X&#x27;)
       (UniformSpace.has_coe_to_fun.{?l_1} X X&#x27;)
       f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>152      refl, exact g.property, exact f.property,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1263, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 258, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 258, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='(λ (X Y : category_theory.bundled.{u_1 u_1} uniform_space.{u_1}), (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β), @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ)) (@category_theory.bundled.α.{u_1 u_1} uniform_space.{u_1} X) (@category_theory.bundled.α.{u_1 u_1} uniform_space.{u_1} Y) (@category_theory.bundled.str.{u_1 u_1} uniform_space.{u_1} X) (@category_theory.bundled.str.{u_1 u_1} uniform_space.{u_1} Y)) X&#x27; (CpltSepUniformSpace.to_UniformSpace.{u_1} Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='(λ (X Y : category_theory.bundled.{u_1 u_1} uniform_space.{u_1}), (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β), @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ)) (@category_theory.bundled.α.{u_1 u_1} uniform_space.{u_1} X) (@category_theory.bundled.α.{u_1 u_1} uniform_space.{u_1} Y) (@category_theory.bundled.str.{u_1 u_1} uniform_space.{u_1} X) (@category_theory.bundled.str.{u_1 u_1} uniform_space.{u_1} Y)) X X&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Shorter name for the tactic `reflexivity`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
X X&#x27; : UniformSpace.{?l_1},
Y : CpltSepUniformSpace.{?l_1},
f :
  (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
     (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
        @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
       (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
       (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
       (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
       (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y))
    X
    X&#x27;,
g :
  (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
     (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
        @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
       (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
       (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
       (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
       (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y))
    X&#x27;
    (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y),
x :
  @coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
    (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
    (CpltSepUniformSpace.to_UniformSpace.{?l_1}
       ((λ (X : UniformSpace.{?l_1}),
           @CpltSepUniformSpace.of.{?l_1}
             (@uniform_space.completion.{?l_1}
                (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                   (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                   X)
                (UniformSpace.uniform_space.{?l_1} X))
             (@uniform_space.completion.uniform_space.{?l_1}
                (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                   (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                   X)
                (UniformSpace.uniform_space.{?l_1} X))
             (UniformSpace.completion_functor._proof_1.{?l_1} X)
             (UniformSpace.completion_functor._proof_2.{?l_1} X))
          X))
⊢ @eq.{?l_1+1}
    (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
       (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
       (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
    (@function.comp.{?l_1+1 ?l_1+1 ?l_1+1}
       (@uniform_space.completion.{?l_1}
          (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
             (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
             X)
          (UniformSpace.uniform_space.{?l_1} X))
       (@uniform_space.completion.{?l_1}
          (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
             (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
             X&#x27;)
          (UniformSpace.uniform_space.{?l_1} X&#x27;))
       (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
          (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
          (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
       (@uniform_space.completion.extension.{?l_1 ?l_1}
          (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
             (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
             X&#x27;)
          (UniformSpace.uniform_space.{?l_1} X&#x27;)
          (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
             (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
             (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
          (UniformSpace.uniform_space.{?l_1} (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
          (@coe_fn.{?l_1+1 ?l_1+1}
             (@category_theory.has_hom.hom.{?l_1 ?l_1+1} UniformSpace.{?l_1}
                (@category_theory.category_struct.to_has_hom.{?l_1 ?l_1+1} UniformSpace.{?l_1}
                   (@category_theory.category.to_category_struct.{?l_1 ?l_1+1} UniformSpace.{?l_1}
                      (@category_theory.bundled_hom.category.{?l_1} uniform_space.{?l_1}
                         (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                            @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                         (@category_theory.unbundled_hom.bundled_hom.{?l_1}
                            (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                            uniform_continuous.{?l_1 ?l_1}
                            UniformSpace.concrete_category_uniform_continuous.{?l_1}))))
                X&#x27;
                (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
             (UniformSpace.has_coe_to_fun.{?l_1} X&#x27; (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
             g))
       (@uniform_space.completion.map.{?l_1 ?l_1}
          (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
             (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
             X)
          (UniformSpace.uniform_space.{?l_1} X)
          (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
             (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
             X&#x27;)
          (UniformSpace.uniform_space.{?l_1} X&#x27;)
          (@coe_fn.{?l_1+1 ?l_1+1}
             (@category_theory.has_hom.hom.{?l_1 ?l_1+1} UniformSpace.{?l_1}
                (@category_theory.category_struct.to_has_hom.{?l_1 ?l_1+1} UniformSpace.{?l_1}
                   (@category_theory.category.to_category_struct.{?l_1 ?l_1+1} UniformSpace.{?l_1}
                      (@category_theory.bundled_hom.category.{?l_1} uniform_space.{?l_1}
                         (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                            @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                         (@category_theory.unbundled_hom.bundled_hom.{?l_1}
                            (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                            uniform_continuous.{?l_1 ?l_1}
                            UniformSpace.concrete_category_uniform_continuous.{?l_1}))))
                X
                X&#x27;)
             (UniformSpace.has_coe_to_fun.{?l_1} X X&#x27;)
             f))
       x)
    (@uniform_space.completion.extension.{?l_1 ?l_1}
       (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
          (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
          X&#x27;)
       (UniformSpace.uniform_space.{?l_1} X&#x27;)
       (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
          (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
          (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
       (UniformSpace.uniform_space.{?l_1} (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
       (@coe_fn.{?l_1+1 ?l_1+1}
          (@category_theory.has_hom.hom.{?l_1 ?l_1+1} UniformSpace.{?l_1}
             (@category_theory.category_struct.to_has_hom.{?l_1 ?l_1+1} UniformSpace.{?l_1}
                (@category_theory.category.to_category_struct.{?l_1 ?l_1+1} UniformSpace.{?l_1}
                   (@category_theory.bundled_hom.category.{?l_1} uniform_space.{?l_1}
                      (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                         @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                      (@category_theory.unbundled_hom.bundled_hom.{?l_1} uniform_space.{?l_1}
                         uniform_continuous.{?l_1 ?l_1}
                         UniformSpace.concrete_category_uniform_continuous.{?l_1}))))
             X&#x27;
             (@category_theory.functor.obj.{?l_1 ?l_1 ?l_1+1 ?l_1+1} CpltSepUniformSpace.{?l_1}
                (@category_theory.concrete_category.to_category.{?l_1} CpltSepUniformSpace.{?l_1}
                   CpltSepUniformSpace.concrete_category.{?l_1})
                UniformSpace.{?l_1}
                (@category_theory.concrete_category.to_category.{?l_1} UniformSpace.{?l_1}
                   (@category_theory.bundled_hom.category_theory.concrete_category.{?l_1} uniform_space.{?l_1}
                      (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                         @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                      (@category_theory.unbundled_hom.bundled_hom.{?l_1} uniform_space.{?l_1}
                         uniform_continuous.{?l_1 ?l_1}
                         UniformSpace.concrete_category_uniform_continuous.{?l_1})))
                (@category_theory.forget₂.{?l_1} CpltSepUniformSpace.{?l_1} UniformSpace.{?l_1}
                   CpltSepUniformSpace.concrete_category.{?l_1}
                   (@category_theory.bundled_hom.category_theory.concrete_category.{?l_1} uniform_space.{?l_1}
                      (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                         @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                      (@category_theory.unbundled_hom.bundled_hom.{?l_1} uniform_space.{?l_1}
                         uniform_continuous.{?l_1 ?l_1}
                         UniformSpace.concrete_category_uniform_continuous.{?l_1}))
                   CpltSepUniformSpace.has_forget_to_UniformSpace.{?l_1})
                Y))
          (UniformSpace.has_coe_to_fun.{?l_1} X&#x27;
             (@category_theory.functor.obj.{?l_1 ?l_1 ?l_1+1 ?l_1+1} CpltSepUniformSpace.{?l_1}
                (@category_theory.concrete_category.to_category.{?l_1} CpltSepUniformSpace.{?l_1}
                   CpltSepUniformSpace.concrete_category.{?l_1})
                UniformSpace.{?l_1}
                (@category_theory.concrete_category.to_category.{?l_1} UniformSpace.{?l_1}
                   (@category_theory.bundled_hom.category_theory.concrete_category.{?l_1} uniform_space.{?l_1}
                      (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                         @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                      (@category_theory.unbundled_hom.bundled_hom.{?l_1} uniform_space.{?l_1}
                         uniform_continuous.{?l_1 ?l_1}
                         UniformSpace.concrete_category_uniform_continuous.{?l_1})))
                (@category_theory.forget₂.{?l_1} CpltSepUniformSpace.{?l_1} UniformSpace.{?l_1}
                   CpltSepUniformSpace.concrete_category.{?l_1}
                   (@category_theory.bundled_hom.category_theory.concrete_category.{?l_1} uniform_space.{?l_1}
                      (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                         @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                      (@category_theory.unbundled_hom.bundled_hom.{?l_1} uniform_space.{?l_1}
                         uniform_continuous.{?l_1 ?l_1}
                         UniformSpace.concrete_category_uniform_continuous.{?l_1}))
                   CpltSepUniformSpace.has_forget_to_UniformSpace.{?l_1})
                Y))
          g)
       (@coe_fn.{?l_1+1 ?l_1+1}
          (@category_theory.has_hom.hom.{?l_1 ?l_1+1} UniformSpace.{?l_1}
             (@category_theory.category_struct.to_has_hom.{?l_1 ?l_1+1} UniformSpace.{?l_1}
                (@category_theory.category.to_category_struct.{?l_1 ?l_1+1} UniformSpace.{?l_1}
                   (@category_theory.bundled_hom.category.{?l_1} uniform_space.{?l_1}
                      (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                         @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                      (@category_theory.unbundled_hom.bundled_hom.{?l_1} uniform_space.{?l_1}
                         uniform_continuous.{?l_1 ?l_1}
                         UniformSpace.concrete_category_uniform_continuous.{?l_1}))))
             (CpltSepUniformSpace.to_UniformSpace.{?l_1}
                (@CpltSepUniformSpace.of.{?l_1}
                   (@uniform_space.completion.{?l_1}
                      (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                         (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                         X)
                      (UniformSpace.uniform_space.{?l_1} X))
                   (@uniform_space.completion.uniform_space.{?l_1}
                      (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                         (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                         X)
                      (UniformSpace.uniform_space.{?l_1} X))
                   (UniformSpace.completion_functor._proof_1.{?l_1} X)
                   (UniformSpace.completion_functor._proof_2.{?l_1} X)))
             (CpltSepUniformSpace.to_UniformSpace.{?l_1}
                (@CpltSepUniformSpace.of.{?l_1}
                   (@uniform_space.completion.{?l_1}
                      (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                         (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                         X&#x27;)
                      (UniformSpace.uniform_space.{?l_1} X&#x27;))
                   (@uniform_space.completion.uniform_space.{?l_1}
                      (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                         (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                         X&#x27;)
                      (UniformSpace.uniform_space.{?l_1} X&#x27;))
                   (UniformSpace.completion_functor._proof_1.{?l_1} X&#x27;)
                   (UniformSpace.completion_functor._proof_2.{?l_1} X&#x27;))))
          (UniformSpace.has_coe_to_fun.{?l_1}
             (CpltSepUniformSpace.to_UniformSpace.{?l_1}
                (@CpltSepUniformSpace.of.{?l_1}
                   (@uniform_space.completion.{?l_1}
                      (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                         (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                         X)
                      (UniformSpace.uniform_space.{?l_1} X))
                   (@uniform_space.completion.uniform_space.{?l_1}
                      (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                         (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                         X)
                      (UniformSpace.uniform_space.{?l_1} X))
                   (UniformSpace.completion_functor._proof_1.{?l_1} X)
                   (UniformSpace.completion_functor._proof_2.{?l_1} X)))
             (CpltSepUniformSpace.to_UniformSpace.{?l_1}
                (@CpltSepUniformSpace.of.{?l_1}
                   (@uniform_space.completion.{?l_1}
                      (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                         (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                         X&#x27;)
                      (UniformSpace.uniform_space.{?l_1} X&#x27;))
                   (@uniform_space.completion.uniform_space.{?l_1}
                      (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                         (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                         X&#x27;)
                      (UniformSpace.uniform_space.{?l_1} X&#x27;))
                   (UniformSpace.completion_functor._proof_1.{?l_1} X&#x27;)
                   (UniformSpace.completion_functor._proof_2.{?l_1} X&#x27;))))
          (@subtype.mk.{?l_1+1}
             (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1}
                (CpltSepUniformSpace.to_UniformSpace.{?l_1}
                   (@CpltSepUniformSpace.of.{?l_1}
                      (@uniform_space.completion.{?l_1}
                         (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                            (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                            X)
                         (UniformSpace.uniform_space.{?l_1} X))
                      (@uniform_space.completion.uniform_space.{?l_1}
                         (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                            (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                            X)
                         (UniformSpace.uniform_space.{?l_1} X))
                      (UniformSpace.completion_functor._proof_3.{?l_1} X)
                      (UniformSpace.completion_functor._proof_4.{?l_1} X))) →
              @category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1}
                (CpltSepUniformSpace.to_UniformSpace.{?l_1}
                   (@CpltSepUniformSpace.of.{?l_1}
                      (@uniform_space.completion.{?l_1}
                         (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                            (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                            X&#x27;)
                         (UniformSpace.uniform_space.{?l_1} X&#x27;))
                      (@uniform_space.completion.uniform_space.{?l_1}
                         (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                            (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                            X&#x27;)
                         (UniformSpace.uniform_space.{?l_1} X&#x27;))
                      (UniformSpace.completion_functor._proof_5.{?l_1} X&#x27;)
                      (UniformSpace.completion_functor._proof_6.{?l_1} X&#x27;))))
             (@uniform_continuous.{?l_1 ?l_1}
                (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1}
                   (CpltSepUniformSpace.to_UniformSpace.{?l_1}
                      (@CpltSepUniformSpace.of.{?l_1}
                         (@uniform_space.completion.{?l_1}
                            (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                               (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                               X)
                            (UniformSpace.uniform_space.{?l_1} X))
                         (@uniform_space.completion.uniform_space.{?l_1}
                            (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                               (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                               X)
                            (UniformSpace.uniform_space.{?l_1} X))
                         (UniformSpace.completion_functor._proof_3.{?l_1} X)
                         (UniformSpace.completion_functor._proof_4.{?l_1} X))))
                (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1}
                   (CpltSepUniformSpace.to_UniformSpace.{?l_1}
                      (@CpltSepUniformSpace.of.{?l_1}
                         (@uniform_space.completion.{?l_1}
                            (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                               (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                               X&#x27;)
                            (UniformSpace.uniform_space.{?l_1} X&#x27;))
                         (@uniform_space.completion.uniform_space.{?l_1}
                            (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                               (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                               X&#x27;)
                            (UniformSpace.uniform_space.{?l_1} X&#x27;))
                         (UniformSpace.completion_functor._proof_5.{?l_1} X&#x27;)
                         (UniformSpace.completion_functor._proof_6.{?l_1} X&#x27;))))
                (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1}
                   (CpltSepUniformSpace.to_UniformSpace.{?l_1}
                      (@CpltSepUniformSpace.of.{?l_1}
                         (@uniform_space.completion.{?l_1}
                            (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                               (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                               X)
                            (UniformSpace.uniform_space.{?l_1} X))
                         (@uniform_space.completion.uniform_space.{?l_1}
                            (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                               (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                               X)
                            (UniformSpace.uniform_space.{?l_1} X))
                         (UniformSpace.completion_functor._proof_3.{?l_1} X)
                         (UniformSpace.completion_functor._proof_4.{?l_1} X))))
                (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1}
                   (CpltSepUniformSpace.to_UniformSpace.{?l_1}
                      (@CpltSepUniformSpace.of.{?l_1}
                         (@uniform_space.completion.{?l_1}
                            (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                               (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                               X&#x27;)
                            (UniformSpace.uniform_space.{?l_1} X&#x27;))
                         (@uniform_space.completion.uniform_space.{?l_1}
                            (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                               (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                               X&#x27;)
                            (UniformSpace.uniform_space.{?l_1} X&#x27;))
                         (UniformSpace.completion_functor._proof_5.{?l_1} X&#x27;)
                         (UniformSpace.completion_functor._proof_6.{?l_1} X&#x27;)))))
             (@uniform_space.completion.map.{?l_1 ?l_1}
                (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                   (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                   X)
                (UniformSpace.uniform_space.{?l_1} X)
                (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                   (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                   X&#x27;)
                (UniformSpace.uniform_space.{?l_1} X&#x27;)
                (@subtype.val.{?l_1+1}
                   (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X →
                    @category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X&#x27;)
                   (@uniform_continuous.{?l_1 ?l_1} (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
                      (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X&#x27;)
                      (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
                      (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X&#x27;))
                   f))
             (@UniformSpace.completion_functor._proof_7.{?l_1} X X&#x27; f))
          x))

X X&#x27; : UniformSpace.{?l_1},
Y : CpltSepUniformSpace.{?l_1},
f :
  (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
     (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
        @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
       (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
       (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
       (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
       (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y))
    X
    X&#x27;,
g :
  (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
     (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
        @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
       (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
       (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
       (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
       (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y))
    X&#x27;
    (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y),
x :
  @coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
    (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
    (CpltSepUniformSpace.to_UniformSpace.{?l_1}
       ((λ (X : UniformSpace.{?l_1}),
           @CpltSepUniformSpace.of.{?l_1}
             (@uniform_space.completion.{?l_1}
                (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                   (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                   X)
                (UniformSpace.uniform_space.{?l_1} X))
             (@uniform_space.completion.uniform_space.{?l_1}
                (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                   (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                   X)
                (UniformSpace.uniform_space.{?l_1} X))
             (UniformSpace.completion_functor._proof_1.{?l_1} X)
             (UniformSpace.completion_functor._proof_2.{?l_1} X))
          X))
⊢ @uniform_continuous.{?l_1 ?l_1}
    (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
       (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
       X&#x27;)
    (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
       (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
       (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
    (UniformSpace.uniform_space.{?l_1} X&#x27;)
    (UniformSpace.uniform_space.{?l_1} (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
    (@coe_fn.{?l_1+1 ?l_1+1}
       (@category_theory.has_hom.hom.{?l_1 ?l_1+1} UniformSpace.{?l_1}
          (@category_theory.category_struct.to_has_hom.{?l_1 ?l_1+1} UniformSpace.{?l_1}
             (@category_theory.category.to_category_struct.{?l_1 ?l_1+1} UniformSpace.{?l_1}
                (@category_theory.bundled_hom.category.{?l_1} uniform_space.{?l_1}
                   (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                      @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                   (@category_theory.unbundled_hom.bundled_hom.{?l_1} (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                      uniform_continuous.{?l_1 ?l_1}
                      UniformSpace.concrete_category_uniform_continuous.{?l_1}))))
          X&#x27;
          (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
       (UniformSpace.has_coe_to_fun.{?l_1} X&#x27; (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
       g)

X X&#x27; : UniformSpace.{?l_1},
Y : CpltSepUniformSpace.{?l_1},
f :
  (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
     (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
        @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
       (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
       (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
       (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
       (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y))
    X
    X&#x27;,
g :
  (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
     (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
        @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
       (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
       (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
       (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
       (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y))
    X&#x27;
    (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y),
x :
  @coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
    (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
    (CpltSepUniformSpace.to_UniformSpace.{?l_1}
       ((λ (X : UniformSpace.{?l_1}),
           @CpltSepUniformSpace.of.{?l_1}
             (@uniform_space.completion.{?l_1}
                (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                   (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                   X)
                (UniformSpace.uniform_space.{?l_1} X))
             (@uniform_space.completion.uniform_space.{?l_1}
                (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                   (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                   X)
                (UniformSpace.uniform_space.{?l_1} X))
             (UniformSpace.completion_functor._proof_1.{?l_1} X)
             (UniformSpace.completion_functor._proof_2.{?l_1} X))
          X))
⊢ @uniform_continuous.{?l_1 ?l_1}
    (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
       (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
       X)
    (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
       (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
       X&#x27;)
    (UniformSpace.uniform_space.{?l_1} X)
    (UniformSpace.uniform_space.{?l_1} X&#x27;)
    (@coe_fn.{?l_1+1 ?l_1+1}
       (@category_theory.has_hom.hom.{?l_1 ?l_1+1} UniformSpace.{?l_1}
          (@category_theory.category_struct.to_has_hom.{?l_1 ?l_1+1} UniformSpace.{?l_1}
             (@category_theory.category.to_category_struct.{?l_1 ?l_1+1} UniformSpace.{?l_1}
                (@category_theory.bundled_hom.category.{?l_1} uniform_space.{?l_1}
                   (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                      @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                   (@category_theory.unbundled_hom.bundled_hom.{?l_1} (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                      uniform_continuous.{?l_1 ?l_1}
                      UniformSpace.concrete_category_uniform_continuous.{?l_1}))))
          X
          X&#x27;)
       (UniformSpace.has_coe_to_fun.{?l_1} X X&#x27;)
       f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
X X&#x27; : UniformSpace.{?l_1},
Y : CpltSepUniformSpace.{?l_1},
f :
  (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
     (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
        @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
       (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
       (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
       (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
       (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y))
    X
    X&#x27;,
g :
  (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
     (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
        @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
       (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
       (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
       (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
       (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y))
    X&#x27;
    (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y),
x :
  @coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
    (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
    (CpltSepUniformSpace.to_UniformSpace.{?l_1}
       ((λ (X : UniformSpace.{?l_1}),
           @CpltSepUniformSpace.of.{?l_1}
             (@uniform_space.completion.{?l_1}
                (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                   (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                   X)
                (UniformSpace.uniform_space.{?l_1} X))
             (@uniform_space.completion.uniform_space.{?l_1}
                (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                   (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                   X)
                (UniformSpace.uniform_space.{?l_1} X))
             (UniformSpace.completion_functor._proof_1.{?l_1} X)
             (UniformSpace.completion_functor._proof_2.{?l_1} X))
          X))
⊢ @uniform_continuous.{?l_1 ?l_1}
    (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
       (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
       X&#x27;)
    (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
       (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
       (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
    (UniformSpace.uniform_space.{?l_1} X&#x27;)
    (UniformSpace.uniform_space.{?l_1} (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
    (@coe_fn.{?l_1+1 ?l_1+1}
       (@category_theory.has_hom.hom.{?l_1 ?l_1+1} UniformSpace.{?l_1}
          (@category_theory.category_struct.to_has_hom.{?l_1 ?l_1+1} UniformSpace.{?l_1}
             (@category_theory.category.to_category_struct.{?l_1 ?l_1+1} UniformSpace.{?l_1}
                (@category_theory.bundled_hom.category.{?l_1} uniform_space.{?l_1}
                   (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                      @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                   (@category_theory.unbundled_hom.bundled_hom.{?l_1} (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                      uniform_continuous.{?l_1 ?l_1}
                      UniformSpace.concrete_category_uniform_continuous.{?l_1}))))
          X&#x27;
          (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
       (UniformSpace.has_coe_to_fun.{?l_1} X&#x27; (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y))
       g)

X X&#x27; : UniformSpace.{?l_1},
Y : CpltSepUniformSpace.{?l_1},
f :
  (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
     (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
        @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
       (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
       (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
       (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
       (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y))
    X
    X&#x27;,
g :
  (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
     (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
        @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
       (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
       (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
       (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
       (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y))
    X&#x27;
    (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y),
x :
  @coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
    (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
    (CpltSepUniformSpace.to_UniformSpace.{?l_1}
       ((λ (X : UniformSpace.{?l_1}),
           @CpltSepUniformSpace.of.{?l_1}
             (@uniform_space.completion.{?l_1}
                (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                   (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                   X)
                (UniformSpace.uniform_space.{?l_1} X))
             (@uniform_space.completion.uniform_space.{?l_1}
                (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                   (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                   X)
                (UniformSpace.uniform_space.{?l_1} X))
             (UniformSpace.completion_functor._proof_1.{?l_1} X)
             (UniformSpace.completion_functor._proof_2.{?l_1} X))
          X))
⊢ @uniform_continuous.{?l_1 ?l_1}
    (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
       (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
       X)
    (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
       (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
       X&#x27;)
    (UniformSpace.uniform_space.{?l_1} X)
    (UniformSpace.uniform_space.{?l_1} X&#x27;)
    (@coe_fn.{?l_1+1 ?l_1+1}
       (@category_theory.has_hom.hom.{?l_1 ?l_1+1} UniformSpace.{?l_1}
          (@category_theory.category_struct.to_has_hom.{?l_1 ?l_1+1} UniformSpace.{?l_1}
             (@category_theory.category.to_category_struct.{?l_1 ?l_1+1} UniformSpace.{?l_1}
                (@category_theory.bundled_hom.category.{?l_1} uniform_space.{?l_1}
                   (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                      @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                   (@category_theory.unbundled_hom.bundled_hom.{?l_1} (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                      uniform_continuous.{?l_1 ?l_1}
                      UniformSpace.concrete_category_uniform_continuous.{?l_1}))))
          X
          X&#x27;)
       (UniformSpace.has_coe_to_fun.{?l_1} X X&#x27;)
       f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='X X&#x27; : UniformSpace.{?l_1},
Y : CpltSepUniformSpace.{?l_1},
f :
  (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
     (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
        @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
       (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
       (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
       (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
       (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y))
    X
    X&#x27;,
g :
  (λ (X Y : category_theory.bundled.{?l_1 ?l_1} uniform_space.{?l_1}),
     (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
        @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
       (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} X)
       (@category_theory.bundled.α.{?l_1 ?l_1} uniform_space.{?l_1} Y)
       (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} X)
       (@category_theory.bundled.str.{?l_1 ?l_1} uniform_space.{?l_1} Y))
    X&#x27;
    (CpltSepUniformSpace.to_UniformSpace.{?l_1} Y),
x :
  @coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
    (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
    (CpltSepUniformSpace.to_UniformSpace.{?l_1}
       ((λ (X : UniformSpace.{?l_1}),
           @CpltSepUniformSpace.of.{?l_1}
             (@uniform_space.completion.{?l_1}
                (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                   (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                   X)
                (UniformSpace.uniform_space.{?l_1} X))
             (@uniform_space.completion.uniform_space.{?l_1}
                (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
                   (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
                   X)
                (UniformSpace.uniform_space.{?l_1} X))
             (UniformSpace.completion_functor._proof_1.{?l_1} X)
             (UniformSpace.completion_functor._proof_2.{?l_1} X))
          X))
⊢ @uniform_continuous.{?l_1 ?l_1}
    (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
       (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
       X)
    (@coe_sort.{?l_1+2 ?l_1+2} UniformSpace.{?l_1}
       (@category_theory.bundled.has_coe_to_sort.{?l_1 ?l_1} uniform_space.{?l_1})
       X&#x27;)
    (UniformSpace.uniform_space.{?l_1} X)
    (UniformSpace.uniform_space.{?l_1} X&#x27;)
    (@coe_fn.{?l_1+1 ?l_1+1}
       (@category_theory.has_hom.hom.{?l_1 ?l_1+1} UniformSpace.{?l_1}
          (@category_theory.category_struct.to_has_hom.{?l_1 ?l_1+1} UniformSpace.{?l_1}
             (@category_theory.category.to_category_struct.{?l_1 ?l_1+1} UniformSpace.{?l_1}
                (@category_theory.bundled_hom.category.{?l_1} uniform_space.{?l_1}
                   (λ (α β : Type ?l_1) (Iα : uniform_space.{?l_1} α) (Iβ : uniform_space.{?l_1} β),
                      @subtype.{?l_1+1} (α → β) (@uniform_continuous.{?l_1 ?l_1} α β Iα Iβ))
                   (@category_theory.unbundled_hom.bundled_hom.{?l_1} (λ (α : Type ?l_1), uniform_space.{?l_1} α)
                      uniform_continuous.{?l_1 ?l_1}
                      UniformSpace.concrete_category_uniform_continuous.{?l_1}))))
          X
          X&#x27;)
       (UniformSpace.has_coe_to_fun.{?l_1} X X&#x27;)
       f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>153    end }</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>154  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>155  noncomputable instance : is_right_adjoint (forget₂ CpltSepUniformSpace UniformSpace) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='blue'><a title='category_theory.is_right_adjoint'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.forget₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='CpltSepUniformSpace'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='UniformSpace'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/adjunction/basic.lean&#x27;, &#x27;line&#x27;: 36, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/concrete_category/basic.lean&#x27;, &#x27;line&#x27;: 112, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 60, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 27, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D], @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 → Type (max u₁ u₂ v₁ v₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (C D : Type (u+1)) [_inst_1 : category_theory.concrete_category.{u} C] [_inst_2 : category_theory.concrete_category.{u} D] [_inst_3 : @category_theory.has_forget₂.{u} C D _inst_1 _inst_2], @category_theory.functor.{u u u+1 u+1} C (@category_theory.concrete_category.to_category.{u} C _inst_1) D (@category_theory.concrete_category.to_category.{u} D _inst_2)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                           </code><font color='orange'><a title=' The forgetful functor `C ⥤ D` between concrete categories for which we have an instance
`has_forget₂ C `.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='A (bundled) complete separated uniform space.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='A (bundled) uniform spaces.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>156  ⟨completion_functor, adj⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='UniformSpace.completion_functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='UniformSpace.adj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 97, &#x27;column&#x27;: 18}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 136, &#x27;column&#x27;: 18}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{u_1 u_1 u_1+1 u_1+1} UniformSpace.{u_1} (@category_theory.bundled_hom.category.{u_1} uniform_space.{u_1} (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β), @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ)) (@category_theory.unbundled_hom.bundled_hom.{u_1} (λ (α : Type u_1), uniform_space.{u_1} α) uniform_continuous.{u_1 u_1} UniformSpace.concrete_category_uniform_continuous.{u_1})) CpltSepUniformSpace.{u_1} (@category_theory.concrete_category.to_category.{u_1} CpltSepUniformSpace.{u_1} CpltSepUniformSpace.concrete_category.{u_1})'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.adjunction.{u_1 u_1 u_1+1 u_1+1} UniformSpace.{u_1} (@category_theory.bundled_hom.category.{u_1} uniform_space.{u_1} (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β), @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ)) (@category_theory.unbundled_hom.bundled_hom.{u_1} (λ (α : Type u_1), uniform_space.{u_1} α) uniform_continuous.{u_1 u_1} UniformSpace.concrete_category_uniform_continuous.{u_1})) CpltSepUniformSpace.{u_1} (@category_theory.concrete_category.to_category.{u_1} CpltSepUniformSpace.{u_1} CpltSepUniformSpace.concrete_category.{u_1}) UniformSpace.completion_functor.{u_1} (@category_theory.forget₂.{u_1} CpltSepUniformSpace.{u_1} UniformSpace.{u_1} CpltSepUniformSpace.concrete_category.{u_1} (@category_theory.bundled_hom.category_theory.concrete_category.{u_1} uniform_space.{u_1} (λ (α β : Type u_1) (Iα : uniform_space.{u_1} α) (Iβ : uniform_space.{u_1} β), @subtype.{u_1+1} (α → β) (@uniform_continuous.{u_1 u_1} α β Iα Iβ)) (@category_theory.unbundled_hom.bundled_hom.{u_1} (λ (α : Type u_1), uniform_space.{u_1} α) uniform_continuous.{u_1 u_1} UniformSpace.concrete_category_uniform_continuous.{u_1})) CpltSepUniformSpace.has_forget_to_UniformSpace.{u_1})'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The functor turning uniform spaces into complete separated uniform spaces.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The completion functor is left adjoint to the forgetful functor.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>157  noncomputable instance : reflective (forget₂ CpltSepUniformSpace UniformSpace) := {}</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='blue'><a title='category_theory.reflective'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.forget₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='CpltSepUniformSpace'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='UniformSpace'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='obviously'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/monad/adjunction.lean&#x27;, &#x27;line&#x27;: 62, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/concrete_category/basic.lean&#x27;, &#x27;line&#x27;: 112, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 60, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 27, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D], @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 → Type (max u₁ u₂ v₁ v₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (C D : Type (u+1)) [_inst_1 : category_theory.concrete_category.{u} C] [_inst_2 : category_theory.concrete_category.{u} D] [_inst_3 : @category_theory.has_forget₂.{u} C D _inst_1 _inst_2], @category_theory.functor.{u u u+1 u+1} C (@category_theory.concrete_category.to_category.{u} C _inst_1) D (@category_theory.concrete_category.to_category.{u} D _inst_2)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='orange'><a title='A functor is *reflective*, or *a reflective inclusion*, if it is fully faithful and right adjoint.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title=' The forgetful functor `C ⥤ D` between concrete categories for which we have an instance
`has_forget₂ C `.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='A (bundled) complete separated uniform space.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='A (bundled) uniform spaces.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='The `obviously` tactic is a &quot;replaceable&quot; tactic, which means that its meaning is defined by tactics that are defined later with the `@[obviously]` attribute. It is intended for use with `auto_param`s for structure fields.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>158  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>159  open category_theory.limits</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>160  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>161  -- TODO Once someone defines `has_limits UniformSpace`, turn this into an instance.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>162  noncomputable example [has_limits.{u} UniformSpace.{u}] : has_limits.{u} CpltSepUniformSpace.{u} :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='blue'><a title='category_theory.limits.has_limits'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='UniformSpace'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='category_theory.limits.has_limits'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='CpltSepUniformSpace'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/limits.lean&#x27;, &#x27;line&#x27;: 416, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 27, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/limits.lean&#x27;, &#x27;line&#x27;: 416, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 60, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='green'><a title='Π (C : Type (u+1)) [𝒞 : category_theory.category.{u u+1} C], Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π (C : Type (u+1)) [𝒞 : category_theory.category.{u u+1} C], Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='`C` has all (small) limits if it has limits of every shape.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='A (bundled) uniform spaces.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='`C` has all (small) limits if it has limits of every shape.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='A (bundled) complete separated uniform space.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>163  has_limits_of_reflective $ forget₂ CpltSepUniformSpace UniformSpace</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.has_limits_of_reflective'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='category_theory.forget₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='CpltSepUniformSpace'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='UniformSpace'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/monad/limits.lean&#x27;, &#x27;line&#x27;: 111, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/concrete_category/basic.lean&#x27;, &#x27;line&#x27;: 112, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 60, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 27, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type (u+1)} [𝒞 : category_theory.category.{u u+1} C] {D : Type (u+1)} [𝒟 : category_theory.category.{u u+1} D] (R : @category_theory.functor.{u u u+1 u+1} D 𝒟 C 𝒞) [_inst_1 : @category_theory.reflective.{u u u+1 u+1} C 𝒞 D 𝒟 R] [_inst_2 : @category_theory.limits.has_limits.{u u+1} C 𝒞], @category_theory.limits.has_limits.{u u+1} D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π (C D : Type (u+1)) [_inst_1 : category_theory.concrete_category.{u} C] [_inst_2 : category_theory.concrete_category.{u} D] [_inst_3 : @category_theory.has_forget₂.{u} C D _inst_1 _inst_2], @category_theory.functor.{u u u+1 u+1} C (@category_theory.concrete_category.to_category.{u} C _inst_1) D (@category_theory.concrete_category.to_category.{u} D _inst_2)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='orange'><a title=' The forgetful functor `C ⥤ D` between concrete categories for which we have an instance
`has_forget₂ C `.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='A (bundled) complete separated uniform space.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='A (bundled) uniform spaces.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>164  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>165  end UniformSpace</code></pre>
</body>