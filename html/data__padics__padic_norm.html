<head>
<meta charset="UTF-8">
<link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro&display=swap" rel="stylesheet">
</head>

<body>
<pre>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  1  /-</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  2  Copyright (c) 2018 Robert Y. Lewis. All rights reserved.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  3  Released under Apache 2.0 license as described in the file LICENSE.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  4  Authors: Robert Y. Lewis</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  5  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  6  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  7  import data.rat algebra.gcd_domain algebra.field_power</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/rat/default.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/gcd_domain.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/field_power.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  8  import ring_theory.multiplicity tactic.ring</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/ring_theory/multiplicity.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/ring.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  9  import data.real.cau_seq</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/cau_seq.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 10  import tactic.norm_cast</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/norm_cast.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 11  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 12  /-!</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 13  # p-adic norm</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 14  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 15  This file defines the p-adic valuation and the p-adic norm on ℚ.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 16  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 17  The p-adic valuation on ℚ is the difference of the multiplicities of `p` in the numerator and</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 18  denominator of `q`. This function obeys the standard properties of a valuation, with the appropriate</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 19  assumptions on p.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 20  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 21  The valuation induces a norm on ℚ. This norm is a nonarchimedean absolute value.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 22  It takes values in {0} ∪ {1/p^k | k ∈ ℤ}.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 23  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 24  ## Notations</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 25  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 26  This file uses the local notation `/.` for `rat.mk`.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 27  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 28  ## Implementation notes</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 29  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 30  Much, but not all, of this file assumes that `p` is prime. This assumption is inferred automatically</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 31  by taking (prime p) as a type class argument.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 32  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 33  ## References</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 34  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 35  * [F. Q. Gouêva, *p-adic numbers*][gouvea1997]</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 36  * [R. Y. Lewis, *A formal proof of Hensel&#x27;s lemma over the p-adic integers*][lewis2019]</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 37  * &lt;https://en.wikipedia.org/wiki/P-adic_number&gt;</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 38  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 39  ## Tags</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 40  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 41  p-adic, p adic, padic, norm, valuation</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 42  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 43  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 44  universe u</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 45  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 46  open nat</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 47  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 48  attribute [class] nat.prime</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='blue'><a title='nat.prime'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/nat/prime.lean&#x27;, &#x27;line&#x27;: 36, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='green'><a title='nat → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='`prime p` means that `p` is a prime number, that is, a natural number
 at least 2 whose only divisors are `p` and `1`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 49  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 50  open_locale rat</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 51  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 52  open multiplicity</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 53  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 54  /--</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 55  For `p ≠ 1`, the p-adic valuation of an integer `z ≠ 0` is the largest natural number `n` such that</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 56  p^n divides z.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 57  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 58  `padic_val_rat` defines the valuation of a rational `q` to be the valuation of `q.num` minus the</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 59  valuation of `q.denom`.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 60  If `q = 0` or `p = 1`, then `padic_val_rat p q` defaults to 0.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 61  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 62  def padic_val_rat (p : ℕ) (q : ℚ) : ℤ :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='blue'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 293, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/rat/basic.lean&#x27;, &#x27;line&#x27;: 46, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/int/basic.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='orange'><a title='`rat`, or `ℚ`, is the type of rational numbers. It is defined
 as the set of pairs ⟨n, d⟩ of integers such that `d` is positive and `n` and
 `d` are coprime. This representation is preferred to the quotient
 because without periodic reduction, the numerator and denominator can grow
 exponentially (for example, adding 1/2 to itself repeatedly).'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 63  if h : q ≠ 0 ∧ p ≠ 1</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='dite'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='q'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ne'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='and'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ne'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 609, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 97, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 97, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π (c : Prop) [h : decidable c] {α : Type}, (c → α) → (not c → α) → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 64  then (multiplicity (p : ℤ) q.num).get</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='multiplicity'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='q'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='rat.num'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='roption.get'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/ring_theory/multiplicity.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/int/basic.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/rat/basic.lean&#x27;, &#x27;line&#x27;: 46, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/pfun.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : comm_semiring.{u_1} α] [_inst_2 : @decidable_rel.{u_1+1} α (@has_dvd.dvd.{u_1} α (@comm_semiring_has_dvd.{u_1} α _inst_1))], α → α → enat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='rat → int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} (c : roption.{0} α), @roption.dom.{0} α c → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='`multiplicity a b` returns the largest natural number `n` such that
 `a ^ n ∣ b`, as an `enat` or natural with infinity. If `∀ n, a ^ n ∣ b`,
 then it returns `⊤`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 65      (multiplicity.finite_int_iff.2 ⟨h.2, rat.num_ne_zero_of_ne_zero h.1⟩) -</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='multiplicity.finite_int_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='iff.mpr'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='and.right'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='rat.num_ne_zero_of_ne_zero'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='and.left'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='has_sub.sub'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/ring_theory/multiplicity.lean&#x27;, &#x27;line&#x27;: 184, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/rat/basic.lean&#x27;, &#x27;line&#x27;: 480, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 315, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='∀ {a b : int}, iff (@multiplicity.finite.{0} int int.comm_semiring a b) (and (@ne.{1} nat (int.nat_abs a) (@has_one.one.{0} nat nat.has_one)) (@ne.{1} int b (@has_zero.zero.{0} int int.has_zero)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, iff a b → b → a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='and (@ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)) (@ne.{1} nat p (@has_one.one.{0} nat nat.has_one))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, and a b → b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {q : rat}, @ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero) → @ne.{1} int (q.num) (@has_zero.zero.{0} int int.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='and (@ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)) (@ne.{1} nat p (@has_one.one.{0} nat nat.has_one))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, and a b → a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type} [c : has_sub.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 66    (multiplicity (p : ℤ) q.denom).get</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='multiplicity'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='q'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='rat.denom'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='roption.get'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/ring_theory/multiplicity.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/int/basic.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/rat/basic.lean&#x27;, &#x27;line&#x27;: 46, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/pfun.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : comm_semiring.{u_1} α] [_inst_2 : @decidable_rel.{u_1+1} α (@has_dvd.dvd.{u_1} α (@comm_semiring_has_dvd.{u_1} α _inst_1))], α → α → enat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='rat → nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} (c : roption.{0} α), @roption.dom.{0} α c → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`multiplicity a b` returns the largest natural number `n` such that
 `a ^ n ∣ b`, as an `enat` or natural with infinity. If `∀ n, a ^ n ∣ b`,
 then it returns `⊤`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 67      (multiplicity.finite_int_iff.2 ⟨h.2, by exact_mod_cast rat.denom_ne_zero _⟩)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='multiplicity.finite_int_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='iff.mpr'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='and.right'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='blue'><a title='rat.denom_ne_zero'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/ring_theory/multiplicity.lean&#x27;, &#x27;line&#x27;: 184, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/norm_cast.lean&#x27;, &#x27;line&#x27;: 335, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/rat/basic.lean&#x27;, &#x27;line&#x27;: 488, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/norm_cast.lean&#x27;, &#x27;line&#x27;: 335, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='∀ {a b : int}, iff (@multiplicity.finite.{0} int int.comm_semiring a b) (and (@ne.{1} nat (int.nat_abs a) (@has_one.one.{0} nat nat.has_one)) (@ne.{1} int b (@has_zero.zero.{0} int int.has_zero)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, iff a b → b → a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='and (@ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)) (@ne.{1} nat p (@has_one.one.{0} nat nat.has_one))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, and a b → b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (q : rat), @ne.{1} nat (q.denom) (@has_zero.zero.{0} nat nat.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                            </code><font color='orange'><a title='Normalize the goal and the given expression,
then close the goal with exact.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='Normalize the goal and the given expression,
then close the goal with exact.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                            </code><font color='teal'><a title='exact_mod_cast'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='exact_mod_cast'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                            </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                           </code><font color='lime'><a title='p : nat,
q : rat,
h : and (@ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)) (@ne.{1} nat p (@has_one.one.{0} nat nat.has_one))
⊢ @ne.{1} int (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
    (@has_zero.zero.{0} int int.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 68  else 0</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='not'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 142, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 69  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 70  /--</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 71  A simplification of the definition of `padic_val_rat p q` when `q ≠ 0` and `p` is prime.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 72  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 73  lemma padic_val_rat_def (p : ℕ) [hp : p.prime] {q : ℚ} (hq : q ≠ 0) : padic_val_rat p q =</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='blue'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='nat.prime'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='q'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ne'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='padic_val_rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='q'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 293, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/nat/prime.lean&#x27;, &#x27;line&#x27;: 36, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/rat/basic.lean&#x27;, &#x27;line&#x27;: 46, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 97, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 62, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='nat → rat → int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='orange'><a title='`prime p` means that `p` is a prime number, that is, a natural number
 at least 2 whose only divisors are `p` and `1`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='`rat`, or `ℚ`, is the type of rational numbers. It is defined
 as the set of pairs ⟨n, d⟩ of integers such that `d` is positive and `n` and
 `d` are coprime. This representation is preferred to the quotient
 because without periodic reduction, the numerator and denominator can grow
 exponentially (for example, adding 1/2 to itself repeatedly).'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='For `p ≠ 1`, the p-adic valuation of an integer `z ≠ 0` is the largest natural number `n` such that
p^n divides z.

`padic_val_rat` defines the valuation of a rational `q` to be the valuation of `q.num` minus the
valuation of `q.denom`.
If `q = 0` or `p = 1`, then `padic_val_rat p q` defaults to 0.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 74    (multiplicity (p : ℤ) q.num).get (finite_int_iff.2 ⟨hp.ne_one, rat.num_ne_zero_of_ne_zero hq⟩) -</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='multiplicity'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='q'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='rat.num'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='roption.get'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='multiplicity.finite_int_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='iff.mpr'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='hp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='nat.prime.ne_one'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='rat.num_ne_zero_of_ne_zero'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='has_sub.sub'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/ring_theory/multiplicity.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/int/basic.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/rat/basic.lean&#x27;, &#x27;line&#x27;: 46, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/pfun.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/ring_theory/multiplicity.lean&#x27;, &#x27;line&#x27;: 184, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/nat/prime.lean&#x27;, &#x27;line&#x27;: 42, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/rat/basic.lean&#x27;, &#x27;line&#x27;: 480, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 315, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : comm_semiring.{u_1} α] [_inst_2 : @decidable_rel.{u_1+1} α (@has_dvd.dvd.{u_1} α (@comm_semiring_has_dvd.{u_1} α _inst_1))], α → α → enat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='rat → int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} (c : roption.{0} α), @roption.dom.{0} α c → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {a b : int}, iff (@multiplicity.finite.{0} int int.comm_semiring a b) (and (@ne.{1} nat (int.nat_abs a) (@has_one.one.{0} nat nat.has_one)) (@ne.{1} int b (@has_zero.zero.{0} int int.has_zero)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, iff a b → b → a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='nat.prime p'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {p : nat}, nat.prime p → @ne.{1} nat p (@has_one.one.{0} nat nat.has_one)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {q : rat}, @ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero) → @ne.{1} int (q.num) (@has_zero.zero.{0} int int.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type} [c : has_sub.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`multiplicity a b` returns the largest natural number `n` such that
 `a ^ n ∣ b`, as an `enat` or natural with infinity. If `∀ n, a ^ n ∣ b`,
 then it returns `⊤`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 75    (multiplicity (p : ℤ) q.denom).get (finite_int_iff.2 ⟨hp.ne_one, by exact_mod_cast rat.denom_ne_zero _⟩) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='multiplicity'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='q'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='rat.denom'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='roption.get'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='multiplicity.finite_int_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='iff.mpr'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='hp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='nat.prime.ne_one'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='blue'><a title='rat.denom_ne_zero'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/ring_theory/multiplicity.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/int/basic.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/rat/basic.lean&#x27;, &#x27;line&#x27;: 46, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/pfun.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/ring_theory/multiplicity.lean&#x27;, &#x27;line&#x27;: 184, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/nat/prime.lean&#x27;, &#x27;line&#x27;: 42, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/norm_cast.lean&#x27;, &#x27;line&#x27;: 335, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/rat/basic.lean&#x27;, &#x27;line&#x27;: 488, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/norm_cast.lean&#x27;, &#x27;line&#x27;: 335, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : comm_semiring.{u_1} α] [_inst_2 : @decidable_rel.{u_1+1} α (@has_dvd.dvd.{u_1} α (@comm_semiring_has_dvd.{u_1} α _inst_1))], α → α → enat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='rat → nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} (c : roption.{0} α), @roption.dom.{0} α c → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {a b : int}, iff (@multiplicity.finite.{0} int int.comm_semiring a b) (and (@ne.{1} nat (int.nat_abs a) (@has_one.one.{0} nat nat.has_one)) (@ne.{1} int b (@has_zero.zero.{0} int int.has_zero)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, iff a b → b → a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='nat.prime p'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {p : nat}, nat.prime p → @ne.{1} nat p (@has_one.one.{0} nat nat.has_one)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (q : rat), @ne.{1} nat (q.denom) (@has_zero.zero.{0} nat nat.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`multiplicity a b` returns the largest natural number `n` such that
 `a ^ n ∣ b`, as an `enat` or natural with infinity. If `∀ n, a ^ n ∣ b`,
 then it returns `⊤`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                       </code><font color='orange'><a title='Normalize the goal and the given expression,
then close the goal with exact.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='Normalize the goal and the given expression,
then close the goal with exact.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                      </code><font color='teal'><a title='exact_mod_cast'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='exact_mod_cast'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                                    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                     </code><font color='lime'><a title='p : nat,
hp : nat.prime p,
q : rat,
hq : @ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)
⊢ @ne.{1} int (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
    (@has_zero.zero.{0} int int.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 76  dif_pos ⟨hq, hp.ne_one⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='dif_pos'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='nat.prime.ne_one'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 928, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/nat/prime.lean&#x27;, &#x27;line&#x27;: 42, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {c : Prop} [h : decidable c] (hc : c) {α : Type} {t : c → α} {e : not c → α}, @eq.{1} α (@dite.{1} c h α t e) (t hc)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='nat.prime p'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {p : nat}, nat.prime p → @ne.{1} nat p (@has_one.one.{0} nat nat.has_one)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 77  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 78  namespace padic_val_rat</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 79  open multiplicity</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 80  section padic_val_rat</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 81  variables {p : ℕ}</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 293, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 82  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 83  /--</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 84  `padic_val_rat p q` is symmetric in `q`.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 85  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 86  @[simp] protected lemma neg (q : ℚ) : padic_val_rat p (-q) = padic_val_rat p q :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='blue'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='padic_val_rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_neg.neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='q'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='padic_val_rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='q'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/rat/basic.lean&#x27;, &#x27;line&#x27;: 46, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 62, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 314, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 62, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='nat → rat → int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type} [c : has_neg.{0} α], α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat → rat → int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='orange'><a title='`rat`, or `ℚ`, is the type of rational numbers. It is defined
 as the set of pairs ⟨n, d⟩ of integers such that `d` is positive and `n` and
 `d` are coprime. This representation is preferred to the quotient
 because without periodic reduction, the numerator and denominator can grow
 exponentially (for example, adding 1/2 to itself repeatedly).'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='For `p ≠ 1`, the p-adic valuation of an integer `z ≠ 0` is the largest natural number `n` such that
p^n divides z.

`padic_val_rat` defines the valuation of a rational `q` to be the valuation of `q.num` minus the
valuation of `q.denom`.
If `q = 0` or `p = 1`, then `padic_val_rat p q` defaults to 0.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='For `p ≠ 1`, the p-adic valuation of an integer `z ≠ 0` is the largest natural number `n` such that
p^n divides z.

`padic_val_rat` defines the valuation of a rational `q` to be the valuation of `q.num` minus the
valuation of `q.denom`.
If `q = 0` or `p = 1`, then `padic_val_rat p q` defaults to 0.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 87  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
q : rat
⊢ @eq.{1} int (padic_val_rat p (@has_neg.neg.{0} rat rat.has_neg q)) (padic_val_rat p q)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 88    unfold padic_val_rat,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1411, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.unfold_config {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.ff, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.ff, beta := bool.tt, eta := bool.ff, proj := bool.ff, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.ff, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Given defined constants `e₁ ... eₙ`, `unfold e₁ ... eₙ` iteratively unfolds all occurrences in the target of the main goal, using equational lemmas associated with the definitions.

As with `simp`, the `at` modifier can be used to specify locations for the unfolding.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='unfold'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id*&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.unfold_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
q : rat
⊢ @eq.{1} int (padic_val_rat p (@has_neg.neg.{0} rat rat.has_neg q)) (padic_val_rat p q)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
q : rat
⊢ @eq.{1} int
    (@dite.{1}
       (and (@ne.{1} rat (@has_neg.neg.{0} rat rat.has_neg q) (@has_zero.zero.{0} rat rat.has_zero))
          (@ne.{1} nat p (@has_one.one.{0} nat nat.has_one)))
       (@and.decidable (@ne.{1} rat (@has_neg.neg.{0} rat rat.has_neg q) (@has_zero.zero.{0} rat rat.has_zero))
          (@ne.{1} nat p (@has_one.one.{0} nat nat.has_one))
          (@ne.decidable.{1} rat (λ (a b : rat), rat.decidable_eq a b) (@has_neg.neg.{0} rat rat.has_neg q)
             (@has_zero.zero.{0} rat rat.has_zero))
          (@ne.decidable.{1} nat (λ (a b : nat), nat.decidable_eq a b) p (@has_one.one.{0} nat nat.has_one)))
       int
       (λ
        (h :
          and (@ne.{1} rat (@has_neg.neg.{0} rat rat.has_neg q) (@has_zero.zero.{0} rat rat.has_zero))
            (@ne.{1} nat p (@has_one.one.{0} nat nat.has_one))),
          @has_sub.sub.{0} int int.has_sub
            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
               (@roption.get.{0} nat
                  (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
                     (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                     ((@has_neg.neg.{0} rat rat.has_neg q).num))
                  (padic_val_rat._proof_1 p (@has_neg.neg.{0} rat rat.has_neg q) h)))
            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
               (@roption.get.{0} nat
                  (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
                     (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                     (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                        ((@has_neg.neg.{0} rat rat.has_neg q).denom)))
                  (padic_val_rat._proof_2 p (@has_neg.neg.{0} rat rat.has_neg q) h))))
       (λ
        (h :
          not
            (and (@ne.{1} rat (@has_neg.neg.{0} rat rat.has_neg q) (@has_zero.zero.{0} rat rat.has_zero))
               (@ne.{1} nat p (@has_one.one.{0} nat nat.has_one)))), @has_zero.zero.{0} int int.has_zero))
    (@dite.{1}
       (and (@ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)) (@ne.{1} nat p (@has_one.one.{0} nat nat.has_one)))
       (@and.decidable (@ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero))
          (@ne.{1} nat p (@has_one.one.{0} nat nat.has_one))
          (@ne.decidable.{1} rat (λ (a b : rat), rat.decidable_eq a b) q (@has_zero.zero.{0} rat rat.has_zero))
          (@ne.decidable.{1} nat (λ (a b : nat), nat.decidable_eq a b) p (@has_one.one.{0} nat nat.has_one)))
       int
       (λ
        (h :
          and (@ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)) (@ne.{1} nat p (@has_one.one.{0} nat nat.has_one))),
          @has_sub.sub.{0} int int.has_sub
            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
               (@roption.get.{0} nat
                  (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
                     (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                     (q.num))
                  (padic_val_rat._proof_1 p q h)))
            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
               (@roption.get.{0} nat
                  (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
                     (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                     (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))
                  (padic_val_rat._proof_2 p q h))))
       (λ
        (h :
          not
            (and (@ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero))
               (@ne.{1} nat p (@has_one.one.{0} nat nat.has_one)))), @has_zero.zero.{0} int int.has_zero))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 89    split_ifs,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/split_ifs.lean&#x27;, &#x27;line&#x27;: 84, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title=' Splits all if-then-else-expressions into multiple goals.

Given a goal of the form `g (if p then x else y)`, `split_ifs` will produce
two goals: `p ⊢ g x` and `¬p ⊢ g y`.

If there are multiple ite-expressions, then `split_ifs` will split them all,
starting with a top-most one whose condition does not contain another
ite-expression.

`split_ifs at *` splits all ite-expressions in all hypotheses as well as the goal.

`split_ifs with h₁ h₂ h₃` overrides the default names for the hypotheses.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='split_ifs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
q : rat
⊢ @eq.{1} int
    (@dite.{1}
       (and (@ne.{1} rat (@has_neg.neg.{0} rat rat.has_neg q) (@has_zero.zero.{0} rat rat.has_zero))
          (@ne.{1} nat p (@has_one.one.{0} nat nat.has_one)))
       (@and.decidable (@ne.{1} rat (@has_neg.neg.{0} rat rat.has_neg q) (@has_zero.zero.{0} rat rat.has_zero))
          (@ne.{1} nat p (@has_one.one.{0} nat nat.has_one))
          (@ne.decidable.{1} rat (λ (a b : rat), rat.decidable_eq a b) (@has_neg.neg.{0} rat rat.has_neg q)
             (@has_zero.zero.{0} rat rat.has_zero))
          (@ne.decidable.{1} nat (λ (a b : nat), nat.decidable_eq a b) p (@has_one.one.{0} nat nat.has_one)))
       int
       (λ
        (h :
          and (@ne.{1} rat (@has_neg.neg.{0} rat rat.has_neg q) (@has_zero.zero.{0} rat rat.has_zero))
            (@ne.{1} nat p (@has_one.one.{0} nat nat.has_one))),
          @has_sub.sub.{0} int int.has_sub
            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
               (@roption.get.{0} nat
                  (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
                     (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                     ((@has_neg.neg.{0} rat rat.has_neg q).num))
                  (padic_val_rat._proof_1 p (@has_neg.neg.{0} rat rat.has_neg q) h)))
            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
               (@roption.get.{0} nat
                  (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
                     (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                     (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                        ((@has_neg.neg.{0} rat rat.has_neg q).denom)))
                  (padic_val_rat._proof_2 p (@has_neg.neg.{0} rat rat.has_neg q) h))))
       (λ
        (h :
          not
            (and (@ne.{1} rat (@has_neg.neg.{0} rat rat.has_neg q) (@has_zero.zero.{0} rat rat.has_zero))
               (@ne.{1} nat p (@has_one.one.{0} nat nat.has_one)))), @has_zero.zero.{0} int int.has_zero))
    (@dite.{1}
       (and (@ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)) (@ne.{1} nat p (@has_one.one.{0} nat nat.has_one)))
       (@and.decidable (@ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero))
          (@ne.{1} nat p (@has_one.one.{0} nat nat.has_one))
          (@ne.decidable.{1} rat (λ (a b : rat), rat.decidable_eq a b) q (@has_zero.zero.{0} rat rat.has_zero))
          (@ne.decidable.{1} nat (λ (a b : nat), nat.decidable_eq a b) p (@has_one.one.{0} nat nat.has_one)))
       int
       (λ
        (h :
          and (@ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)) (@ne.{1} nat p (@has_one.one.{0} nat nat.has_one))),
          @has_sub.sub.{0} int int.has_sub
            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
               (@roption.get.{0} nat
                  (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
                     (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                     (q.num))
                  (padic_val_rat._proof_1 p q h)))
            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
               (@roption.get.{0} nat
                  (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
                     (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                     (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))
                  (padic_val_rat._proof_2 p q h))))
       (λ
        (h :
          not
            (and (@ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero))
               (@ne.{1} nat p (@has_one.one.{0} nat nat.has_one)))), @has_zero.zero.{0} int int.has_zero))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='4 goals
p : nat,
q : rat,
h :
  and (@ne.{1} rat (@has_neg.neg.{0} rat rat.has_neg q) (@has_zero.zero.{0} rat rat.has_zero))
    (@ne.{1} nat p (@has_one.one.{0} nat nat.has_one)),
h_1 : and (@ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)) (@ne.{1} nat p (@has_one.one.{0} nat nat.has_one))
⊢ @eq.{1} int
    (@has_sub.sub.{0} int int.has_sub
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
          (@roption.get.{0} nat
             (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                ((@has_neg.neg.{0} rat rat.has_neg q).num))
             (padic_val_rat._proof_1 p (@has_neg.neg.{0} rat rat.has_neg q) h)))
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
          (@roption.get.{0} nat
             (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                   ((@has_neg.neg.{0} rat rat.has_neg q).denom)))
             (padic_val_rat._proof_2 p (@has_neg.neg.{0} rat rat.has_neg q) h))))
    (@has_sub.sub.{0} int int.has_sub
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
          (@roption.get.{0} nat
             (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                (q.num))
             (padic_val_rat._proof_1 p q h_1)))
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
          (@roption.get.{0} nat
             (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))
             (padic_val_rat._proof_2 p q h_1))))

p : nat,
q : rat,
h :
  and (@ne.{1} rat (@has_neg.neg.{0} rat rat.has_neg q) (@has_zero.zero.{0} rat rat.has_zero))
    (@ne.{1} nat p (@has_one.one.{0} nat nat.has_one)),
h_1 : not (and (@ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)) (@ne.{1} nat p (@has_one.one.{0} nat nat.has_one)))
⊢ @eq.{1} int
    (@has_sub.sub.{0} int int.has_sub
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
          (@roption.get.{0} nat
             (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                ((@has_neg.neg.{0} rat rat.has_neg q).num))
             (padic_val_rat._proof_1 p (@has_neg.neg.{0} rat rat.has_neg q) h)))
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
          (@roption.get.{0} nat
             (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                   ((@has_neg.neg.{0} rat rat.has_neg q).denom)))
             (padic_val_rat._proof_2 p (@has_neg.neg.{0} rat rat.has_neg q) h))))
    (@has_zero.zero.{0} int int.has_zero)

p : nat,
q : rat,
h :
  not
    (and (@ne.{1} rat (@has_neg.neg.{0} rat rat.has_neg q) (@has_zero.zero.{0} rat rat.has_zero))
       (@ne.{1} nat p (@has_one.one.{0} nat nat.has_one))),
h_1 : and (@ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)) (@ne.{1} nat p (@has_one.one.{0} nat nat.has_one))
⊢ @eq.{1} int (@has_zero.zero.{0} int int.has_zero)
    (@has_sub.sub.{0} int int.has_sub
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
          (@roption.get.{0} nat
             (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                (q.num))
             (padic_val_rat._proof_1 p q h_1)))
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
          (@roption.get.{0} nat
             (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))
             (padic_val_rat._proof_2 p q h_1))))

p : nat,
q : rat,
h :
  not
    (and (@ne.{1} rat (@has_neg.neg.{0} rat rat.has_neg q) (@has_zero.zero.{0} rat rat.has_zero))
       (@ne.{1} nat p (@has_one.one.{0} nat nat.has_one))),
h_1 : not (and (@ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)) (@ne.{1} nat p (@has_one.one.{0} nat nat.has_one)))
⊢ @eq.{1} int (@has_zero.zero.{0} int int.has_zero) (@has_zero.zero.{0} int int.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 90    { simp [-add_comm]; refl },</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1263, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Shorter name for the tactic `reflexivity`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='4 goals
p : nat,
q : rat,
h :
  and (@ne.{1} rat (@has_neg.neg.{0} rat rat.has_neg q) (@has_zero.zero.{0} rat rat.has_zero))
    (@ne.{1} nat p (@has_one.one.{0} nat nat.has_one)),
h_1 : and (@ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)) (@ne.{1} nat p (@has_one.one.{0} nat nat.has_one))
⊢ @eq.{1} int
    (@has_sub.sub.{0} int int.has_sub
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
          (@roption.get.{0} nat
             (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                ((@has_neg.neg.{0} rat rat.has_neg q).num))
             (padic_val_rat._proof_1 p (@has_neg.neg.{0} rat rat.has_neg q) h)))
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
          (@roption.get.{0} nat
             (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                   ((@has_neg.neg.{0} rat rat.has_neg q).denom)))
             (padic_val_rat._proof_2 p (@has_neg.neg.{0} rat rat.has_neg q) h))))
    (@has_sub.sub.{0} int int.has_sub
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
          (@roption.get.{0} nat
             (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                (q.num))
             (padic_val_rat._proof_1 p q h_1)))
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
          (@roption.get.{0} nat
             (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))
             (padic_val_rat._proof_2 p q h_1))))

p : nat,
q : rat,
h :
  and (@ne.{1} rat (@has_neg.neg.{0} rat rat.has_neg q) (@has_zero.zero.{0} rat rat.has_zero))
    (@ne.{1} nat p (@has_one.one.{0} nat nat.has_one)),
h_1 : not (and (@ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)) (@ne.{1} nat p (@has_one.one.{0} nat nat.has_one)))
⊢ @eq.{1} int
    (@has_sub.sub.{0} int int.has_sub
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
          (@roption.get.{0} nat
             (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                ((@has_neg.neg.{0} rat rat.has_neg q).num))
             (padic_val_rat._proof_1 p (@has_neg.neg.{0} rat rat.has_neg q) h)))
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
          (@roption.get.{0} nat
             (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                   ((@has_neg.neg.{0} rat rat.has_neg q).denom)))
             (padic_val_rat._proof_2 p (@has_neg.neg.{0} rat rat.has_neg q) h))))
    (@has_zero.zero.{0} int int.has_zero)

p : nat,
q : rat,
h :
  not
    (and (@ne.{1} rat (@has_neg.neg.{0} rat rat.has_neg q) (@has_zero.zero.{0} rat rat.has_zero))
       (@ne.{1} nat p (@has_one.one.{0} nat nat.has_one))),
h_1 : and (@ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)) (@ne.{1} nat p (@has_one.one.{0} nat nat.has_one))
⊢ @eq.{1} int (@has_zero.zero.{0} int int.has_zero)
    (@has_sub.sub.{0} int int.has_sub
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
          (@roption.get.{0} nat
             (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                (q.num))
             (padic_val_rat._proof_1 p q h_1)))
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
          (@roption.get.{0} nat
             (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))
             (padic_val_rat._proof_2 p q h_1))))

p : nat,
q : rat,
h :
  not
    (and (@ne.{1} rat (@has_neg.neg.{0} rat rat.has_neg q) (@has_zero.zero.{0} rat rat.has_zero))
       (@ne.{1} nat p (@has_one.one.{0} nat nat.has_one))),
h_1 : not (and (@ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)) (@ne.{1} nat p (@has_one.one.{0} nat nat.has_one)))
⊢ @eq.{1} int (@has_zero.zero.{0} int int.has_zero) (@has_zero.zero.{0} int int.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
q : rat,
h :
  and (@ne.{1} rat (@has_neg.neg.{0} rat rat.has_neg q) (@has_zero.zero.{0} rat rat.has_zero))
    (@ne.{1} nat p (@has_one.one.{0} nat nat.has_one)),
h_1 : and (@ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)) (@ne.{1} nat p (@has_one.one.{0} nat nat.has_one))
⊢ @eq.{1} int
    (@has_sub.sub.{0} int int.has_sub
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
          (@roption.get.{0} nat
             (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                ((@has_neg.neg.{0} rat rat.has_neg q).num))
             (padic_val_rat._proof_1 p (@has_neg.neg.{0} rat rat.has_neg q) h)))
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
          (@roption.get.{0} nat
             (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                   ((@has_neg.neg.{0} rat rat.has_neg q).denom)))
             (padic_val_rat._proof_2 p (@has_neg.neg.{0} rat rat.has_neg q) h))))
    (@has_sub.sub.{0} int int.has_sub
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
          (@roption.get.{0} nat
             (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                (q.num))
             (padic_val_rat._proof_1 p q h_1)))
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
          (@roption.get.{0} nat
             (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))
             (padic_val_rat._proof_2 p q h_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
p : nat,
q : rat,
h :
  and (@ne.{1} rat (@has_neg.neg.{0} rat rat.has_neg q) (@has_zero.zero.{0} rat rat.has_zero))
    (@ne.{1} nat p (@has_one.one.{0} nat nat.has_one)),
h_1 : not (and (@ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)) (@ne.{1} nat p (@has_one.one.{0} nat nat.has_one)))
⊢ @eq.{1} int
    (@has_sub.sub.{0} int int.has_sub
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
          (@roption.get.{0} nat
             (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                ((@has_neg.neg.{0} rat rat.has_neg q).num))
             (padic_val_rat._proof_1 p (@has_neg.neg.{0} rat rat.has_neg q) h)))
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
          (@roption.get.{0} nat
             (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                   ((@has_neg.neg.{0} rat rat.has_neg q).denom)))
             (padic_val_rat._proof_2 p (@has_neg.neg.{0} rat rat.has_neg q) h))))
    (@has_zero.zero.{0} int int.has_zero)

p : nat,
q : rat,
h :
  not
    (and (@ne.{1} rat (@has_neg.neg.{0} rat rat.has_neg q) (@has_zero.zero.{0} rat rat.has_zero))
       (@ne.{1} nat p (@has_one.one.{0} nat nat.has_one))),
h_1 : and (@ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)) (@ne.{1} nat p (@has_one.one.{0} nat nat.has_one))
⊢ @eq.{1} int (@has_zero.zero.{0} int int.has_zero)
    (@has_sub.sub.{0} int int.has_sub
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
          (@roption.get.{0} nat
             (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                (q.num))
             (padic_val_rat._proof_1 p q h_1)))
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
          (@roption.get.{0} nat
             (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))
             (padic_val_rat._proof_2 p q h_1))))

p : nat,
q : rat,
h :
  not
    (and (@ne.{1} rat (@has_neg.neg.{0} rat rat.has_neg q) (@has_zero.zero.{0} rat rat.has_zero))
       (@ne.{1} nat p (@has_one.one.{0} nat nat.has_one))),
h_1 : not (and (@ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)) (@ne.{1} nat p (@has_one.one.{0} nat nat.has_one)))
⊢ @eq.{1} int (@has_zero.zero.{0} int int.has_zero) (@has_zero.zero.{0} int int.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 91    { exfalso, simp * at * },</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1026, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Replaces the target of the main goal by `false`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exfalso'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='5'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
p : nat,
q : rat,
h :
  and (@ne.{1} rat (@has_neg.neg.{0} rat rat.has_neg q) (@has_zero.zero.{0} rat rat.has_zero))
    (@ne.{1} nat p (@has_one.one.{0} nat nat.has_one)),
h_1 : not (and (@ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)) (@ne.{1} nat p (@has_one.one.{0} nat nat.has_one)))
⊢ @eq.{1} int
    (@has_sub.sub.{0} int int.has_sub
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
          (@roption.get.{0} nat
             (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                ((@has_neg.neg.{0} rat rat.has_neg q).num))
             (padic_val_rat._proof_1 p (@has_neg.neg.{0} rat rat.has_neg q) h)))
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
          (@roption.get.{0} nat
             (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                   ((@has_neg.neg.{0} rat rat.has_neg q).denom)))
             (padic_val_rat._proof_2 p (@has_neg.neg.{0} rat rat.has_neg q) h))))
    (@has_zero.zero.{0} int int.has_zero)

p : nat,
q : rat,
h :
  not
    (and (@ne.{1} rat (@has_neg.neg.{0} rat rat.has_neg q) (@has_zero.zero.{0} rat rat.has_zero))
       (@ne.{1} nat p (@has_one.one.{0} nat nat.has_one))),
h_1 : and (@ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)) (@ne.{1} nat p (@has_one.one.{0} nat nat.has_one))
⊢ @eq.{1} int (@has_zero.zero.{0} int int.has_zero)
    (@has_sub.sub.{0} int int.has_sub
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
          (@roption.get.{0} nat
             (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                (q.num))
             (padic_val_rat._proof_1 p q h_1)))
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
          (@roption.get.{0} nat
             (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))
             (padic_val_rat._proof_2 p q h_1))))

p : nat,
q : rat,
h :
  not
    (and (@ne.{1} rat (@has_neg.neg.{0} rat rat.has_neg q) (@has_zero.zero.{0} rat rat.has_zero))
       (@ne.{1} nat p (@has_one.one.{0} nat nat.has_one))),
h_1 : not (and (@ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)) (@ne.{1} nat p (@has_one.one.{0} nat nat.has_one)))
⊢ @eq.{1} int (@has_zero.zero.{0} int int.has_zero) (@has_zero.zero.{0} int int.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
q : rat,
h :
  and (@ne.{1} rat (@has_neg.neg.{0} rat rat.has_neg q) (@has_zero.zero.{0} rat rat.has_zero))
    (@ne.{1} nat p (@has_one.one.{0} nat nat.has_one)),
h_1 : not (and (@ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)) (@ne.{1} nat p (@has_one.one.{0} nat nat.has_one)))
⊢ @eq.{1} int
    (@has_sub.sub.{0} int int.has_sub
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
          (@roption.get.{0} nat
             (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                ((@has_neg.neg.{0} rat rat.has_neg q).num))
             (padic_val_rat._proof_1 p (@has_neg.neg.{0} rat rat.has_neg q) h)))
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
          (@roption.get.{0} nat
             (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                   ((@has_neg.neg.{0} rat rat.has_neg q).denom)))
             (padic_val_rat._proof_2 p (@has_neg.neg.{0} rat rat.has_neg q) h))))
    (@has_zero.zero.{0} int int.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
q : rat,
h :
  and (@ne.{1} rat (@has_neg.neg.{0} rat rat.has_neg q) (@has_zero.zero.{0} rat rat.has_zero))
    (@ne.{1} nat p (@has_one.one.{0} nat nat.has_one)),
h_1 : not (and (@ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)) (@ne.{1} nat p (@has_one.one.{0} nat nat.has_one)))
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
p : nat,
q : rat,
h :
  not
    (and (@ne.{1} rat (@has_neg.neg.{0} rat rat.has_neg q) (@has_zero.zero.{0} rat rat.has_zero))
       (@ne.{1} nat p (@has_one.one.{0} nat nat.has_one))),
h_1 : and (@ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)) (@ne.{1} nat p (@has_one.one.{0} nat nat.has_one))
⊢ @eq.{1} int (@has_zero.zero.{0} int int.has_zero)
    (@has_sub.sub.{0} int int.has_sub
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
          (@roption.get.{0} nat
             (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                (q.num))
             (padic_val_rat._proof_1 p q h_1)))
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
          (@roption.get.{0} nat
             (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))
             (padic_val_rat._proof_2 p q h_1))))

p : nat,
q : rat,
h :
  not
    (and (@ne.{1} rat (@has_neg.neg.{0} rat rat.has_neg q) (@has_zero.zero.{0} rat rat.has_zero))
       (@ne.{1} nat p (@has_one.one.{0} nat nat.has_one))),
h_1 : not (and (@ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)) (@ne.{1} nat p (@has_one.one.{0} nat nat.has_one)))
⊢ @eq.{1} int (@has_zero.zero.{0} int int.has_zero) (@has_zero.zero.{0} int int.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 92    { exfalso, simp * at * },</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1026, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Replaces the target of the main goal by `false`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exfalso'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='5'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
p : nat,
q : rat,
h :
  not
    (and (@ne.{1} rat (@has_neg.neg.{0} rat rat.has_neg q) (@has_zero.zero.{0} rat rat.has_zero))
       (@ne.{1} nat p (@has_one.one.{0} nat nat.has_one))),
h_1 : and (@ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)) (@ne.{1} nat p (@has_one.one.{0} nat nat.has_one))
⊢ @eq.{1} int (@has_zero.zero.{0} int int.has_zero)
    (@has_sub.sub.{0} int int.has_sub
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
          (@roption.get.{0} nat
             (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                (q.num))
             (padic_val_rat._proof_1 p q h_1)))
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
          (@roption.get.{0} nat
             (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))
             (padic_val_rat._proof_2 p q h_1))))

p : nat,
q : rat,
h :
  not
    (and (@ne.{1} rat (@has_neg.neg.{0} rat rat.has_neg q) (@has_zero.zero.{0} rat rat.has_zero))
       (@ne.{1} nat p (@has_one.one.{0} nat nat.has_one))),
h_1 : not (and (@ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)) (@ne.{1} nat p (@has_one.one.{0} nat nat.has_one)))
⊢ @eq.{1} int (@has_zero.zero.{0} int int.has_zero) (@has_zero.zero.{0} int int.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
q : rat,
h :
  not
    (and (@ne.{1} rat (@has_neg.neg.{0} rat rat.has_neg q) (@has_zero.zero.{0} rat rat.has_zero))
       (@ne.{1} nat p (@has_one.one.{0} nat nat.has_one))),
h_1 : and (@ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)) (@ne.{1} nat p (@has_one.one.{0} nat nat.has_one))
⊢ @eq.{1} int (@has_zero.zero.{0} int int.has_zero)
    (@has_sub.sub.{0} int int.has_sub
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
          (@roption.get.{0} nat
             (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                (q.num))
             (padic_val_rat._proof_1 p q h_1)))
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
          (@roption.get.{0} nat
             (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))
             (padic_val_rat._proof_2 p q h_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
q : rat,
h :
  not
    (and (@ne.{1} rat (@has_neg.neg.{0} rat rat.has_neg q) (@has_zero.zero.{0} rat rat.has_zero))
       (@ne.{1} nat p (@has_one.one.{0} nat nat.has_one))),
h_1 : and (@ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)) (@ne.{1} nat p (@has_one.one.{0} nat nat.has_one))
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
q : rat,
h :
  not
    (and (@ne.{1} rat (@has_neg.neg.{0} rat rat.has_neg q) (@has_zero.zero.{0} rat rat.has_zero))
       (@ne.{1} nat p (@has_one.one.{0} nat nat.has_one))),
h_1 : not (and (@ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)) (@ne.{1} nat p (@has_one.one.{0} nat nat.has_one)))
⊢ @eq.{1} int (@has_zero.zero.{0} int int.has_zero) (@has_zero.zero.{0} int int.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 93    { refl }</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1263, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Shorter name for the tactic `reflexivity`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
q : rat,
h :
  not
    (and (@ne.{1} rat (@has_neg.neg.{0} rat rat.has_neg q) (@has_zero.zero.{0} rat rat.has_zero))
       (@ne.{1} nat p (@has_one.one.{0} nat nat.has_one))),
h_1 : not (and (@ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)) (@ne.{1} nat p (@has_one.one.{0} nat nat.has_one)))
⊢ @eq.{1} int (@has_zero.zero.{0} int int.has_zero) (@has_zero.zero.{0} int int.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 94  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 95  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 96  /--</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 97  `padic_val_rat p 1` is 0 for any `p`.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 98  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 99  @[simp] protected lemma one : padic_val_rat p 1 = 0 :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='blue'><a title='padic_val_rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='red'><a title='{&#x27;line&#x27;: 62, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='green'><a title='nat → rat → int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='orange'><a title='For `p ≠ 1`, the p-adic valuation of an integer `z ≠ 0` is the largest natural number `n` such that
p^n divides z.

`padic_val_rat` defines the valuation of a rational `q` to be the valuation of `q.num` minus the
valuation of `q.denom`.
If `q = 0` or `p = 1`, then `padic_val_rat p q` defaults to 0.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>100  by unfold padic_val_rat; split_ifs; simp *</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1411, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/split_ifs.lean&#x27;, &#x27;line&#x27;: 84, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.unfold_config {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.ff, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.ff, beta := bool.tt, eta := bool.ff, proj := bool.ff, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.ff, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='Given defined constants `e₁ ... eₙ`, `unfold e₁ ... eₙ` iteratively unfolds all occurrences in the target of the main goal, using equational lemmas associated with the definitions.

As with `simp`, the `at` modifier can be used to specify locations for the unfolding.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title=' Splits all if-then-else-expressions into multiple goals.

Given a goal of the form `g (if p then x else y)`, `split_ifs` will produce
two goals: `p ⊢ g x` and `¬p ⊢ g y`.

If there are multiple ite-expressions, then `split_ifs` will split them all,
starting with a top-most one whose condition does not contain another
ite-expression.

`split_ifs at *` splits all ite-expressions in all hypotheses as well as the goal.

`split_ifs with h₁ h₂ h₃` overrides the default names for the hypotheses.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='unfold'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='split_ifs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;id*&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.unfold_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='p : nat
⊢ @eq.{1} int (padic_val_rat p (@has_one.one.{0} rat rat.has_one)) (@has_zero.zero.{0} int int.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>101  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat
⊢ @eq.{1} int (padic_val_rat p (@has_one.one.{0} rat rat.has_one)) (@has_zero.zero.{0} int int.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>102  /--</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>103  For `p ≠ 0, p ≠ 1, `padic_val_rat p p` is 1.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>104  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>105  @[simp] lemma padic_val_rat_self (hp : 1 &lt; p) : padic_val_rat p p = 1 :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                         </code><font color='blue'><a title='has_lt.lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='padic_val_rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 320, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 62, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                         </code><font color='green'><a title='Π {α : Type} [c : has_lt.{0} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='nat → rat → int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                          </code><font color='orange'><a title='For `p ≠ 1`, the p-adic valuation of an integer `z ≠ 0` is the largest natural number `n` such that
p^n divides z.

`padic_val_rat` defines the valuation of a rational `q` to be the valuation of `q.num` minus the
valuation of `q.denom`.
If `q = 0` or `p = 1`, then `padic_val_rat p q` defaults to 0.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>106  by unfold padic_val_rat; split_ifs; simp [*, nat.one_lt_iff_ne_zero_and_ne_one] at *</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                             </code><font color='blue'><a title='nat.one_lt_iff_ne_zero_and_ne_one'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1411, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/split_ifs.lean&#x27;, &#x27;line&#x27;: 84, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/nat/basic.lean&#x27;, &#x27;line&#x27;: 154, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.unfold_config {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.ff, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.ff, beta := bool.tt, eta := bool.ff, proj := bool.ff, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.ff, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {n : nat}, iff (@has_lt.lt.{0} nat nat.has_lt (@has_one.one.{0} nat nat.has_one) n) (and (@ne.{1} nat n (@has_zero.zero.{0} nat nat.has_zero)) (@ne.{1} nat n (@has_one.one.{0} nat nat.has_one)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='Given defined constants `e₁ ... eₙ`, `unfold e₁ ... eₙ` iteratively unfolds all occurrences in the target of the main goal, using equational lemmas associated with the definitions.

As with `simp`, the `at` modifier can be used to specify locations for the unfolding.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title=' Splits all if-then-else-expressions into multiple goals.

Given a goal of the form `g (if p then x else y)`, `split_ifs` will produce
two goals: `p ⊢ g x` and `¬p ⊢ g y`.

If there are multiple ite-expressions, then `split_ifs` will split them all,
starting with a top-most one whose condition does not contain another
ite-expression.

`split_ifs at *` splits all ite-expressions in all hypotheses as well as the goal.

`split_ifs with h₁ h₂ h₃` overrides the default names for the hypotheses.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='unfold'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='split_ifs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;id*&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.unfold_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='5'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='p : nat,
hp : @has_lt.lt.{0} nat nat.has_lt (@has_one.one.{0} nat nat.has_one) p
⊢ @eq.{1} int
    (padic_val_rat p
       (@coe.{1 1} nat rat
          (@coe_to_lift.{1 1} nat rat
             (@coe_base.{1 1} nat rat (@nat.cast_coe.{0} rat rat.has_zero rat.has_one rat.has_add)))
          p))
    (@has_one.one.{0} int int.has_one)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>107  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='5'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : @has_lt.lt.{0} nat nat.has_lt (@has_one.one.{0} nat nat.has_one) p
⊢ @eq.{1} int
    (padic_val_rat p
       (@coe.{1 1} nat rat
          (@coe_to_lift.{1 1} nat rat
             (@coe_base.{1 1} nat rat (@nat.cast_coe.{0} rat rat.has_zero rat.has_one rat.has_add)))
          p))
    (@has_one.one.{0} int int.has_one)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>108  /--</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>109  The p-adic value of an integer `z ≠ 0` is the multiplicity of `p` in `z`.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>110  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>111  lemma padic_val_rat_of_int (z : ℤ) (hp : p ≠ 1) (hz : z ≠ 0) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='blue'><a title='int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ne'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ne'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/int/basic.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 97, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 97, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>112    padic_val_rat p (z : ℚ) = (multiplicity (p : ℤ) z).get</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='padic_val_rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='multiplicity'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='roption.get'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 62, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/rat/basic.lean&#x27;, &#x27;line&#x27;: 46, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/ring_theory/multiplicity.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/int/basic.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/pfun.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='nat → rat → int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : comm_semiring.{u_1} α] [_inst_2 : @decidable_rel.{u_1+1} α (@has_dvd.dvd.{u_1} α (@comm_semiring_has_dvd.{u_1} α _inst_1))], α → α → enat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} (c : roption.{0} α), @roption.dom.{0} α c → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='For `p ≠ 1`, the p-adic valuation of an integer `z ≠ 0` is the largest natural number `n` such that
p^n divides z.

`padic_val_rat` defines the valuation of a rational `q` to be the valuation of `q.num` minus the
valuation of `q.denom`.
If `q = 0` or `p = 1`, then `padic_val_rat p q` defaults to 0.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='`rat`, or `ℚ`, is the type of rational numbers. It is defined
 as the set of pairs ⟨n, d⟩ of integers such that `d` is positive and `n` and
 `d` are coprime. This representation is preferred to the quotient
 because without periodic reduction, the numerator and denominator can grow
 exponentially (for example, adding 1/2 to itself repeatedly).'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='`multiplicity a b` returns the largest natural number `n` such that
 `a ^ n ∣ b`, as an `enat` or natural with infinity. If `∀ n, a ^ n ∣ b`,
 then it returns `⊤`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>113      (finite_int_iff.2 ⟨hp, hz⟩) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='multiplicity.finite_int_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='iff.mpr'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='hp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hz'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/ring_theory/multiplicity.lean&#x27;, &#x27;line&#x27;: 184, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='∀ {a b : int}, iff (@multiplicity.finite.{0} int int.comm_semiring a b) (and (@ne.{1} nat (int.nat_abs a) (@has_one.one.{0} nat nat.has_one)) (@ne.{1} int b (@has_zero.zero.{0} int int.has_zero)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, iff a b → b → a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@ne.{1} nat p (@has_one.one.{0} nat nat.has_one)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@ne.{1} int z (@has_zero.zero.{0} int int.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>114  by rw [padic_val_rat, dif_pos]; simp *; refl</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='padic_val_rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='dif_pos'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 62, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 928, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1263, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat → rat → int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {c : Prop} [h : decidable c] (hc : c) {α : Type} {t : c → α} {e : not c → α}, @eq.{1} α (@dite.{1} c h α t e) (t hc)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='For `p ≠ 1`, the p-adic valuation of an integer `z ≠ 0` is the largest natural number `n` such that
p^n divides z.

`padic_val_rat` defines the valuation of a rational `q` to be the valuation of `q.num` minus the
valuation of `q.denom`.
If `q = 0` or `p = 1`, then `padic_val_rat p q` defaults to 0.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Shorter name for the tactic `reflexivity`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='p : nat,
z : int,
hp : @ne.{1} nat p (@has_one.one.{0} nat nat.has_one),
hz : @ne.{1} int z (@has_zero.zero.{0} int int.has_zero)
⊢ @eq.{1} int
    (padic_val_rat p
       (@coe.{1 1} int rat
          (@coe_to_lift.{1 1} int rat
             (@coe_base.{1 1} int rat (@int.cast_coe.{0} rat rat.has_neg rat.has_zero rat.has_one rat.has_add)))
          z))
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
       (@roption.get.{0} nat
          (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
             z)
          (@iff.mpr
             (@multiplicity.finite.{0} int int.comm_semiring
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                z)
             (and
                (@ne.{1} nat
                   (int.nat_abs
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                   (@has_one.one.{0} nat nat.has_one))
                (@ne.{1} int z (@has_zero.zero.{0} int int.has_zero)))
             (@multiplicity.finite_int_iff
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                z)
             (@and.intro
                (@ne.{1} nat
                   (int.nat_abs
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                   (@has_one.one.{0} nat nat.has_one))
                (@ne.{1} int z (@has_zero.zero.{0} int int.has_zero))
                hp
                hz))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
z : int,
hp : @ne.{1} nat p (@has_one.one.{0} nat nat.has_one),
hz : @ne.{1} int z (@has_zero.zero.{0} int int.has_zero)
⊢ @eq.{1} int
    (@dite.{1}
       (and
          (@ne.{1} rat
             (@coe.{1 1} int rat
                (@coe_to_lift.{1 1} int rat
                   (@coe_base.{1 1} int rat (@int.cast_coe.{0} rat rat.has_neg rat.has_zero rat.has_one rat.has_add)))
                z)
             (@has_zero.zero.{0} rat rat.has_zero))
          (@ne.{1} nat p (@has_one.one.{0} nat nat.has_one)))
       (@and.decidable
          (@ne.{1} rat
             (@coe.{1 1} int rat
                (@coe_to_lift.{1 1} int rat
                   (@coe_base.{1 1} int rat (@int.cast_coe.{0} rat rat.has_neg rat.has_zero rat.has_one rat.has_add)))
                z)
             (@has_zero.zero.{0} rat rat.has_zero))
          (@ne.{1} nat p (@has_one.one.{0} nat nat.has_one))
          (@ne.decidable.{1} rat (λ (a b : rat), rat.decidable_eq a b)
             (@coe.{1 1} int rat
                (@coe_to_lift.{1 1} int rat
                   (@coe_base.{1 1} int rat (@int.cast_coe.{0} rat rat.has_neg rat.has_zero rat.has_one rat.has_add)))
                z)
             (@has_zero.zero.{0} rat rat.has_zero))
          (@ne.decidable.{1} nat (λ (a b : nat), nat.decidable_eq a b) p (@has_one.one.{0} nat nat.has_one)))
       int
       (λ
        (h :
          and
            (@ne.{1} rat
               (@coe.{1 1} int rat
                  (@coe_to_lift.{1 1} int rat
                     (@coe_base.{1 1} int rat (@int.cast_coe.{0} rat rat.has_neg rat.has_zero rat.has_one rat.has_add)))
                  z)
               (@has_zero.zero.{0} rat rat.has_zero))
            (@ne.{1} nat p (@has_one.one.{0} nat nat.has_one))),
          @has_sub.sub.{0} int int.has_sub
            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
               (@roption.get.{0} nat
                  (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
                     (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                     ((@coe.{1 1} int rat
                         (@coe_to_lift.{1 1} int rat
                            (@coe_base.{1 1} int rat
                               (@int.cast_coe.{0} rat rat.has_neg rat.has_zero rat.has_one rat.has_add)))
                         z).num))
                  (padic_val_rat._proof_1 p
                     (@coe.{1 1} int rat
                        (@coe_to_lift.{1 1} int rat
                           (@coe_base.{1 1} int rat
                              (@int.cast_coe.{0} rat rat.has_neg rat.has_zero rat.has_one rat.has_add)))
                        z)
                     h)))
            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
               (@roption.get.{0} nat
                  (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
                     (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                     (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                        ((@coe.{1 1} int rat
                            (@coe_to_lift.{1 1} int rat
                               (@coe_base.{1 1} int rat
                                  (@int.cast_coe.{0} rat rat.has_neg rat.has_zero rat.has_one rat.has_add)))
                            z).denom)))
                  (padic_val_rat._proof_2 p
                     (@coe.{1 1} int rat
                        (@coe_to_lift.{1 1} int rat
                           (@coe_base.{1 1} int rat
                              (@int.cast_coe.{0} rat rat.has_neg rat.has_zero rat.has_one rat.has_add)))
                        z)
                     h))))
       (λ
        (h :
          not
            (and
               (@ne.{1} rat
                  (@coe.{1 1} int rat
                     (@coe_to_lift.{1 1} int rat
                        (@coe_base.{1 1} int rat
                           (@int.cast_coe.{0} rat rat.has_neg rat.has_zero rat.has_one rat.has_add)))
                     z)
                  (@has_zero.zero.{0} rat rat.has_zero))
               (@ne.{1} nat p (@has_one.one.{0} nat nat.has_one)))), @has_zero.zero.{0} int int.has_zero))
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
       (@roption.get.{0} nat
          (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
             z)
          (@iff.mpr
             (@multiplicity.finite.{0} int int.comm_semiring
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                z)
             (and
                (@ne.{1} nat
                   (int.nat_abs
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                   (@has_one.one.{0} nat nat.has_one))
                (@ne.{1} int z (@has_zero.zero.{0} int int.has_zero)))
             (@multiplicity.finite_int_iff
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                z)
             (@and.intro
                (@ne.{1} nat
                   (int.nat_abs
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                   (@has_one.one.{0} nat nat.has_one))
                (@ne.{1} int z (@has_zero.zero.{0} int int.has_zero))
                hp
                hz))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
p : nat,
z : int,
hp : @ne.{1} nat p (@has_one.one.{0} nat nat.has_one),
hz : @ne.{1} int z (@has_zero.zero.{0} int int.has_zero)
⊢ @eq.{1} int
    (@has_sub.sub.{0} int int.has_sub
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
          (@roption.get.{0} nat
             (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                ((@coe.{1 1} int rat
                    (@coe_to_lift.{1 1} int rat
                       (@coe_base.{1 1} int rat
                          (@int.cast_coe.{0} rat rat.has_neg rat.has_zero rat.has_one rat.has_add)))
                    z).num))
             (padic_val_rat._proof_1 p
                (@coe.{1 1} int rat
                   (@coe_to_lift.{1 1} int rat
                      (@coe_base.{1 1} int rat
                         (@int.cast_coe.{0} rat rat.has_neg rat.has_zero rat.has_one rat.has_add)))
                   z)
                ?m_1)))
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
          (@roption.get.{0} nat
             (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                   ((@coe.{1 1} int rat
                       (@coe_to_lift.{1 1} int rat
                          (@coe_base.{1 1} int rat
                             (@int.cast_coe.{0} rat rat.has_neg rat.has_zero rat.has_one rat.has_add)))
                       z).denom)))
             (padic_val_rat._proof_2 p
                (@coe.{1 1} int rat
                   (@coe_to_lift.{1 1} int rat
                      (@coe_base.{1 1} int rat
                         (@int.cast_coe.{0} rat rat.has_neg rat.has_zero rat.has_one rat.has_add)))
                   z)
                ?m_1))))
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
       (@roption.get.{0} nat
          (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
             z)
          (@iff.mpr
             (@multiplicity.finite.{0} int int.comm_semiring
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                z)
             (and
                (@ne.{1} nat
                   (int.nat_abs
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                   (@has_one.one.{0} nat nat.has_one))
                (@ne.{1} int z (@has_zero.zero.{0} int int.has_zero)))
             (@multiplicity.finite_int_iff
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                z)
             (@and.intro
                (@ne.{1} nat
                   (int.nat_abs
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                   (@has_one.one.{0} nat nat.has_one))
                (@ne.{1} int z (@has_zero.zero.{0} int int.has_zero))
                hp
                hz))))

p : nat,
z : int,
hp : @ne.{1} nat p (@has_one.one.{0} nat nat.has_one),
hz : @ne.{1} int z (@has_zero.zero.{0} int int.has_zero)
⊢ and
    (@ne.{1} rat
       (@coe.{1 1} int rat
          (@coe_to_lift.{1 1} int rat
             (@coe_base.{1 1} int rat (@int.cast_coe.{0} rat rat.has_neg rat.has_zero rat.has_one rat.has_add)))
          z)
       (@has_zero.zero.{0} rat rat.has_zero))
    (@ne.{1} nat p (@has_one.one.{0} nat nat.has_one))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
z : int,
hp : @ne.{1} nat p (@has_one.one.{0} nat nat.has_one),
hz : @ne.{1} int z (@has_zero.zero.{0} int int.has_zero)
⊢ @eq.{1} int
    (padic_val_rat p
       (@coe.{1 1} int rat
          (@coe_to_lift.{1 1} int rat
             (@coe_base.{1 1} int rat (@int.cast_coe.{0} rat rat.has_neg rat.has_zero rat.has_one rat.has_add)))
          z))
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
       (@roption.get.{0} nat
          (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
             z)
          (@iff.mpr
             (@multiplicity.finite.{0} int int.comm_semiring
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                z)
             (and
                (@ne.{1} nat
                   (int.nat_abs
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                   (@has_one.one.{0} nat nat.has_one))
                (@ne.{1} int z (@has_zero.zero.{0} int int.has_zero)))
             (@multiplicity.finite_int_iff
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                z)
             (@and.intro
                (@ne.{1} nat
                   (int.nat_abs
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                   (@has_one.one.{0} nat nat.has_one))
                (@ne.{1} int z (@has_zero.zero.{0} int int.has_zero))
                hp
                hz))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>115  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1263, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Shorter name for the tactic `reflexivity`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
z : int,
hp : @ne.{1} nat p (@has_one.one.{0} nat nat.has_one),
hz : @ne.{1} int z (@has_zero.zero.{0} int int.has_zero)
⊢ @eq.{1} int
    (padic_val_rat p
       (@coe.{1 1} int rat
          (@coe_to_lift.{1 1} int rat
             (@coe_base.{1 1} int rat (@int.cast_coe.{0} rat rat.has_neg rat.has_zero rat.has_one rat.has_add)))
          z))
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
       (@roption.get.{0} nat
          (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
             z)
          (@iff.mpr
             (@multiplicity.finite.{0} int int.comm_semiring
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                z)
             (and
                (@ne.{1} nat
                   (int.nat_abs
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                   (@has_one.one.{0} nat nat.has_one))
                (@ne.{1} int z (@has_zero.zero.{0} int int.has_zero)))
             (@multiplicity.finite_int_iff
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                z)
             (@and.intro
                (@ne.{1} nat
                   (int.nat_abs
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                   (@has_one.one.{0} nat nat.has_one))
                (@ne.{1} int z (@has_zero.zero.{0} int int.has_zero))
                hp
                hz))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>116  end padic_val_rat</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>117  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>118  section padic_val_rat</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>119  open multiplicity</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>120  variables (p : ℕ) [p_prime : nat.prime p]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='nat.prime'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 293, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/nat/prime.lean&#x27;, &#x27;line&#x27;: 36, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='nat → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='orange'><a title='`prime p` means that `p` is a prime number, that is, a natural number
 at least 2 whose only divisors are `p` and `1`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>121  include p_prime</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>122  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>123  /--</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>124  The multiplicity of `p : ℕ` in `a : ℤ` is finite exactly when `a ≠ 0`.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>125  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>126  lemma finite_int_prime_iff {p : ℕ} [p_prime : p.prime] {a : ℤ} : finite (p : ℤ) a ↔ a ≠ 0 :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='blue'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='nat.prime'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='multiplicity.finite'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ne'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 293, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/nat/prime.lean&#x27;, &#x27;line&#x27;: 36, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/int/basic.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/ring_theory/multiplicity.lean&#x27;, &#x27;line&#x27;: 29, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/int/basic.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 97, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : comm_semiring.{u_1} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                               </code><font color='orange'><a title='`prime p` means that `p` is a prime number, that is, a natural number
 at least 2 whose only divisors are `p` and `1`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>127  by simp [finite_int_iff, ne.symm (ne_of_lt (p_prime.one_lt))]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='multiplicity.finite_int_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ne.symm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ne_of_lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='p_prime'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/ring_theory/multiplicity.lean&#x27;, &#x27;line&#x27;: 184, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 112, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 87, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/nat/prime.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : int}, iff (@multiplicity.finite.{0} int int.comm_semiring a b) (and (@ne.{1} nat (int.nat_abs a) (@has_one.one.{0} nat nat.has_one)) (@ne.{1} int b (@has_zero.zero.{0} int int.has_zero)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} {a b : α}, @ne.{1} α a b → @ne.{1} α b a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type} [_inst_1 : preorder.{0} α] {a b : α}, @has_lt.lt.{0} α (@preorder.to_has_lt.{0} α _inst_1) a b → @ne.{1} α a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat.prime p'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='p : nat,
p_prime : nat.prime p,
a : int
⊢ iff
    (@multiplicity.finite.{0} int int.comm_semiring
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
       a)
    (@ne.{1} int a (@has_zero.zero.{0} int int.has_zero))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>128  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
p_prime : nat.prime p,
a : int
⊢ iff
    (@multiplicity.finite.{0} int int.comm_semiring
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
       a)
    (@ne.{1} int a (@has_zero.zero.{0} int int.has_zero))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>129  /--</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>130  A rewrite lemma for `padic_val_rat p q` when `q` is expressed in terms of `rat.mk`.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>131  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>132  protected lemma defn {q : ℚ} {n d : ℤ} (hqz : q ≠ 0) (qdf : q = n /. d) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='blue'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='q'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ne'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='q'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='rat.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='d'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/rat/basic.lean&#x27;, &#x27;line&#x27;: 46, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/int/basic.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 97, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/rat/basic.lean&#x27;, &#x27;line&#x27;: 96, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='int → int → rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='orange'><a title='`rat`, or `ℚ`, is the type of rational numbers. It is defined
 as the set of pairs ⟨n, d⟩ of integers such that `d` is positive and `n` and
 `d` are coprime. This representation is preferred to the quotient
 because without periodic reduction, the numerator and denominator can grow
 exponentially (for example, adding 1/2 to itself repeatedly).'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='orange'><a title='Form the quotient `n / d` where `n d : ℤ`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>133    padic_val_rat p q = (multiplicity (p : ℤ) n).get (finite_int_iff.2</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='padic_val_rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='q'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='multiplicity'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='roption.get'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='multiplicity.finite_int_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='iff.mpr'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 62, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/ring_theory/multiplicity.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/int/basic.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/pfun.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/ring_theory/multiplicity.lean&#x27;, &#x27;line&#x27;: 184, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='nat → rat → int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : comm_semiring.{u_1} α] [_inst_2 : @decidable_rel.{u_1+1} α (@has_dvd.dvd.{u_1} α (@comm_semiring_has_dvd.{u_1} α _inst_1))], α → α → enat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} (c : roption.{0} α), @roption.dom.{0} α c → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {a b : int}, iff (@multiplicity.finite.{0} int int.comm_semiring a b) (and (@ne.{1} nat (int.nat_abs a) (@has_one.one.{0} nat nat.has_one)) (@ne.{1} int b (@has_zero.zero.{0} int int.has_zero)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, iff a b → b → a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='For `p ≠ 1`, the p-adic valuation of an integer `z ≠ 0` is the largest natural number `n` such that
p^n divides z.

`padic_val_rat` defines the valuation of a rational `q` to be the valuation of `q.num` minus the
valuation of `q.denom`.
If `q = 0` or `p = 1`, then `padic_val_rat p q` defaults to 0.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='`multiplicity a b` returns the largest natural number `n` such that
 `a ^ n ∣ b`, as an `enat` or natural with infinity. If `∀ n, a ^ n ∣ b`,
 then it returns `⊤`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>134      ⟨ne.symm $ ne_of_lt p_prime.one_lt, λ hn, by simp * at *⟩) -</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='ne.symm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='ne_of_lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p_prime'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='nat.prime.one_lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='hn'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='blue'><a title='has_sub.sub'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 112, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 87, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/nat/prime.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 315, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='∀ {α : Sort u} {a b : α}, @ne.{u} α a b → @ne.{u} α b a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {α : Type u} [_inst_1 : preorder.{u} α] {a b : α}, @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a b → @ne.{u+1} α a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat.prime p'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {p : nat}, nat.prime p → @has_lt.lt.{0} nat nat.has_lt (@has_one.one.{0} nat nat.has_one) p'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@eq.{1} int n (@has_zero.zero.{0} int int.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type} [c : has_sub.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                 </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                 </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                 </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                </code><font color='lime'><a title='p : nat,
p_prime : nat.prime p,
q : rat,
n d : int,
hqz : @ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero),
qdf : @eq.{1} rat q (rat.mk n d),
hn : @eq.{1} int n (@has_zero.zero.{0} int int.has_zero)
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>135    (multiplicity (p : ℤ) d).get (finite_int_iff.2 ⟨ne.symm $ ne_of_lt p_prime.one_lt,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='multiplicity'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='d'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='roption.get'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='multiplicity.finite_int_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='iff.mpr'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='ne.symm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='ne_of_lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p_prime'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='nat.prime.one_lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/ring_theory/multiplicity.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/int/basic.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/pfun.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/ring_theory/multiplicity.lean&#x27;, &#x27;line&#x27;: 184, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 112, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 87, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/nat/prime.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : comm_semiring.{u_1} α] [_inst_2 : @decidable_rel.{u_1+1} α (@has_dvd.dvd.{u_1} α (@comm_semiring_has_dvd.{u_1} α _inst_1))], α → α → enat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} (c : roption.{0} α), @roption.dom.{0} α c → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {a b : int}, iff (@multiplicity.finite.{0} int int.comm_semiring a b) (and (@ne.{1} nat (int.nat_abs a) (@has_one.one.{0} nat nat.has_one)) (@ne.{1} int b (@has_zero.zero.{0} int int.has_zero)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, iff a b → b → a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {α : Sort u} {a b : α}, @ne.{u} α a b → @ne.{u} α b a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {α : Type u} [_inst_1 : preorder.{u} α] {a b : α}, @has_lt.lt.{u} α (@preorder.to_has_lt.{u} α _inst_1) a b → @ne.{u+1} α a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat.prime p'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {p : nat}, nat.prime p → @has_lt.lt.{0} nat nat.has_lt (@has_one.one.{0} nat nat.has_one) p'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`multiplicity a b` returns the largest natural number `n` such that
 `a ^ n ∣ b`, as an `enat` or natural with infinity. If `∀ n, a ^ n ∣ b`,
 then it returns `⊤`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>136      λ hd, by simp * at *⟩) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='hd'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@eq.{1} int d (@has_zero.zero.{0} int int.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='lime'><a title='p : nat,
p_prime : nat.prime p,
q : rat,
n d : int,
hqz : @ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero),
qdf : @eq.{1} rat q (rat.mk n d),
hd : @eq.{1} int d (@has_zero.zero.{0} int int.has_zero)
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>137  have hn : n ≠ 0, from rat.mk_num_ne_zero_of_ne_zero hqz qdf,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ne'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='rat.mk_num_ne_zero_of_ne_zero'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hqz'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='qdf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 97, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/rat/basic.lean&#x27;, &#x27;line&#x27;: 497, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='∀ {q : rat} {n d : int}, @ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero) → @eq.{1} rat q (rat.mk n d) → @ne.{1} int n (@has_zero.zero.{0} int int.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@eq.{1} rat q (rat.mk n d)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>138  have hd : d ≠ 0, from rat.mk_denom_ne_zero_of_ne_zero hqz qdf,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='d'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ne'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='rat.mk_denom_ne_zero_of_ne_zero'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hqz'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='qdf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 97, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/rat/basic.lean&#x27;, &#x27;line&#x27;: 501, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='∀ {q : rat} {n d : int}, @ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero) → @eq.{1} rat q (rat.mk n d) → @ne.{1} int d (@has_zero.zero.{0} int int.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@eq.{1} rat q (rat.mk n d)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>139  let ⟨c, hc1, hc2⟩ := rat.num_denom_mk hn hd qdf in</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='_let_match'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='blue'><a title='rat.num_denom_mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hn'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hd'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='qdf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/rat/basic.lean&#x27;, &#x27;line&#x27;: 525, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@Exists.{1} int (λ (c : int), and (@eq.{1} int n (@has_mul.mul.{0} int int.has_mul c (q.num))) (@eq.{1} int d (@has_mul.mul.{0} int int.has_mul c (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))))) → @eq.{1} int (padic_val_rat p q) (@has_sub.sub.{0} int int.has_sub (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (@roption.get.{0} nat (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p) n) (@iff.mpr (@multiplicity.finite.{0} int int.comm_semiring (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p) n) (and (@ne.{1} nat (int.nat_abs (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)) (@has_one.one.{0} nat nat.has_one)) (@ne.{1} int n (@has_zero.zero.{0} int int.has_zero))) (@multiplicity.finite_int_iff (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p) n) (@and.intro (@ne.{1} nat (int.nat_abs (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)) (@has_one.one.{0} nat nat.has_one)) (@ne.{1} int n (@has_zero.zero.{0} int int.has_zero)) (@ne.symm.{1} nat (@has_one.one.{0} nat nat.has_one) (int.nat_abs (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)) (@ne_of_lt.{0} nat (@partial_order.to_preorder.{0} nat (@ordered_comm_monoid.to_partial_order.{0} nat (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))) (@has_one.one.{0} nat nat.has_one) (int.nat_abs (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)) (@nat.prime.one_lt p p_prime))) (λ (hn : @eq.{1} int n (@has_zero.zero.{0} int int.has_zero)), false.rec.{0} false (@eq.mp.{0} (@eq.{1} rat q (rat.mk n d)) false (@eq.trans.{1} Prop (@eq.{1} rat q (rat.mk n d)) (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)) false ((λ (a a_1 : rat) (e_1 : @eq.{1} rat a a_1) (a_2 a_3 : rat) (e_2 : @eq.{1} rat a_2 a_3), @congr.{1 1} rat Prop (@eq.{1} rat a) (@eq.{1} rat a_1) a_2 a_3 (@congr_arg.{1 1} rat (rat → Prop) a a_1 (@eq.{1} rat) e_1) e_2) q q (@eq.refl.{1} rat q) (rat.mk n d) (@has_zero.zero.{0} rat rat.has_zero) (@eq.trans.{1} rat (rat.mk n d) (rat.mk (@has_zero.zero.{0} int int.has_zero) d) (@has_zero.zero.{0} rat rat.has_zero) ((λ (a a_1 : int) (e_1 : @eq.{1} int a a_1) (a_2 a_3 : int) (e_2 : @eq.{1} int a_2 a_3), @congr.{1 1} int rat (rat.mk a) (rat.mk a_1) a_2 a_3 (@congr_arg.{1 1} int (int → rat) a a_1 rat.mk e_1) e_2) n (@has_zero.zero.{0} int int.has_zero) hn d d (@eq.refl.{1} int d)) (rat.zero_mk d))) (@propext (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)) false (@iff_false_intro (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)) hqz))) qdf)))))) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (@roption.get.{0} nat (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p) d) (@iff.mpr (@multiplicity.finite.{0} int int.comm_semiring (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p) d) (and (@ne.{1} nat (int.nat_abs (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)) (@has_one.one.{0} nat nat.has_one)) (@ne.{1} int d (@has_zero.zero.{0} int int.has_zero))) (@multiplicity.finite_int_iff (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p) d) (@and.intro (@ne.{1} nat (int.nat_abs (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)) (@has_one.one.{0} nat nat.has_one)) (@ne.{1} int d (@has_zero.zero.{0} int int.has_zero)) (@ne.symm.{1} nat (@has_one.one.{0} nat nat.has_one) (int.nat_abs (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)) (@ne_of_lt.{0} nat (@partial_order.to_preorder.{0} nat (@ordered_comm_monoid.to_partial_order.{0} nat (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))) (@has_one.one.{0} nat nat.has_one) (int.nat_abs (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)) (@nat.prime.one_lt p p_prime))) (λ (hd : @eq.{1} int d (@has_zero.zero.{0} int int.has_zero)), false.rec.{0} false (@eq.mp.{0} (@eq.{1} rat q (rat.mk n d)) false (@eq.trans.{1} Prop (@eq.{1} rat q (rat.mk n d)) (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)) false ((λ (a a_1 : rat) (e_1 : @eq.{1} rat a a_1) (a_2 a_3 : rat) (e_2 : @eq.{1} rat a_2 a_3), @congr.{1 1} rat Prop (@eq.{1} rat a) (@eq.{1} rat a_1) a_2 a_3 (@congr_arg.{1 1} rat (rat → Prop) a a_1 (@eq.{1} rat) e_1) e_2) q q (@eq.refl.{1} rat q) (rat.mk n d) (@has_zero.zero.{0} rat rat.has_zero) (@eq.trans.{1} rat (rat.mk n d) (rat.mk n (@has_zero.zero.{0} int int.has_zero)) (@has_zero.zero.{0} rat rat.has_zero) ((λ (a a_1 : int) (e_1 : @eq.{1} int a a_1) (a_2 a_3 : int) (e_2 : @eq.{1} int a_2 a_3), @congr.{1 1} int rat (rat.mk a) (rat.mk a_1) a_2 a_3 (@congr_arg.{1 1} int (int → rat) a a_1 rat.mk e_1) e_2) n n (@eq.refl.{1} int n) d (@has_zero.zero.{0} int int.has_zero) hd) (rat.mk_zero n))) (@propext (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)) false (@iff_false_intro (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)) hqz))) qdf)))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='green'><a title='∀ {q : rat} {n d : int}, @ne.{1} int n (@has_zero.zero.{0} int int.has_zero) → @ne.{1} int d (@has_zero.zero.{0} int int.has_zero) → @eq.{1} rat q (rat.mk n d) → @Exists.{1} int (λ (c : int), and (@eq.{1} int n (@has_mul.mul.{0} int int.has_mul c (q.num))) (@eq.{1} int d (@has_mul.mul.{0} int int.has_mul c (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@ne.{1} int n (@has_zero.zero.{0} int int.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@ne.{1} int d (@has_zero.zero.{0} int int.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@eq.{1} rat q (rat.mk n d)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>140  by rw [padic_val_rat, dif_pos];</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='padic_val_rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='dif_pos'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 62, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 928, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat → rat → int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {c : Prop} [h : decidable c] (hc : c) {α : Type} {t : c → α} {e : not c → α}, @eq.{1} α (@dite.{1} c h α t e) (t hc)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='For `p ≠ 1`, the p-adic valuation of an integer `z ≠ 0` is the largest natural number `n` such that
p^n divides z.

`padic_val_rat` defines the valuation of a rational `q` to be the valuation of `q.num` minus the
valuation of `q.denom`.
If `q = 0` or `p = 1`, then `padic_val_rat p q` defaults to 0.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='p : nat,
p_prime : nat.prime p,
q : rat,
n d : int,
hqz : @ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero),
qdf : @eq.{1} rat q (rat.mk n d),
hn : @ne.{1} int n (@has_zero.zero.{0} int int.has_zero),
hd : @ne.{1} int d (@has_zero.zero.{0} int int.has_zero),
_let_match :
  @Exists.{1} int
    (λ (c : int),
       and (@eq.{1} int n (@has_mul.mul.{0} int int.has_mul c (q.num)))
         (@eq.{1} int d
            (@has_mul.mul.{0} int int.has_mul c
               (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))))) →
  @eq.{1} int (padic_val_rat p q)
    (@has_sub.sub.{0} int int.has_sub
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
          (@roption.get.{0} nat
             (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                n)
             (@iff.mpr
                (@multiplicity.finite.{0} int int.comm_semiring
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   n)
                (and
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int n (@has_zero.zero.{0} int int.has_zero)))
                (@multiplicity.finite_int_iff
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   n)
                (@and.intro
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int n (@has_zero.zero.{0} int int.has_zero))
                   (@ne.symm.{1} nat (@has_one.one.{0} nat nat.has_one)
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@ne_of_lt.{0} nat
                         (@partial_order.to_preorder.{0} nat
                            (@ordered_comm_monoid.to_partial_order.{0} nat
                               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
                         (@has_one.one.{0} nat nat.has_one)
                         (int.nat_abs
                            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                         (@nat.prime.one_lt p p_prime)))
                   (λ (hn : @eq.{1} int n (@has_zero.zero.{0} int int.has_zero)),
                      false.rec.{0} false
                        (@eq.mp.{0} (@eq.{1} rat q (rat.mk n d)) false
                           (@eq.trans.{1} Prop (@eq.{1} rat q (rat.mk n d))
                              (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero))
                              false
                              ((λ (a a_1 : rat) (e_1 : @eq.{1} rat a a_1) (a_2 a_3 : rat) (e_2 : @eq.{1} rat a_2 a_3),
                                  @congr.{1 1} rat Prop (@eq.{1} rat a) (@eq.{1} rat a_1) a_2 a_3
                                    (@congr_arg.{1 1} rat (rat → Prop) a a_1 (@eq.{1} rat) e_1)
                                    e_2)
                                 q
                                 q
                                 (@eq.refl.{1} rat q)
                                 (rat.mk n d)
                                 (@has_zero.zero.{0} rat rat.has_zero)
                                 (@eq.trans.{1} rat (rat.mk n d) (rat.mk (@has_zero.zero.{0} int int.has_zero) d)
                                    (@has_zero.zero.{0} rat rat.has_zero)
                                    ((λ (a a_1 : int) (e_1 : @eq.{1} int a a_1) (a_2 a_3 : int)
                                      (e_2 : @eq.{1} int a_2 a_3),
                                        @congr.{1 1} int rat (rat.mk a) (rat.mk a_1) a_2 a_3
                                          (@congr_arg.{1 1} int (int → rat) a a_1 rat.mk e_1)
                                          e_2)
                                       n
                                       (@has_zero.zero.{0} int int.has_zero)
                                       hn
                                       d
                                       d
                                       (@eq.refl.{1} int d))
                                    (rat.zero_mk d)))
                              (@propext (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)) false
                                 (@iff_false_intro (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)) hqz)))
                           qdf))))))
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
          (@roption.get.{0} nat
             (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                d)
             (@iff.mpr
                (@multiplicity.finite.{0} int int.comm_semiring
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   d)
                (and
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int d (@has_zero.zero.{0} int int.has_zero)))
                (@multiplicity.finite_int_iff
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   d)
                (@and.intro
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int d (@has_zero.zero.{0} int int.has_zero))
                   (@ne.symm.{1} nat (@has_one.one.{0} nat nat.has_one)
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@ne_of_lt.{0} nat
                         (@partial_order.to_preorder.{0} nat
                            (@ordered_comm_monoid.to_partial_order.{0} nat
                               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
                         (@has_one.one.{0} nat nat.has_one)
                         (int.nat_abs
                            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                         (@nat.prime.one_lt p p_prime)))
                   (λ (hd : @eq.{1} int d (@has_zero.zero.{0} int int.has_zero)),
                      false.rec.{0} false
                        (@eq.mp.{0} (@eq.{1} rat q (rat.mk n d)) false
                           (@eq.trans.{1} Prop (@eq.{1} rat q (rat.mk n d))
                              (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero))
                              false
                              ((λ (a a_1 : rat) (e_1 : @eq.{1} rat a a_1) (a_2 a_3 : rat) (e_2 : @eq.{1} rat a_2 a_3),
                                  @congr.{1 1} rat Prop (@eq.{1} rat a) (@eq.{1} rat a_1) a_2 a_3
                                    (@congr_arg.{1 1} rat (rat → Prop) a a_1 (@eq.{1} rat) e_1)
                                    e_2)
                                 q
                                 q
                                 (@eq.refl.{1} rat q)
                                 (rat.mk n d)
                                 (@has_zero.zero.{0} rat rat.has_zero)
                                 (@eq.trans.{1} rat (rat.mk n d) (rat.mk n (@has_zero.zero.{0} int int.has_zero))
                                    (@has_zero.zero.{0} rat rat.has_zero)
                                    ((λ (a a_1 : int) (e_1 : @eq.{1} int a a_1) (a_2 a_3 : int)
                                      (e_2 : @eq.{1} int a_2 a_3),
                                        @congr.{1 1} int rat (rat.mk a) (rat.mk a_1) a_2 a_3
                                          (@congr_arg.{1 1} int (int → rat) a a_1 rat.mk e_1)
                                          e_2)
                                       n
                                       n
                                       (@eq.refl.{1} int n)
                                       d
                                       (@has_zero.zero.{0} int int.has_zero)
                                       hd)
                                    (rat.mk_zero n)))
                              (@propext (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)) false
                                 (@iff_false_intro (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)) hqz)))
                           qdf))))))),
c : int,
hc1 : @eq.{1} int n (@has_mul.mul.{0} int int.has_mul c (q.num)),
hc2 :
  @eq.{1} int d
    (@has_mul.mul.{0} int int.has_mul c
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))
⊢ @eq.{1} int (padic_val_rat p q)
    (@has_sub.sub.{0} int int.has_sub
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
          (@roption.get.{0} nat
             (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                n)
             (@iff.mpr
                (@multiplicity.finite.{0} int int.comm_semiring
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   n)
                (and
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int n (@has_zero.zero.{0} int int.has_zero)))
                (@multiplicity.finite_int_iff
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   n)
                (@and.intro
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int n (@has_zero.zero.{0} int int.has_zero))
                   (@ne.symm.{1} nat (@has_one.one.{0} nat nat.has_one)
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@ne_of_lt.{0} nat
                         (@partial_order.to_preorder.{0} nat
                            (@ordered_comm_monoid.to_partial_order.{0} nat
                               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
                         (@has_one.one.{0} nat nat.has_one)
                         (int.nat_abs
                            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                         (@nat.prime.one_lt p p_prime)))
                   (λ (hn : @eq.{1} int n (@has_zero.zero.{0} int int.has_zero)),
                      false.rec.{0} false
                        (@eq.mp.{0} (@eq.{1} rat q (rat.mk n d)) false
                           (@eq.trans.{1} Prop (@eq.{1} rat q (rat.mk n d))
                              (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero))
                              false
                              ((λ (a a_1 : rat) (e_1 : @eq.{1} rat a a_1) (a_2 a_3 : rat) (e_2 : @eq.{1} rat a_2 a_3),
                                  @congr.{1 1} rat Prop (@eq.{1} rat a) (@eq.{1} rat a_1) a_2 a_3
                                    (@congr_arg.{1 1} rat (rat → Prop) a a_1 (@eq.{1} rat) e_1)
                                    e_2)
                                 q
                                 q
                                 (@eq.refl.{1} rat q)
                                 (rat.mk n d)
                                 (@has_zero.zero.{0} rat rat.has_zero)
                                 (@eq.trans.{1} rat (rat.mk n d) (rat.mk (@has_zero.zero.{0} int int.has_zero) d)
                                    (@has_zero.zero.{0} rat rat.has_zero)
                                    ((λ (a a_1 : int) (e_1 : @eq.{1} int a a_1) (a_2 a_3 : int)
                                      (e_2 : @eq.{1} int a_2 a_3),
                                        @congr.{1 1} int rat (rat.mk a) (rat.mk a_1) a_2 a_3
                                          (@congr_arg.{1 1} int (int → rat) a a_1 rat.mk e_1)
                                          e_2)
                                       n
                                       (@has_zero.zero.{0} int int.has_zero)
                                       hn
                                       d
                                       d
                                       (@eq.refl.{1} int d))
                                    (rat.zero_mk d)))
                              (@propext (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)) false
                                 (@iff_false_intro (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)) hqz)))
                           qdf))))))
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
          (@roption.get.{0} nat
             (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                d)
             (@iff.mpr
                (@multiplicity.finite.{0} int int.comm_semiring
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   d)
                (and
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int d (@has_zero.zero.{0} int int.has_zero)))
                (@multiplicity.finite_int_iff
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   d)
                (@and.intro
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int d (@has_zero.zero.{0} int int.has_zero))
                   (@ne.symm.{1} nat (@has_one.one.{0} nat nat.has_one)
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@ne_of_lt.{0} nat
                         (@partial_order.to_preorder.{0} nat
                            (@ordered_comm_monoid.to_partial_order.{0} nat
                               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
                         (@has_one.one.{0} nat nat.has_one)
                         (int.nat_abs
                            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                         (@nat.prime.one_lt p p_prime)))
                   (λ (hd : @eq.{1} int d (@has_zero.zero.{0} int int.has_zero)),
                      false.rec.{0} false
                        (@eq.mp.{0} (@eq.{1} rat q (rat.mk n d)) false
                           (@eq.trans.{1} Prop (@eq.{1} rat q (rat.mk n d))
                              (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero))
                              false
                              ((λ (a a_1 : rat) (e_1 : @eq.{1} rat a a_1) (a_2 a_3 : rat) (e_2 : @eq.{1} rat a_2 a_3),
                                  @congr.{1 1} rat Prop (@eq.{1} rat a) (@eq.{1} rat a_1) a_2 a_3
                                    (@congr_arg.{1 1} rat (rat → Prop) a a_1 (@eq.{1} rat) e_1)
                                    e_2)
                                 q
                                 q
                                 (@eq.refl.{1} rat q)
                                 (rat.mk n d)
                                 (@has_zero.zero.{0} rat rat.has_zero)
                                 (@eq.trans.{1} rat (rat.mk n d) (rat.mk n (@has_zero.zero.{0} int int.has_zero))
                                    (@has_zero.zero.{0} rat rat.has_zero)
                                    ((λ (a a_1 : int) (e_1 : @eq.{1} int a a_1) (a_2 a_3 : int)
                                      (e_2 : @eq.{1} int a_2 a_3),
                                        @congr.{1 1} int rat (rat.mk a) (rat.mk a_1) a_2 a_3
                                          (@congr_arg.{1 1} int (int → rat) a a_1 rat.mk e_1)
                                          e_2)
                                       n
                                       n
                                       (@eq.refl.{1} int n)
                                       d
                                       (@has_zero.zero.{0} int int.has_zero)
                                       hd)
                                    (rat.mk_zero n)))
                              (@propext (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)) false
                                 (@iff_false_intro (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)) hqz)))
                           qdf)))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
p_prime : nat.prime p,
q : rat,
n d : int,
hqz : @ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero),
qdf : @eq.{1} rat q (rat.mk n d),
hn : @ne.{1} int n (@has_zero.zero.{0} int int.has_zero),
hd : @ne.{1} int d (@has_zero.zero.{0} int int.has_zero),
_let_match :
  @Exists.{1} int
    (λ (c : int),
       and (@eq.{1} int n (@has_mul.mul.{0} int int.has_mul c (q.num)))
         (@eq.{1} int d
            (@has_mul.mul.{0} int int.has_mul c
               (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))))) →
  @eq.{1} int (padic_val_rat p q)
    (@has_sub.sub.{0} int int.has_sub
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
          (@roption.get.{0} nat
             (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                n)
             (@iff.mpr
                (@multiplicity.finite.{0} int int.comm_semiring
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   n)
                (and
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int n (@has_zero.zero.{0} int int.has_zero)))
                (@multiplicity.finite_int_iff
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   n)
                (@and.intro
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int n (@has_zero.zero.{0} int int.has_zero))
                   (@ne.symm.{1} nat (@has_one.one.{0} nat nat.has_one)
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@ne_of_lt.{0} nat
                         (@partial_order.to_preorder.{0} nat
                            (@ordered_comm_monoid.to_partial_order.{0} nat
                               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
                         (@has_one.one.{0} nat nat.has_one)
                         (int.nat_abs
                            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                         (@nat.prime.one_lt p p_prime)))
                   (λ (hn : @eq.{1} int n (@has_zero.zero.{0} int int.has_zero)),
                      false.rec.{0} false
                        (@eq.mp.{0} (@eq.{1} rat q (rat.mk n d)) false
                           (@eq.trans.{1} Prop (@eq.{1} rat q (rat.mk n d))
                              (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero))
                              false
                              ((λ (a a_1 : rat) (e_1 : @eq.{1} rat a a_1) (a_2 a_3 : rat) (e_2 : @eq.{1} rat a_2 a_3),
                                  @congr.{1 1} rat Prop (@eq.{1} rat a) (@eq.{1} rat a_1) a_2 a_3
                                    (@congr_arg.{1 1} rat (rat → Prop) a a_1 (@eq.{1} rat) e_1)
                                    e_2)
                                 q
                                 q
                                 (@eq.refl.{1} rat q)
                                 (rat.mk n d)
                                 (@has_zero.zero.{0} rat rat.has_zero)
                                 (@eq.trans.{1} rat (rat.mk n d) (rat.mk (@has_zero.zero.{0} int int.has_zero) d)
                                    (@has_zero.zero.{0} rat rat.has_zero)
                                    ((λ (a a_1 : int) (e_1 : @eq.{1} int a a_1) (a_2 a_3 : int)
                                      (e_2 : @eq.{1} int a_2 a_3),
                                        @congr.{1 1} int rat (rat.mk a) (rat.mk a_1) a_2 a_3
                                          (@congr_arg.{1 1} int (int → rat) a a_1 rat.mk e_1)
                                          e_2)
                                       n
                                       (@has_zero.zero.{0} int int.has_zero)
                                       hn
                                       d
                                       d
                                       (@eq.refl.{1} int d))
                                    (rat.zero_mk d)))
                              (@propext (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)) false
                                 (@iff_false_intro (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)) hqz)))
                           qdf))))))
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
          (@roption.get.{0} nat
             (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                d)
             (@iff.mpr
                (@multiplicity.finite.{0} int int.comm_semiring
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   d)
                (and
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int d (@has_zero.zero.{0} int int.has_zero)))
                (@multiplicity.finite_int_iff
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   d)
                (@and.intro
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int d (@has_zero.zero.{0} int int.has_zero))
                   (@ne.symm.{1} nat (@has_one.one.{0} nat nat.has_one)
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@ne_of_lt.{0} nat
                         (@partial_order.to_preorder.{0} nat
                            (@ordered_comm_monoid.to_partial_order.{0} nat
                               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
                         (@has_one.one.{0} nat nat.has_one)
                         (int.nat_abs
                            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                         (@nat.prime.one_lt p p_prime)))
                   (λ (hd : @eq.{1} int d (@has_zero.zero.{0} int int.has_zero)),
                      false.rec.{0} false
                        (@eq.mp.{0} (@eq.{1} rat q (rat.mk n d)) false
                           (@eq.trans.{1} Prop (@eq.{1} rat q (rat.mk n d))
                              (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero))
                              false
                              ((λ (a a_1 : rat) (e_1 : @eq.{1} rat a a_1) (a_2 a_3 : rat) (e_2 : @eq.{1} rat a_2 a_3),
                                  @congr.{1 1} rat Prop (@eq.{1} rat a) (@eq.{1} rat a_1) a_2 a_3
                                    (@congr_arg.{1 1} rat (rat → Prop) a a_1 (@eq.{1} rat) e_1)
                                    e_2)
                                 q
                                 q
                                 (@eq.refl.{1} rat q)
                                 (rat.mk n d)
                                 (@has_zero.zero.{0} rat rat.has_zero)
                                 (@eq.trans.{1} rat (rat.mk n d) (rat.mk n (@has_zero.zero.{0} int int.has_zero))
                                    (@has_zero.zero.{0} rat rat.has_zero)
                                    ((λ (a a_1 : int) (e_1 : @eq.{1} int a a_1) (a_2 a_3 : int)
                                      (e_2 : @eq.{1} int a_2 a_3),
                                        @congr.{1 1} int rat (rat.mk a) (rat.mk a_1) a_2 a_3
                                          (@congr_arg.{1 1} int (int → rat) a a_1 rat.mk e_1)
                                          e_2)
                                       n
                                       n
                                       (@eq.refl.{1} int n)
                                       d
                                       (@has_zero.zero.{0} int int.has_zero)
                                       hd)
                                    (rat.mk_zero n)))
                              (@propext (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)) false
                                 (@iff_false_intro (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)) hqz)))
                           qdf))))))),
c : int,
hc1 : @eq.{1} int n (@has_mul.mul.{0} int int.has_mul c (q.num)),
hc2 :
  @eq.{1} int d
    (@has_mul.mul.{0} int int.has_mul c
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))
⊢ @eq.{1} int
    (@dite.{1}
       (and (@ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)) (@ne.{1} nat p (@has_one.one.{0} nat nat.has_one)))
       (@and.decidable (@ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero))
          (@ne.{1} nat p (@has_one.one.{0} nat nat.has_one))
          (@ne.decidable.{1} rat (λ (a b : rat), rat.decidable_eq a b) q (@has_zero.zero.{0} rat rat.has_zero))
          (@ne.decidable.{1} nat (λ (a b : nat), nat.decidable_eq a b) p (@has_one.one.{0} nat nat.has_one)))
       int
       (λ
        (h :
          and (@ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)) (@ne.{1} nat p (@has_one.one.{0} nat nat.has_one))),
          @has_sub.sub.{0} int int.has_sub
            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
               (@roption.get.{0} nat
                  (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
                     (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                     (q.num))
                  (padic_val_rat._proof_1 p q h)))
            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
               (@roption.get.{0} nat
                  (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
                     (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                     (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))
                  (padic_val_rat._proof_2 p q h))))
       (λ
        (h :
          not
            (and (@ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero))
               (@ne.{1} nat p (@has_one.one.{0} nat nat.has_one)))), @has_zero.zero.{0} int int.has_zero))
    (@has_sub.sub.{0} int int.has_sub
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
          (@roption.get.{0} nat
             (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                n)
             (@iff.mpr
                (@multiplicity.finite.{0} int int.comm_semiring
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   n)
                (and
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int n (@has_zero.zero.{0} int int.has_zero)))
                (@multiplicity.finite_int_iff
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   n)
                (@and.intro
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int n (@has_zero.zero.{0} int int.has_zero))
                   (@ne.symm.{1} nat (@has_one.one.{0} nat nat.has_one)
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@ne_of_lt.{0} nat
                         (@partial_order.to_preorder.{0} nat
                            (@ordered_comm_monoid.to_partial_order.{0} nat
                               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
                         (@has_one.one.{0} nat nat.has_one)
                         (int.nat_abs
                            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                         (@nat.prime.one_lt p p_prime)))
                   (λ (hn : @eq.{1} int n (@has_zero.zero.{0} int int.has_zero)),
                      false.rec.{0} false
                        (@eq.mp.{0} (@eq.{1} rat q (rat.mk n d)) false
                           (@eq.trans.{1} Prop (@eq.{1} rat q (rat.mk n d))
                              (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero))
                              false
                              ((λ (a a_1 : rat) (e_1 : @eq.{1} rat a a_1) (a_2 a_3 : rat) (e_2 : @eq.{1} rat a_2 a_3),
                                  @congr.{1 1} rat Prop (@eq.{1} rat a) (@eq.{1} rat a_1) a_2 a_3
                                    (@congr_arg.{1 1} rat (rat → Prop) a a_1 (@eq.{1} rat) e_1)
                                    e_2)
                                 q
                                 q
                                 (@eq.refl.{1} rat q)
                                 (rat.mk n d)
                                 (@has_zero.zero.{0} rat rat.has_zero)
                                 (@eq.trans.{1} rat (rat.mk n d) (rat.mk (@has_zero.zero.{0} int int.has_zero) d)
                                    (@has_zero.zero.{0} rat rat.has_zero)
                                    ((λ (a a_1 : int) (e_1 : @eq.{1} int a a_1) (a_2 a_3 : int)
                                      (e_2 : @eq.{1} int a_2 a_3),
                                        @congr.{1 1} int rat (rat.mk a) (rat.mk a_1) a_2 a_3
                                          (@congr_arg.{1 1} int (int → rat) a a_1 rat.mk e_1)
                                          e_2)
                                       n
                                       (@has_zero.zero.{0} int int.has_zero)
                                       hn
                                       d
                                       d
                                       (@eq.refl.{1} int d))
                                    (rat.zero_mk d)))
                              (@propext (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)) false
                                 (@iff_false_intro (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)) hqz)))
                           qdf))))))
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
          (@roption.get.{0} nat
             (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                d)
             (@iff.mpr
                (@multiplicity.finite.{0} int int.comm_semiring
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   d)
                (and
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int d (@has_zero.zero.{0} int int.has_zero)))
                (@multiplicity.finite_int_iff
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   d)
                (@and.intro
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int d (@has_zero.zero.{0} int int.has_zero))
                   (@ne.symm.{1} nat (@has_one.one.{0} nat nat.has_one)
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@ne_of_lt.{0} nat
                         (@partial_order.to_preorder.{0} nat
                            (@ordered_comm_monoid.to_partial_order.{0} nat
                               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
                         (@has_one.one.{0} nat nat.has_one)
                         (int.nat_abs
                            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                         (@nat.prime.one_lt p p_prime)))
                   (λ (hd : @eq.{1} int d (@has_zero.zero.{0} int int.has_zero)),
                      false.rec.{0} false
                        (@eq.mp.{0} (@eq.{1} rat q (rat.mk n d)) false
                           (@eq.trans.{1} Prop (@eq.{1} rat q (rat.mk n d))
                              (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero))
                              false
                              ((λ (a a_1 : rat) (e_1 : @eq.{1} rat a a_1) (a_2 a_3 : rat) (e_2 : @eq.{1} rat a_2 a_3),
                                  @congr.{1 1} rat Prop (@eq.{1} rat a) (@eq.{1} rat a_1) a_2 a_3
                                    (@congr_arg.{1 1} rat (rat → Prop) a a_1 (@eq.{1} rat) e_1)
                                    e_2)
                                 q
                                 q
                                 (@eq.refl.{1} rat q)
                                 (rat.mk n d)
                                 (@has_zero.zero.{0} rat rat.has_zero)
                                 (@eq.trans.{1} rat (rat.mk n d) (rat.mk n (@has_zero.zero.{0} int int.has_zero))
                                    (@has_zero.zero.{0} rat rat.has_zero)
                                    ((λ (a a_1 : int) (e_1 : @eq.{1} int a a_1) (a_2 a_3 : int)
                                      (e_2 : @eq.{1} int a_2 a_3),
                                        @congr.{1 1} int rat (rat.mk a) (rat.mk a_1) a_2 a_3
                                          (@congr_arg.{1 1} int (int → rat) a a_1 rat.mk e_1)
                                          e_2)
                                       n
                                       n
                                       (@eq.refl.{1} int n)
                                       d
                                       (@has_zero.zero.{0} int int.has_zero)
                                       hd)
                                    (rat.mk_zero n)))
                              (@propext (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)) false
                                 (@iff_false_intro (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)) hqz)))
                           qdf)))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
p : nat,
p_prime : nat.prime p,
q : rat,
n d : int,
hqz : @ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero),
qdf : @eq.{1} rat q (rat.mk n d),
hn : @ne.{1} int n (@has_zero.zero.{0} int int.has_zero),
hd : @ne.{1} int d (@has_zero.zero.{0} int int.has_zero),
_let_match :
  @Exists.{1} int
    (λ (c : int),
       and (@eq.{1} int n (@has_mul.mul.{0} int int.has_mul c (q.num)))
         (@eq.{1} int d
            (@has_mul.mul.{0} int int.has_mul c
               (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))))) →
  @eq.{1} int (padic_val_rat p q)
    (@has_sub.sub.{0} int int.has_sub
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
          (@roption.get.{0} nat
             (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                n)
             (@iff.mpr
                (@multiplicity.finite.{0} int int.comm_semiring
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   n)
                (and
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int n (@has_zero.zero.{0} int int.has_zero)))
                (@multiplicity.finite_int_iff
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   n)
                (@and.intro
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int n (@has_zero.zero.{0} int int.has_zero))
                   (@ne.symm.{1} nat (@has_one.one.{0} nat nat.has_one)
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@ne_of_lt.{0} nat
                         (@partial_order.to_preorder.{0} nat
                            (@ordered_comm_monoid.to_partial_order.{0} nat
                               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
                         (@has_one.one.{0} nat nat.has_one)
                         (int.nat_abs
                            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                         (@nat.prime.one_lt p p_prime)))
                   (λ (hn : @eq.{1} int n (@has_zero.zero.{0} int int.has_zero)),
                      false.rec.{0} false
                        (@eq.mp.{0} (@eq.{1} rat q (rat.mk n d)) false
                           (@eq.trans.{1} Prop (@eq.{1} rat q (rat.mk n d))
                              (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero))
                              false
                              ((λ (a a_1 : rat) (e_1 : @eq.{1} rat a a_1) (a_2 a_3 : rat) (e_2 : @eq.{1} rat a_2 a_3),
                                  @congr.{1 1} rat Prop (@eq.{1} rat a) (@eq.{1} rat a_1) a_2 a_3
                                    (@congr_arg.{1 1} rat (rat → Prop) a a_1 (@eq.{1} rat) e_1)
                                    e_2)
                                 q
                                 q
                                 (@eq.refl.{1} rat q)
                                 (rat.mk n d)
                                 (@has_zero.zero.{0} rat rat.has_zero)
                                 (@eq.trans.{1} rat (rat.mk n d) (rat.mk (@has_zero.zero.{0} int int.has_zero) d)
                                    (@has_zero.zero.{0} rat rat.has_zero)
                                    ((λ (a a_1 : int) (e_1 : @eq.{1} int a a_1) (a_2 a_3 : int)
                                      (e_2 : @eq.{1} int a_2 a_3),
                                        @congr.{1 1} int rat (rat.mk a) (rat.mk a_1) a_2 a_3
                                          (@congr_arg.{1 1} int (int → rat) a a_1 rat.mk e_1)
                                          e_2)
                                       n
                                       (@has_zero.zero.{0} int int.has_zero)
                                       hn
                                       d
                                       d
                                       (@eq.refl.{1} int d))
                                    (rat.zero_mk d)))
                              (@propext (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)) false
                                 (@iff_false_intro (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)) hqz)))
                           qdf))))))
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
          (@roption.get.{0} nat
             (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                d)
             (@iff.mpr
                (@multiplicity.finite.{0} int int.comm_semiring
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   d)
                (and
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int d (@has_zero.zero.{0} int int.has_zero)))
                (@multiplicity.finite_int_iff
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   d)
                (@and.intro
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int d (@has_zero.zero.{0} int int.has_zero))
                   (@ne.symm.{1} nat (@has_one.one.{0} nat nat.has_one)
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@ne_of_lt.{0} nat
                         (@partial_order.to_preorder.{0} nat
                            (@ordered_comm_monoid.to_partial_order.{0} nat
                               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
                         (@has_one.one.{0} nat nat.has_one)
                         (int.nat_abs
                            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                         (@nat.prime.one_lt p p_prime)))
                   (λ (hd : @eq.{1} int d (@has_zero.zero.{0} int int.has_zero)),
                      false.rec.{0} false
                        (@eq.mp.{0} (@eq.{1} rat q (rat.mk n d)) false
                           (@eq.trans.{1} Prop (@eq.{1} rat q (rat.mk n d))
                              (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero))
                              false
                              ((λ (a a_1 : rat) (e_1 : @eq.{1} rat a a_1) (a_2 a_3 : rat) (e_2 : @eq.{1} rat a_2 a_3),
                                  @congr.{1 1} rat Prop (@eq.{1} rat a) (@eq.{1} rat a_1) a_2 a_3
                                    (@congr_arg.{1 1} rat (rat → Prop) a a_1 (@eq.{1} rat) e_1)
                                    e_2)
                                 q
                                 q
                                 (@eq.refl.{1} rat q)
                                 (rat.mk n d)
                                 (@has_zero.zero.{0} rat rat.has_zero)
                                 (@eq.trans.{1} rat (rat.mk n d) (rat.mk n (@has_zero.zero.{0} int int.has_zero))
                                    (@has_zero.zero.{0} rat rat.has_zero)
                                    ((λ (a a_1 : int) (e_1 : @eq.{1} int a a_1) (a_2 a_3 : int)
                                      (e_2 : @eq.{1} int a_2 a_3),
                                        @congr.{1 1} int rat (rat.mk a) (rat.mk a_1) a_2 a_3
                                          (@congr_arg.{1 1} int (int → rat) a a_1 rat.mk e_1)
                                          e_2)
                                       n
                                       n
                                       (@eq.refl.{1} int n)
                                       d
                                       (@has_zero.zero.{0} int int.has_zero)
                                       hd)
                                    (rat.mk_zero n)))
                              (@propext (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)) false
                                 (@iff_false_intro (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)) hqz)))
                           qdf))))))),
c : int,
hc1 : @eq.{1} int n (@has_mul.mul.{0} int int.has_mul c (q.num)),
hc2 :
  @eq.{1} int d
    (@has_mul.mul.{0} int int.has_mul c
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))
⊢ @eq.{1} int
    (@has_sub.sub.{0} int int.has_sub
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
          (@roption.get.{0} nat
             (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                (q.num))
             (padic_val_rat._proof_1 p q ?m_1)))
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
          (@roption.get.{0} nat
             (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))
             (padic_val_rat._proof_2 p q ?m_1))))
    (@has_sub.sub.{0} int int.has_sub
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
          (@roption.get.{0} nat
             (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                n)
             (@iff.mpr
                (@multiplicity.finite.{0} int int.comm_semiring
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   n)
                (and
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int n (@has_zero.zero.{0} int int.has_zero)))
                (@multiplicity.finite_int_iff
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   n)
                (@and.intro
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int n (@has_zero.zero.{0} int int.has_zero))
                   (@ne.symm.{1} nat (@has_one.one.{0} nat nat.has_one)
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@ne_of_lt.{0} nat
                         (@partial_order.to_preorder.{0} nat
                            (@ordered_comm_monoid.to_partial_order.{0} nat
                               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
                         (@has_one.one.{0} nat nat.has_one)
                         (int.nat_abs
                            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                         (@nat.prime.one_lt p p_prime)))
                   (λ (hn : @eq.{1} int n (@has_zero.zero.{0} int int.has_zero)),
                      false.rec.{0} false
                        (@eq.mp.{0} (@eq.{1} rat q (rat.mk n d)) false
                           (@eq.trans.{1} Prop (@eq.{1} rat q (rat.mk n d))
                              (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero))
                              false
                              ((λ (a a_1 : rat) (e_1 : @eq.{1} rat a a_1) (a_2 a_3 : rat) (e_2 : @eq.{1} rat a_2 a_3),
                                  @congr.{1 1} rat Prop (@eq.{1} rat a) (@eq.{1} rat a_1) a_2 a_3
                                    (@congr_arg.{1 1} rat (rat → Prop) a a_1 (@eq.{1} rat) e_1)
                                    e_2)
                                 q
                                 q
                                 (@eq.refl.{1} rat q)
                                 (rat.mk n d)
                                 (@has_zero.zero.{0} rat rat.has_zero)
                                 (@eq.trans.{1} rat (rat.mk n d) (rat.mk (@has_zero.zero.{0} int int.has_zero) d)
                                    (@has_zero.zero.{0} rat rat.has_zero)
                                    ((λ (a a_1 : int) (e_1 : @eq.{1} int a a_1) (a_2 a_3 : int)
                                      (e_2 : @eq.{1} int a_2 a_3),
                                        @congr.{1 1} int rat (rat.mk a) (rat.mk a_1) a_2 a_3
                                          (@congr_arg.{1 1} int (int → rat) a a_1 rat.mk e_1)
                                          e_2)
                                       n
                                       (@has_zero.zero.{0} int int.has_zero)
                                       hn
                                       d
                                       d
                                       (@eq.refl.{1} int d))
                                    (rat.zero_mk d)))
                              (@propext (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)) false
                                 (@iff_false_intro (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)) hqz)))
                           qdf))))))
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
          (@roption.get.{0} nat
             (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                d)
             (@iff.mpr
                (@multiplicity.finite.{0} int int.comm_semiring
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   d)
                (and
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int d (@has_zero.zero.{0} int int.has_zero)))
                (@multiplicity.finite_int_iff
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   d)
                (@and.intro
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int d (@has_zero.zero.{0} int int.has_zero))
                   (@ne.symm.{1} nat (@has_one.one.{0} nat nat.has_one)
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@ne_of_lt.{0} nat
                         (@partial_order.to_preorder.{0} nat
                            (@ordered_comm_monoid.to_partial_order.{0} nat
                               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
                         (@has_one.one.{0} nat nat.has_one)
                         (int.nat_abs
                            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                         (@nat.prime.one_lt p p_prime)))
                   (λ (hd : @eq.{1} int d (@has_zero.zero.{0} int int.has_zero)),
                      false.rec.{0} false
                        (@eq.mp.{0} (@eq.{1} rat q (rat.mk n d)) false
                           (@eq.trans.{1} Prop (@eq.{1} rat q (rat.mk n d))
                              (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero))
                              false
                              ((λ (a a_1 : rat) (e_1 : @eq.{1} rat a a_1) (a_2 a_3 : rat) (e_2 : @eq.{1} rat a_2 a_3),
                                  @congr.{1 1} rat Prop (@eq.{1} rat a) (@eq.{1} rat a_1) a_2 a_3
                                    (@congr_arg.{1 1} rat (rat → Prop) a a_1 (@eq.{1} rat) e_1)
                                    e_2)
                                 q
                                 q
                                 (@eq.refl.{1} rat q)
                                 (rat.mk n d)
                                 (@has_zero.zero.{0} rat rat.has_zero)
                                 (@eq.trans.{1} rat (rat.mk n d) (rat.mk n (@has_zero.zero.{0} int int.has_zero))
                                    (@has_zero.zero.{0} rat rat.has_zero)
                                    ((λ (a a_1 : int) (e_1 : @eq.{1} int a a_1) (a_2 a_3 : int)
                                      (e_2 : @eq.{1} int a_2 a_3),
                                        @congr.{1 1} int rat (rat.mk a) (rat.mk a_1) a_2 a_3
                                          (@congr_arg.{1 1} int (int → rat) a a_1 rat.mk e_1)
                                          e_2)
                                       n
                                       n
                                       (@eq.refl.{1} int n)
                                       d
                                       (@has_zero.zero.{0} int int.has_zero)
                                       hd)
                                    (rat.mk_zero n)))
                              (@propext (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)) false
                                 (@iff_false_intro (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)) hqz)))
                           qdf)))))))

p : nat,
p_prime : nat.prime p,
q : rat,
n d : int,
hqz : @ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero),
qdf : @eq.{1} rat q (rat.mk n d),
hn : @ne.{1} int n (@has_zero.zero.{0} int int.has_zero),
hd : @ne.{1} int d (@has_zero.zero.{0} int int.has_zero),
_let_match :
  @Exists.{1} int
    (λ (c : int),
       and (@eq.{1} int n (@has_mul.mul.{0} int int.has_mul c (q.num)))
         (@eq.{1} int d
            (@has_mul.mul.{0} int int.has_mul c
               (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))))) →
  @eq.{1} int (padic_val_rat p q)
    (@has_sub.sub.{0} int int.has_sub
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
          (@roption.get.{0} nat
             (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                n)
             (@iff.mpr
                (@multiplicity.finite.{0} int int.comm_semiring
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   n)
                (and
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int n (@has_zero.zero.{0} int int.has_zero)))
                (@multiplicity.finite_int_iff
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   n)
                (@and.intro
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int n (@has_zero.zero.{0} int int.has_zero))
                   (@ne.symm.{1} nat (@has_one.one.{0} nat nat.has_one)
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@ne_of_lt.{0} nat
                         (@partial_order.to_preorder.{0} nat
                            (@ordered_comm_monoid.to_partial_order.{0} nat
                               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
                         (@has_one.one.{0} nat nat.has_one)
                         (int.nat_abs
                            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                         (@nat.prime.one_lt p p_prime)))
                   (λ (hn : @eq.{1} int n (@has_zero.zero.{0} int int.has_zero)),
                      false.rec.{0} false
                        (@eq.mp.{0} (@eq.{1} rat q (rat.mk n d)) false
                           (@eq.trans.{1} Prop (@eq.{1} rat q (rat.mk n d))
                              (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero))
                              false
                              ((λ (a a_1 : rat) (e_1 : @eq.{1} rat a a_1) (a_2 a_3 : rat) (e_2 : @eq.{1} rat a_2 a_3),
                                  @congr.{1 1} rat Prop (@eq.{1} rat a) (@eq.{1} rat a_1) a_2 a_3
                                    (@congr_arg.{1 1} rat (rat → Prop) a a_1 (@eq.{1} rat) e_1)
                                    e_2)
                                 q
                                 q
                                 (@eq.refl.{1} rat q)
                                 (rat.mk n d)
                                 (@has_zero.zero.{0} rat rat.has_zero)
                                 (@eq.trans.{1} rat (rat.mk n d) (rat.mk (@has_zero.zero.{0} int int.has_zero) d)
                                    (@has_zero.zero.{0} rat rat.has_zero)
                                    ((λ (a a_1 : int) (e_1 : @eq.{1} int a a_1) (a_2 a_3 : int)
                                      (e_2 : @eq.{1} int a_2 a_3),
                                        @congr.{1 1} int rat (rat.mk a) (rat.mk a_1) a_2 a_3
                                          (@congr_arg.{1 1} int (int → rat) a a_1 rat.mk e_1)
                                          e_2)
                                       n
                                       (@has_zero.zero.{0} int int.has_zero)
                                       hn
                                       d
                                       d
                                       (@eq.refl.{1} int d))
                                    (rat.zero_mk d)))
                              (@propext (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)) false
                                 (@iff_false_intro (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)) hqz)))
                           qdf))))))
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
          (@roption.get.{0} nat
             (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                d)
             (@iff.mpr
                (@multiplicity.finite.{0} int int.comm_semiring
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   d)
                (and
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int d (@has_zero.zero.{0} int int.has_zero)))
                (@multiplicity.finite_int_iff
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   d)
                (@and.intro
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int d (@has_zero.zero.{0} int int.has_zero))
                   (@ne.symm.{1} nat (@has_one.one.{0} nat nat.has_one)
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@ne_of_lt.{0} nat
                         (@partial_order.to_preorder.{0} nat
                            (@ordered_comm_monoid.to_partial_order.{0} nat
                               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
                         (@has_one.one.{0} nat nat.has_one)
                         (int.nat_abs
                            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                         (@nat.prime.one_lt p p_prime)))
                   (λ (hd : @eq.{1} int d (@has_zero.zero.{0} int int.has_zero)),
                      false.rec.{0} false
                        (@eq.mp.{0} (@eq.{1} rat q (rat.mk n d)) false
                           (@eq.trans.{1} Prop (@eq.{1} rat q (rat.mk n d))
                              (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero))
                              false
                              ((λ (a a_1 : rat) (e_1 : @eq.{1} rat a a_1) (a_2 a_3 : rat) (e_2 : @eq.{1} rat a_2 a_3),
                                  @congr.{1 1} rat Prop (@eq.{1} rat a) (@eq.{1} rat a_1) a_2 a_3
                                    (@congr_arg.{1 1} rat (rat → Prop) a a_1 (@eq.{1} rat) e_1)
                                    e_2)
                                 q
                                 q
                                 (@eq.refl.{1} rat q)
                                 (rat.mk n d)
                                 (@has_zero.zero.{0} rat rat.has_zero)
                                 (@eq.trans.{1} rat (rat.mk n d) (rat.mk n (@has_zero.zero.{0} int int.has_zero))
                                    (@has_zero.zero.{0} rat rat.has_zero)
                                    ((λ (a a_1 : int) (e_1 : @eq.{1} int a a_1) (a_2 a_3 : int)
                                      (e_2 : @eq.{1} int a_2 a_3),
                                        @congr.{1 1} int rat (rat.mk a) (rat.mk a_1) a_2 a_3
                                          (@congr_arg.{1 1} int (int → rat) a a_1 rat.mk e_1)
                                          e_2)
                                       n
                                       n
                                       (@eq.refl.{1} int n)
                                       d
                                       (@has_zero.zero.{0} int int.has_zero)
                                       hd)
                                    (rat.mk_zero n)))
                              (@propext (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)) false
                                 (@iff_false_intro (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)) hqz)))
                           qdf))))))),
c : int,
hc1 : @eq.{1} int n (@has_mul.mul.{0} int int.has_mul c (q.num)),
hc2 :
  @eq.{1} int d
    (@has_mul.mul.{0} int int.has_mul c
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))
⊢ and (@ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)) (@ne.{1} nat p (@has_one.one.{0} nat nat.has_one))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
p_prime : nat.prime p,
q : rat,
n d : int,
hqz : @ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero),
qdf : @eq.{1} rat q (rat.mk n d),
hn : @ne.{1} int n (@has_zero.zero.{0} int int.has_zero),
hd : @ne.{1} int d (@has_zero.zero.{0} int int.has_zero),
_let_match :
  @Exists.{1} int
    (λ (c : int),
       and (@eq.{1} int n (@has_mul.mul.{0} int int.has_mul c (q.num)))
         (@eq.{1} int d
            (@has_mul.mul.{0} int int.has_mul c
               (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))))) →
  @eq.{1} int (padic_val_rat p q)
    (@has_sub.sub.{0} int int.has_sub
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
          (@roption.get.{0} nat
             (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                n)
             (@iff.mpr
                (@multiplicity.finite.{0} int int.comm_semiring
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   n)
                (and
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int n (@has_zero.zero.{0} int int.has_zero)))
                (@multiplicity.finite_int_iff
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   n)
                (@and.intro
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int n (@has_zero.zero.{0} int int.has_zero))
                   (@ne.symm.{1} nat (@has_one.one.{0} nat nat.has_one)
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@ne_of_lt.{0} nat
                         (@partial_order.to_preorder.{0} nat
                            (@ordered_comm_monoid.to_partial_order.{0} nat
                               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
                         (@has_one.one.{0} nat nat.has_one)
                         (int.nat_abs
                            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                         (@nat.prime.one_lt p p_prime)))
                   (λ (hn : @eq.{1} int n (@has_zero.zero.{0} int int.has_zero)),
                      false.rec.{0} false
                        (@eq.mp.{0} (@eq.{1} rat q (rat.mk n d)) false
                           (@eq.trans.{1} Prop (@eq.{1} rat q (rat.mk n d))
                              (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero))
                              false
                              ((λ (a a_1 : rat) (e_1 : @eq.{1} rat a a_1) (a_2 a_3 : rat) (e_2 : @eq.{1} rat a_2 a_3),
                                  @congr.{1 1} rat Prop (@eq.{1} rat a) (@eq.{1} rat a_1) a_2 a_3
                                    (@congr_arg.{1 1} rat (rat → Prop) a a_1 (@eq.{1} rat) e_1)
                                    e_2)
                                 q
                                 q
                                 (@eq.refl.{1} rat q)
                                 (rat.mk n d)
                                 (@has_zero.zero.{0} rat rat.has_zero)
                                 (@eq.trans.{1} rat (rat.mk n d) (rat.mk (@has_zero.zero.{0} int int.has_zero) d)
                                    (@has_zero.zero.{0} rat rat.has_zero)
                                    ((λ (a a_1 : int) (e_1 : @eq.{1} int a a_1) (a_2 a_3 : int)
                                      (e_2 : @eq.{1} int a_2 a_3),
                                        @congr.{1 1} int rat (rat.mk a) (rat.mk a_1) a_2 a_3
                                          (@congr_arg.{1 1} int (int → rat) a a_1 rat.mk e_1)
                                          e_2)
                                       n
                                       (@has_zero.zero.{0} int int.has_zero)
                                       hn
                                       d
                                       d
                                       (@eq.refl.{1} int d))
                                    (rat.zero_mk d)))
                              (@propext (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)) false
                                 (@iff_false_intro (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)) hqz)))
                           qdf))))))
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
          (@roption.get.{0} nat
             (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                d)
             (@iff.mpr
                (@multiplicity.finite.{0} int int.comm_semiring
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   d)
                (and
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int d (@has_zero.zero.{0} int int.has_zero)))
                (@multiplicity.finite_int_iff
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   d)
                (@and.intro
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int d (@has_zero.zero.{0} int int.has_zero))
                   (@ne.symm.{1} nat (@has_one.one.{0} nat nat.has_one)
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@ne_of_lt.{0} nat
                         (@partial_order.to_preorder.{0} nat
                            (@ordered_comm_monoid.to_partial_order.{0} nat
                               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
                         (@has_one.one.{0} nat nat.has_one)
                         (int.nat_abs
                            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                         (@nat.prime.one_lt p p_prime)))
                   (λ (hd : @eq.{1} int d (@has_zero.zero.{0} int int.has_zero)),
                      false.rec.{0} false
                        (@eq.mp.{0} (@eq.{1} rat q (rat.mk n d)) false
                           (@eq.trans.{1} Prop (@eq.{1} rat q (rat.mk n d))
                              (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero))
                              false
                              ((λ (a a_1 : rat) (e_1 : @eq.{1} rat a a_1) (a_2 a_3 : rat) (e_2 : @eq.{1} rat a_2 a_3),
                                  @congr.{1 1} rat Prop (@eq.{1} rat a) (@eq.{1} rat a_1) a_2 a_3
                                    (@congr_arg.{1 1} rat (rat → Prop) a a_1 (@eq.{1} rat) e_1)
                                    e_2)
                                 q
                                 q
                                 (@eq.refl.{1} rat q)
                                 (rat.mk n d)
                                 (@has_zero.zero.{0} rat rat.has_zero)
                                 (@eq.trans.{1} rat (rat.mk n d) (rat.mk n (@has_zero.zero.{0} int int.has_zero))
                                    (@has_zero.zero.{0} rat rat.has_zero)
                                    ((λ (a a_1 : int) (e_1 : @eq.{1} int a a_1) (a_2 a_3 : int)
                                      (e_2 : @eq.{1} int a_2 a_3),
                                        @congr.{1 1} int rat (rat.mk a) (rat.mk a_1) a_2 a_3
                                          (@congr_arg.{1 1} int (int → rat) a a_1 rat.mk e_1)
                                          e_2)
                                       n
                                       n
                                       (@eq.refl.{1} int n)
                                       d
                                       (@has_zero.zero.{0} int int.has_zero)
                                       hd)
                                    (rat.mk_zero n)))
                              (@propext (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)) false
                                 (@iff_false_intro (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)) hqz)))
                           qdf))))))),
c : int,
hc1 : @eq.{1} int n (@has_mul.mul.{0} int int.has_mul c (q.num)),
hc2 :
  @eq.{1} int d
    (@has_mul.mul.{0} int int.has_mul c
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))
⊢ @eq.{1} int (padic_val_rat p q)
    (@has_sub.sub.{0} int int.has_sub
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
          (@roption.get.{0} nat
             (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                n)
             (@iff.mpr
                (@multiplicity.finite.{0} int int.comm_semiring
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   n)
                (and
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int n (@has_zero.zero.{0} int int.has_zero)))
                (@multiplicity.finite_int_iff
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   n)
                (@and.intro
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int n (@has_zero.zero.{0} int int.has_zero))
                   (@ne.symm.{1} nat (@has_one.one.{0} nat nat.has_one)
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@ne_of_lt.{0} nat
                         (@partial_order.to_preorder.{0} nat
                            (@ordered_comm_monoid.to_partial_order.{0} nat
                               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
                         (@has_one.one.{0} nat nat.has_one)
                         (int.nat_abs
                            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                         (@nat.prime.one_lt p p_prime)))
                   (λ (hn : @eq.{1} int n (@has_zero.zero.{0} int int.has_zero)),
                      false.rec.{0} false
                        (@eq.mp.{0} (@eq.{1} rat q (rat.mk n d)) false
                           (@eq.trans.{1} Prop (@eq.{1} rat q (rat.mk n d))
                              (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero))
                              false
                              ((λ (a a_1 : rat) (e_1 : @eq.{1} rat a a_1) (a_2 a_3 : rat) (e_2 : @eq.{1} rat a_2 a_3),
                                  @congr.{1 1} rat Prop (@eq.{1} rat a) (@eq.{1} rat a_1) a_2 a_3
                                    (@congr_arg.{1 1} rat (rat → Prop) a a_1 (@eq.{1} rat) e_1)
                                    e_2)
                                 q
                                 q
                                 (@eq.refl.{1} rat q)
                                 (rat.mk n d)
                                 (@has_zero.zero.{0} rat rat.has_zero)
                                 (@eq.trans.{1} rat (rat.mk n d) (rat.mk (@has_zero.zero.{0} int int.has_zero) d)
                                    (@has_zero.zero.{0} rat rat.has_zero)
                                    ((λ (a a_1 : int) (e_1 : @eq.{1} int a a_1) (a_2 a_3 : int)
                                      (e_2 : @eq.{1} int a_2 a_3),
                                        @congr.{1 1} int rat (rat.mk a) (rat.mk a_1) a_2 a_3
                                          (@congr_arg.{1 1} int (int → rat) a a_1 rat.mk e_1)
                                          e_2)
                                       n
                                       (@has_zero.zero.{0} int int.has_zero)
                                       hn
                                       d
                                       d
                                       (@eq.refl.{1} int d))
                                    (rat.zero_mk d)))
                              (@propext (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)) false
                                 (@iff_false_intro (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)) hqz)))
                           qdf))))))
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
          (@roption.get.{0} nat
             (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                d)
             (@iff.mpr
                (@multiplicity.finite.{0} int int.comm_semiring
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   d)
                (and
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int d (@has_zero.zero.{0} int int.has_zero)))
                (@multiplicity.finite_int_iff
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   d)
                (@and.intro
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int d (@has_zero.zero.{0} int int.has_zero))
                   (@ne.symm.{1} nat (@has_one.one.{0} nat nat.has_one)
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@ne_of_lt.{0} nat
                         (@partial_order.to_preorder.{0} nat
                            (@ordered_comm_monoid.to_partial_order.{0} nat
                               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
                         (@has_one.one.{0} nat nat.has_one)
                         (int.nat_abs
                            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                         (@nat.prime.one_lt p p_prime)))
                   (λ (hd : @eq.{1} int d (@has_zero.zero.{0} int int.has_zero)),
                      false.rec.{0} false
                        (@eq.mp.{0} (@eq.{1} rat q (rat.mk n d)) false
                           (@eq.trans.{1} Prop (@eq.{1} rat q (rat.mk n d))
                              (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero))
                              false
                              ((λ (a a_1 : rat) (e_1 : @eq.{1} rat a a_1) (a_2 a_3 : rat) (e_2 : @eq.{1} rat a_2 a_3),
                                  @congr.{1 1} rat Prop (@eq.{1} rat a) (@eq.{1} rat a_1) a_2 a_3
                                    (@congr_arg.{1 1} rat (rat → Prop) a a_1 (@eq.{1} rat) e_1)
                                    e_2)
                                 q
                                 q
                                 (@eq.refl.{1} rat q)
                                 (rat.mk n d)
                                 (@has_zero.zero.{0} rat rat.has_zero)
                                 (@eq.trans.{1} rat (rat.mk n d) (rat.mk n (@has_zero.zero.{0} int int.has_zero))
                                    (@has_zero.zero.{0} rat rat.has_zero)
                                    ((λ (a a_1 : int) (e_1 : @eq.{1} int a a_1) (a_2 a_3 : int)
                                      (e_2 : @eq.{1} int a_2 a_3),
                                        @congr.{1 1} int rat (rat.mk a) (rat.mk a_1) a_2 a_3
                                          (@congr_arg.{1 1} int (int → rat) a a_1 rat.mk e_1)
                                          e_2)
                                       n
                                       n
                                       (@eq.refl.{1} int n)
                                       d
                                       (@has_zero.zero.{0} int int.has_zero)
                                       hd)
                                    (rat.mk_zero n)))
                              (@propext (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)) false
                                 (@iff_false_intro (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)) hqz)))
                           qdf)))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>141    simp [hc1, hc2, multiplicity.mul&#x27; (nat.prime_iff_prime_int.1 p_prime),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='hc1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hc2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='multiplicity.mul&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='nat.prime_iff_prime_int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='p_prime'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/ring_theory/multiplicity.lean&#x27;, &#x27;line&#x27;: 302, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/gcd_domain.lean&#x27;, &#x27;line&#x27;: 579, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{1} int n (@has_mul.mul.{0} int int.has_mul c (q.num))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{1} int d (@has_mul.mul.{0} int int.has_mul c (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : integral_domain.{0} α] [_inst_2 : @decidable_rel.{1} α (@has_dvd.dvd.{0} α (@comm_semiring_has_dvd.{0} α (@nonzero_comm_semiring.to_comm_semiring.{0} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} α (@integral_domain.to_nonzero_comm_ring.{0} α _inst_1)))))] {p a b : α} (hp : @prime.{0} α (@nonzero_comm_semiring.to_comm_semiring.{0} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} α (@integral_domain.to_nonzero_comm_ring.{0} α _inst_1))) p) (h : @roption.dom.{0} nat (@multiplicity.{0} α (@nonzero_comm_semiring.to_comm_semiring.{0} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} α (@integral_domain.to_nonzero_comm_ring.{0} α _inst_1))) (λ (a b : α), _inst_2 a b) p (@has_mul.mul.{0} α (@no_zero_divisors.to_has_mul.{0} α (@domain.to_no_zero_divisors.{0} α (@integral_domain.to_domain.{0} α _inst_1))) a b))), @eq.{1} nat (@roption.get.{0} nat (@multiplicity.{0} α (@nonzero_comm_semiring.to_comm_semiring.{0} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} α (@integral_domain.to_nonzero_comm_ring.{0} α _inst_1))) (λ (a b : α), _inst_2 a b) p (@has_mul.mul.{0} α (@no_zero_divisors.to_has_mul.{0} α (@domain.to_no_zero_divisors.{0} α (@integral_domain.to_domain.{0} α _inst_1))) a b)) h) (@has_add.add.{0} nat nat.has_add (@roption.get.{0} nat (@multiplicity.{0} α (@nonzero_comm_semiring.to_comm_semiring.{0} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} α (@integral_domain.to_nonzero_comm_ring.{0} α _inst_1))) (λ (a b : α), _inst_2 a b) p a) (@and.left (@multiplicity.finite.{0} α (@nonzero_comm_semiring.to_comm_semiring.{0} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} α (@integral_domain.to_nonzero_comm_ring.{0} α _inst_1))) p a) (@multiplicity.finite.{0} α (@nonzero_comm_semiring.to_comm_semiring.{0} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} α (@integral_domain.to_nonzero_comm_ring.{0} α _inst_1))) p b) (@iff.mp (@multiplicity.finite.{0} α (@nonzero_comm_semiring.to_comm_semiring.{0} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} α (@integral_domain.to_nonzero_comm_ring.{0} α _inst_1))) p (@has_mul.mul.{0} α (@no_zero_divisors.to_has_mul.{0} α (@domain.to_no_zero_divisors.{0} α (@integral_domain.to_domain.{0} α _inst_1))) a b)) (and (@multiplicity.finite.{0} α (@nonzero_comm_semiring.to_comm_semiring.{0} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} α (@integral_domain.to_nonzero_comm_ring.{0} α _inst_1))) p a) (@multiplicity.finite.{0} α (@nonzero_comm_semiring.to_comm_semiring.{0} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} α (@integral_domain.to_nonzero_comm_ring.{0} α _inst_1))) p b)) (@multiplicity.finite_mul_iff.{0} α _inst_1 (λ (a b : α), _inst_2 a b) p a b hp) h))) (@roption.get.{0} nat (@multiplicity.{0} α (@nonzero_comm_semiring.to_comm_semiring.{0} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} α (@integral_domain.to_nonzero_comm_ring.{0} α _inst_1))) (λ (a b : α), _inst_2 a b) p b) (@and.right (@multiplicity.finite.{0} α (@nonzero_comm_semiring.to_comm_semiring.{0} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} α (@integral_domain.to_nonzero_comm_ring.{0} α _inst_1))) p a) (@multiplicity.finite.{0} α (@nonzero_comm_semiring.to_comm_semiring.{0} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} α (@integral_domain.to_nonzero_comm_ring.{0} α _inst_1))) p b) (@iff.mp (@multiplicity.finite.{0} α (@nonzero_comm_semiring.to_comm_semiring.{0} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} α (@integral_domain.to_nonzero_comm_ring.{0} α _inst_1))) p (@has_mul.mul.{0} α (@no_zero_divisors.to_has_mul.{0} α (@domain.to_no_zero_divisors.{0} α (@integral_domain.to_domain.{0} α _inst_1))) a b)) (and (@multiplicity.finite.{0} α (@nonzero_comm_semiring.to_comm_semiring.{0} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} α (@integral_domain.to_nonzero_comm_ring.{0} α _inst_1))) p a) (@multiplicity.finite.{0} α (@nonzero_comm_semiring.to_comm_semiring.{0} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} α (@integral_domain.to_nonzero_comm_ring.{0} α _inst_1))) p b)) (@multiplicity.finite_mul_iff.{0} α _inst_1 (λ (a b : α), _inst_2 a b) p a b hp) h))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {p : nat}, iff (nat.prime p) (@prime.{0} int int.comm_semiring (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat.prime p'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
p_prime : nat.prime p,
q : rat,
n d : int,
hqz : @ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero),
qdf : @eq.{1} rat q (rat.mk n d),
hn : @ne.{1} int n (@has_zero.zero.{0} int int.has_zero),
hd : @ne.{1} int d (@has_zero.zero.{0} int int.has_zero),
_let_match :
  @Exists.{1} int
    (λ (c : int),
       and (@eq.{1} int n (@has_mul.mul.{0} int int.has_mul c (q.num)))
         (@eq.{1} int d
            (@has_mul.mul.{0} int int.has_mul c
               (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))))) →
  @eq.{1} int (padic_val_rat p q)
    (@has_sub.sub.{0} int int.has_sub
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
          (@roption.get.{0} nat
             (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                n)
             (@iff.mpr
                (@multiplicity.finite.{0} int int.comm_semiring
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   n)
                (and
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int n (@has_zero.zero.{0} int int.has_zero)))
                (@multiplicity.finite_int_iff
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   n)
                (@and.intro
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int n (@has_zero.zero.{0} int int.has_zero))
                   (@ne.symm.{1} nat (@has_one.one.{0} nat nat.has_one)
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@ne_of_lt.{0} nat
                         (@partial_order.to_preorder.{0} nat
                            (@ordered_comm_monoid.to_partial_order.{0} nat
                               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
                         (@has_one.one.{0} nat nat.has_one)
                         (int.nat_abs
                            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                         (@nat.prime.one_lt p p_prime)))
                   (λ (hn : @eq.{1} int n (@has_zero.zero.{0} int int.has_zero)),
                      false.rec.{0} false
                        (@eq.mp.{0} (@eq.{1} rat q (rat.mk n d)) false
                           (@eq.trans.{1} Prop (@eq.{1} rat q (rat.mk n d))
                              (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero))
                              false
                              ((λ (a a_1 : rat) (e_1 : @eq.{1} rat a a_1) (a_2 a_3 : rat) (e_2 : @eq.{1} rat a_2 a_3),
                                  @congr.{1 1} rat Prop (@eq.{1} rat a) (@eq.{1} rat a_1) a_2 a_3
                                    (@congr_arg.{1 1} rat (rat → Prop) a a_1 (@eq.{1} rat) e_1)
                                    e_2)
                                 q
                                 q
                                 (@eq.refl.{1} rat q)
                                 (rat.mk n d)
                                 (@has_zero.zero.{0} rat rat.has_zero)
                                 (@eq.trans.{1} rat (rat.mk n d) (rat.mk (@has_zero.zero.{0} int int.has_zero) d)
                                    (@has_zero.zero.{0} rat rat.has_zero)
                                    ((λ (a a_1 : int) (e_1 : @eq.{1} int a a_1) (a_2 a_3 : int)
                                      (e_2 : @eq.{1} int a_2 a_3),
                                        @congr.{1 1} int rat (rat.mk a) (rat.mk a_1) a_2 a_3
                                          (@congr_arg.{1 1} int (int → rat) a a_1 rat.mk e_1)
                                          e_2)
                                       n
                                       (@has_zero.zero.{0} int int.has_zero)
                                       hn
                                       d
                                       d
                                       (@eq.refl.{1} int d))
                                    (rat.zero_mk d)))
                              (@propext (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)) false
                                 (@iff_false_intro (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)) hqz)))
                           qdf))))))
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
          (@roption.get.{0} nat
             (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                d)
             (@iff.mpr
                (@multiplicity.finite.{0} int int.comm_semiring
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   d)
                (and
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int d (@has_zero.zero.{0} int int.has_zero)))
                (@multiplicity.finite_int_iff
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   d)
                (@and.intro
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int d (@has_zero.zero.{0} int int.has_zero))
                   (@ne.symm.{1} nat (@has_one.one.{0} nat nat.has_one)
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@ne_of_lt.{0} nat
                         (@partial_order.to_preorder.{0} nat
                            (@ordered_comm_monoid.to_partial_order.{0} nat
                               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
                         (@has_one.one.{0} nat nat.has_one)
                         (int.nat_abs
                            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                         (@nat.prime.one_lt p p_prime)))
                   (λ (hd : @eq.{1} int d (@has_zero.zero.{0} int int.has_zero)),
                      false.rec.{0} false
                        (@eq.mp.{0} (@eq.{1} rat q (rat.mk n d)) false
                           (@eq.trans.{1} Prop (@eq.{1} rat q (rat.mk n d))
                              (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero))
                              false
                              ((λ (a a_1 : rat) (e_1 : @eq.{1} rat a a_1) (a_2 a_3 : rat) (e_2 : @eq.{1} rat a_2 a_3),
                                  @congr.{1 1} rat Prop (@eq.{1} rat a) (@eq.{1} rat a_1) a_2 a_3
                                    (@congr_arg.{1 1} rat (rat → Prop) a a_1 (@eq.{1} rat) e_1)
                                    e_2)
                                 q
                                 q
                                 (@eq.refl.{1} rat q)
                                 (rat.mk n d)
                                 (@has_zero.zero.{0} rat rat.has_zero)
                                 (@eq.trans.{1} rat (rat.mk n d) (rat.mk n (@has_zero.zero.{0} int int.has_zero))
                                    (@has_zero.zero.{0} rat rat.has_zero)
                                    ((λ (a a_1 : int) (e_1 : @eq.{1} int a a_1) (a_2 a_3 : int)
                                      (e_2 : @eq.{1} int a_2 a_3),
                                        @congr.{1 1} int rat (rat.mk a) (rat.mk a_1) a_2 a_3
                                          (@congr_arg.{1 1} int (int → rat) a a_1 rat.mk e_1)
                                          e_2)
                                       n
                                       n
                                       (@eq.refl.{1} int n)
                                       d
                                       (@has_zero.zero.{0} int int.has_zero)
                                       hd)
                                    (rat.mk_zero n)))
                              (@propext (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)) false
                                 (@iff_false_intro (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)) hqz)))
                           qdf))))))),
c : int,
hc1 : @eq.{1} int n (@has_mul.mul.{0} int int.has_mul c (q.num)),
hc2 :
  @eq.{1} int d
    (@has_mul.mul.{0} int int.has_mul c
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))
⊢ @eq.{1} int (padic_val_rat p q)
    (@has_sub.sub.{0} int int.has_sub
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
          (@roption.get.{0} nat
             (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                n)
             (@iff.mpr
                (@multiplicity.finite.{0} int int.comm_semiring
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   n)
                (and
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int n (@has_zero.zero.{0} int int.has_zero)))
                (@multiplicity.finite_int_iff
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   n)
                (@and.intro
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int n (@has_zero.zero.{0} int int.has_zero))
                   (@ne.symm.{1} nat (@has_one.one.{0} nat nat.has_one)
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@ne_of_lt.{0} nat
                         (@partial_order.to_preorder.{0} nat
                            (@ordered_comm_monoid.to_partial_order.{0} nat
                               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
                         (@has_one.one.{0} nat nat.has_one)
                         (int.nat_abs
                            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                         (@nat.prime.one_lt p p_prime)))
                   (λ (hn : @eq.{1} int n (@has_zero.zero.{0} int int.has_zero)),
                      false.rec.{0} false
                        (@eq.mp.{0} (@eq.{1} rat q (rat.mk n d)) false
                           (@eq.trans.{1} Prop (@eq.{1} rat q (rat.mk n d))
                              (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero))
                              false
                              ((λ (a a_1 : rat) (e_1 : @eq.{1} rat a a_1) (a_2 a_3 : rat) (e_2 : @eq.{1} rat a_2 a_3),
                                  @congr.{1 1} rat Prop (@eq.{1} rat a) (@eq.{1} rat a_1) a_2 a_3
                                    (@congr_arg.{1 1} rat (rat → Prop) a a_1 (@eq.{1} rat) e_1)
                                    e_2)
                                 q
                                 q
                                 (@eq.refl.{1} rat q)
                                 (rat.mk n d)
                                 (@has_zero.zero.{0} rat rat.has_zero)
                                 (@eq.trans.{1} rat (rat.mk n d) (rat.mk (@has_zero.zero.{0} int int.has_zero) d)
                                    (@has_zero.zero.{0} rat rat.has_zero)
                                    ((λ (a a_1 : int) (e_1 : @eq.{1} int a a_1) (a_2 a_3 : int)
                                      (e_2 : @eq.{1} int a_2 a_3),
                                        @congr.{1 1} int rat (rat.mk a) (rat.mk a_1) a_2 a_3
                                          (@congr_arg.{1 1} int (int → rat) a a_1 rat.mk e_1)
                                          e_2)
                                       n
                                       (@has_zero.zero.{0} int int.has_zero)
                                       hn
                                       d
                                       d
                                       (@eq.refl.{1} int d))
                                    (rat.zero_mk d)))
                              (@propext (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)) false
                                 (@iff_false_intro (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)) hqz)))
                           qdf))))))
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
          (@roption.get.{0} nat
             (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                d)
             (@iff.mpr
                (@multiplicity.finite.{0} int int.comm_semiring
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   d)
                (and
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int d (@has_zero.zero.{0} int int.has_zero)))
                (@multiplicity.finite_int_iff
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   d)
                (@and.intro
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int d (@has_zero.zero.{0} int int.has_zero))
                   (@ne.symm.{1} nat (@has_one.one.{0} nat nat.has_one)
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@ne_of_lt.{0} nat
                         (@partial_order.to_preorder.{0} nat
                            (@ordered_comm_monoid.to_partial_order.{0} nat
                               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
                         (@has_one.one.{0} nat nat.has_one)
                         (int.nat_abs
                            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                         (@nat.prime.one_lt p p_prime)))
                   (λ (hd : @eq.{1} int d (@has_zero.zero.{0} int int.has_zero)),
                      false.rec.{0} false
                        (@eq.mp.{0} (@eq.{1} rat q (rat.mk n d)) false
                           (@eq.trans.{1} Prop (@eq.{1} rat q (rat.mk n d))
                              (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero))
                              false
                              ((λ (a a_1 : rat) (e_1 : @eq.{1} rat a a_1) (a_2 a_3 : rat) (e_2 : @eq.{1} rat a_2 a_3),
                                  @congr.{1 1} rat Prop (@eq.{1} rat a) (@eq.{1} rat a_1) a_2 a_3
                                    (@congr_arg.{1 1} rat (rat → Prop) a a_1 (@eq.{1} rat) e_1)
                                    e_2)
                                 q
                                 q
                                 (@eq.refl.{1} rat q)
                                 (rat.mk n d)
                                 (@has_zero.zero.{0} rat rat.has_zero)
                                 (@eq.trans.{1} rat (rat.mk n d) (rat.mk n (@has_zero.zero.{0} int int.has_zero))
                                    (@has_zero.zero.{0} rat rat.has_zero)
                                    ((λ (a a_1 : int) (e_1 : @eq.{1} int a a_1) (a_2 a_3 : int)
                                      (e_2 : @eq.{1} int a_2 a_3),
                                        @congr.{1 1} int rat (rat.mk a) (rat.mk a_1) a_2 a_3
                                          (@congr_arg.{1 1} int (int → rat) a a_1 rat.mk e_1)
                                          e_2)
                                       n
                                       n
                                       (@eq.refl.{1} int n)
                                       d
                                       (@has_zero.zero.{0} int int.has_zero)
                                       hd)
                                    (rat.mk_zero n)))
                              (@propext (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)) false
                                 (@iff_false_intro (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)) hqz)))
                           qdf)))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>142      (ne.symm (ne_of_lt p_prime.one_lt)), hqz]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='ne.symm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ne_of_lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p_prime'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='hqz'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 112, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 87, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/nat/prime.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type} {a b : α}, @ne.{1} α a b → @ne.{1} α b a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type} [_inst_1 : preorder.{0} α] {a b : α}, @has_lt.lt.{0} α (@preorder.to_has_lt.{0} α _inst_1) a b → @ne.{1} α a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat.prime p'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
p_prime : nat.prime p,
q : rat,
n d : int,
hqz : @ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero),
qdf : @eq.{1} rat q (rat.mk n d),
hn : @ne.{1} int n (@has_zero.zero.{0} int int.has_zero),
hd : @ne.{1} int d (@has_zero.zero.{0} int int.has_zero),
_let_match :
  @Exists.{1} int
    (λ (c : int),
       and (@eq.{1} int n (@has_mul.mul.{0} int int.has_mul c (q.num)))
         (@eq.{1} int d
            (@has_mul.mul.{0} int int.has_mul c
               (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))))) →
  @eq.{1} int (padic_val_rat p q)
    (@has_sub.sub.{0} int int.has_sub
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
          (@roption.get.{0} nat
             (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                n)
             (@iff.mpr
                (@multiplicity.finite.{0} int int.comm_semiring
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   n)
                (and
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int n (@has_zero.zero.{0} int int.has_zero)))
                (@multiplicity.finite_int_iff
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   n)
                (@and.intro
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int n (@has_zero.zero.{0} int int.has_zero))
                   (@ne.symm.{1} nat (@has_one.one.{0} nat nat.has_one)
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@ne_of_lt.{0} nat
                         (@partial_order.to_preorder.{0} nat
                            (@ordered_comm_monoid.to_partial_order.{0} nat
                               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
                         (@has_one.one.{0} nat nat.has_one)
                         (int.nat_abs
                            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                         (@nat.prime.one_lt p p_prime)))
                   (λ (hn : @eq.{1} int n (@has_zero.zero.{0} int int.has_zero)),
                      false.rec.{0} false
                        (@eq.mp.{0} (@eq.{1} rat q (rat.mk n d)) false
                           (@eq.trans.{1} Prop (@eq.{1} rat q (rat.mk n d))
                              (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero))
                              false
                              ((λ (a a_1 : rat) (e_1 : @eq.{1} rat a a_1) (a_2 a_3 : rat) (e_2 : @eq.{1} rat a_2 a_3),
                                  @congr.{1 1} rat Prop (@eq.{1} rat a) (@eq.{1} rat a_1) a_2 a_3
                                    (@congr_arg.{1 1} rat (rat → Prop) a a_1 (@eq.{1} rat) e_1)
                                    e_2)
                                 q
                                 q
                                 (@eq.refl.{1} rat q)
                                 (rat.mk n d)
                                 (@has_zero.zero.{0} rat rat.has_zero)
                                 (@eq.trans.{1} rat (rat.mk n d) (rat.mk (@has_zero.zero.{0} int int.has_zero) d)
                                    (@has_zero.zero.{0} rat rat.has_zero)
                                    ((λ (a a_1 : int) (e_1 : @eq.{1} int a a_1) (a_2 a_3 : int)
                                      (e_2 : @eq.{1} int a_2 a_3),
                                        @congr.{1 1} int rat (rat.mk a) (rat.mk a_1) a_2 a_3
                                          (@congr_arg.{1 1} int (int → rat) a a_1 rat.mk e_1)
                                          e_2)
                                       n
                                       (@has_zero.zero.{0} int int.has_zero)
                                       hn
                                       d
                                       d
                                       (@eq.refl.{1} int d))
                                    (rat.zero_mk d)))
                              (@propext (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)) false
                                 (@iff_false_intro (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)) hqz)))
                           qdf))))))
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
          (@roption.get.{0} nat
             (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                d)
             (@iff.mpr
                (@multiplicity.finite.{0} int int.comm_semiring
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   d)
                (and
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int d (@has_zero.zero.{0} int int.has_zero)))
                (@multiplicity.finite_int_iff
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   d)
                (@and.intro
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int d (@has_zero.zero.{0} int int.has_zero))
                   (@ne.symm.{1} nat (@has_one.one.{0} nat nat.has_one)
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@ne_of_lt.{0} nat
                         (@partial_order.to_preorder.{0} nat
                            (@ordered_comm_monoid.to_partial_order.{0} nat
                               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
                         (@has_one.one.{0} nat nat.has_one)
                         (int.nat_abs
                            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                         (@nat.prime.one_lt p p_prime)))
                   (λ (hd : @eq.{1} int d (@has_zero.zero.{0} int int.has_zero)),
                      false.rec.{0} false
                        (@eq.mp.{0} (@eq.{1} rat q (rat.mk n d)) false
                           (@eq.trans.{1} Prop (@eq.{1} rat q (rat.mk n d))
                              (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero))
                              false
                              ((λ (a a_1 : rat) (e_1 : @eq.{1} rat a a_1) (a_2 a_3 : rat) (e_2 : @eq.{1} rat a_2 a_3),
                                  @congr.{1 1} rat Prop (@eq.{1} rat a) (@eq.{1} rat a_1) a_2 a_3
                                    (@congr_arg.{1 1} rat (rat → Prop) a a_1 (@eq.{1} rat) e_1)
                                    e_2)
                                 q
                                 q
                                 (@eq.refl.{1} rat q)
                                 (rat.mk n d)
                                 (@has_zero.zero.{0} rat rat.has_zero)
                                 (@eq.trans.{1} rat (rat.mk n d) (rat.mk n (@has_zero.zero.{0} int int.has_zero))
                                    (@has_zero.zero.{0} rat rat.has_zero)
                                    ((λ (a a_1 : int) (e_1 : @eq.{1} int a a_1) (a_2 a_3 : int)
                                      (e_2 : @eq.{1} int a_2 a_3),
                                        @congr.{1 1} int rat (rat.mk a) (rat.mk a_1) a_2 a_3
                                          (@congr_arg.{1 1} int (int → rat) a a_1 rat.mk e_1)
                                          e_2)
                                       n
                                       n
                                       (@eq.refl.{1} int n)
                                       d
                                       (@has_zero.zero.{0} int int.has_zero)
                                       hd)
                                    (rat.mk_zero n)))
                              (@propext (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)) false
                                 (@iff_false_intro (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)) hqz)))
                           qdf))))))),
c : int,
hc1 : @eq.{1} int n (@has_mul.mul.{0} int int.has_mul c (q.num)),
hc2 :
  @eq.{1} int d
    (@has_mul.mul.{0} int int.has_mul c
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))
⊢ @eq.{1} int (padic_val_rat p q)
    (@has_sub.sub.{0} int int.has_sub
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
          (@roption.get.{0} nat
             (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                n)
             (@iff.mpr
                (@multiplicity.finite.{0} int int.comm_semiring
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   n)
                (and
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int n (@has_zero.zero.{0} int int.has_zero)))
                (@multiplicity.finite_int_iff
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   n)
                (@and.intro
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int n (@has_zero.zero.{0} int int.has_zero))
                   (@ne.symm.{1} nat (@has_one.one.{0} nat nat.has_one)
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@ne_of_lt.{0} nat
                         (@partial_order.to_preorder.{0} nat
                            (@ordered_comm_monoid.to_partial_order.{0} nat
                               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
                         (@has_one.one.{0} nat nat.has_one)
                         (int.nat_abs
                            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                         (@nat.prime.one_lt p p_prime)))
                   (λ (hn : @eq.{1} int n (@has_zero.zero.{0} int int.has_zero)),
                      false.rec.{0} false
                        (@eq.mp.{0} (@eq.{1} rat q (rat.mk n d)) false
                           (@eq.trans.{1} Prop (@eq.{1} rat q (rat.mk n d))
                              (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero))
                              false
                              ((λ (a a_1 : rat) (e_1 : @eq.{1} rat a a_1) (a_2 a_3 : rat) (e_2 : @eq.{1} rat a_2 a_3),
                                  @congr.{1 1} rat Prop (@eq.{1} rat a) (@eq.{1} rat a_1) a_2 a_3
                                    (@congr_arg.{1 1} rat (rat → Prop) a a_1 (@eq.{1} rat) e_1)
                                    e_2)
                                 q
                                 q
                                 (@eq.refl.{1} rat q)
                                 (rat.mk n d)
                                 (@has_zero.zero.{0} rat rat.has_zero)
                                 (@eq.trans.{1} rat (rat.mk n d) (rat.mk (@has_zero.zero.{0} int int.has_zero) d)
                                    (@has_zero.zero.{0} rat rat.has_zero)
                                    ((λ (a a_1 : int) (e_1 : @eq.{1} int a a_1) (a_2 a_3 : int)
                                      (e_2 : @eq.{1} int a_2 a_3),
                                        @congr.{1 1} int rat (rat.mk a) (rat.mk a_1) a_2 a_3
                                          (@congr_arg.{1 1} int (int → rat) a a_1 rat.mk e_1)
                                          e_2)
                                       n
                                       (@has_zero.zero.{0} int int.has_zero)
                                       hn
                                       d
                                       d
                                       (@eq.refl.{1} int d))
                                    (rat.zero_mk d)))
                              (@propext (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)) false
                                 (@iff_false_intro (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)) hqz)))
                           qdf))))))
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
          (@roption.get.{0} nat
             (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                d)
             (@iff.mpr
                (@multiplicity.finite.{0} int int.comm_semiring
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   d)
                (and
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int d (@has_zero.zero.{0} int int.has_zero)))
                (@multiplicity.finite_int_iff
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   d)
                (@and.intro
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int d (@has_zero.zero.{0} int int.has_zero))
                   (@ne.symm.{1} nat (@has_one.one.{0} nat nat.has_one)
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@ne_of_lt.{0} nat
                         (@partial_order.to_preorder.{0} nat
                            (@ordered_comm_monoid.to_partial_order.{0} nat
                               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
                         (@has_one.one.{0} nat nat.has_one)
                         (int.nat_abs
                            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                         (@nat.prime.one_lt p p_prime)))
                   (λ (hd : @eq.{1} int d (@has_zero.zero.{0} int int.has_zero)),
                      false.rec.{0} false
                        (@eq.mp.{0} (@eq.{1} rat q (rat.mk n d)) false
                           (@eq.trans.{1} Prop (@eq.{1} rat q (rat.mk n d))
                              (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero))
                              false
                              ((λ (a a_1 : rat) (e_1 : @eq.{1} rat a a_1) (a_2 a_3 : rat) (e_2 : @eq.{1} rat a_2 a_3),
                                  @congr.{1 1} rat Prop (@eq.{1} rat a) (@eq.{1} rat a_1) a_2 a_3
                                    (@congr_arg.{1 1} rat (rat → Prop) a a_1 (@eq.{1} rat) e_1)
                                    e_2)
                                 q
                                 q
                                 (@eq.refl.{1} rat q)
                                 (rat.mk n d)
                                 (@has_zero.zero.{0} rat rat.has_zero)
                                 (@eq.trans.{1} rat (rat.mk n d) (rat.mk n (@has_zero.zero.{0} int int.has_zero))
                                    (@has_zero.zero.{0} rat rat.has_zero)
                                    ((λ (a a_1 : int) (e_1 : @eq.{1} int a a_1) (a_2 a_3 : int)
                                      (e_2 : @eq.{1} int a_2 a_3),
                                        @congr.{1 1} int rat (rat.mk a) (rat.mk a_1) a_2 a_3
                                          (@congr_arg.{1 1} int (int → rat) a a_1 rat.mk e_1)
                                          e_2)
                                       n
                                       n
                                       (@eq.refl.{1} int n)
                                       d
                                       (@has_zero.zero.{0} int int.has_zero)
                                       hd)
                                    (rat.mk_zero n)))
                              (@propext (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)) false
                                 (@iff_false_intro (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)) hqz)))
                           qdf)))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>143  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
p_prime : nat.prime p,
q : rat,
n d : int,
hqz : @ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero),
qdf : @eq.{1} rat q (rat.mk n d),
hn : @ne.{1} int n (@has_zero.zero.{0} int int.has_zero),
hd : @ne.{1} int d (@has_zero.zero.{0} int int.has_zero),
_let_match :
  @Exists.{1} int
    (λ (c : int),
       and (@eq.{1} int n (@has_mul.mul.{0} int int.has_mul c (q.num)))
         (@eq.{1} int d
            (@has_mul.mul.{0} int int.has_mul c
               (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))))) →
  @eq.{1} int (padic_val_rat p q)
    (@has_sub.sub.{0} int int.has_sub
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
          (@roption.get.{0} nat
             (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                n)
             (@iff.mpr
                (@multiplicity.finite.{0} int int.comm_semiring
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   n)
                (and
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int n (@has_zero.zero.{0} int int.has_zero)))
                (@multiplicity.finite_int_iff
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   n)
                (@and.intro
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int n (@has_zero.zero.{0} int int.has_zero))
                   (@ne.symm.{1} nat (@has_one.one.{0} nat nat.has_one)
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@ne_of_lt.{0} nat
                         (@partial_order.to_preorder.{0} nat
                            (@ordered_comm_monoid.to_partial_order.{0} nat
                               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
                         (@has_one.one.{0} nat nat.has_one)
                         (int.nat_abs
                            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                         (@nat.prime.one_lt p p_prime)))
                   (λ (hn : @eq.{1} int n (@has_zero.zero.{0} int int.has_zero)),
                      false.rec.{0} false
                        (@eq.mp.{0} (@eq.{1} rat q (rat.mk n d)) false
                           (@eq.trans.{1} Prop (@eq.{1} rat q (rat.mk n d))
                              (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero))
                              false
                              ((λ (a a_1 : rat) (e_1 : @eq.{1} rat a a_1) (a_2 a_3 : rat) (e_2 : @eq.{1} rat a_2 a_3),
                                  @congr.{1 1} rat Prop (@eq.{1} rat a) (@eq.{1} rat a_1) a_2 a_3
                                    (@congr_arg.{1 1} rat (rat → Prop) a a_1 (@eq.{1} rat) e_1)
                                    e_2)
                                 q
                                 q
                                 (@eq.refl.{1} rat q)
                                 (rat.mk n d)
                                 (@has_zero.zero.{0} rat rat.has_zero)
                                 (@eq.trans.{1} rat (rat.mk n d) (rat.mk (@has_zero.zero.{0} int int.has_zero) d)
                                    (@has_zero.zero.{0} rat rat.has_zero)
                                    ((λ (a a_1 : int) (e_1 : @eq.{1} int a a_1) (a_2 a_3 : int)
                                      (e_2 : @eq.{1} int a_2 a_3),
                                        @congr.{1 1} int rat (rat.mk a) (rat.mk a_1) a_2 a_3
                                          (@congr_arg.{1 1} int (int → rat) a a_1 rat.mk e_1)
                                          e_2)
                                       n
                                       (@has_zero.zero.{0} int int.has_zero)
                                       hn
                                       d
                                       d
                                       (@eq.refl.{1} int d))
                                    (rat.zero_mk d)))
                              (@propext (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)) false
                                 (@iff_false_intro (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)) hqz)))
                           qdf))))))
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
          (@roption.get.{0} nat
             (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                d)
             (@iff.mpr
                (@multiplicity.finite.{0} int int.comm_semiring
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   d)
                (and
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int d (@has_zero.zero.{0} int int.has_zero)))
                (@multiplicity.finite_int_iff
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   d)
                (@and.intro
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int d (@has_zero.zero.{0} int int.has_zero))
                   (@ne.symm.{1} nat (@has_one.one.{0} nat nat.has_one)
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@ne_of_lt.{0} nat
                         (@partial_order.to_preorder.{0} nat
                            (@ordered_comm_monoid.to_partial_order.{0} nat
                               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
                         (@has_one.one.{0} nat nat.has_one)
                         (int.nat_abs
                            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                         (@nat.prime.one_lt p p_prime)))
                   (λ (hd : @eq.{1} int d (@has_zero.zero.{0} int int.has_zero)),
                      false.rec.{0} false
                        (@eq.mp.{0} (@eq.{1} rat q (rat.mk n d)) false
                           (@eq.trans.{1} Prop (@eq.{1} rat q (rat.mk n d))
                              (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero))
                              false
                              ((λ (a a_1 : rat) (e_1 : @eq.{1} rat a a_1) (a_2 a_3 : rat) (e_2 : @eq.{1} rat a_2 a_3),
                                  @congr.{1 1} rat Prop (@eq.{1} rat a) (@eq.{1} rat a_1) a_2 a_3
                                    (@congr_arg.{1 1} rat (rat → Prop) a a_1 (@eq.{1} rat) e_1)
                                    e_2)
                                 q
                                 q
                                 (@eq.refl.{1} rat q)
                                 (rat.mk n d)
                                 (@has_zero.zero.{0} rat rat.has_zero)
                                 (@eq.trans.{1} rat (rat.mk n d) (rat.mk n (@has_zero.zero.{0} int int.has_zero))
                                    (@has_zero.zero.{0} rat rat.has_zero)
                                    ((λ (a a_1 : int) (e_1 : @eq.{1} int a a_1) (a_2 a_3 : int)
                                      (e_2 : @eq.{1} int a_2 a_3),
                                        @congr.{1 1} int rat (rat.mk a) (rat.mk a_1) a_2 a_3
                                          (@congr_arg.{1 1} int (int → rat) a a_1 rat.mk e_1)
                                          e_2)
                                       n
                                       n
                                       (@eq.refl.{1} int n)
                                       d
                                       (@has_zero.zero.{0} int int.has_zero)
                                       hd)
                                    (rat.mk_zero n)))
                              (@propext (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)) false
                                 (@iff_false_intro (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)) hqz)))
                           qdf))))))),
c : int,
hc1 : @eq.{1} int n (@has_mul.mul.{0} int int.has_mul c (q.num)),
hc2 :
  @eq.{1} int d
    (@has_mul.mul.{0} int int.has_mul c
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))
⊢ @eq.{1} int (padic_val_rat p q)
    (@has_sub.sub.{0} int int.has_sub
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
          (@roption.get.{0} nat
             (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                n)
             (@iff.mpr
                (@multiplicity.finite.{0} int int.comm_semiring
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   n)
                (and
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int n (@has_zero.zero.{0} int int.has_zero)))
                (@multiplicity.finite_int_iff
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   n)
                (@and.intro
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int n (@has_zero.zero.{0} int int.has_zero))
                   (@ne.symm.{1} nat (@has_one.one.{0} nat nat.has_one)
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@ne_of_lt.{0} nat
                         (@partial_order.to_preorder.{0} nat
                            (@ordered_comm_monoid.to_partial_order.{0} nat
                               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
                         (@has_one.one.{0} nat nat.has_one)
                         (int.nat_abs
                            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                         (@nat.prime.one_lt p p_prime)))
                   (λ (hn : @eq.{1} int n (@has_zero.zero.{0} int int.has_zero)),
                      false.rec.{0} false
                        (@eq.mp.{0} (@eq.{1} rat q (rat.mk n d)) false
                           (@eq.trans.{1} Prop (@eq.{1} rat q (rat.mk n d))
                              (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero))
                              false
                              ((λ (a a_1 : rat) (e_1 : @eq.{1} rat a a_1) (a_2 a_3 : rat) (e_2 : @eq.{1} rat a_2 a_3),
                                  @congr.{1 1} rat Prop (@eq.{1} rat a) (@eq.{1} rat a_1) a_2 a_3
                                    (@congr_arg.{1 1} rat (rat → Prop) a a_1 (@eq.{1} rat) e_1)
                                    e_2)
                                 q
                                 q
                                 (@eq.refl.{1} rat q)
                                 (rat.mk n d)
                                 (@has_zero.zero.{0} rat rat.has_zero)
                                 (@eq.trans.{1} rat (rat.mk n d) (rat.mk (@has_zero.zero.{0} int int.has_zero) d)
                                    (@has_zero.zero.{0} rat rat.has_zero)
                                    ((λ (a a_1 : int) (e_1 : @eq.{1} int a a_1) (a_2 a_3 : int)
                                      (e_2 : @eq.{1} int a_2 a_3),
                                        @congr.{1 1} int rat (rat.mk a) (rat.mk a_1) a_2 a_3
                                          (@congr_arg.{1 1} int (int → rat) a a_1 rat.mk e_1)
                                          e_2)
                                       n
                                       (@has_zero.zero.{0} int int.has_zero)
                                       hn
                                       d
                                       d
                                       (@eq.refl.{1} int d))
                                    (rat.zero_mk d)))
                              (@propext (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)) false
                                 (@iff_false_intro (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)) hqz)))
                           qdf))))))
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
          (@roption.get.{0} nat
             (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                d)
             (@iff.mpr
                (@multiplicity.finite.{0} int int.comm_semiring
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   d)
                (and
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int d (@has_zero.zero.{0} int int.has_zero)))
                (@multiplicity.finite_int_iff
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   d)
                (@and.intro
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int d (@has_zero.zero.{0} int int.has_zero))
                   (@ne.symm.{1} nat (@has_one.one.{0} nat nat.has_one)
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@ne_of_lt.{0} nat
                         (@partial_order.to_preorder.{0} nat
                            (@ordered_comm_monoid.to_partial_order.{0} nat
                               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
                         (@has_one.one.{0} nat nat.has_one)
                         (int.nat_abs
                            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                         (@nat.prime.one_lt p p_prime)))
                   (λ (hd : @eq.{1} int d (@has_zero.zero.{0} int int.has_zero)),
                      false.rec.{0} false
                        (@eq.mp.{0} (@eq.{1} rat q (rat.mk n d)) false
                           (@eq.trans.{1} Prop (@eq.{1} rat q (rat.mk n d))
                              (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero))
                              false
                              ((λ (a a_1 : rat) (e_1 : @eq.{1} rat a a_1) (a_2 a_3 : rat) (e_2 : @eq.{1} rat a_2 a_3),
                                  @congr.{1 1} rat Prop (@eq.{1} rat a) (@eq.{1} rat a_1) a_2 a_3
                                    (@congr_arg.{1 1} rat (rat → Prop) a a_1 (@eq.{1} rat) e_1)
                                    e_2)
                                 q
                                 q
                                 (@eq.refl.{1} rat q)
                                 (rat.mk n d)
                                 (@has_zero.zero.{0} rat rat.has_zero)
                                 (@eq.trans.{1} rat (rat.mk n d) (rat.mk n (@has_zero.zero.{0} int int.has_zero))
                                    (@has_zero.zero.{0} rat rat.has_zero)
                                    ((λ (a a_1 : int) (e_1 : @eq.{1} int a a_1) (a_2 a_3 : int)
                                      (e_2 : @eq.{1} int a_2 a_3),
                                        @congr.{1 1} int rat (rat.mk a) (rat.mk a_1) a_2 a_3
                                          (@congr_arg.{1 1} int (int → rat) a a_1 rat.mk e_1)
                                          e_2)
                                       n
                                       n
                                       (@eq.refl.{1} int n)
                                       d
                                       (@has_zero.zero.{0} int int.has_zero)
                                       hd)
                                    (rat.mk_zero n)))
                              (@propext (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)) false
                                 (@iff_false_intro (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)) hqz)))
                           qdf)))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>144  /--</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>145  A rewrite lemma for `padic_val_rat p (q * r)` with conditions `q ≠ 0`, `r ≠ 0`.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>146  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>147  protected lemma mul {q r : ℚ} (hq : q ≠ 0) (hr : r ≠ 0) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='blue'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='q'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ne'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='r'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ne'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/rat/basic.lean&#x27;, &#x27;line&#x27;: 46, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 97, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 97, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='orange'><a title='`rat`, or `ℚ`, is the type of rational numbers. It is defined
 as the set of pairs ⟨n, d⟩ of integers such that `d` is positive and `n` and
 `d` are coprime. This representation is preferred to the quotient
 because without periodic reduction, the numerator and denominator can grow
 exponentially (for example, adding 1/2 to itself repeatedly).'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>148    padic_val_rat p (q * r) = padic_val_rat p q + padic_val_rat p r :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='padic_val_rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='q'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mul.mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='r'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='padic_val_rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='q'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='padic_val_rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='r'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 62, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 312, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 62, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 62, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='nat → rat → int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_mul.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat → rat → int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_add.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat → rat → int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='For `p ≠ 1`, the p-adic valuation of an integer `z ≠ 0` is the largest natural number `n` such that
p^n divides z.

`padic_val_rat` defines the valuation of a rational `q` to be the valuation of `q.num` minus the
valuation of `q.denom`.
If `q = 0` or `p = 1`, then `padic_val_rat p q` defaults to 0.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='For `p ≠ 1`, the p-adic valuation of an integer `z ≠ 0` is the largest natural number `n` such that
p^n divides z.

`padic_val_rat` defines the valuation of a rational `q` to be the valuation of `q.num` minus the
valuation of `q.denom`.
If `q = 0` or `p = 1`, then `padic_val_rat p q` defaults to 0.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='For `p ≠ 1`, the p-adic valuation of an integer `z ≠ 0` is the largest natural number `n` such that
p^n divides z.

`padic_val_rat` defines the valuation of a rational `q` to be the valuation of `q.num` minus the
valuation of `q.denom`.
If `q = 0` or `p = 1`, then `padic_val_rat p q` defaults to 0.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>149  have q*r = (q.num * r.num) /. (↑q.denom * ↑r.denom), by rw_mod_cast rat.mul_num_denom,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='q'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_mul.mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='r'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='q'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='rat.num'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mul.mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='r'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='rat.num'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='rat.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='coe'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='q'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='rat.denom'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mul.mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='coe'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='r'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='rat.denom'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='blue'><a title='rat.mul_num_denom'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 312, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/rat/basic.lean&#x27;, &#x27;line&#x27;: 46, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 312, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/rat/basic.lean&#x27;, &#x27;line&#x27;: 46, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/rat/basic.lean&#x27;, &#x27;line&#x27;: 96, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/coe.lean&#x27;, &#x27;line&#x27;: 67, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/rat/basic.lean&#x27;, &#x27;line&#x27;: 46, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 312, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/coe.lean&#x27;, &#x27;line&#x27;: 67, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/rat/basic.lean&#x27;, &#x27;line&#x27;: 46, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/norm_cast.lean&#x27;, &#x27;line&#x27;: 317, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/rat/basic.lean&#x27;, &#x27;line&#x27;: 509, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type} [c : has_mul.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='rat → int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_mul.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='rat → int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='int → int → rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {a b : Type} [_inst_1 : has_lift_t.{1 1} a b], a → b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='rat → nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_mul.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {a b : Type} [_inst_1 : has_lift_t.{1 1} a b], a → b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='rat → nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (q r : rat), @eq.{1} rat (@has_mul.mul.{0} rat rat.has_mul q r) (rat.mk (@has_mul.mul.{0} int int.has_mul (q.num) (r.num)) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (@has_mul.mul.{0} nat nat.has_mul (q.denom) (r.denom))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='orange'><a title='Form the quotient `n / d` where `n d : ℤ`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='orange'><a title='Rewrite with the given rule and normalize casts between steps.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                        </code><font color='teal'><a title='rw_mod_cast'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                       </code><font color='lime'><a title='p : nat,
p_prime : nat.prime p,
q r : rat,
hq : @ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero),
hr : @ne.{1} rat r (@has_zero.zero.{0} rat rat.has_zero)
⊢ @eq.{1} rat (@has_mul.mul.{0} rat rat.has_mul q r)
    (rat.mk (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
       (@has_mul.mul.{0} int int.has_mul
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>150  have hq&#x27; : q.num /. q.denom ≠ 0, by rw rat.num_denom; exact hq,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='q'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='rat.num'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='rat.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='q'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='rat.denom'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ne'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='rat.num_denom'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='hq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/rat/basic.lean&#x27;, &#x27;line&#x27;: 46, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/rat/basic.lean&#x27;, &#x27;line&#x27;: 96, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/rat/basic.lean&#x27;, &#x27;line&#x27;: 46, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 97, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/rat/basic.lean&#x27;, &#x27;line&#x27;: 216, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='rat → int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='int → int → rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='rat → nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a : rat}, @eq.{1} rat (rat.mk (a.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (a.denom))) a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='Form the quotient `n / d` where `n d : ℤ`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='lime'><a title='p : nat,
p_prime : nat.prime p,
q r : rat,
hq : @ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero),
hr : @ne.{1} rat r (@has_zero.zero.{0} rat rat.has_zero),
this :
  @eq.{1} rat (@has_mul.mul.{0} rat rat.has_mul q r)
    (rat.mk (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
       (@has_mul.mul.{0} int int.has_mul
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom))))
⊢ @ne.{1} rat
    (rat.mk (q.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))
    (@has_zero.zero.{0} rat rat.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>151  have hr&#x27; : r.num /. r.denom ≠ 0, by rw rat.num_denom; exact hr,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='r'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='rat.num'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='rat.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='r'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='rat.denom'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ne'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='rat.num_denom'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='hr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/rat/basic.lean&#x27;, &#x27;line&#x27;: 46, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/rat/basic.lean&#x27;, &#x27;line&#x27;: 96, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/rat/basic.lean&#x27;, &#x27;line&#x27;: 46, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 97, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/rat/basic.lean&#x27;, &#x27;line&#x27;: 216, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='rat → int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='int → int → rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='rat → nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a : rat}, @eq.{1} rat (rat.mk (a.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (a.denom))) a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@ne.{1} rat r (@has_zero.zero.{0} rat rat.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='Form the quotient `n / d` where `n d : ℤ`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='lime'><a title='p : nat,
p_prime : nat.prime p,
q r : rat,
hq : @ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero),
hr : @ne.{1} rat r (@has_zero.zero.{0} rat rat.has_zero),
this :
  @eq.{1} rat (@has_mul.mul.{0} rat rat.has_mul q r)
    (rat.mk (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
       (@has_mul.mul.{0} int int.has_mul
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))),
hq&#x27; :
  @ne.{1} rat
    (rat.mk (q.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))
    (@has_zero.zero.{0} rat rat.has_zero)
⊢ @ne.{1} rat
    (rat.mk (r.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
    (@has_zero.zero.{0} rat rat.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>152  have hp&#x27; : _root_.prime (p : ℤ), from nat.prime_iff_prime_int.1 p_prime,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='prime'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='nat.prime_iff_prime_int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='iff.mp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='p_prime'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/associated.lean&#x27;, &#x27;line&#x27;: 125, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/int/basic.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/gcd_domain.lean&#x27;, &#x27;line&#x27;: 579, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Π {α : Type} [_inst_1 : comm_semiring.{0} α], α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='∀ {p : nat}, iff (nat.prime p) (@prime.{0} int int.comm_semiring (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, iff a b → a → b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='nat.prime p'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='prime element of a semiring'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>153  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
p_prime : nat.prime p,
q r : rat,
hq : @ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero),
hr : @ne.{1} rat r (@has_zero.zero.{0} rat rat.has_zero),
this :
  @eq.{1} rat (@has_mul.mul.{0} rat rat.has_mul q r)
    (rat.mk (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
       (@has_mul.mul.{0} int int.has_mul
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))),
hq&#x27; :
  @ne.{1} rat
    (rat.mk (q.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))
    (@has_zero.zero.{0} rat rat.has_zero),
hr&#x27; :
  @ne.{1} rat
    (rat.mk (r.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
    (@has_zero.zero.{0} rat rat.has_zero),
hp&#x27; :
  @prime.{0} int int.comm_semiring
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
⊢ @eq.{1} int (padic_val_rat p (@has_mul.mul.{0} rat rat.has_mul q r))
    (@has_add.add.{0} int int.has_add (padic_val_rat p q) (padic_val_rat p r))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>154    rw [padic_val_rat.defn p (mul_ne_zero hq hr) this],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='padic_val_rat.defn'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='mul_ne_zero'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 132, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/ring.lean&#x27;, &#x27;line&#x27;: 287, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (p : nat) [p_prime : nat.prime p] {q : rat} {n d : int} (hqz : @ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)) (qdf : @eq.{1} rat q (rat.mk n d)), @eq.{1} int (padic_val_rat p q) (@has_sub.sub.{0} int int.has_sub (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (@roption.get.{0} nat (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p) n) (@iff.mpr (@multiplicity.finite.{0} int int.comm_semiring (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p) n) (and (@ne.{1} nat (int.nat_abs (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)) (@has_one.one.{0} nat nat.has_one)) (@ne.{1} int n (@has_zero.zero.{0} int int.has_zero))) (@multiplicity.finite_int_iff (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p) n) (@and.intro (@ne.{1} nat (int.nat_abs (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)) (@has_one.one.{0} nat nat.has_one)) (@ne.{1} int n (@has_zero.zero.{0} int int.has_zero)) (@ne.symm.{1} nat (@has_one.one.{0} nat nat.has_one) (int.nat_abs (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)) (@ne_of_lt.{0} nat (@partial_order.to_preorder.{0} nat (@ordered_comm_monoid.to_partial_order.{0} nat (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))) (@has_one.one.{0} nat nat.has_one) (int.nat_abs (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)) (@nat.prime.one_lt p p_prime))) (λ (hn : @eq.{1} int n (@has_zero.zero.{0} int int.has_zero)), false.rec.{0} false (@eq.mp.{0} (@eq.{1} rat q (rat.mk n d)) false (@eq.trans.{1} Prop (@eq.{1} rat q (rat.mk n d)) (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)) false ((λ (a a_1 : rat) (e_1 : @eq.{1} rat a a_1) (a_2 a_3 : rat) (e_2 : @eq.{1} rat a_2 a_3), @congr.{1 1} rat Prop (@eq.{1} rat a) (@eq.{1} rat a_1) a_2 a_3 (@congr_arg.{1 1} rat (rat → Prop) a a_1 (@eq.{1} rat) e_1) e_2) q q (@eq.refl.{1} rat q) (rat.mk n d) (@has_zero.zero.{0} rat rat.has_zero) (@eq.trans.{1} rat (rat.mk n d) (rat.mk (@has_zero.zero.{0} int int.has_zero) d) (@has_zero.zero.{0} rat rat.has_zero) ((λ (a a_1 : int) (e_1 : @eq.{1} int a a_1) (a_2 a_3 : int) (e_2 : @eq.{1} int a_2 a_3), @congr.{1 1} int rat (rat.mk a) (rat.mk a_1) a_2 a_3 (@congr_arg.{1 1} int (int → rat) a a_1 rat.mk e_1) e_2) n (@has_zero.zero.{0} int int.has_zero) hn d d (@eq.refl.{1} int d)) (rat.zero_mk d))) (@propext (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)) false (@iff_false_intro (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)) hqz))) qdf)))))) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (@roption.get.{0} nat (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p) d) (@iff.mpr (@multiplicity.finite.{0} int int.comm_semiring (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p) d) (and (@ne.{1} nat (int.nat_abs (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)) (@has_one.one.{0} nat nat.has_one)) (@ne.{1} int d (@has_zero.zero.{0} int int.has_zero))) (@multiplicity.finite_int_iff (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p) d) (@and.intro (@ne.{1} nat (int.nat_abs (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)) (@has_one.one.{0} nat nat.has_one)) (@ne.{1} int d (@has_zero.zero.{0} int int.has_zero)) (@ne.symm.{1} nat (@has_one.one.{0} nat nat.has_one) (int.nat_abs (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)) (@ne_of_lt.{0} nat (@partial_order.to_preorder.{0} nat (@ordered_comm_monoid.to_partial_order.{0} nat (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))) (@has_one.one.{0} nat nat.has_one) (int.nat_abs (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)) (@nat.prime.one_lt p p_prime))) (λ (hd : @eq.{1} int d (@has_zero.zero.{0} int int.has_zero)), false.rec.{0} false (@eq.mp.{0} (@eq.{1} rat q (rat.mk n d)) false (@eq.trans.{1} Prop (@eq.{1} rat q (rat.mk n d)) (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)) false ((λ (a a_1 : rat) (e_1 : @eq.{1} rat a a_1) (a_2 a_3 : rat) (e_2 : @eq.{1} rat a_2 a_3), @congr.{1 1} rat Prop (@eq.{1} rat a) (@eq.{1} rat a_1) a_2 a_3 (@congr_arg.{1 1} rat (rat → Prop) a a_1 (@eq.{1} rat) e_1) e_2) q q (@eq.refl.{1} rat q) (rat.mk n d) (@has_zero.zero.{0} rat rat.has_zero) (@eq.trans.{1} rat (rat.mk n d) (rat.mk n (@has_zero.zero.{0} int int.has_zero)) (@has_zero.zero.{0} rat rat.has_zero) ((λ (a a_1 : int) (e_1 : @eq.{1} int a a_1) (a_2 a_3 : int) (e_2 : @eq.{1} int a_2 a_3), @congr.{1 1} int rat (rat.mk a) (rat.mk a_1) a_2 a_3 (@congr_arg.{1 1} int (int → rat) a a_1 rat.mk e_1) e_2) n n (@eq.refl.{1} int n) d (@has_zero.zero.{0} int int.has_zero) hd) (rat.mk_zero n))) (@propext (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)) false (@iff_false_intro (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)) hqz))) qdf)))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type} [_inst_1 : integral_domain.{0} α] {a b : α}, @ne.{1} α a (@has_zero.zero.{0} α (@no_zero_divisors.to_has_zero.{0} α (@integral_domain.to_no_zero_divisors.{0} α _inst_1))) → @ne.{1} α b (@has_zero.zero.{0} α (@no_zero_divisors.to_has_zero.{0} α (@integral_domain.to_no_zero_divisors.{0} α _inst_1))) → @ne.{1} α (@has_mul.mul.{0} α (@no_zero_divisors.to_has_mul.{0} α (@integral_domain.to_no_zero_divisors.{0} α _inst_1)) a b) (@has_zero.zero.{0} α (@no_zero_divisors.to_has_zero.{0} α (@integral_domain.to_no_zero_divisors.{0} α _inst_1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@ne.{1} rat r (@has_zero.zero.{0} rat rat.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{1} rat (@has_mul.mul.{0} rat rat.has_mul q r) (rat.mk (@has_mul.mul.{0} int int.has_mul (q.num) (r.num)) (@has_mul.mul.{0} int int.has_mul (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='A rewrite lemma for `padic_val_rat p q` when `q` is expressed in terms of `rat.mk`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
p_prime : nat.prime p,
q r : rat,
hq : @ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero),
hr : @ne.{1} rat r (@has_zero.zero.{0} rat rat.has_zero),
this :
  @eq.{1} rat (@has_mul.mul.{0} rat rat.has_mul q r)
    (rat.mk (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
       (@has_mul.mul.{0} int int.has_mul
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))),
hq&#x27; :
  @ne.{1} rat
    (rat.mk (q.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))
    (@has_zero.zero.{0} rat rat.has_zero),
hr&#x27; :
  @ne.{1} rat
    (rat.mk (r.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
    (@has_zero.zero.{0} rat rat.has_zero),
hp&#x27; :
  @prime.{0} int int.comm_semiring
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
⊢ @eq.{1} int (padic_val_rat p (@has_mul.mul.{0} rat rat.has_mul q r))
    (@has_add.add.{0} int int.has_add (padic_val_rat p q) (padic_val_rat p r))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
p_prime : nat.prime p,
q r : rat,
hq : @ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero),
hr : @ne.{1} rat r (@has_zero.zero.{0} rat rat.has_zero),
this :
  @eq.{1} rat (@has_mul.mul.{0} rat rat.has_mul q r)
    (rat.mk (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
       (@has_mul.mul.{0} int int.has_mul
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))),
hq&#x27; :
  @ne.{1} rat
    (rat.mk (q.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))
    (@has_zero.zero.{0} rat rat.has_zero),
hr&#x27; :
  @ne.{1} rat
    (rat.mk (r.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
    (@has_zero.zero.{0} rat rat.has_zero),
hp&#x27; :
  @prime.{0} int int.comm_semiring
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
⊢ @eq.{1} int
    (@has_sub.sub.{0} int int.has_sub
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
          (@roption.get.{0} nat
             (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                (@has_mul.mul.{0} int int.has_mul (q.num) (r.num)))
             (@iff.mpr
                (@multiplicity.finite.{0} int int.comm_semiring
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   (@has_mul.mul.{0} int int.has_mul (q.num) (r.num)))
                (and
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
                      (@has_zero.zero.{0} int int.has_zero)))
                (@multiplicity.finite_int_iff
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   (@has_mul.mul.{0} int int.has_mul (q.num) (r.num)))
                (@and.intro
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
                      (@has_zero.zero.{0} int int.has_zero))
                   (@ne.symm.{1} nat (@has_one.one.{0} nat nat.has_one)
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@ne_of_lt.{0} nat
                         (@partial_order.to_preorder.{0} nat
                            (@ordered_comm_monoid.to_partial_order.{0} nat
                               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
                         (@has_one.one.{0} nat nat.has_one)
                         (int.nat_abs
                            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                         (@nat.prime.one_lt p p_prime)))
                   (λ
                    (hn :
                      @eq.{1} int (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
                        (@has_zero.zero.{0} int int.has_zero)),
                      false.rec.{0} false
                        (@eq.mp.{0}
                           (@eq.{1} rat
                              (@has_mul.mul.{0} rat
                                 (@no_zero_divisors.to_has_mul.{0} rat
                                    (@integral_domain.to_no_zero_divisors.{0} rat rat.integral_domain))
                                 q
                                 r)
                              (rat.mk (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
                                 (@has_mul.mul.{0} int int.has_mul
                                    (@coe.{1 1} nat int
                                       (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                       (q.denom))
                                    (@coe.{1 1} nat int
                                       (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                       (r.denom)))))
                           false
                           (@eq.trans.{1} Prop
                              (@eq.{1} rat
                                 (@has_mul.mul.{0} rat
                                    (@no_zero_divisors.to_has_mul.{0} rat
                                       (@integral_domain.to_no_zero_divisors.{0} rat rat.integral_domain))
                                    q
                                    r)
                                 (rat.mk (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
                                    (@has_mul.mul.{0} int int.has_mul
                                       (@coe.{1 1} nat int
                                          (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                          (q.denom))
                                       (@coe.{1 1} nat int
                                          (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                          (r.denom)))))
                              (@eq.{1} rat
                                 (@has_mul.mul.{0} rat
                                    (@no_zero_divisors.to_has_mul.{0} rat
                                       (@integral_domain.to_no_zero_divisors.{0} rat rat.integral_domain))
                                    q
                                    r)
                                 (@has_zero.zero.{0} rat rat.has_zero))
                              false
                              ((λ (a a_1 : rat) (e_1 : @eq.{1} rat a a_1) (a_2 a_3 : rat) (e_2 : @eq.{1} rat a_2 a_3),
                                  @congr.{1 1} rat Prop (@eq.{1} rat a) (@eq.{1} rat a_1) a_2 a_3
                                    (@congr_arg.{1 1} rat (rat → Prop) a a_1 (@eq.{1} rat) e_1)
                                    e_2)
                                 (@has_mul.mul.{0} rat
                                    (@no_zero_divisors.to_has_mul.{0} rat
                                       (@integral_domain.to_no_zero_divisors.{0} rat rat.integral_domain))
                                    q
                                    r)
                                 (@has_mul.mul.{0} rat
                                    (@no_zero_divisors.to_has_mul.{0} rat
                                       (@integral_domain.to_no_zero_divisors.{0} rat rat.integral_domain))
                                    q
                                    r)
                                 (@eq.refl.{1} rat
                                    (@has_mul.mul.{0} rat
                                       (@no_zero_divisors.to_has_mul.{0} rat
                                          (@integral_domain.to_no_zero_divisors.{0} rat rat.integral_domain))
                                       q
                                       r))
                                 (rat.mk (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
                                    (@has_mul.mul.{0} int int.has_mul
                                       (@coe.{1 1} nat int
                                          (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                          (q.denom))
                                       (@coe.{1 1} nat int
                                          (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                          (r.denom))))
                                 (@has_zero.zero.{0} rat rat.has_zero)
                                 (@eq.trans.{1} rat
                                    (rat.mk (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
                                       (@has_mul.mul.{0} int int.has_mul
                                          (@coe.{1 1} nat int
                                             (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                             (q.denom))
                                          (@coe.{1 1} nat int
                                             (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                             (r.denom))))
                                    (rat.mk (@has_zero.zero.{0} int int.has_zero)
                                       (@has_mul.mul.{0} int int.has_mul
                                          (@coe.{1 1} nat int
                                             (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                             (q.denom))
                                          (@coe.{1 1} nat int
                                             (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                             (r.denom))))
                                    (@has_zero.zero.{0} rat rat.has_zero)
                                    ((λ (a a_1 : int) (e_1 : @eq.{1} int a a_1) (a_2 a_3 : int)
                                      (e_2 : @eq.{1} int a_2 a_3),
                                        @congr.{1 1} int rat (rat.mk a) (rat.mk a_1) a_2 a_3
                                          (@congr_arg.{1 1} int (int → rat) a a_1 rat.mk e_1)
                                          e_2)
                                       (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
                                       (@has_zero.zero.{0} int int.has_zero)
                                       hn
                                       (@has_mul.mul.{0} int int.has_mul
                                          (@coe.{1 1} nat int
                                             (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                             (q.denom))
                                          (@coe.{1 1} nat int
                                             (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                             (r.denom)))
                                       (@has_mul.mul.{0} int int.has_mul
                                          (@coe.{1 1} nat int
                                             (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                             (q.denom))
                                          (@coe.{1 1} nat int
                                             (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                             (r.denom)))
                                       (@eq.refl.{1} int
                                          (@has_mul.mul.{0} int int.has_mul
                                             (@coe.{1 1} nat int
                                                (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                                (q.denom))
                                             (@coe.{1 1} nat int
                                                (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                                (r.denom)))))
                                    (rat.zero_mk
                                       (@has_mul.mul.{0} int int.has_mul
                                          (@coe.{1 1} nat int
                                             (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                             (q.denom))
                                          (@coe.{1 1} nat int
                                             (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                             (r.denom))))))
                              (@propext
                                 (@eq.{1} rat
                                    (@has_mul.mul.{0} rat
                                       (@no_zero_divisors.to_has_mul.{0} rat
                                          (@integral_domain.to_no_zero_divisors.{0} rat rat.integral_domain))
                                       q
                                       r)
                                    (@has_zero.zero.{0} rat rat.has_zero))
                                 false
                                 (@iff_false_intro
                                    (@eq.{1} rat
                                       (@has_mul.mul.{0} rat
                                          (@no_zero_divisors.to_has_mul.{0} rat
                                             (@integral_domain.to_no_zero_divisors.{0} rat rat.integral_domain))
                                          q
                                          r)
                                       (@has_zero.zero.{0} rat rat.has_zero))
                                    (@mul_ne_zero.{0} rat rat.integral_domain q r hq hr))))
                           this))))))
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
          (@roption.get.{0} nat
             (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                (@has_mul.mul.{0} int int.has_mul
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom))))
             (@iff.mpr
                (@multiplicity.finite.{0} int int.comm_semiring
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   (@has_mul.mul.{0} int int.has_mul
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                         (r.denom))))
                (and
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int
                      (@has_mul.mul.{0} int int.has_mul
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                            (q.denom))
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                            (r.denom)))
                      (@has_zero.zero.{0} int int.has_zero)))
                (@multiplicity.finite_int_iff
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   (@has_mul.mul.{0} int int.has_mul
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                         (r.denom))))
                (@and.intro
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int
                      (@has_mul.mul.{0} int int.has_mul
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                            (q.denom))
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                            (r.denom)))
                      (@has_zero.zero.{0} int int.has_zero))
                   (@ne.symm.{1} nat (@has_one.one.{0} nat nat.has_one)
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@ne_of_lt.{0} nat
                         (@partial_order.to_preorder.{0} nat
                            (@ordered_comm_monoid.to_partial_order.{0} nat
                               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
                         (@has_one.one.{0} nat nat.has_one)
                         (int.nat_abs
                            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                         (@nat.prime.one_lt p p_prime)))
                   (λ
                    (hd :
                      @eq.{1} int
                        (@has_mul.mul.{0} int int.has_mul
                           (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                              (q.denom))
                           (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                              (r.denom)))
                        (@has_zero.zero.{0} int int.has_zero)),
                      false.rec.{0} false
                        (@eq.mp.{0}
                           (@eq.{1} rat
                              (@has_mul.mul.{0} rat
                                 (@no_zero_divisors.to_has_mul.{0} rat
                                    (@integral_domain.to_no_zero_divisors.{0} rat rat.integral_domain))
                                 q
                                 r)
                              (rat.mk (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
                                 (@has_mul.mul.{0} int int.has_mul
                                    (@coe.{1 1} nat int
                                       (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                       (q.denom))
                                    (@coe.{1 1} nat int
                                       (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                       (r.denom)))))
                           false
                           (@eq.trans.{1} Prop
                              (@eq.{1} rat
                                 (@has_mul.mul.{0} rat
                                    (@no_zero_divisors.to_has_mul.{0} rat
                                       (@integral_domain.to_no_zero_divisors.{0} rat rat.integral_domain))
                                    q
                                    r)
                                 (rat.mk (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
                                    (@has_mul.mul.{0} int int.has_mul
                                       (@coe.{1 1} nat int
                                          (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                          (q.denom))
                                       (@coe.{1 1} nat int
                                          (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                          (r.denom)))))
                              (@eq.{1} rat
                                 (@has_mul.mul.{0} rat
                                    (@no_zero_divisors.to_has_mul.{0} rat
                                       (@integral_domain.to_no_zero_divisors.{0} rat rat.integral_domain))
                                    q
                                    r)
                                 (@has_zero.zero.{0} rat rat.has_zero))
                              false
                              ((λ (a a_1 : rat) (e_1 : @eq.{1} rat a a_1) (a_2 a_3 : rat) (e_2 : @eq.{1} rat a_2 a_3),
                                  @congr.{1 1} rat Prop (@eq.{1} rat a) (@eq.{1} rat a_1) a_2 a_3
                                    (@congr_arg.{1 1} rat (rat → Prop) a a_1 (@eq.{1} rat) e_1)
                                    e_2)
                                 (@has_mul.mul.{0} rat
                                    (@no_zero_divisors.to_has_mul.{0} rat
                                       (@integral_domain.to_no_zero_divisors.{0} rat rat.integral_domain))
                                    q
                                    r)
                                 (@has_mul.mul.{0} rat
                                    (@no_zero_divisors.to_has_mul.{0} rat
                                       (@integral_domain.to_no_zero_divisors.{0} rat rat.integral_domain))
                                    q
                                    r)
                                 (@eq.refl.{1} rat
                                    (@has_mul.mul.{0} rat
                                       (@no_zero_divisors.to_has_mul.{0} rat
                                          (@integral_domain.to_no_zero_divisors.{0} rat rat.integral_domain))
                                       q
                                       r))
                                 (rat.mk (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
                                    (@has_mul.mul.{0} int int.has_mul
                                       (@coe.{1 1} nat int
                                          (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                          (q.denom))
                                       (@coe.{1 1} nat int
                                          (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                          (r.denom))))
                                 (@has_zero.zero.{0} rat rat.has_zero)
                                 (@eq.trans.{1} rat
                                    (rat.mk (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
                                       (@has_mul.mul.{0} int int.has_mul
                                          (@coe.{1 1} nat int
                                             (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                             (q.denom))
                                          (@coe.{1 1} nat int
                                             (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                             (r.denom))))
                                    (rat.mk (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
                                       (@has_zero.zero.{0} int int.has_zero))
                                    (@has_zero.zero.{0} rat rat.has_zero)
                                    ((λ (a a_1 : int) (e_1 : @eq.{1} int a a_1) (a_2 a_3 : int)
                                      (e_2 : @eq.{1} int a_2 a_3),
                                        @congr.{1 1} int rat (rat.mk a) (rat.mk a_1) a_2 a_3
                                          (@congr_arg.{1 1} int (int → rat) a a_1 rat.mk e_1)
                                          e_2)
                                       (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
                                       (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
                                       (@eq.refl.{1} int (@has_mul.mul.{0} int int.has_mul (q.num) (r.num)))
                                       (@has_mul.mul.{0} int int.has_mul
                                          (@coe.{1 1} nat int
                                             (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                             (q.denom))
                                          (@coe.{1 1} nat int
                                             (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                             (r.denom)))
                                       (@has_zero.zero.{0} int int.has_zero)
                                       hd)
                                    (rat.mk_zero (@has_mul.mul.{0} int int.has_mul (q.num) (r.num)))))
                              (@propext
                                 (@eq.{1} rat
                                    (@has_mul.mul.{0} rat
                                       (@no_zero_divisors.to_has_mul.{0} rat
                                          (@integral_domain.to_no_zero_divisors.{0} rat rat.integral_domain))
                                       q
                                       r)
                                    (@has_zero.zero.{0} rat rat.has_zero))
                                 false
                                 (@iff_false_intro
                                    (@eq.{1} rat
                                       (@has_mul.mul.{0} rat
                                          (@no_zero_divisors.to_has_mul.{0} rat
                                             (@integral_domain.to_no_zero_divisors.{0} rat rat.integral_domain))
                                          q
                                          r)
                                       (@has_zero.zero.{0} rat rat.has_zero))
                                    (@mul_ne_zero.{0} rat rat.integral_domain q r hq hr))))
                           this)))))))
    (@has_add.add.{0} int int.has_add (padic_val_rat p q) (padic_val_rat p r))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>155    conv_rhs { rw [←(@rat.num_denom q), padic_val_rat.defn p hq&#x27;,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='blue'><a title='rat.num_denom'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='q'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='padic_val_rat.defn'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hq&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/converter/interactive.lean&#x27;, &#x27;line&#x27;: 128, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/rat/basic.lean&#x27;, &#x27;line&#x27;: 216, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 132, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit name (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.ident)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) (lean.parser.pexpr std.prec.max))) → conv.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {a : rat}, @eq.{1} rat (rat.mk (a.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (a.denom))) a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (p : nat) [p_prime : nat.prime p] {q : rat} {n d : int} (hqz : @ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)) (qdf : @eq.{1} rat q (rat.mk n d)), @eq.{1} int (padic_val_rat p q) (@has_sub.sub.{0} int int.has_sub (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (@roption.get.{0} nat (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p) n) (@iff.mpr (@multiplicity.finite.{0} int int.comm_semiring (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p) n) (and (@ne.{1} nat (int.nat_abs (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)) (@has_one.one.{0} nat nat.has_one)) (@ne.{1} int n (@has_zero.zero.{0} int int.has_zero))) (@multiplicity.finite_int_iff (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p) n) (@and.intro (@ne.{1} nat (int.nat_abs (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)) (@has_one.one.{0} nat nat.has_one)) (@ne.{1} int n (@has_zero.zero.{0} int int.has_zero)) (@ne.symm.{1} nat (@has_one.one.{0} nat nat.has_one) (int.nat_abs (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)) (@ne_of_lt.{0} nat (@partial_order.to_preorder.{0} nat (@ordered_comm_monoid.to_partial_order.{0} nat (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))) (@has_one.one.{0} nat nat.has_one) (int.nat_abs (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)) (@nat.prime.one_lt p p_prime))) (λ (hn : @eq.{1} int n (@has_zero.zero.{0} int int.has_zero)), false.rec.{0} false (@eq.mp.{0} (@eq.{1} rat q (rat.mk n d)) false (@eq.trans.{1} Prop (@eq.{1} rat q (rat.mk n d)) (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)) false ((λ (a a_1 : rat) (e_1 : @eq.{1} rat a a_1) (a_2 a_3 : rat) (e_2 : @eq.{1} rat a_2 a_3), @congr.{1 1} rat Prop (@eq.{1} rat a) (@eq.{1} rat a_1) a_2 a_3 (@congr_arg.{1 1} rat (rat → Prop) a a_1 (@eq.{1} rat) e_1) e_2) q q (@eq.refl.{1} rat q) (rat.mk n d) (@has_zero.zero.{0} rat rat.has_zero) (@eq.trans.{1} rat (rat.mk n d) (rat.mk (@has_zero.zero.{0} int int.has_zero) d) (@has_zero.zero.{0} rat rat.has_zero) ((λ (a a_1 : int) (e_1 : @eq.{1} int a a_1) (a_2 a_3 : int) (e_2 : @eq.{1} int a_2 a_3), @congr.{1 1} int rat (rat.mk a) (rat.mk a_1) a_2 a_3 (@congr_arg.{1 1} int (int → rat) a a_1 rat.mk e_1) e_2) n (@has_zero.zero.{0} int int.has_zero) hn d d (@eq.refl.{1} int d)) (rat.zero_mk d))) (@propext (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)) false (@iff_false_intro (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)) hqz))) qdf)))))) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (@roption.get.{0} nat (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p) d) (@iff.mpr (@multiplicity.finite.{0} int int.comm_semiring (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p) d) (and (@ne.{1} nat (int.nat_abs (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)) (@has_one.one.{0} nat nat.has_one)) (@ne.{1} int d (@has_zero.zero.{0} int int.has_zero))) (@multiplicity.finite_int_iff (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p) d) (@and.intro (@ne.{1} nat (int.nat_abs (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)) (@has_one.one.{0} nat nat.has_one)) (@ne.{1} int d (@has_zero.zero.{0} int int.has_zero)) (@ne.symm.{1} nat (@has_one.one.{0} nat nat.has_one) (int.nat_abs (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)) (@ne_of_lt.{0} nat (@partial_order.to_preorder.{0} nat (@ordered_comm_monoid.to_partial_order.{0} nat (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))) (@has_one.one.{0} nat nat.has_one) (int.nat_abs (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)) (@nat.prime.one_lt p p_prime))) (λ (hd : @eq.{1} int d (@has_zero.zero.{0} int int.has_zero)), false.rec.{0} false (@eq.mp.{0} (@eq.{1} rat q (rat.mk n d)) false (@eq.trans.{1} Prop (@eq.{1} rat q (rat.mk n d)) (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)) false ((λ (a a_1 : rat) (e_1 : @eq.{1} rat a a_1) (a_2 a_3 : rat) (e_2 : @eq.{1} rat a_2 a_3), @congr.{1 1} rat Prop (@eq.{1} rat a) (@eq.{1} rat a_1) a_2 a_3 (@congr_arg.{1 1} rat (rat → Prop) a a_1 (@eq.{1} rat) e_1) e_2) q q (@eq.refl.{1} rat q) (rat.mk n d) (@has_zero.zero.{0} rat rat.has_zero) (@eq.trans.{1} rat (rat.mk n d) (rat.mk n (@has_zero.zero.{0} int int.has_zero)) (@has_zero.zero.{0} rat rat.has_zero) ((λ (a a_1 : int) (e_1 : @eq.{1} int a a_1) (a_2 a_3 : int) (e_2 : @eq.{1} int a_2 a_3), @congr.{1 1} int rat (rat.mk a) (rat.mk a_1) a_2 a_3 (@congr_arg.{1 1} int (int → rat) a a_1 rat.mk e_1) e_2) n n (@eq.refl.{1} int n) d (@has_zero.zero.{0} int int.has_zero) hd) (rat.mk_zero n))) (@propext (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)) false (@iff_false_intro (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)) hqz))) qdf)))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@ne.{1} rat (rat.mk (q.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))) (@has_zero.zero.{0} rat rat.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='orange'><a title='A rewrite lemma for `padic_val_rat p q` when `q` is expressed in terms of `rat.mk`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='conv_rhs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(at id)?&#x27;, &#x27;(in expr)?&#x27;, &#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
p_prime : nat.prime p,
q r : rat,
hq : @ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero),
hr : @ne.{1} rat r (@has_zero.zero.{0} rat rat.has_zero),
this :
  @eq.{1} rat (@has_mul.mul.{0} rat rat.has_mul q r)
    (rat.mk (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
       (@has_mul.mul.{0} int int.has_mul
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))),
hq&#x27; :
  @ne.{1} rat
    (rat.mk (q.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))
    (@has_zero.zero.{0} rat rat.has_zero),
hr&#x27; :
  @ne.{1} rat
    (rat.mk (r.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
    (@has_zero.zero.{0} rat rat.has_zero),
hp&#x27; :
  @prime.{0} int int.comm_semiring
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
⊢ @eq.{1} int
    (@has_sub.sub.{0} int int.has_sub
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
          (@roption.get.{0} nat
             (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                (@has_mul.mul.{0} int int.has_mul (q.num) (r.num)))
             (@iff.mpr
                (@multiplicity.finite.{0} int int.comm_semiring
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   (@has_mul.mul.{0} int int.has_mul (q.num) (r.num)))
                (and
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
                      (@has_zero.zero.{0} int int.has_zero)))
                (@multiplicity.finite_int_iff
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   (@has_mul.mul.{0} int int.has_mul (q.num) (r.num)))
                (@and.intro
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
                      (@has_zero.zero.{0} int int.has_zero))
                   (@ne.symm.{1} nat (@has_one.one.{0} nat nat.has_one)
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@ne_of_lt.{0} nat
                         (@partial_order.to_preorder.{0} nat
                            (@ordered_comm_monoid.to_partial_order.{0} nat
                               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
                         (@has_one.one.{0} nat nat.has_one)
                         (int.nat_abs
                            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                         (@nat.prime.one_lt p p_prime)))
                   (λ
                    (hn :
                      @eq.{1} int (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
                        (@has_zero.zero.{0} int int.has_zero)),
                      false.rec.{0} false
                        (@eq.mp.{0}
                           (@eq.{1} rat
                              (@has_mul.mul.{0} rat
                                 (@no_zero_divisors.to_has_mul.{0} rat
                                    (@integral_domain.to_no_zero_divisors.{0} rat rat.integral_domain))
                                 q
                                 r)
                              (rat.mk (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
                                 (@has_mul.mul.{0} int int.has_mul
                                    (@coe.{1 1} nat int
                                       (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                       (q.denom))
                                    (@coe.{1 1} nat int
                                       (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                       (r.denom)))))
                           false
                           (@eq.trans.{1} Prop
                              (@eq.{1} rat
                                 (@has_mul.mul.{0} rat
                                    (@no_zero_divisors.to_has_mul.{0} rat
                                       (@integral_domain.to_no_zero_divisors.{0} rat rat.integral_domain))
                                    q
                                    r)
                                 (rat.mk (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
                                    (@has_mul.mul.{0} int int.has_mul
                                       (@coe.{1 1} nat int
                                          (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                          (q.denom))
                                       (@coe.{1 1} nat int
                                          (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                          (r.denom)))))
                              (@eq.{1} rat
                                 (@has_mul.mul.{0} rat
                                    (@no_zero_divisors.to_has_mul.{0} rat
                                       (@integral_domain.to_no_zero_divisors.{0} rat rat.integral_domain))
                                    q
                                    r)
                                 (@has_zero.zero.{0} rat rat.has_zero))
                              false
                              ((λ (a a_1 : rat) (e_1 : @eq.{1} rat a a_1) (a_2 a_3 : rat) (e_2 : @eq.{1} rat a_2 a_3),
                                  @congr.{1 1} rat Prop (@eq.{1} rat a) (@eq.{1} rat a_1) a_2 a_3
                                    (@congr_arg.{1 1} rat (rat → Prop) a a_1 (@eq.{1} rat) e_1)
                                    e_2)
                                 (@has_mul.mul.{0} rat
                                    (@no_zero_divisors.to_has_mul.{0} rat
                                       (@integral_domain.to_no_zero_divisors.{0} rat rat.integral_domain))
                                    q
                                    r)
                                 (@has_mul.mul.{0} rat
                                    (@no_zero_divisors.to_has_mul.{0} rat
                                       (@integral_domain.to_no_zero_divisors.{0} rat rat.integral_domain))
                                    q
                                    r)
                                 (@eq.refl.{1} rat
                                    (@has_mul.mul.{0} rat
                                       (@no_zero_divisors.to_has_mul.{0} rat
                                          (@integral_domain.to_no_zero_divisors.{0} rat rat.integral_domain))
                                       q
                                       r))
                                 (rat.mk (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
                                    (@has_mul.mul.{0} int int.has_mul
                                       (@coe.{1 1} nat int
                                          (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                          (q.denom))
                                       (@coe.{1 1} nat int
                                          (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                          (r.denom))))
                                 (@has_zero.zero.{0} rat rat.has_zero)
                                 (@eq.trans.{1} rat
                                    (rat.mk (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
                                       (@has_mul.mul.{0} int int.has_mul
                                          (@coe.{1 1} nat int
                                             (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                             (q.denom))
                                          (@coe.{1 1} nat int
                                             (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                             (r.denom))))
                                    (rat.mk (@has_zero.zero.{0} int int.has_zero)
                                       (@has_mul.mul.{0} int int.has_mul
                                          (@coe.{1 1} nat int
                                             (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                             (q.denom))
                                          (@coe.{1 1} nat int
                                             (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                             (r.denom))))
                                    (@has_zero.zero.{0} rat rat.has_zero)
                                    ((λ (a a_1 : int) (e_1 : @eq.{1} int a a_1) (a_2 a_3 : int)
                                      (e_2 : @eq.{1} int a_2 a_3),
                                        @congr.{1 1} int rat (rat.mk a) (rat.mk a_1) a_2 a_3
                                          (@congr_arg.{1 1} int (int → rat) a a_1 rat.mk e_1)
                                          e_2)
                                       (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
                                       (@has_zero.zero.{0} int int.has_zero)
                                       hn
                                       (@has_mul.mul.{0} int int.has_mul
                                          (@coe.{1 1} nat int
                                             (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                             (q.denom))
                                          (@coe.{1 1} nat int
                                             (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                             (r.denom)))
                                       (@has_mul.mul.{0} int int.has_mul
                                          (@coe.{1 1} nat int
                                             (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                             (q.denom))
                                          (@coe.{1 1} nat int
                                             (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                             (r.denom)))
                                       (@eq.refl.{1} int
                                          (@has_mul.mul.{0} int int.has_mul
                                             (@coe.{1 1} nat int
                                                (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                                (q.denom))
                                             (@coe.{1 1} nat int
                                                (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                                (r.denom)))))
                                    (rat.zero_mk
                                       (@has_mul.mul.{0} int int.has_mul
                                          (@coe.{1 1} nat int
                                             (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                             (q.denom))
                                          (@coe.{1 1} nat int
                                             (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                             (r.denom))))))
                              (@propext
                                 (@eq.{1} rat
                                    (@has_mul.mul.{0} rat
                                       (@no_zero_divisors.to_has_mul.{0} rat
                                          (@integral_domain.to_no_zero_divisors.{0} rat rat.integral_domain))
                                       q
                                       r)
                                    (@has_zero.zero.{0} rat rat.has_zero))
                                 false
                                 (@iff_false_intro
                                    (@eq.{1} rat
                                       (@has_mul.mul.{0} rat
                                          (@no_zero_divisors.to_has_mul.{0} rat
                                             (@integral_domain.to_no_zero_divisors.{0} rat rat.integral_domain))
                                          q
                                          r)
                                       (@has_zero.zero.{0} rat rat.has_zero))
                                    (@mul_ne_zero.{0} rat rat.integral_domain q r hq hr))))
                           this))))))
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
          (@roption.get.{0} nat
             (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                (@has_mul.mul.{0} int int.has_mul
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom))))
             (@iff.mpr
                (@multiplicity.finite.{0} int int.comm_semiring
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   (@has_mul.mul.{0} int int.has_mul
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                         (r.denom))))
                (and
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int
                      (@has_mul.mul.{0} int int.has_mul
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                            (q.denom))
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                            (r.denom)))
                      (@has_zero.zero.{0} int int.has_zero)))
                (@multiplicity.finite_int_iff
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   (@has_mul.mul.{0} int int.has_mul
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                         (r.denom))))
                (@and.intro
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int
                      (@has_mul.mul.{0} int int.has_mul
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                            (q.denom))
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                            (r.denom)))
                      (@has_zero.zero.{0} int int.has_zero))
                   (@ne.symm.{1} nat (@has_one.one.{0} nat nat.has_one)
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@ne_of_lt.{0} nat
                         (@partial_order.to_preorder.{0} nat
                            (@ordered_comm_monoid.to_partial_order.{0} nat
                               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
                         (@has_one.one.{0} nat nat.has_one)
                         (int.nat_abs
                            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                         (@nat.prime.one_lt p p_prime)))
                   (λ
                    (hd :
                      @eq.{1} int
                        (@has_mul.mul.{0} int int.has_mul
                           (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                              (q.denom))
                           (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                              (r.denom)))
                        (@has_zero.zero.{0} int int.has_zero)),
                      false.rec.{0} false
                        (@eq.mp.{0}
                           (@eq.{1} rat
                              (@has_mul.mul.{0} rat
                                 (@no_zero_divisors.to_has_mul.{0} rat
                                    (@integral_domain.to_no_zero_divisors.{0} rat rat.integral_domain))
                                 q
                                 r)
                              (rat.mk (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
                                 (@has_mul.mul.{0} int int.has_mul
                                    (@coe.{1 1} nat int
                                       (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                       (q.denom))
                                    (@coe.{1 1} nat int
                                       (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                       (r.denom)))))
                           false
                           (@eq.trans.{1} Prop
                              (@eq.{1} rat
                                 (@has_mul.mul.{0} rat
                                    (@no_zero_divisors.to_has_mul.{0} rat
                                       (@integral_domain.to_no_zero_divisors.{0} rat rat.integral_domain))
                                    q
                                    r)
                                 (rat.mk (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
                                    (@has_mul.mul.{0} int int.has_mul
                                       (@coe.{1 1} nat int
                                          (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                          (q.denom))
                                       (@coe.{1 1} nat int
                                          (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                          (r.denom)))))
                              (@eq.{1} rat
                                 (@has_mul.mul.{0} rat
                                    (@no_zero_divisors.to_has_mul.{0} rat
                                       (@integral_domain.to_no_zero_divisors.{0} rat rat.integral_domain))
                                    q
                                    r)
                                 (@has_zero.zero.{0} rat rat.has_zero))
                              false
                              ((λ (a a_1 : rat) (e_1 : @eq.{1} rat a a_1) (a_2 a_3 : rat) (e_2 : @eq.{1} rat a_2 a_3),
                                  @congr.{1 1} rat Prop (@eq.{1} rat a) (@eq.{1} rat a_1) a_2 a_3
                                    (@congr_arg.{1 1} rat (rat → Prop) a a_1 (@eq.{1} rat) e_1)
                                    e_2)
                                 (@has_mul.mul.{0} rat
                                    (@no_zero_divisors.to_has_mul.{0} rat
                                       (@integral_domain.to_no_zero_divisors.{0} rat rat.integral_domain))
                                    q
                                    r)
                                 (@has_mul.mul.{0} rat
                                    (@no_zero_divisors.to_has_mul.{0} rat
                                       (@integral_domain.to_no_zero_divisors.{0} rat rat.integral_domain))
                                    q
                                    r)
                                 (@eq.refl.{1} rat
                                    (@has_mul.mul.{0} rat
                                       (@no_zero_divisors.to_has_mul.{0} rat
                                          (@integral_domain.to_no_zero_divisors.{0} rat rat.integral_domain))
                                       q
                                       r))
                                 (rat.mk (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
                                    (@has_mul.mul.{0} int int.has_mul
                                       (@coe.{1 1} nat int
                                          (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                          (q.denom))
                                       (@coe.{1 1} nat int
                                          (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                          (r.denom))))
                                 (@has_zero.zero.{0} rat rat.has_zero)
                                 (@eq.trans.{1} rat
                                    (rat.mk (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
                                       (@has_mul.mul.{0} int int.has_mul
                                          (@coe.{1 1} nat int
                                             (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                             (q.denom))
                                          (@coe.{1 1} nat int
                                             (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                             (r.denom))))
                                    (rat.mk (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
                                       (@has_zero.zero.{0} int int.has_zero))
                                    (@has_zero.zero.{0} rat rat.has_zero)
                                    ((λ (a a_1 : int) (e_1 : @eq.{1} int a a_1) (a_2 a_3 : int)
                                      (e_2 : @eq.{1} int a_2 a_3),
                                        @congr.{1 1} int rat (rat.mk a) (rat.mk a_1) a_2 a_3
                                          (@congr_arg.{1 1} int (int → rat) a a_1 rat.mk e_1)
                                          e_2)
                                       (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
                                       (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
                                       (@eq.refl.{1} int (@has_mul.mul.{0} int int.has_mul (q.num) (r.num)))
                                       (@has_mul.mul.{0} int int.has_mul
                                          (@coe.{1 1} nat int
                                             (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                             (q.denom))
                                          (@coe.{1 1} nat int
                                             (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                             (r.denom)))
                                       (@has_zero.zero.{0} int int.has_zero)
                                       hd)
                                    (rat.mk_zero (@has_mul.mul.{0} int int.has_mul (q.num) (r.num)))))
                              (@propext
                                 (@eq.{1} rat
                                    (@has_mul.mul.{0} rat
                                       (@no_zero_divisors.to_has_mul.{0} rat
                                          (@integral_domain.to_no_zero_divisors.{0} rat rat.integral_domain))
                                       q
                                       r)
                                    (@has_zero.zero.{0} rat rat.has_zero))
                                 false
                                 (@iff_false_intro
                                    (@eq.{1} rat
                                       (@has_mul.mul.{0} rat
                                          (@no_zero_divisors.to_has_mul.{0} rat
                                             (@integral_domain.to_no_zero_divisors.{0} rat rat.integral_domain))
                                          q
                                          r)
                                       (@has_zero.zero.{0} rat rat.has_zero))
                                    (@mul_ne_zero.{0} rat rat.integral_domain q r hq hr))))
                           this)))))))
    (@has_add.add.{0} int int.has_add (padic_val_rat p q) (padic_val_rat p r))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
p_prime : nat.prime p,
q r : rat,
hq : @ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero),
hr : @ne.{1} rat r (@has_zero.zero.{0} rat rat.has_zero),
this :
  @eq.{1} rat (@has_mul.mul.{0} rat rat.has_mul q r)
    (rat.mk (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
       (@has_mul.mul.{0} int int.has_mul
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))),
hq&#x27; :
  @ne.{1} rat
    (rat.mk (q.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))
    (@has_zero.zero.{0} rat rat.has_zero),
hr&#x27; :
  @ne.{1} rat
    (rat.mk (r.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
    (@has_zero.zero.{0} rat rat.has_zero),
hp&#x27; :
  @prime.{0} int int.comm_semiring
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
| @has_add.add.{0} int int.has_add (padic_val_rat p q) (padic_val_rat p r)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
p_prime : nat.prime p,
q r : rat,
hq : @ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero),
hr : @ne.{1} rat r (@has_zero.zero.{0} rat rat.has_zero),
this :
  @eq.{1} rat (@has_mul.mul.{0} rat rat.has_mul q r)
    (rat.mk (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
       (@has_mul.mul.{0} int int.has_mul
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))),
hq&#x27; :
  @ne.{1} rat
    (rat.mk (q.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))
    (@has_zero.zero.{0} rat rat.has_zero),
hr&#x27; :
  @ne.{1} rat
    (rat.mk (r.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
    (@has_zero.zero.{0} rat rat.has_zero),
hp&#x27; :
  @prime.{0} int int.comm_semiring
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
| @has_add.add.{0} int int.has_add
    (padic_val_rat p
       (rat.mk (q.num)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))))
    (padic_val_rat p r)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='4 goals
p : nat,
p_prime : nat.prime p,
q r : rat,
hq : @ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero),
hr : @ne.{1} rat r (@has_zero.zero.{0} rat rat.has_zero),
this :
  @eq.{1} rat (@has_mul.mul.{0} rat rat.has_mul q r)
    (rat.mk (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
       (@has_mul.mul.{0} int int.has_mul
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))),
hq&#x27; :
  @ne.{1} rat
    (rat.mk (q.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))
    (@has_zero.zero.{0} rat rat.has_zero),
hr&#x27; :
  @ne.{1} rat
    (rat.mk (r.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
    (@has_zero.zero.{0} rat rat.has_zero),
hp&#x27; :
  @prime.{0} int int.comm_semiring
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
| @has_add.add.{0} int int.has_add
    (@has_sub.sub.{0} int int.has_sub
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
          (@roption.get.{0} nat
             (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                ?m_1)
             (@iff.mpr
                (@multiplicity.finite.{0} int int.comm_semiring
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   ?m_1)
                (and
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int ?m_1 (@has_zero.zero.{0} int int.has_zero)))
                (@multiplicity.finite_int_iff
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   ?m_1)
                (@and.intro
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int ?m_1 (@has_zero.zero.{0} int int.has_zero))
                   (@ne.symm.{1} nat (@has_one.one.{0} nat nat.has_one)
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@ne_of_lt.{0} nat
                         (@partial_order.to_preorder.{0} nat
                            (@ordered_comm_monoid.to_partial_order.{0} nat
                               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
                         (@has_one.one.{0} nat nat.has_one)
                         (int.nat_abs
                            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                         (@nat.prime.one_lt p p_prime)))
                   (λ (hn : @eq.{1} int ?m_1 (@has_zero.zero.{0} int int.has_zero)),
                      false.rec.{0} false
                        (@eq.mp.{0}
                           (@eq.{1} rat
                              (rat.mk (q.num)
                                 (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                    (q.denom)))
                              (rat.mk ?m_1 ?m_2))
                           false
                           (@eq.trans.{1} Prop
                              (@eq.{1} rat
                                 (rat.mk (q.num)
                                    (@coe.{1 1} nat int
                                       (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                       (q.denom)))
                                 (rat.mk ?m_1 ?m_2))
                              (@eq.{1} rat
                                 (rat.mk (q.num)
                                    (@coe.{1 1} nat int
                                       (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                       (q.denom)))
                                 (@has_zero.zero.{0} rat rat.has_zero))
                              false
                              ((λ (a a_1 : rat) (e_1 : @eq.{1} rat a a_1) (a_2 a_3 : rat) (e_2 : @eq.{1} rat a_2 a_3),
                                  @congr.{1 1} rat Prop (@eq.{1} rat a) (@eq.{1} rat a_1) a_2 a_3
                                    (@congr_arg.{1 1} rat (rat → Prop) a a_1 (@eq.{1} rat) e_1)
                                    e_2)
                                 (rat.mk (q.num)
                                    (@coe.{1 1} nat int
                                       (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                       (q.denom)))
                                 (rat.mk (q.num)
                                    (@coe.{1 1} nat int
                                       (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                       (q.denom)))
                                 (@eq.refl.{1} rat
                                    (rat.mk (q.num)
                                       (@coe.{1 1} nat int
                                          (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                          (q.denom))))
                                 (rat.mk ?m_1 ?m_2)
                                 (@has_zero.zero.{0} rat rat.has_zero)
                                 (@eq.trans.{1} rat (rat.mk ?m_1 ?m_2)
                                    (rat.mk (@has_zero.zero.{0} int int.has_zero) ?m_2)
                                    (@has_zero.zero.{0} rat rat.has_zero)
                                    ((λ (a a_1 : int) (e_1 : @eq.{1} int a a_1) (a_2 a_3 : int)
                                      (e_2 : @eq.{1} int a_2 a_3),
                                        @congr.{1 1} int rat (rat.mk a) (rat.mk a_1) a_2 a_3
                                          (@congr_arg.{1 1} int (int → rat) a a_1 rat.mk e_1)
                                          e_2)
                                       ?m_1
                                       (@has_zero.zero.{0} int int.has_zero)
                                       hn
                                       ?m_2
                                       ?m_2
                                       (@eq.refl.{1} int ?m_2))
                                    (rat.zero_mk ?m_2)))
                              (@propext
                                 (@eq.{1} rat
                                    (rat.mk (q.num)
                                       (@coe.{1 1} nat int
                                          (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                          (q.denom)))
                                    (@has_zero.zero.{0} rat rat.has_zero))
                                 false
                                 (@iff_false_intro
                                    (@eq.{1} rat
                                       (rat.mk (q.num)
                                          (@coe.{1 1} nat int
                                             (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                             (q.denom)))
                                       (@has_zero.zero.{0} rat rat.has_zero))
                                    hq&#x27;)))
                           ?m_3))))))
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
          (@roption.get.{0} nat
             (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                ?m_2)
             (@iff.mpr
                (@multiplicity.finite.{0} int int.comm_semiring
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   ?m_2)
                (and
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int ?m_2 (@has_zero.zero.{0} int int.has_zero)))
                (@multiplicity.finite_int_iff
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   ?m_2)
                (@and.intro
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int ?m_2 (@has_zero.zero.{0} int int.has_zero))
                   (@ne.symm.{1} nat (@has_one.one.{0} nat nat.has_one)
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@ne_of_lt.{0} nat
                         (@partial_order.to_preorder.{0} nat
                            (@ordered_comm_monoid.to_partial_order.{0} nat
                               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
                         (@has_one.one.{0} nat nat.has_one)
                         (int.nat_abs
                            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                         (@nat.prime.one_lt p p_prime)))
                   (λ (hd : @eq.{1} int ?m_2 (@has_zero.zero.{0} int int.has_zero)),
                      false.rec.{0} false
                        (@eq.mp.{0}
                           (@eq.{1} rat
                              (rat.mk (q.num)
                                 (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                    (q.denom)))
                              (rat.mk ?m_1 ?m_2))
                           false
                           (@eq.trans.{1} Prop
                              (@eq.{1} rat
                                 (rat.mk (q.num)
                                    (@coe.{1 1} nat int
                                       (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                       (q.denom)))
                                 (rat.mk ?m_1 ?m_2))
                              (@eq.{1} rat
                                 (rat.mk (q.num)
                                    (@coe.{1 1} nat int
                                       (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                       (q.denom)))
                                 (@has_zero.zero.{0} rat rat.has_zero))
                              false
                              ((λ (a a_1 : rat) (e_1 : @eq.{1} rat a a_1) (a_2 a_3 : rat) (e_2 : @eq.{1} rat a_2 a_3),
                                  @congr.{1 1} rat Prop (@eq.{1} rat a) (@eq.{1} rat a_1) a_2 a_3
                                    (@congr_arg.{1 1} rat (rat → Prop) a a_1 (@eq.{1} rat) e_1)
                                    e_2)
                                 (rat.mk (q.num)
                                    (@coe.{1 1} nat int
                                       (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                       (q.denom)))
                                 (rat.mk (q.num)
                                    (@coe.{1 1} nat int
                                       (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                       (q.denom)))
                                 (@eq.refl.{1} rat
                                    (rat.mk (q.num)
                                       (@coe.{1 1} nat int
                                          (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                          (q.denom))))
                                 (rat.mk ?m_1 ?m_2)
                                 (@has_zero.zero.{0} rat rat.has_zero)
                                 (@eq.trans.{1} rat (rat.mk ?m_1 ?m_2)
                                    (rat.mk ?m_1 (@has_zero.zero.{0} int int.has_zero))
                                    (@has_zero.zero.{0} rat rat.has_zero)
                                    ((λ (a a_1 : int) (e_1 : @eq.{1} int a a_1) (a_2 a_3 : int)
                                      (e_2 : @eq.{1} int a_2 a_3),
                                        @congr.{1 1} int rat (rat.mk a) (rat.mk a_1) a_2 a_3
                                          (@congr_arg.{1 1} int (int → rat) a a_1 rat.mk e_1)
                                          e_2)
                                       ?m_1
                                       ?m_1
                                       (@eq.refl.{1} int ?m_1)
                                       ?m_2
                                       (@has_zero.zero.{0} int int.has_zero)
                                       hd)
                                    (rat.mk_zero ?m_1)))
                              (@propext
                                 (@eq.{1} rat
                                    (rat.mk (q.num)
                                       (@coe.{1 1} nat int
                                          (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                          (q.denom)))
                                    (@has_zero.zero.{0} rat rat.has_zero))
                                 false
                                 (@iff_false_intro
                                    (@eq.{1} rat
                                       (rat.mk (q.num)
                                          (@coe.{1 1} nat int
                                             (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                             (q.denom)))
                                       (@has_zero.zero.{0} rat rat.has_zero))
                                    hq&#x27;)))
                           ?m_3)))))))
    (padic_val_rat p r)

p : nat,
p_prime : nat.prime p,
q r : rat,
hq : @ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero),
hr : @ne.{1} rat r (@has_zero.zero.{0} rat rat.has_zero),
this :
  @eq.{1} rat (@has_mul.mul.{0} rat rat.has_mul q r)
    (rat.mk (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
       (@has_mul.mul.{0} int int.has_mul
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))),
hq&#x27; :
  @ne.{1} rat
    (rat.mk (q.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))
    (@has_zero.zero.{0} rat rat.has_zero),
hr&#x27; :
  @ne.{1} rat
    (rat.mk (r.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
    (@has_zero.zero.{0} rat rat.has_zero),
hp&#x27; :
  @prime.{0} int int.comm_semiring
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
| rat.mk (q.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))

p : nat,
p_prime : nat.prime p,
q r : rat,
hq : @ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero),
hr : @ne.{1} rat r (@has_zero.zero.{0} rat rat.has_zero),
this :
  @eq.{1} rat (@has_mul.mul.{0} rat rat.has_mul q r)
    (rat.mk (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
       (@has_mul.mul.{0} int int.has_mul
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))),
hq&#x27; :
  @ne.{1} rat
    (rat.mk (q.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))
    (@has_zero.zero.{0} rat rat.has_zero),
hr&#x27; :
  @ne.{1} rat
    (rat.mk (r.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
    (@has_zero.zero.{0} rat rat.has_zero),
hp&#x27; :
  @prime.{0} int int.comm_semiring
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
⊢ int

p : nat,
p_prime : nat.prime p,
q r : rat,
hq : @ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero),
hr : @ne.{1} rat r (@has_zero.zero.{0} rat rat.has_zero),
this :
  @eq.{1} rat (@has_mul.mul.{0} rat rat.has_mul q r)
    (rat.mk (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
       (@has_mul.mul.{0} int int.has_mul
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))),
hq&#x27; :
  @ne.{1} rat
    (rat.mk (q.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))
    (@has_zero.zero.{0} rat rat.has_zero),
hr&#x27; :
  @ne.{1} rat
    (rat.mk (r.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
    (@has_zero.zero.{0} rat rat.has_zero),
hp&#x27; :
  @prime.{0} int int.comm_semiring
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
⊢ int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>156      ←(@rat.num_denom r), padic_val_rat.defn p hr&#x27;] },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='rat.num_denom'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='r'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='padic_val_rat.defn'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hr&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/rat/basic.lean&#x27;, &#x27;line&#x27;: 216, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 132, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/converter/interactive.lean&#x27;, &#x27;line&#x27;: 128, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {a : rat}, @eq.{1} rat (rat.mk (a.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (a.denom))) a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (p : nat) [p_prime : nat.prime p] {q : rat} {n d : int} (hqz : @ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)) (qdf : @eq.{1} rat q (rat.mk n d)), @eq.{1} int (padic_val_rat p q) (@has_sub.sub.{0} int int.has_sub (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (@roption.get.{0} nat (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p) n) (@iff.mpr (@multiplicity.finite.{0} int int.comm_semiring (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p) n) (and (@ne.{1} nat (int.nat_abs (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)) (@has_one.one.{0} nat nat.has_one)) (@ne.{1} int n (@has_zero.zero.{0} int int.has_zero))) (@multiplicity.finite_int_iff (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p) n) (@and.intro (@ne.{1} nat (int.nat_abs (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)) (@has_one.one.{0} nat nat.has_one)) (@ne.{1} int n (@has_zero.zero.{0} int int.has_zero)) (@ne.symm.{1} nat (@has_one.one.{0} nat nat.has_one) (int.nat_abs (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)) (@ne_of_lt.{0} nat (@partial_order.to_preorder.{0} nat (@ordered_comm_monoid.to_partial_order.{0} nat (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))) (@has_one.one.{0} nat nat.has_one) (int.nat_abs (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)) (@nat.prime.one_lt p p_prime))) (λ (hn : @eq.{1} int n (@has_zero.zero.{0} int int.has_zero)), false.rec.{0} false (@eq.mp.{0} (@eq.{1} rat q (rat.mk n d)) false (@eq.trans.{1} Prop (@eq.{1} rat q (rat.mk n d)) (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)) false ((λ (a a_1 : rat) (e_1 : @eq.{1} rat a a_1) (a_2 a_3 : rat) (e_2 : @eq.{1} rat a_2 a_3), @congr.{1 1} rat Prop (@eq.{1} rat a) (@eq.{1} rat a_1) a_2 a_3 (@congr_arg.{1 1} rat (rat → Prop) a a_1 (@eq.{1} rat) e_1) e_2) q q (@eq.refl.{1} rat q) (rat.mk n d) (@has_zero.zero.{0} rat rat.has_zero) (@eq.trans.{1} rat (rat.mk n d) (rat.mk (@has_zero.zero.{0} int int.has_zero) d) (@has_zero.zero.{0} rat rat.has_zero) ((λ (a a_1 : int) (e_1 : @eq.{1} int a a_1) (a_2 a_3 : int) (e_2 : @eq.{1} int a_2 a_3), @congr.{1 1} int rat (rat.mk a) (rat.mk a_1) a_2 a_3 (@congr_arg.{1 1} int (int → rat) a a_1 rat.mk e_1) e_2) n (@has_zero.zero.{0} int int.has_zero) hn d d (@eq.refl.{1} int d)) (rat.zero_mk d))) (@propext (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)) false (@iff_false_intro (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)) hqz))) qdf)))))) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (@roption.get.{0} nat (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p) d) (@iff.mpr (@multiplicity.finite.{0} int int.comm_semiring (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p) d) (and (@ne.{1} nat (int.nat_abs (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)) (@has_one.one.{0} nat nat.has_one)) (@ne.{1} int d (@has_zero.zero.{0} int int.has_zero))) (@multiplicity.finite_int_iff (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p) d) (@and.intro (@ne.{1} nat (int.nat_abs (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)) (@has_one.one.{0} nat nat.has_one)) (@ne.{1} int d (@has_zero.zero.{0} int int.has_zero)) (@ne.symm.{1} nat (@has_one.one.{0} nat nat.has_one) (int.nat_abs (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)) (@ne_of_lt.{0} nat (@partial_order.to_preorder.{0} nat (@ordered_comm_monoid.to_partial_order.{0} nat (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))) (@has_one.one.{0} nat nat.has_one) (int.nat_abs (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)) (@nat.prime.one_lt p p_prime))) (λ (hd : @eq.{1} int d (@has_zero.zero.{0} int int.has_zero)), false.rec.{0} false (@eq.mp.{0} (@eq.{1} rat q (rat.mk n d)) false (@eq.trans.{1} Prop (@eq.{1} rat q (rat.mk n d)) (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)) false ((λ (a a_1 : rat) (e_1 : @eq.{1} rat a a_1) (a_2 a_3 : rat) (e_2 : @eq.{1} rat a_2 a_3), @congr.{1 1} rat Prop (@eq.{1} rat a) (@eq.{1} rat a_1) a_2 a_3 (@congr_arg.{1 1} rat (rat → Prop) a a_1 (@eq.{1} rat) e_1) e_2) q q (@eq.refl.{1} rat q) (rat.mk n d) (@has_zero.zero.{0} rat rat.has_zero) (@eq.trans.{1} rat (rat.mk n d) (rat.mk n (@has_zero.zero.{0} int int.has_zero)) (@has_zero.zero.{0} rat rat.has_zero) ((λ (a a_1 : int) (e_1 : @eq.{1} int a a_1) (a_2 a_3 : int) (e_2 : @eq.{1} int a_2 a_3), @congr.{1 1} int rat (rat.mk a) (rat.mk a_1) a_2 a_3 (@congr_arg.{1 1} int (int → rat) a a_1 rat.mk e_1) e_2) n n (@eq.refl.{1} int n) d (@has_zero.zero.{0} int int.has_zero) hd) (rat.mk_zero n))) (@propext (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)) false (@iff_false_intro (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)) hqz))) qdf)))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@ne.{1} rat (rat.mk (r.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom))) (@has_zero.zero.{0} rat rat.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit name (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.ident)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) (lean.parser.pexpr std.prec.max))) → conv.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='orange'><a title='A rewrite lemma for `padic_val_rat p q` when `q` is expressed in terms of `rat.mk`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='conv_rhs'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;(at id)?&#x27;, &#x27;(in expr)?&#x27;, &#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='4 goals
p : nat,
p_prime : nat.prime p,
q r : rat,
hq : @ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero),
hr : @ne.{1} rat r (@has_zero.zero.{0} rat rat.has_zero),
this :
  @eq.{1} rat (@has_mul.mul.{0} rat rat.has_mul q r)
    (rat.mk (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
       (@has_mul.mul.{0} int int.has_mul
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))),
hq&#x27; :
  @ne.{1} rat
    (rat.mk (q.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))
    (@has_zero.zero.{0} rat rat.has_zero),
hr&#x27; :
  @ne.{1} rat
    (rat.mk (r.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
    (@has_zero.zero.{0} rat rat.has_zero),
hp&#x27; :
  @prime.{0} int int.comm_semiring
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
| @has_add.add.{0} int int.has_add
    (@has_sub.sub.{0} int int.has_sub
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
          (@roption.get.{0} nat
             (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                ?m_1)
             (@iff.mpr
                (@multiplicity.finite.{0} int int.comm_semiring
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   ?m_1)
                (and
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int ?m_1 (@has_zero.zero.{0} int int.has_zero)))
                (@multiplicity.finite_int_iff
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   ?m_1)
                (@and.intro
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int ?m_1 (@has_zero.zero.{0} int int.has_zero))
                   (@ne.symm.{1} nat (@has_one.one.{0} nat nat.has_one)
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@ne_of_lt.{0} nat
                         (@partial_order.to_preorder.{0} nat
                            (@ordered_comm_monoid.to_partial_order.{0} nat
                               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
                         (@has_one.one.{0} nat nat.has_one)
                         (int.nat_abs
                            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                         (@nat.prime.one_lt p p_prime)))
                   (λ (hn : @eq.{1} int ?m_1 (@has_zero.zero.{0} int int.has_zero)),
                      false.rec.{0} false
                        (@eq.mp.{0}
                           (@eq.{1} rat
                              (rat.mk (q.num)
                                 (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                    (q.denom)))
                              (rat.mk ?m_1 ?m_2))
                           false
                           (@eq.trans.{1} Prop
                              (@eq.{1} rat
                                 (rat.mk (q.num)
                                    (@coe.{1 1} nat int
                                       (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                       (q.denom)))
                                 (rat.mk ?m_1 ?m_2))
                              (@eq.{1} rat
                                 (rat.mk (q.num)
                                    (@coe.{1 1} nat int
                                       (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                       (q.denom)))
                                 (@has_zero.zero.{0} rat rat.has_zero))
                              false
                              ((λ (a a_1 : rat) (e_1 : @eq.{1} rat a a_1) (a_2 a_3 : rat) (e_2 : @eq.{1} rat a_2 a_3),
                                  @congr.{1 1} rat Prop (@eq.{1} rat a) (@eq.{1} rat a_1) a_2 a_3
                                    (@congr_arg.{1 1} rat (rat → Prop) a a_1 (@eq.{1} rat) e_1)
                                    e_2)
                                 (rat.mk (q.num)
                                    (@coe.{1 1} nat int
                                       (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                       (q.denom)))
                                 (rat.mk (q.num)
                                    (@coe.{1 1} nat int
                                       (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                       (q.denom)))
                                 (@eq.refl.{1} rat
                                    (rat.mk (q.num)
                                       (@coe.{1 1} nat int
                                          (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                          (q.denom))))
                                 (rat.mk ?m_1 ?m_2)
                                 (@has_zero.zero.{0} rat rat.has_zero)
                                 (@eq.trans.{1} rat (rat.mk ?m_1 ?m_2)
                                    (rat.mk (@has_zero.zero.{0} int int.has_zero) ?m_2)
                                    (@has_zero.zero.{0} rat rat.has_zero)
                                    ((λ (a a_1 : int) (e_1 : @eq.{1} int a a_1) (a_2 a_3 : int)
                                      (e_2 : @eq.{1} int a_2 a_3),
                                        @congr.{1 1} int rat (rat.mk a) (rat.mk a_1) a_2 a_3
                                          (@congr_arg.{1 1} int (int → rat) a a_1 rat.mk e_1)
                                          e_2)
                                       ?m_1
                                       (@has_zero.zero.{0} int int.has_zero)
                                       hn
                                       ?m_2
                                       ?m_2
                                       (@eq.refl.{1} int ?m_2))
                                    (rat.zero_mk ?m_2)))
                              (@propext
                                 (@eq.{1} rat
                                    (rat.mk (q.num)
                                       (@coe.{1 1} nat int
                                          (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                          (q.denom)))
                                    (@has_zero.zero.{0} rat rat.has_zero))
                                 false
                                 (@iff_false_intro
                                    (@eq.{1} rat
                                       (rat.mk (q.num)
                                          (@coe.{1 1} nat int
                                             (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                             (q.denom)))
                                       (@has_zero.zero.{0} rat rat.has_zero))
                                    hq&#x27;)))
                           ?m_3))))))
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
          (@roption.get.{0} nat
             (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                ?m_2)
             (@iff.mpr
                (@multiplicity.finite.{0} int int.comm_semiring
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   ?m_2)
                (and
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int ?m_2 (@has_zero.zero.{0} int int.has_zero)))
                (@multiplicity.finite_int_iff
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   ?m_2)
                (@and.intro
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int ?m_2 (@has_zero.zero.{0} int int.has_zero))
                   (@ne.symm.{1} nat (@has_one.one.{0} nat nat.has_one)
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@ne_of_lt.{0} nat
                         (@partial_order.to_preorder.{0} nat
                            (@ordered_comm_monoid.to_partial_order.{0} nat
                               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
                         (@has_one.one.{0} nat nat.has_one)
                         (int.nat_abs
                            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                         (@nat.prime.one_lt p p_prime)))
                   (λ (hd : @eq.{1} int ?m_2 (@has_zero.zero.{0} int int.has_zero)),
                      false.rec.{0} false
                        (@eq.mp.{0}
                           (@eq.{1} rat
                              (rat.mk (q.num)
                                 (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                    (q.denom)))
                              (rat.mk ?m_1 ?m_2))
                           false
                           (@eq.trans.{1} Prop
                              (@eq.{1} rat
                                 (rat.mk (q.num)
                                    (@coe.{1 1} nat int
                                       (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                       (q.denom)))
                                 (rat.mk ?m_1 ?m_2))
                              (@eq.{1} rat
                                 (rat.mk (q.num)
                                    (@coe.{1 1} nat int
                                       (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                       (q.denom)))
                                 (@has_zero.zero.{0} rat rat.has_zero))
                              false
                              ((λ (a a_1 : rat) (e_1 : @eq.{1} rat a a_1) (a_2 a_3 : rat) (e_2 : @eq.{1} rat a_2 a_3),
                                  @congr.{1 1} rat Prop (@eq.{1} rat a) (@eq.{1} rat a_1) a_2 a_3
                                    (@congr_arg.{1 1} rat (rat → Prop) a a_1 (@eq.{1} rat) e_1)
                                    e_2)
                                 (rat.mk (q.num)
                                    (@coe.{1 1} nat int
                                       (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                       (q.denom)))
                                 (rat.mk (q.num)
                                    (@coe.{1 1} nat int
                                       (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                       (q.denom)))
                                 (@eq.refl.{1} rat
                                    (rat.mk (q.num)
                                       (@coe.{1 1} nat int
                                          (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                          (q.denom))))
                                 (rat.mk ?m_1 ?m_2)
                                 (@has_zero.zero.{0} rat rat.has_zero)
                                 (@eq.trans.{1} rat (rat.mk ?m_1 ?m_2)
                                    (rat.mk ?m_1 (@has_zero.zero.{0} int int.has_zero))
                                    (@has_zero.zero.{0} rat rat.has_zero)
                                    ((λ (a a_1 : int) (e_1 : @eq.{1} int a a_1) (a_2 a_3 : int)
                                      (e_2 : @eq.{1} int a_2 a_3),
                                        @congr.{1 1} int rat (rat.mk a) (rat.mk a_1) a_2 a_3
                                          (@congr_arg.{1 1} int (int → rat) a a_1 rat.mk e_1)
                                          e_2)
                                       ?m_1
                                       ?m_1
                                       (@eq.refl.{1} int ?m_1)
                                       ?m_2
                                       (@has_zero.zero.{0} int int.has_zero)
                                       hd)
                                    (rat.mk_zero ?m_1)))
                              (@propext
                                 (@eq.{1} rat
                                    (rat.mk (q.num)
                                       (@coe.{1 1} nat int
                                          (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                          (q.denom)))
                                    (@has_zero.zero.{0} rat rat.has_zero))
                                 false
                                 (@iff_false_intro
                                    (@eq.{1} rat
                                       (rat.mk (q.num)
                                          (@coe.{1 1} nat int
                                             (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                             (q.denom)))
                                       (@has_zero.zero.{0} rat rat.has_zero))
                                    hq&#x27;)))
                           ?m_3)))))))
    (padic_val_rat p r)

p : nat,
p_prime : nat.prime p,
q r : rat,
hq : @ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero),
hr : @ne.{1} rat r (@has_zero.zero.{0} rat rat.has_zero),
this :
  @eq.{1} rat (@has_mul.mul.{0} rat rat.has_mul q r)
    (rat.mk (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
       (@has_mul.mul.{0} int int.has_mul
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))),
hq&#x27; :
  @ne.{1} rat
    (rat.mk (q.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))
    (@has_zero.zero.{0} rat rat.has_zero),
hr&#x27; :
  @ne.{1} rat
    (rat.mk (r.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
    (@has_zero.zero.{0} rat rat.has_zero),
hp&#x27; :
  @prime.{0} int int.comm_semiring
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
| rat.mk (q.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))

p : nat,
p_prime : nat.prime p,
q r : rat,
hq : @ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero),
hr : @ne.{1} rat r (@has_zero.zero.{0} rat rat.has_zero),
this :
  @eq.{1} rat (@has_mul.mul.{0} rat rat.has_mul q r)
    (rat.mk (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
       (@has_mul.mul.{0} int int.has_mul
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))),
hq&#x27; :
  @ne.{1} rat
    (rat.mk (q.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))
    (@has_zero.zero.{0} rat rat.has_zero),
hr&#x27; :
  @ne.{1} rat
    (rat.mk (r.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
    (@has_zero.zero.{0} rat rat.has_zero),
hp&#x27; :
  @prime.{0} int int.comm_semiring
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
⊢ int

p : nat,
p_prime : nat.prime p,
q r : rat,
hq : @ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero),
hr : @ne.{1} rat r (@has_zero.zero.{0} rat rat.has_zero),
this :
  @eq.{1} rat (@has_mul.mul.{0} rat rat.has_mul q r)
    (rat.mk (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
       (@has_mul.mul.{0} int int.has_mul
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))),
hq&#x27; :
  @ne.{1} rat
    (rat.mk (q.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))
    (@has_zero.zero.{0} rat rat.has_zero),
hr&#x27; :
  @ne.{1} rat
    (rat.mk (r.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
    (@has_zero.zero.{0} rat rat.has_zero),
hp&#x27; :
  @prime.{0} int int.comm_semiring
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
⊢ int'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='4 goals
p : nat,
p_prime : nat.prime p,
q r : rat,
hq : @ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero),
hr : @ne.{1} rat r (@has_zero.zero.{0} rat rat.has_zero),
this :
  @eq.{1} rat (@has_mul.mul.{0} rat rat.has_mul q r)
    (rat.mk (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
       (@has_mul.mul.{0} int int.has_mul
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))),
hq&#x27; :
  @ne.{1} rat
    (rat.mk (q.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))
    (@has_zero.zero.{0} rat rat.has_zero),
hr&#x27; :
  @ne.{1} rat
    (rat.mk (r.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
    (@has_zero.zero.{0} rat rat.has_zero),
hp&#x27; :
  @prime.{0} int int.comm_semiring
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
| @has_add.add.{0} int int.has_add
    (@has_sub.sub.{0} int int.has_sub
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
          (@roption.get.{0} nat
             (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                ?m_1)
             (@iff.mpr
                (@multiplicity.finite.{0} int int.comm_semiring
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   ?m_1)
                (and
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int ?m_1 (@has_zero.zero.{0} int int.has_zero)))
                (@multiplicity.finite_int_iff
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   ?m_1)
                (@and.intro
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int ?m_1 (@has_zero.zero.{0} int int.has_zero))
                   (@ne.symm.{1} nat (@has_one.one.{0} nat nat.has_one)
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@ne_of_lt.{0} nat
                         (@partial_order.to_preorder.{0} nat
                            (@ordered_comm_monoid.to_partial_order.{0} nat
                               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
                         (@has_one.one.{0} nat nat.has_one)
                         (int.nat_abs
                            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                         (@nat.prime.one_lt p p_prime)))
                   (λ (hn : @eq.{1} int ?m_1 (@has_zero.zero.{0} int int.has_zero)),
                      false.rec.{0} false
                        (@eq.mp.{0}
                           (@eq.{1} rat
                              (rat.mk (q.num)
                                 (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                    (q.denom)))
                              (rat.mk ?m_1 ?m_2))
                           false
                           (@eq.trans.{1} Prop
                              (@eq.{1} rat
                                 (rat.mk (q.num)
                                    (@coe.{1 1} nat int
                                       (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                       (q.denom)))
                                 (rat.mk ?m_1 ?m_2))
                              (@eq.{1} rat
                                 (rat.mk (q.num)
                                    (@coe.{1 1} nat int
                                       (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                       (q.denom)))
                                 (@has_zero.zero.{0} rat rat.has_zero))
                              false
                              ((λ (a a_1 : rat) (e_1 : @eq.{1} rat a a_1) (a_2 a_3 : rat) (e_2 : @eq.{1} rat a_2 a_3),
                                  @congr.{1 1} rat Prop (@eq.{1} rat a) (@eq.{1} rat a_1) a_2 a_3
                                    (@congr_arg.{1 1} rat (rat → Prop) a a_1 (@eq.{1} rat) e_1)
                                    e_2)
                                 (rat.mk (q.num)
                                    (@coe.{1 1} nat int
                                       (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                       (q.denom)))
                                 (rat.mk (q.num)
                                    (@coe.{1 1} nat int
                                       (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                       (q.denom)))
                                 (@eq.refl.{1} rat
                                    (rat.mk (q.num)
                                       (@coe.{1 1} nat int
                                          (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                          (q.denom))))
                                 (rat.mk ?m_1 ?m_2)
                                 (@has_zero.zero.{0} rat rat.has_zero)
                                 (@eq.trans.{1} rat (rat.mk ?m_1 ?m_2)
                                    (rat.mk (@has_zero.zero.{0} int int.has_zero) ?m_2)
                                    (@has_zero.zero.{0} rat rat.has_zero)
                                    ((λ (a a_1 : int) (e_1 : @eq.{1} int a a_1) (a_2 a_3 : int)
                                      (e_2 : @eq.{1} int a_2 a_3),
                                        @congr.{1 1} int rat (rat.mk a) (rat.mk a_1) a_2 a_3
                                          (@congr_arg.{1 1} int (int → rat) a a_1 rat.mk e_1)
                                          e_2)
                                       ?m_1
                                       (@has_zero.zero.{0} int int.has_zero)
                                       hn
                                       ?m_2
                                       ?m_2
                                       (@eq.refl.{1} int ?m_2))
                                    (rat.zero_mk ?m_2)))
                              (@propext
                                 (@eq.{1} rat
                                    (rat.mk (q.num)
                                       (@coe.{1 1} nat int
                                          (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                          (q.denom)))
                                    (@has_zero.zero.{0} rat rat.has_zero))
                                 false
                                 (@iff_false_intro
                                    (@eq.{1} rat
                                       (rat.mk (q.num)
                                          (@coe.{1 1} nat int
                                             (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                             (q.denom)))
                                       (@has_zero.zero.{0} rat rat.has_zero))
                                    hq&#x27;)))
                           ?m_3))))))
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
          (@roption.get.{0} nat
             (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                ?m_2)
             (@iff.mpr
                (@multiplicity.finite.{0} int int.comm_semiring
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   ?m_2)
                (and
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int ?m_2 (@has_zero.zero.{0} int int.has_zero)))
                (@multiplicity.finite_int_iff
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   ?m_2)
                (@and.intro
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int ?m_2 (@has_zero.zero.{0} int int.has_zero))
                   (@ne.symm.{1} nat (@has_one.one.{0} nat nat.has_one)
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@ne_of_lt.{0} nat
                         (@partial_order.to_preorder.{0} nat
                            (@ordered_comm_monoid.to_partial_order.{0} nat
                               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
                         (@has_one.one.{0} nat nat.has_one)
                         (int.nat_abs
                            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                         (@nat.prime.one_lt p p_prime)))
                   (λ (hd : @eq.{1} int ?m_2 (@has_zero.zero.{0} int int.has_zero)),
                      false.rec.{0} false
                        (@eq.mp.{0}
                           (@eq.{1} rat
                              (rat.mk (q.num)
                                 (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                    (q.denom)))
                              (rat.mk ?m_1 ?m_2))
                           false
                           (@eq.trans.{1} Prop
                              (@eq.{1} rat
                                 (rat.mk (q.num)
                                    (@coe.{1 1} nat int
                                       (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                       (q.denom)))
                                 (rat.mk ?m_1 ?m_2))
                              (@eq.{1} rat
                                 (rat.mk (q.num)
                                    (@coe.{1 1} nat int
                                       (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                       (q.denom)))
                                 (@has_zero.zero.{0} rat rat.has_zero))
                              false
                              ((λ (a a_1 : rat) (e_1 : @eq.{1} rat a a_1) (a_2 a_3 : rat) (e_2 : @eq.{1} rat a_2 a_3),
                                  @congr.{1 1} rat Prop (@eq.{1} rat a) (@eq.{1} rat a_1) a_2 a_3
                                    (@congr_arg.{1 1} rat (rat → Prop) a a_1 (@eq.{1} rat) e_1)
                                    e_2)
                                 (rat.mk (q.num)
                                    (@coe.{1 1} nat int
                                       (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                       (q.denom)))
                                 (rat.mk (q.num)
                                    (@coe.{1 1} nat int
                                       (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                       (q.denom)))
                                 (@eq.refl.{1} rat
                                    (rat.mk (q.num)
                                       (@coe.{1 1} nat int
                                          (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                          (q.denom))))
                                 (rat.mk ?m_1 ?m_2)
                                 (@has_zero.zero.{0} rat rat.has_zero)
                                 (@eq.trans.{1} rat (rat.mk ?m_1 ?m_2)
                                    (rat.mk ?m_1 (@has_zero.zero.{0} int int.has_zero))
                                    (@has_zero.zero.{0} rat rat.has_zero)
                                    ((λ (a a_1 : int) (e_1 : @eq.{1} int a a_1) (a_2 a_3 : int)
                                      (e_2 : @eq.{1} int a_2 a_3),
                                        @congr.{1 1} int rat (rat.mk a) (rat.mk a_1) a_2 a_3
                                          (@congr_arg.{1 1} int (int → rat) a a_1 rat.mk e_1)
                                          e_2)
                                       ?m_1
                                       ?m_1
                                       (@eq.refl.{1} int ?m_1)
                                       ?m_2
                                       (@has_zero.zero.{0} int int.has_zero)
                                       hd)
                                    (rat.mk_zero ?m_1)))
                              (@propext
                                 (@eq.{1} rat
                                    (rat.mk (q.num)
                                       (@coe.{1 1} nat int
                                          (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                          (q.denom)))
                                    (@has_zero.zero.{0} rat rat.has_zero))
                                 false
                                 (@iff_false_intro
                                    (@eq.{1} rat
                                       (rat.mk (q.num)
                                          (@coe.{1 1} nat int
                                             (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                             (q.denom)))
                                       (@has_zero.zero.{0} rat rat.has_zero))
                                    hq&#x27;)))
                           ?m_3)))))))
    (padic_val_rat p
       (rat.mk (r.num)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom))))

p : nat,
p_prime : nat.prime p,
q r : rat,
hq : @ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero),
hr : @ne.{1} rat r (@has_zero.zero.{0} rat rat.has_zero),
this :
  @eq.{1} rat (@has_mul.mul.{0} rat rat.has_mul q r)
    (rat.mk (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
       (@has_mul.mul.{0} int int.has_mul
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))),
hq&#x27; :
  @ne.{1} rat
    (rat.mk (q.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))
    (@has_zero.zero.{0} rat rat.has_zero),
hr&#x27; :
  @ne.{1} rat
    (rat.mk (r.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
    (@has_zero.zero.{0} rat rat.has_zero),
hp&#x27; :
  @prime.{0} int int.comm_semiring
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
| rat.mk (q.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))

p : nat,
p_prime : nat.prime p,
q r : rat,
hq : @ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero),
hr : @ne.{1} rat r (@has_zero.zero.{0} rat rat.has_zero),
this :
  @eq.{1} rat (@has_mul.mul.{0} rat rat.has_mul q r)
    (rat.mk (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
       (@has_mul.mul.{0} int int.has_mul
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))),
hq&#x27; :
  @ne.{1} rat
    (rat.mk (q.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))
    (@has_zero.zero.{0} rat rat.has_zero),
hr&#x27; :
  @ne.{1} rat
    (rat.mk (r.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
    (@has_zero.zero.{0} rat rat.has_zero),
hp&#x27; :
  @prime.{0} int int.comm_semiring
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
⊢ int

p : nat,
p_prime : nat.prime p,
q r : rat,
hq : @ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero),
hr : @ne.{1} rat r (@has_zero.zero.{0} rat rat.has_zero),
this :
  @eq.{1} rat (@has_mul.mul.{0} rat rat.has_mul q r)
    (rat.mk (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
       (@has_mul.mul.{0} int int.has_mul
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))),
hq&#x27; :
  @ne.{1} rat
    (rat.mk (q.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))
    (@has_zero.zero.{0} rat rat.has_zero),
hr&#x27; :
  @ne.{1} rat
    (rat.mk (r.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
    (@has_zero.zero.{0} rat rat.has_zero),
hp&#x27; :
  @prime.{0} int int.comm_semiring
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
⊢ int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='lime'><a title='p : nat,
p_prime : nat.prime p,
q r : rat,
hq : @ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero),
hr : @ne.{1} rat r (@has_zero.zero.{0} rat rat.has_zero),
this :
  @eq.{1} rat (@has_mul.mul.{0} rat rat.has_mul q r)
    (rat.mk (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
       (@has_mul.mul.{0} int int.has_mul
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))),
hq&#x27; :
  @ne.{1} rat
    (rat.mk (q.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))
    (@has_zero.zero.{0} rat rat.has_zero),
hr&#x27; :
  @ne.{1} rat
    (rat.mk (r.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
    (@has_zero.zero.{0} rat rat.has_zero),
hp&#x27; :
  @prime.{0} int int.comm_semiring
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
| @has_add.add.{0} int int.has_add (padic_val_rat p q) (padic_val_rat p r)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='7 goals
p : nat,
p_prime : nat.prime p,
q r : rat,
hq : @ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero),
hr : @ne.{1} rat r (@has_zero.zero.{0} rat rat.has_zero),
this :
  @eq.{1} rat (@has_mul.mul.{0} rat rat.has_mul q r)
    (rat.mk (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
       (@has_mul.mul.{0} int int.has_mul
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))),
hq&#x27; :
  @ne.{1} rat
    (rat.mk (q.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))
    (@has_zero.zero.{0} rat rat.has_zero),
hr&#x27; :
  @ne.{1} rat
    (rat.mk (r.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
    (@has_zero.zero.{0} rat rat.has_zero),
hp&#x27; :
  @prime.{0} int int.comm_semiring
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
| @has_add.add.{0} int int.has_add
    (@has_sub.sub.{0} int int.has_sub
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
          (@roption.get.{0} nat
             (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                ?m_1)
             (@iff.mpr
                (@multiplicity.finite.{0} int int.comm_semiring
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   ?m_1)
                (and
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int ?m_1 (@has_zero.zero.{0} int int.has_zero)))
                (@multiplicity.finite_int_iff
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   ?m_1)
                (@and.intro
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int ?m_1 (@has_zero.zero.{0} int int.has_zero))
                   (@ne.symm.{1} nat (@has_one.one.{0} nat nat.has_one)
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@ne_of_lt.{0} nat
                         (@partial_order.to_preorder.{0} nat
                            (@ordered_comm_monoid.to_partial_order.{0} nat
                               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
                         (@has_one.one.{0} nat nat.has_one)
                         (int.nat_abs
                            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                         (@nat.prime.one_lt p p_prime)))
                   (λ (hn : @eq.{1} int ?m_1 (@has_zero.zero.{0} int int.has_zero)),
                      false.rec.{0} false
                        (@eq.mp.{0}
                           (@eq.{1} rat
                              (rat.mk (q.num)
                                 (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                    (q.denom)))
                              (rat.mk ?m_1 ?m_2))
                           false
                           (@eq.trans.{1} Prop
                              (@eq.{1} rat
                                 (rat.mk (q.num)
                                    (@coe.{1 1} nat int
                                       (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                       (q.denom)))
                                 (rat.mk ?m_1 ?m_2))
                              (@eq.{1} rat
                                 (rat.mk (q.num)
                                    (@coe.{1 1} nat int
                                       (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                       (q.denom)))
                                 (@has_zero.zero.{0} rat rat.has_zero))
                              false
                              ((λ (a a_1 : rat) (e_1 : @eq.{1} rat a a_1) (a_2 a_3 : rat) (e_2 : @eq.{1} rat a_2 a_3),
                                  @congr.{1 1} rat Prop (@eq.{1} rat a) (@eq.{1} rat a_1) a_2 a_3
                                    (@congr_arg.{1 1} rat (rat → Prop) a a_1 (@eq.{1} rat) e_1)
                                    e_2)
                                 (rat.mk (q.num)
                                    (@coe.{1 1} nat int
                                       (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                       (q.denom)))
                                 (rat.mk (q.num)
                                    (@coe.{1 1} nat int
                                       (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                       (q.denom)))
                                 (@eq.refl.{1} rat
                                    (rat.mk (q.num)
                                       (@coe.{1 1} nat int
                                          (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                          (q.denom))))
                                 (rat.mk ?m_1 ?m_2)
                                 (@has_zero.zero.{0} rat rat.has_zero)
                                 (@eq.trans.{1} rat (rat.mk ?m_1 ?m_2)
                                    (rat.mk (@has_zero.zero.{0} int int.has_zero) ?m_2)
                                    (@has_zero.zero.{0} rat rat.has_zero)
                                    ((λ (a a_1 : int) (e_1 : @eq.{1} int a a_1) (a_2 a_3 : int)
                                      (e_2 : @eq.{1} int a_2 a_3),
                                        @congr.{1 1} int rat (rat.mk a) (rat.mk a_1) a_2 a_3
                                          (@congr_arg.{1 1} int (int → rat) a a_1 rat.mk e_1)
                                          e_2)
                                       ?m_1
                                       (@has_zero.zero.{0} int int.has_zero)
                                       hn
                                       ?m_2
                                       ?m_2
                                       (@eq.refl.{1} int ?m_2))
                                    (rat.zero_mk ?m_2)))
                              (@propext
                                 (@eq.{1} rat
                                    (rat.mk (q.num)
                                       (@coe.{1 1} nat int
                                          (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                          (q.denom)))
                                    (@has_zero.zero.{0} rat rat.has_zero))
                                 false
                                 (@iff_false_intro
                                    (@eq.{1} rat
                                       (rat.mk (q.num)
                                          (@coe.{1 1} nat int
                                             (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                             (q.denom)))
                                       (@has_zero.zero.{0} rat rat.has_zero))
                                    hq&#x27;)))
                           ?m_3))))))
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
          (@roption.get.{0} nat
             (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                ?m_2)
             (@iff.mpr
                (@multiplicity.finite.{0} int int.comm_semiring
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   ?m_2)
                (and
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int ?m_2 (@has_zero.zero.{0} int int.has_zero)))
                (@multiplicity.finite_int_iff
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   ?m_2)
                (@and.intro
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int ?m_2 (@has_zero.zero.{0} int int.has_zero))
                   (@ne.symm.{1} nat (@has_one.one.{0} nat nat.has_one)
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@ne_of_lt.{0} nat
                         (@partial_order.to_preorder.{0} nat
                            (@ordered_comm_monoid.to_partial_order.{0} nat
                               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
                         (@has_one.one.{0} nat nat.has_one)
                         (int.nat_abs
                            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                         (@nat.prime.one_lt p p_prime)))
                   (λ (hd : @eq.{1} int ?m_2 (@has_zero.zero.{0} int int.has_zero)),
                      false.rec.{0} false
                        (@eq.mp.{0}
                           (@eq.{1} rat
                              (rat.mk (q.num)
                                 (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                    (q.denom)))
                              (rat.mk ?m_1 ?m_2))
                           false
                           (@eq.trans.{1} Prop
                              (@eq.{1} rat
                                 (rat.mk (q.num)
                                    (@coe.{1 1} nat int
                                       (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                       (q.denom)))
                                 (rat.mk ?m_1 ?m_2))
                              (@eq.{1} rat
                                 (rat.mk (q.num)
                                    (@coe.{1 1} nat int
                                       (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                       (q.denom)))
                                 (@has_zero.zero.{0} rat rat.has_zero))
                              false
                              ((λ (a a_1 : rat) (e_1 : @eq.{1} rat a a_1) (a_2 a_3 : rat) (e_2 : @eq.{1} rat a_2 a_3),
                                  @congr.{1 1} rat Prop (@eq.{1} rat a) (@eq.{1} rat a_1) a_2 a_3
                                    (@congr_arg.{1 1} rat (rat → Prop) a a_1 (@eq.{1} rat) e_1)
                                    e_2)
                                 (rat.mk (q.num)
                                    (@coe.{1 1} nat int
                                       (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                       (q.denom)))
                                 (rat.mk (q.num)
                                    (@coe.{1 1} nat int
                                       (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                       (q.denom)))
                                 (@eq.refl.{1} rat
                                    (rat.mk (q.num)
                                       (@coe.{1 1} nat int
                                          (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                          (q.denom))))
                                 (rat.mk ?m_1 ?m_2)
                                 (@has_zero.zero.{0} rat rat.has_zero)
                                 (@eq.trans.{1} rat (rat.mk ?m_1 ?m_2)
                                    (rat.mk ?m_1 (@has_zero.zero.{0} int int.has_zero))
                                    (@has_zero.zero.{0} rat rat.has_zero)
                                    ((λ (a a_1 : int) (e_1 : @eq.{1} int a a_1) (a_2 a_3 : int)
                                      (e_2 : @eq.{1} int a_2 a_3),
                                        @congr.{1 1} int rat (rat.mk a) (rat.mk a_1) a_2 a_3
                                          (@congr_arg.{1 1} int (int → rat) a a_1 rat.mk e_1)
                                          e_2)
                                       ?m_1
                                       ?m_1
                                       (@eq.refl.{1} int ?m_1)
                                       ?m_2
                                       (@has_zero.zero.{0} int int.has_zero)
                                       hd)
                                    (rat.mk_zero ?m_1)))
                              (@propext
                                 (@eq.{1} rat
                                    (rat.mk (q.num)
                                       (@coe.{1 1} nat int
                                          (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                          (q.denom)))
                                    (@has_zero.zero.{0} rat rat.has_zero))
                                 false
                                 (@iff_false_intro
                                    (@eq.{1} rat
                                       (rat.mk (q.num)
                                          (@coe.{1 1} nat int
                                             (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                             (q.denom)))
                                       (@has_zero.zero.{0} rat rat.has_zero))
                                    hq&#x27;)))
                           ?m_3)))))))
    (@has_sub.sub.{0} int int.has_sub
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
          (@roption.get.{0} nat
             (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                ?m_4)
             (@iff.mpr
                (@multiplicity.finite.{0} int int.comm_semiring
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   ?m_4)
                (and
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int ?m_4 (@has_zero.zero.{0} int int.has_zero)))
                (@multiplicity.finite_int_iff
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   ?m_4)
                (@and.intro
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int ?m_4 (@has_zero.zero.{0} int int.has_zero))
                   (@ne.symm.{1} nat (@has_one.one.{0} nat nat.has_one)
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@ne_of_lt.{0} nat
                         (@partial_order.to_preorder.{0} nat
                            (@ordered_comm_monoid.to_partial_order.{0} nat
                               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
                         (@has_one.one.{0} nat nat.has_one)
                         (int.nat_abs
                            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                         (@nat.prime.one_lt p p_prime)))
                   (λ (hn : @eq.{1} int ?m_4 (@has_zero.zero.{0} int int.has_zero)),
                      false.rec.{0} false
                        (@eq.mp.{0}
                           (@eq.{1} rat
                              (rat.mk (r.num)
                                 (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                    (r.denom)))
                              (rat.mk ?m_4 ?m_5))
                           false
                           (@eq.trans.{1} Prop
                              (@eq.{1} rat
                                 (rat.mk (r.num)
                                    (@coe.{1 1} nat int
                                       (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                       (r.denom)))
                                 (rat.mk ?m_4 ?m_5))
                              (@eq.{1} rat
                                 (rat.mk (r.num)
                                    (@coe.{1 1} nat int
                                       (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                       (r.denom)))
                                 (@has_zero.zero.{0} rat rat.has_zero))
                              false
                              ((λ (a a_1 : rat) (e_1 : @eq.{1} rat a a_1) (a_2 a_3 : rat) (e_2 : @eq.{1} rat a_2 a_3),
                                  @congr.{1 1} rat Prop (@eq.{1} rat a) (@eq.{1} rat a_1) a_2 a_3
                                    (@congr_arg.{1 1} rat (rat → Prop) a a_1 (@eq.{1} rat) e_1)
                                    e_2)
                                 (rat.mk (r.num)
                                    (@coe.{1 1} nat int
                                       (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                       (r.denom)))
                                 (rat.mk (r.num)
                                    (@coe.{1 1} nat int
                                       (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                       (r.denom)))
                                 (@eq.refl.{1} rat
                                    (rat.mk (r.num)
                                       (@coe.{1 1} nat int
                                          (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                          (r.denom))))
                                 (rat.mk ?m_4 ?m_5)
                                 (@has_zero.zero.{0} rat rat.has_zero)
                                 (@eq.trans.{1} rat (rat.mk ?m_4 ?m_5)
                                    (rat.mk (@has_zero.zero.{0} int int.has_zero) ?m_5)
                                    (@has_zero.zero.{0} rat rat.has_zero)
                                    ((λ (a a_1 : int) (e_1 : @eq.{1} int a a_1) (a_2 a_3 : int)
                                      (e_2 : @eq.{1} int a_2 a_3),
                                        @congr.{1 1} int rat (rat.mk a) (rat.mk a_1) a_2 a_3
                                          (@congr_arg.{1 1} int (int → rat) a a_1 rat.mk e_1)
                                          e_2)
                                       ?m_4
                                       (@has_zero.zero.{0} int int.has_zero)
                                       hn
                                       ?m_5
                                       ?m_5
                                       (@eq.refl.{1} int ?m_5))
                                    (rat.zero_mk ?m_5)))
                              (@propext
                                 (@eq.{1} rat
                                    (rat.mk (r.num)
                                       (@coe.{1 1} nat int
                                          (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                          (r.denom)))
                                    (@has_zero.zero.{0} rat rat.has_zero))
                                 false
                                 (@iff_false_intro
                                    (@eq.{1} rat
                                       (rat.mk (r.num)
                                          (@coe.{1 1} nat int
                                             (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                             (r.denom)))
                                       (@has_zero.zero.{0} rat rat.has_zero))
                                    hr&#x27;)))
                           ?m_6))))))
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
          (@roption.get.{0} nat
             (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                ?m_5)
             (@iff.mpr
                (@multiplicity.finite.{0} int int.comm_semiring
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   ?m_5)
                (and
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int ?m_5 (@has_zero.zero.{0} int int.has_zero)))
                (@multiplicity.finite_int_iff
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   ?m_5)
                (@and.intro
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int ?m_5 (@has_zero.zero.{0} int int.has_zero))
                   (@ne.symm.{1} nat (@has_one.one.{0} nat nat.has_one)
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@ne_of_lt.{0} nat
                         (@partial_order.to_preorder.{0} nat
                            (@ordered_comm_monoid.to_partial_order.{0} nat
                               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
                         (@has_one.one.{0} nat nat.has_one)
                         (int.nat_abs
                            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                         (@nat.prime.one_lt p p_prime)))
                   (λ (hd : @eq.{1} int ?m_5 (@has_zero.zero.{0} int int.has_zero)),
                      false.rec.{0} false
                        (@eq.mp.{0}
                           (@eq.{1} rat
                              (rat.mk (r.num)
                                 (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                    (r.denom)))
                              (rat.mk ?m_4 ?m_5))
                           false
                           (@eq.trans.{1} Prop
                              (@eq.{1} rat
                                 (rat.mk (r.num)
                                    (@coe.{1 1} nat int
                                       (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                       (r.denom)))
                                 (rat.mk ?m_4 ?m_5))
                              (@eq.{1} rat
                                 (rat.mk (r.num)
                                    (@coe.{1 1} nat int
                                       (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                       (r.denom)))
                                 (@has_zero.zero.{0} rat rat.has_zero))
                              false
                              ((λ (a a_1 : rat) (e_1 : @eq.{1} rat a a_1) (a_2 a_3 : rat) (e_2 : @eq.{1} rat a_2 a_3),
                                  @congr.{1 1} rat Prop (@eq.{1} rat a) (@eq.{1} rat a_1) a_2 a_3
                                    (@congr_arg.{1 1} rat (rat → Prop) a a_1 (@eq.{1} rat) e_1)
                                    e_2)
                                 (rat.mk (r.num)
                                    (@coe.{1 1} nat int
                                       (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                       (r.denom)))
                                 (rat.mk (r.num)
                                    (@coe.{1 1} nat int
                                       (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                       (r.denom)))
                                 (@eq.refl.{1} rat
                                    (rat.mk (r.num)
                                       (@coe.{1 1} nat int
                                          (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                          (r.denom))))
                                 (rat.mk ?m_4 ?m_5)
                                 (@has_zero.zero.{0} rat rat.has_zero)
                                 (@eq.trans.{1} rat (rat.mk ?m_4 ?m_5)
                                    (rat.mk ?m_4 (@has_zero.zero.{0} int int.has_zero))
                                    (@has_zero.zero.{0} rat rat.has_zero)
                                    ((λ (a a_1 : int) (e_1 : @eq.{1} int a a_1) (a_2 a_3 : int)
                                      (e_2 : @eq.{1} int a_2 a_3),
                                        @congr.{1 1} int rat (rat.mk a) (rat.mk a_1) a_2 a_3
                                          (@congr_arg.{1 1} int (int → rat) a a_1 rat.mk e_1)
                                          e_2)
                                       ?m_4
                                       ?m_4
                                       (@eq.refl.{1} int ?m_4)
                                       ?m_5
                                       (@has_zero.zero.{0} int int.has_zero)
                                       hd)
                                    (rat.mk_zero ?m_4)))
                              (@propext
                                 (@eq.{1} rat
                                    (rat.mk (r.num)
                                       (@coe.{1 1} nat int
                                          (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                          (r.denom)))
                                    (@has_zero.zero.{0} rat rat.has_zero))
                                 false
                                 (@iff_false_intro
                                    (@eq.{1} rat
                                       (rat.mk (r.num)
                                          (@coe.{1 1} nat int
                                             (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                             (r.denom)))
                                       (@has_zero.zero.{0} rat rat.has_zero))
                                    hr&#x27;)))
                           ?m_6)))))))

p : nat,
p_prime : nat.prime p,
q r : rat,
hq : @ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero),
hr : @ne.{1} rat r (@has_zero.zero.{0} rat rat.has_zero),
this :
  @eq.{1} rat (@has_mul.mul.{0} rat rat.has_mul q r)
    (rat.mk (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
       (@has_mul.mul.{0} int int.has_mul
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))),
hq&#x27; :
  @ne.{1} rat
    (rat.mk (q.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))
    (@has_zero.zero.{0} rat rat.has_zero),
hr&#x27; :
  @ne.{1} rat
    (rat.mk (r.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
    (@has_zero.zero.{0} rat rat.has_zero),
hp&#x27; :
  @prime.{0} int int.comm_semiring
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
| rat.mk (r.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom))

p : nat,
p_prime : nat.prime p,
q r : rat,
hq : @ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero),
hr : @ne.{1} rat r (@has_zero.zero.{0} rat rat.has_zero),
this :
  @eq.{1} rat (@has_mul.mul.{0} rat rat.has_mul q r)
    (rat.mk (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
       (@has_mul.mul.{0} int int.has_mul
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))),
hq&#x27; :
  @ne.{1} rat
    (rat.mk (q.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))
    (@has_zero.zero.{0} rat rat.has_zero),
hr&#x27; :
  @ne.{1} rat
    (rat.mk (r.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
    (@has_zero.zero.{0} rat rat.has_zero),
hp&#x27; :
  @prime.{0} int int.comm_semiring
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
⊢ int

p : nat,
p_prime : nat.prime p,
q r : rat,
hq : @ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero),
hr : @ne.{1} rat r (@has_zero.zero.{0} rat rat.has_zero),
this :
  @eq.{1} rat (@has_mul.mul.{0} rat rat.has_mul q r)
    (rat.mk (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
       (@has_mul.mul.{0} int int.has_mul
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))),
hq&#x27; :
  @ne.{1} rat
    (rat.mk (q.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))
    (@has_zero.zero.{0} rat rat.has_zero),
hr&#x27; :
  @ne.{1} rat
    (rat.mk (r.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
    (@has_zero.zero.{0} rat rat.has_zero),
hp&#x27; :
  @prime.{0} int int.comm_semiring
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
⊢ int

p : nat,
p_prime : nat.prime p,
q r : rat,
hq : @ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero),
hr : @ne.{1} rat r (@has_zero.zero.{0} rat rat.has_zero),
this :
  @eq.{1} rat (@has_mul.mul.{0} rat rat.has_mul q r)
    (rat.mk (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
       (@has_mul.mul.{0} int int.has_mul
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))),
hq&#x27; :
  @ne.{1} rat
    (rat.mk (q.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))
    (@has_zero.zero.{0} rat rat.has_zero),
hr&#x27; :
  @ne.{1} rat
    (rat.mk (r.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
    (@has_zero.zero.{0} rat rat.has_zero),
hp&#x27; :
  @prime.{0} int int.comm_semiring
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
| rat.mk (q.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))

p : nat,
p_prime : nat.prime p,
q r : rat,
hq : @ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero),
hr : @ne.{1} rat r (@has_zero.zero.{0} rat rat.has_zero),
this :
  @eq.{1} rat (@has_mul.mul.{0} rat rat.has_mul q r)
    (rat.mk (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
       (@has_mul.mul.{0} int int.has_mul
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))),
hq&#x27; :
  @ne.{1} rat
    (rat.mk (q.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))
    (@has_zero.zero.{0} rat rat.has_zero),
hr&#x27; :
  @ne.{1} rat
    (rat.mk (r.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
    (@has_zero.zero.{0} rat rat.has_zero),
hp&#x27; :
  @prime.{0} int int.comm_semiring
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
⊢ int

p : nat,
p_prime : nat.prime p,
q r : rat,
hq : @ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero),
hr : @ne.{1} rat r (@has_zero.zero.{0} rat rat.has_zero),
this :
  @eq.{1} rat (@has_mul.mul.{0} rat rat.has_mul q r)
    (rat.mk (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
       (@has_mul.mul.{0} int int.has_mul
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))),
hq&#x27; :
  @ne.{1} rat
    (rat.mk (q.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))
    (@has_zero.zero.{0} rat rat.has_zero),
hr&#x27; :
  @ne.{1} rat
    (rat.mk (r.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
    (@has_zero.zero.{0} rat rat.has_zero),
hp&#x27; :
  @prime.{0} int int.comm_semiring
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
⊢ int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
p_prime : nat.prime p,
q r : rat,
hq : @ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero),
hr : @ne.{1} rat r (@has_zero.zero.{0} rat rat.has_zero),
this :
  @eq.{1} rat (@has_mul.mul.{0} rat rat.has_mul q r)
    (rat.mk (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
       (@has_mul.mul.{0} int int.has_mul
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))),
hq&#x27; :
  @ne.{1} rat
    (rat.mk (q.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))
    (@has_zero.zero.{0} rat rat.has_zero),
hr&#x27; :
  @ne.{1} rat
    (rat.mk (r.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
    (@has_zero.zero.{0} rat rat.has_zero),
hp&#x27; :
  @prime.{0} int int.comm_semiring
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
⊢ @eq.{1} int
    (@has_sub.sub.{0} int int.has_sub
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
          (@roption.get.{0} nat
             (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                (@has_mul.mul.{0} int int.has_mul (q.num) (r.num)))
             (@iff.mpr
                (@multiplicity.finite.{0} int int.comm_semiring
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   (@has_mul.mul.{0} int int.has_mul (q.num) (r.num)))
                (and
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
                      (@has_zero.zero.{0} int int.has_zero)))
                (@multiplicity.finite_int_iff
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   (@has_mul.mul.{0} int int.has_mul (q.num) (r.num)))
                (@and.intro
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
                      (@has_zero.zero.{0} int int.has_zero))
                   (@ne.symm.{1} nat (@has_one.one.{0} nat nat.has_one)
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@ne_of_lt.{0} nat
                         (@partial_order.to_preorder.{0} nat
                            (@ordered_comm_monoid.to_partial_order.{0} nat
                               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
                         (@has_one.one.{0} nat nat.has_one)
                         (int.nat_abs
                            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                         (@nat.prime.one_lt p p_prime)))
                   (λ
                    (hn :
                      @eq.{1} int (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
                        (@has_zero.zero.{0} int int.has_zero)),
                      false.rec.{0} false
                        (@eq.mp.{0}
                           (@eq.{1} rat
                              (@has_mul.mul.{0} rat
                                 (@no_zero_divisors.to_has_mul.{0} rat
                                    (@integral_domain.to_no_zero_divisors.{0} rat rat.integral_domain))
                                 q
                                 r)
                              (rat.mk (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
                                 (@has_mul.mul.{0} int int.has_mul
                                    (@coe.{1 1} nat int
                                       (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                       (q.denom))
                                    (@coe.{1 1} nat int
                                       (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                       (r.denom)))))
                           false
                           (@eq.trans.{1} Prop
                              (@eq.{1} rat
                                 (@has_mul.mul.{0} rat
                                    (@no_zero_divisors.to_has_mul.{0} rat
                                       (@integral_domain.to_no_zero_divisors.{0} rat rat.integral_domain))
                                    q
                                    r)
                                 (rat.mk (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
                                    (@has_mul.mul.{0} int int.has_mul
                                       (@coe.{1 1} nat int
                                          (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                          (q.denom))
                                       (@coe.{1 1} nat int
                                          (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                          (r.denom)))))
                              (@eq.{1} rat
                                 (@has_mul.mul.{0} rat
                                    (@no_zero_divisors.to_has_mul.{0} rat
                                       (@integral_domain.to_no_zero_divisors.{0} rat rat.integral_domain))
                                    q
                                    r)
                                 (@has_zero.zero.{0} rat rat.has_zero))
                              false
                              ((λ (a a_1 : rat) (e_1 : @eq.{1} rat a a_1) (a_2 a_3 : rat) (e_2 : @eq.{1} rat a_2 a_3),
                                  @congr.{1 1} rat Prop (@eq.{1} rat a) (@eq.{1} rat a_1) a_2 a_3
                                    (@congr_arg.{1 1} rat (rat → Prop) a a_1 (@eq.{1} rat) e_1)
                                    e_2)
                                 (@has_mul.mul.{0} rat
                                    (@no_zero_divisors.to_has_mul.{0} rat
                                       (@integral_domain.to_no_zero_divisors.{0} rat rat.integral_domain))
                                    q
                                    r)
                                 (@has_mul.mul.{0} rat
                                    (@no_zero_divisors.to_has_mul.{0} rat
                                       (@integral_domain.to_no_zero_divisors.{0} rat rat.integral_domain))
                                    q
                                    r)
                                 (@eq.refl.{1} rat
                                    (@has_mul.mul.{0} rat
                                       (@no_zero_divisors.to_has_mul.{0} rat
                                          (@integral_domain.to_no_zero_divisors.{0} rat rat.integral_domain))
                                       q
                                       r))
                                 (rat.mk (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
                                    (@has_mul.mul.{0} int int.has_mul
                                       (@coe.{1 1} nat int
                                          (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                          (q.denom))
                                       (@coe.{1 1} nat int
                                          (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                          (r.denom))))
                                 (@has_zero.zero.{0} rat rat.has_zero)
                                 (@eq.trans.{1} rat
                                    (rat.mk (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
                                       (@has_mul.mul.{0} int int.has_mul
                                          (@coe.{1 1} nat int
                                             (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                             (q.denom))
                                          (@coe.{1 1} nat int
                                             (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                             (r.denom))))
                                    (rat.mk (@has_zero.zero.{0} int int.has_zero)
                                       (@has_mul.mul.{0} int int.has_mul
                                          (@coe.{1 1} nat int
                                             (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                             (q.denom))
                                          (@coe.{1 1} nat int
                                             (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                             (r.denom))))
                                    (@has_zero.zero.{0} rat rat.has_zero)
                                    ((λ (a a_1 : int) (e_1 : @eq.{1} int a a_1) (a_2 a_3 : int)
                                      (e_2 : @eq.{1} int a_2 a_3),
                                        @congr.{1 1} int rat (rat.mk a) (rat.mk a_1) a_2 a_3
                                          (@congr_arg.{1 1} int (int → rat) a a_1 rat.mk e_1)
                                          e_2)
                                       (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
                                       (@has_zero.zero.{0} int int.has_zero)
                                       hn
                                       (@has_mul.mul.{0} int int.has_mul
                                          (@coe.{1 1} nat int
                                             (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                             (q.denom))
                                          (@coe.{1 1} nat int
                                             (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                             (r.denom)))
                                       (@has_mul.mul.{0} int int.has_mul
                                          (@coe.{1 1} nat int
                                             (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                             (q.denom))
                                          (@coe.{1 1} nat int
                                             (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                             (r.denom)))
                                       (@eq.refl.{1} int
                                          (@has_mul.mul.{0} int int.has_mul
                                             (@coe.{1 1} nat int
                                                (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                                (q.denom))
                                             (@coe.{1 1} nat int
                                                (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                                (r.denom)))))
                                    (rat.zero_mk
                                       (@has_mul.mul.{0} int int.has_mul
                                          (@coe.{1 1} nat int
                                             (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                             (q.denom))
                                          (@coe.{1 1} nat int
                                             (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                             (r.denom))))))
                              (@propext
                                 (@eq.{1} rat
                                    (@has_mul.mul.{0} rat
                                       (@no_zero_divisors.to_has_mul.{0} rat
                                          (@integral_domain.to_no_zero_divisors.{0} rat rat.integral_domain))
                                       q
                                       r)
                                    (@has_zero.zero.{0} rat rat.has_zero))
                                 false
                                 (@iff_false_intro
                                    (@eq.{1} rat
                                       (@has_mul.mul.{0} rat
                                          (@no_zero_divisors.to_has_mul.{0} rat
                                             (@integral_domain.to_no_zero_divisors.{0} rat rat.integral_domain))
                                          q
                                          r)
                                       (@has_zero.zero.{0} rat rat.has_zero))
                                    (@mul_ne_zero.{0} rat rat.integral_domain q r hq hr))))
                           this))))))
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
          (@roption.get.{0} nat
             (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                (@has_mul.mul.{0} int int.has_mul
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom))))
             (@iff.mpr
                (@multiplicity.finite.{0} int int.comm_semiring
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   (@has_mul.mul.{0} int int.has_mul
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                         (r.denom))))
                (and
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int
                      (@has_mul.mul.{0} int int.has_mul
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                            (q.denom))
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                            (r.denom)))
                      (@has_zero.zero.{0} int int.has_zero)))
                (@multiplicity.finite_int_iff
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   (@has_mul.mul.{0} int int.has_mul
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                         (r.denom))))
                (@and.intro
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int
                      (@has_mul.mul.{0} int int.has_mul
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                            (q.denom))
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                            (r.denom)))
                      (@has_zero.zero.{0} int int.has_zero))
                   (@ne.symm.{1} nat (@has_one.one.{0} nat nat.has_one)
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@ne_of_lt.{0} nat
                         (@partial_order.to_preorder.{0} nat
                            (@ordered_comm_monoid.to_partial_order.{0} nat
                               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
                         (@has_one.one.{0} nat nat.has_one)
                         (int.nat_abs
                            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                         (@nat.prime.one_lt p p_prime)))
                   (λ
                    (hd :
                      @eq.{1} int
                        (@has_mul.mul.{0} int int.has_mul
                           (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                              (q.denom))
                           (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                              (r.denom)))
                        (@has_zero.zero.{0} int int.has_zero)),
                      false.rec.{0} false
                        (@eq.mp.{0}
                           (@eq.{1} rat
                              (@has_mul.mul.{0} rat
                                 (@no_zero_divisors.to_has_mul.{0} rat
                                    (@integral_domain.to_no_zero_divisors.{0} rat rat.integral_domain))
                                 q
                                 r)
                              (rat.mk (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
                                 (@has_mul.mul.{0} int int.has_mul
                                    (@coe.{1 1} nat int
                                       (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                       (q.denom))
                                    (@coe.{1 1} nat int
                                       (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                       (r.denom)))))
                           false
                           (@eq.trans.{1} Prop
                              (@eq.{1} rat
                                 (@has_mul.mul.{0} rat
                                    (@no_zero_divisors.to_has_mul.{0} rat
                                       (@integral_domain.to_no_zero_divisors.{0} rat rat.integral_domain))
                                    q
                                    r)
                                 (rat.mk (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
                                    (@has_mul.mul.{0} int int.has_mul
                                       (@coe.{1 1} nat int
                                          (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                          (q.denom))
                                       (@coe.{1 1} nat int
                                          (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                          (r.denom)))))
                              (@eq.{1} rat
                                 (@has_mul.mul.{0} rat
                                    (@no_zero_divisors.to_has_mul.{0} rat
                                       (@integral_domain.to_no_zero_divisors.{0} rat rat.integral_domain))
                                    q
                                    r)
                                 (@has_zero.zero.{0} rat rat.has_zero))
                              false
                              ((λ (a a_1 : rat) (e_1 : @eq.{1} rat a a_1) (a_2 a_3 : rat) (e_2 : @eq.{1} rat a_2 a_3),
                                  @congr.{1 1} rat Prop (@eq.{1} rat a) (@eq.{1} rat a_1) a_2 a_3
                                    (@congr_arg.{1 1} rat (rat → Prop) a a_1 (@eq.{1} rat) e_1)
                                    e_2)
                                 (@has_mul.mul.{0} rat
                                    (@no_zero_divisors.to_has_mul.{0} rat
                                       (@integral_domain.to_no_zero_divisors.{0} rat rat.integral_domain))
                                    q
                                    r)
                                 (@has_mul.mul.{0} rat
                                    (@no_zero_divisors.to_has_mul.{0} rat
                                       (@integral_domain.to_no_zero_divisors.{0} rat rat.integral_domain))
                                    q
                                    r)
                                 (@eq.refl.{1} rat
                                    (@has_mul.mul.{0} rat
                                       (@no_zero_divisors.to_has_mul.{0} rat
                                          (@integral_domain.to_no_zero_divisors.{0} rat rat.integral_domain))
                                       q
                                       r))
                                 (rat.mk (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
                                    (@has_mul.mul.{0} int int.has_mul
                                       (@coe.{1 1} nat int
                                          (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                          (q.denom))
                                       (@coe.{1 1} nat int
                                          (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                          (r.denom))))
                                 (@has_zero.zero.{0} rat rat.has_zero)
                                 (@eq.trans.{1} rat
                                    (rat.mk (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
                                       (@has_mul.mul.{0} int int.has_mul
                                          (@coe.{1 1} nat int
                                             (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                             (q.denom))
                                          (@coe.{1 1} nat int
                                             (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                             (r.denom))))
                                    (rat.mk (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
                                       (@has_zero.zero.{0} int int.has_zero))
                                    (@has_zero.zero.{0} rat rat.has_zero)
                                    ((λ (a a_1 : int) (e_1 : @eq.{1} int a a_1) (a_2 a_3 : int)
                                      (e_2 : @eq.{1} int a_2 a_3),
                                        @congr.{1 1} int rat (rat.mk a) (rat.mk a_1) a_2 a_3
                                          (@congr_arg.{1 1} int (int → rat) a a_1 rat.mk e_1)
                                          e_2)
                                       (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
                                       (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
                                       (@eq.refl.{1} int (@has_mul.mul.{0} int int.has_mul (q.num) (r.num)))
                                       (@has_mul.mul.{0} int int.has_mul
                                          (@coe.{1 1} nat int
                                             (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                             (q.denom))
                                          (@coe.{1 1} nat int
                                             (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                             (r.denom)))
                                       (@has_zero.zero.{0} int int.has_zero)
                                       hd)
                                    (rat.mk_zero (@has_mul.mul.{0} int int.has_mul (q.num) (r.num)))))
                              (@propext
                                 (@eq.{1} rat
                                    (@has_mul.mul.{0} rat
                                       (@no_zero_divisors.to_has_mul.{0} rat
                                          (@integral_domain.to_no_zero_divisors.{0} rat rat.integral_domain))
                                       q
                                       r)
                                    (@has_zero.zero.{0} rat rat.has_zero))
                                 false
                                 (@iff_false_intro
                                    (@eq.{1} rat
                                       (@has_mul.mul.{0} rat
                                          (@no_zero_divisors.to_has_mul.{0} rat
                                             (@integral_domain.to_no_zero_divisors.{0} rat rat.integral_domain))
                                          q
                                          r)
                                       (@has_zero.zero.{0} rat rat.has_zero))
                                    (@mul_ne_zero.{0} rat rat.integral_domain q r hq hr))))
                           this)))))))
    (@has_add.add.{0} int int.has_add
       (@has_sub.sub.{0} int int.has_sub
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
             (@roption.get.{0} nat
                (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   (q.num))
                (@iff.mpr
                   (@multiplicity.finite.{0} int int.comm_semiring
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                      (q.num))
                   (and
                      (@ne.{1} nat
                         (int.nat_abs
                            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                         (@has_one.one.{0} nat nat.has_one))
                      (@ne.{1} int (q.num) (@has_zero.zero.{0} int int.has_zero)))
                   (@multiplicity.finite_int_iff
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                      (q.num))
                   (@and.intro
                      (@ne.{1} nat
                         (int.nat_abs
                            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                         (@has_one.one.{0} nat nat.has_one))
                      (@ne.{1} int (q.num) (@has_zero.zero.{0} int int.has_zero))
                      (@ne.symm.{1} nat (@has_one.one.{0} nat nat.has_one)
                         (int.nat_abs
                            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                         (@ne_of_lt.{0} nat
                            (@partial_order.to_preorder.{0} nat
                               (@ordered_comm_monoid.to_partial_order.{0} nat
                                  (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                                     (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
                            (@has_one.one.{0} nat nat.has_one)
                            (int.nat_abs
                               (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                  p))
                            (@nat.prime.one_lt p p_prime)))
                      (λ (hn : @eq.{1} int (q.num) (@has_zero.zero.{0} int int.has_zero)),
                         false.rec.{0} false
                           (@eq.mp.{0}
                              (@eq.{1} rat
                                 (rat.mk (q.num)
                                    (@coe.{1 1} nat int
                                       (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                       (q.denom)))
                                 (rat.mk (q.num)
                                    (@coe.{1 1} nat int
                                       (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                       (q.denom))))
                              false
                              (@eq.trans.{1} Prop
                                 (@eq.{1} rat
                                    (rat.mk (q.num)
                                       (@coe.{1 1} nat int
                                          (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                          (q.denom)))
                                    (rat.mk (q.num)
                                       (@coe.{1 1} nat int
                                          (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                          (q.denom))))
                                 (@eq.{1} rat
                                    (rat.mk (q.num)
                                       (@coe.{1 1} nat int
                                          (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                          (q.denom)))
                                    (@has_zero.zero.{0} rat rat.has_zero))
                                 false
                                 ((λ (a a_1 : rat) (e_1 : @eq.{1} rat a a_1) (a_2 a_3 : rat)
                                   (e_2 : @eq.{1} rat a_2 a_3),
                                     @congr.{1 1} rat Prop (@eq.{1} rat a) (@eq.{1} rat a_1) a_2 a_3
                                       (@congr_arg.{1 1} rat (rat → Prop) a a_1 (@eq.{1} rat) e_1)
                                       e_2)
                                    (rat.mk (q.num)
                                       (@coe.{1 1} nat int
                                          (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                          (q.denom)))
                                    (rat.mk (q.num)
                                       (@coe.{1 1} nat int
                                          (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                          (q.denom)))
                                    (@eq.refl.{1} rat
                                       (rat.mk (q.num)
                                          (@coe.{1 1} nat int
                                             (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                             (q.denom))))
                                    (rat.mk (q.num)
                                       (@coe.{1 1} nat int
                                          (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                          (q.denom)))
                                    (@has_zero.zero.{0} rat rat.has_zero)
                                    (@eq.trans.{1} rat
                                       (rat.mk (q.num)
                                          (@coe.{1 1} nat int
                                             (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                             (q.denom)))
                                       (rat.mk (@has_zero.zero.{0} int int.has_zero)
                                          (@coe.{1 1} nat int
                                             (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                             (q.denom)))
                                       (@has_zero.zero.{0} rat rat.has_zero)
                                       ((λ (a a_1 : int) (e_1 : @eq.{1} int a a_1) (a_2 a_3 : int)
                                         (e_2 : @eq.{1} int a_2 a_3),
                                           @congr.{1 1} int rat (rat.mk a) (rat.mk a_1) a_2 a_3
                                             (@congr_arg.{1 1} int (int → rat) a a_1 rat.mk e_1)
                                             e_2)
                                          (q.num)
                                          (@has_zero.zero.{0} int int.has_zero)
                                          hn
                                          (@coe.{1 1} nat int
                                             (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                             (q.denom))
                                          (@coe.{1 1} nat int
                                             (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                             (q.denom))
                                          (@eq.refl.{1} int
                                             (@coe.{1 1} nat int
                                                (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                                (q.denom))))
                                       (rat.zero_mk
                                          (@coe.{1 1} nat int
                                             (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                             (q.denom)))))
                                 (@propext
                                    (@eq.{1} rat
                                       (rat.mk (q.num)
                                          (@coe.{1 1} nat int
                                             (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                             (q.denom)))
                                       (@has_zero.zero.{0} rat rat.has_zero))
                                    false
                                    (@iff_false_intro
                                       (@eq.{1} rat
                                          (rat.mk (q.num)
                                             (@coe.{1 1} nat int
                                                (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                                (q.denom)))
                                          (@has_zero.zero.{0} rat rat.has_zero))
                                       hq&#x27;)))
                              (@eq.refl.{1} rat
                                 (rat.mk (q.num)
                                    (@coe.{1 1} nat int
                                       (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                       (q.denom))))))))))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
             (@roption.get.{0} nat
                (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))
                (@iff.mpr
                   (@multiplicity.finite.{0} int int.comm_semiring
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))
                   (and
                      (@ne.{1} nat
                         (int.nat_abs
                            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                         (@has_one.one.{0} nat nat.has_one))
                      (@ne.{1} int
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                            (q.denom))
                         (@has_zero.zero.{0} int int.has_zero)))
                   (@multiplicity.finite_int_iff
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))
                   (@and.intro
                      (@ne.{1} nat
                         (int.nat_abs
                            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                         (@has_one.one.{0} nat nat.has_one))
                      (@ne.{1} int
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                            (q.denom))
                         (@has_zero.zero.{0} int int.has_zero))
                      (@ne.symm.{1} nat (@has_one.one.{0} nat nat.has_one)
                         (int.nat_abs
                            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                         (@ne_of_lt.{0} nat
                            (@partial_order.to_preorder.{0} nat
                               (@ordered_comm_monoid.to_partial_order.{0} nat
                                  (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                                     (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
                            (@has_one.one.{0} nat nat.has_one)
                            (int.nat_abs
                               (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                  p))
                            (@nat.prime.one_lt p p_prime)))
                      (λ
                       (hd :
                         @eq.{1} int
                           (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                              (q.denom))
                           (@has_zero.zero.{0} int int.has_zero)),
                         false.rec.{0} false
                           (@eq.mp.{0}
                              (@eq.{1} rat
                                 (rat.mk (q.num)
                                    (@coe.{1 1} nat int
                                       (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                       (q.denom)))
                                 (rat.mk (q.num)
                                    (@coe.{1 1} nat int
                                       (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                       (q.denom))))
                              false
                              (@eq.trans.{1} Prop
                                 (@eq.{1} rat
                                    (rat.mk (q.num)
                                       (@coe.{1 1} nat int
                                          (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                          (q.denom)))
                                    (rat.mk (q.num)
                                       (@coe.{1 1} nat int
                                          (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                          (q.denom))))
                                 (@eq.{1} rat
                                    (rat.mk (q.num)
                                       (@coe.{1 1} nat int
                                          (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                          (q.denom)))
                                    (@has_zero.zero.{0} rat rat.has_zero))
                                 false
                                 ((λ (a a_1 : rat) (e_1 : @eq.{1} rat a a_1) (a_2 a_3 : rat)
                                   (e_2 : @eq.{1} rat a_2 a_3),
                                     @congr.{1 1} rat Prop (@eq.{1} rat a) (@eq.{1} rat a_1) a_2 a_3
                                       (@congr_arg.{1 1} rat (rat → Prop) a a_1 (@eq.{1} rat) e_1)
                                       e_2)
                                    (rat.mk (q.num)
                                       (@coe.{1 1} nat int
                                          (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                          (q.denom)))
                                    (rat.mk (q.num)
                                       (@coe.{1 1} nat int
                                          (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                          (q.denom)))
                                    (@eq.refl.{1} rat
                                       (rat.mk (q.num)
                                          (@coe.{1 1} nat int
                                             (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                             (q.denom))))
                                    (rat.mk (q.num)
                                       (@coe.{1 1} nat int
                                          (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                          (q.denom)))
                                    (@has_zero.zero.{0} rat rat.has_zero)
                                    (@eq.trans.{1} rat
                                       (rat.mk (q.num)
                                          (@coe.{1 1} nat int
                                             (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                             (q.denom)))
                                       (rat.mk (q.num) (@has_zero.zero.{0} int int.has_zero))
                                       (@has_zero.zero.{0} rat rat.has_zero)
                                       ((λ (a a_1 : int) (e_1 : @eq.{1} int a a_1) (a_2 a_3 : int)
                                         (e_2 : @eq.{1} int a_2 a_3),
                                           @congr.{1 1} int rat (rat.mk a) (rat.mk a_1) a_2 a_3
                                             (@congr_arg.{1 1} int (int → rat) a a_1 rat.mk e_1)
                                             e_2)
                                          (q.num)
                                          (q.num)
                                          (@eq.refl.{1} int (q.num))
                                          (@coe.{1 1} nat int
                                             (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                             (q.denom))
                                          (@has_zero.zero.{0} int int.has_zero)
                                          hd)
                                       (rat.mk_zero (q.num))))
                                 (@propext
                                    (@eq.{1} rat
                                       (rat.mk (q.num)
                                          (@coe.{1 1} nat int
                                             (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                             (q.denom)))
                                       (@has_zero.zero.{0} rat rat.has_zero))
                                    false
                                    (@iff_false_intro
                                       (@eq.{1} rat
                                          (rat.mk (q.num)
                                             (@coe.{1 1} nat int
                                                (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                                (q.denom)))
                                          (@has_zero.zero.{0} rat rat.has_zero))
                                       hq&#x27;)))
                              (@eq.refl.{1} rat
                                 (rat.mk (q.num)
                                    (@coe.{1 1} nat int
                                       (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                       (q.denom)))))))))))
       (@has_sub.sub.{0} int int.has_sub
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
             (@roption.get.{0} nat
                (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   (r.num))
                (@iff.mpr
                   (@multiplicity.finite.{0} int int.comm_semiring
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                      (r.num))
                   (and
                      (@ne.{1} nat
                         (int.nat_abs
                            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                         (@has_one.one.{0} nat nat.has_one))
                      (@ne.{1} int (r.num) (@has_zero.zero.{0} int int.has_zero)))
                   (@multiplicity.finite_int_iff
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                      (r.num))
                   (@and.intro
                      (@ne.{1} nat
                         (int.nat_abs
                            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                         (@has_one.one.{0} nat nat.has_one))
                      (@ne.{1} int (r.num) (@has_zero.zero.{0} int int.has_zero))
                      (… … …)
                      …))))
          …))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>157    rw [multiplicity.mul&#x27; hp&#x27;, multiplicity.mul&#x27; hp&#x27;]; simp</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='multiplicity.mul&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hp&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='multiplicity.mul&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hp&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/ring_theory/multiplicity.lean&#x27;, &#x27;line&#x27;: 302, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/ring_theory/multiplicity.lean&#x27;, &#x27;line&#x27;: 302, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : integral_domain.{0} α] [_inst_2 : @decidable_rel.{1} α (@has_dvd.dvd.{0} α (@comm_semiring_has_dvd.{0} α (@nonzero_comm_semiring.to_comm_semiring.{0} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} α (@integral_domain.to_nonzero_comm_ring.{0} α _inst_1)))))] {p a b : α} (hp : @prime.{0} α (@nonzero_comm_semiring.to_comm_semiring.{0} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} α (@integral_domain.to_nonzero_comm_ring.{0} α _inst_1))) p) (h : @roption.dom.{0} nat (@multiplicity.{0} α (@nonzero_comm_semiring.to_comm_semiring.{0} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} α (@integral_domain.to_nonzero_comm_ring.{0} α _inst_1))) (λ (a b : α), _inst_2 a b) p (@has_mul.mul.{0} α (@no_zero_divisors.to_has_mul.{0} α (@domain.to_no_zero_divisors.{0} α (@integral_domain.to_domain.{0} α _inst_1))) a b))), @eq.{1} nat (@roption.get.{0} nat (@multiplicity.{0} α (@nonzero_comm_semiring.to_comm_semiring.{0} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} α (@integral_domain.to_nonzero_comm_ring.{0} α _inst_1))) (λ (a b : α), _inst_2 a b) p (@has_mul.mul.{0} α (@no_zero_divisors.to_has_mul.{0} α (@domain.to_no_zero_divisors.{0} α (@integral_domain.to_domain.{0} α _inst_1))) a b)) h) (@has_add.add.{0} nat nat.has_add (@roption.get.{0} nat (@multiplicity.{0} α (@nonzero_comm_semiring.to_comm_semiring.{0} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} α (@integral_domain.to_nonzero_comm_ring.{0} α _inst_1))) (λ (a b : α), _inst_2 a b) p a) (@and.left (@multiplicity.finite.{0} α (@nonzero_comm_semiring.to_comm_semiring.{0} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} α (@integral_domain.to_nonzero_comm_ring.{0} α _inst_1))) p a) (@multiplicity.finite.{0} α (@nonzero_comm_semiring.to_comm_semiring.{0} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} α (@integral_domain.to_nonzero_comm_ring.{0} α _inst_1))) p b) (@iff.mp (@multiplicity.finite.{0} α (@nonzero_comm_semiring.to_comm_semiring.{0} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} α (@integral_domain.to_nonzero_comm_ring.{0} α _inst_1))) p (@has_mul.mul.{0} α (@no_zero_divisors.to_has_mul.{0} α (@domain.to_no_zero_divisors.{0} α (@integral_domain.to_domain.{0} α _inst_1))) a b)) (and (@multiplicity.finite.{0} α (@nonzero_comm_semiring.to_comm_semiring.{0} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} α (@integral_domain.to_nonzero_comm_ring.{0} α _inst_1))) p a) (@multiplicity.finite.{0} α (@nonzero_comm_semiring.to_comm_semiring.{0} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} α (@integral_domain.to_nonzero_comm_ring.{0} α _inst_1))) p b)) (@multiplicity.finite_mul_iff.{0} α _inst_1 (λ (a b : α), _inst_2 a b) p a b hp) h))) (@roption.get.{0} nat (@multiplicity.{0} α (@nonzero_comm_semiring.to_comm_semiring.{0} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} α (@integral_domain.to_nonzero_comm_ring.{0} α _inst_1))) (λ (a b : α), _inst_2 a b) p b) (@and.right (@multiplicity.finite.{0} α (@nonzero_comm_semiring.to_comm_semiring.{0} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} α (@integral_domain.to_nonzero_comm_ring.{0} α _inst_1))) p a) (@multiplicity.finite.{0} α (@nonzero_comm_semiring.to_comm_semiring.{0} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} α (@integral_domain.to_nonzero_comm_ring.{0} α _inst_1))) p b) (@iff.mp (@multiplicity.finite.{0} α (@nonzero_comm_semiring.to_comm_semiring.{0} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} α (@integral_domain.to_nonzero_comm_ring.{0} α _inst_1))) p (@has_mul.mul.{0} α (@no_zero_divisors.to_has_mul.{0} α (@domain.to_no_zero_divisors.{0} α (@integral_domain.to_domain.{0} α _inst_1))) a b)) (and (@multiplicity.finite.{0} α (@nonzero_comm_semiring.to_comm_semiring.{0} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} α (@integral_domain.to_nonzero_comm_ring.{0} α _inst_1))) p a) (@multiplicity.finite.{0} α (@nonzero_comm_semiring.to_comm_semiring.{0} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} α (@integral_domain.to_nonzero_comm_ring.{0} α _inst_1))) p b)) (@multiplicity.finite_mul_iff.{0} α _inst_1 (λ (a b : α), _inst_2 a b) p a b hp) h))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@prime.{0} int int.comm_semiring (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : integral_domain.{0} α] [_inst_2 : @decidable_rel.{1} α (@has_dvd.dvd.{0} α (@comm_semiring_has_dvd.{0} α (@nonzero_comm_semiring.to_comm_semiring.{0} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} α (@integral_domain.to_nonzero_comm_ring.{0} α _inst_1)))))] {p a b : α} (hp : @prime.{0} α (@nonzero_comm_semiring.to_comm_semiring.{0} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} α (@integral_domain.to_nonzero_comm_ring.{0} α _inst_1))) p) (h : @roption.dom.{0} nat (@multiplicity.{0} α (@nonzero_comm_semiring.to_comm_semiring.{0} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} α (@integral_domain.to_nonzero_comm_ring.{0} α _inst_1))) (λ (a b : α), _inst_2 a b) p (@has_mul.mul.{0} α (@no_zero_divisors.to_has_mul.{0} α (@domain.to_no_zero_divisors.{0} α (@integral_domain.to_domain.{0} α _inst_1))) a b))), @eq.{1} nat (@roption.get.{0} nat (@multiplicity.{0} α (@nonzero_comm_semiring.to_comm_semiring.{0} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} α (@integral_domain.to_nonzero_comm_ring.{0} α _inst_1))) (λ (a b : α), _inst_2 a b) p (@has_mul.mul.{0} α (@no_zero_divisors.to_has_mul.{0} α (@domain.to_no_zero_divisors.{0} α (@integral_domain.to_domain.{0} α _inst_1))) a b)) h) (@has_add.add.{0} nat nat.has_add (@roption.get.{0} nat (@multiplicity.{0} α (@nonzero_comm_semiring.to_comm_semiring.{0} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} α (@integral_domain.to_nonzero_comm_ring.{0} α _inst_1))) (λ (a b : α), _inst_2 a b) p a) (@and.left (@multiplicity.finite.{0} α (@nonzero_comm_semiring.to_comm_semiring.{0} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} α (@integral_domain.to_nonzero_comm_ring.{0} α _inst_1))) p a) (@multiplicity.finite.{0} α (@nonzero_comm_semiring.to_comm_semiring.{0} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} α (@integral_domain.to_nonzero_comm_ring.{0} α _inst_1))) p b) (@iff.mp (@multiplicity.finite.{0} α (@nonzero_comm_semiring.to_comm_semiring.{0} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} α (@integral_domain.to_nonzero_comm_ring.{0} α _inst_1))) p (@has_mul.mul.{0} α (@no_zero_divisors.to_has_mul.{0} α (@domain.to_no_zero_divisors.{0} α (@integral_domain.to_domain.{0} α _inst_1))) a b)) (and (@multiplicity.finite.{0} α (@nonzero_comm_semiring.to_comm_semiring.{0} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} α (@integral_domain.to_nonzero_comm_ring.{0} α _inst_1))) p a) (@multiplicity.finite.{0} α (@nonzero_comm_semiring.to_comm_semiring.{0} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} α (@integral_domain.to_nonzero_comm_ring.{0} α _inst_1))) p b)) (@multiplicity.finite_mul_iff.{0} α _inst_1 (λ (a b : α), _inst_2 a b) p a b hp) h))) (@roption.get.{0} nat (@multiplicity.{0} α (@nonzero_comm_semiring.to_comm_semiring.{0} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} α (@integral_domain.to_nonzero_comm_ring.{0} α _inst_1))) (λ (a b : α), _inst_2 a b) p b) (@and.right (@multiplicity.finite.{0} α (@nonzero_comm_semiring.to_comm_semiring.{0} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} α (@integral_domain.to_nonzero_comm_ring.{0} α _inst_1))) p a) (@multiplicity.finite.{0} α (@nonzero_comm_semiring.to_comm_semiring.{0} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} α (@integral_domain.to_nonzero_comm_ring.{0} α _inst_1))) p b) (@iff.mp (@multiplicity.finite.{0} α (@nonzero_comm_semiring.to_comm_semiring.{0} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} α (@integral_domain.to_nonzero_comm_ring.{0} α _inst_1))) p (@has_mul.mul.{0} α (@no_zero_divisors.to_has_mul.{0} α (@domain.to_no_zero_divisors.{0} α (@integral_domain.to_domain.{0} α _inst_1))) a b)) (and (@multiplicity.finite.{0} α (@nonzero_comm_semiring.to_comm_semiring.{0} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} α (@integral_domain.to_nonzero_comm_ring.{0} α _inst_1))) p a) (@multiplicity.finite.{0} α (@nonzero_comm_semiring.to_comm_semiring.{0} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} α (@integral_domain.to_nonzero_comm_ring.{0} α _inst_1))) p b)) (@multiplicity.finite_mul_iff.{0} α _inst_1 (λ (a b : α), _inst_2 a b) p a b hp) h))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@prime.{0} int int.comm_semiring (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
p_prime : nat.prime p,
q r : rat,
hq : @ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero),
hr : @ne.{1} rat r (@has_zero.zero.{0} rat rat.has_zero),
this :
  @eq.{1} rat (@has_mul.mul.{0} rat rat.has_mul q r)
    (rat.mk (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
       (@has_mul.mul.{0} int int.has_mul
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))),
hq&#x27; :
  @ne.{1} rat
    (rat.mk (q.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))
    (@has_zero.zero.{0} rat rat.has_zero),
hr&#x27; :
  @ne.{1} rat
    (rat.mk (r.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
    (@has_zero.zero.{0} rat rat.has_zero),
hp&#x27; :
  @prime.{0} int int.comm_semiring
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
⊢ @eq.{1} int
    (@has_sub.sub.{0} int int.has_sub
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
          (@roption.get.{0} nat
             (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                (@has_mul.mul.{0} int int.has_mul (q.num) (r.num)))
             (@iff.mpr
                (@multiplicity.finite.{0} int int.comm_semiring
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   (@has_mul.mul.{0} int int.has_mul (q.num) (r.num)))
                (and
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
                      (@has_zero.zero.{0} int int.has_zero)))
                (@multiplicity.finite_int_iff
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   (@has_mul.mul.{0} int int.has_mul (q.num) (r.num)))
                (@and.intro
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
                      (@has_zero.zero.{0} int int.has_zero))
                   (@ne.symm.{1} nat (@has_one.one.{0} nat nat.has_one)
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@ne_of_lt.{0} nat
                         (@partial_order.to_preorder.{0} nat
                            (@ordered_comm_monoid.to_partial_order.{0} nat
                               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
                         (@has_one.one.{0} nat nat.has_one)
                         (int.nat_abs
                            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                         (@nat.prime.one_lt p p_prime)))
                   (λ
                    (hn :
                      @eq.{1} int (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
                        (@has_zero.zero.{0} int int.has_zero)),
                      false.rec.{0} false
                        (@eq.mp.{0}
                           (@eq.{1} rat
                              (@has_mul.mul.{0} rat
                                 (@no_zero_divisors.to_has_mul.{0} rat
                                    (@integral_domain.to_no_zero_divisors.{0} rat rat.integral_domain))
                                 q
                                 r)
                              (rat.mk (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
                                 (@has_mul.mul.{0} int int.has_mul
                                    (@coe.{1 1} nat int
                                       (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                       (q.denom))
                                    (@coe.{1 1} nat int
                                       (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                       (r.denom)))))
                           false
                           (@eq.trans.{1} Prop
                              (@eq.{1} rat
                                 (@has_mul.mul.{0} rat
                                    (@no_zero_divisors.to_has_mul.{0} rat
                                       (@integral_domain.to_no_zero_divisors.{0} rat rat.integral_domain))
                                    q
                                    r)
                                 (rat.mk (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
                                    (@has_mul.mul.{0} int int.has_mul
                                       (@coe.{1 1} nat int
                                          (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                          (q.denom))
                                       (@coe.{1 1} nat int
                                          (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                          (r.denom)))))
                              (@eq.{1} rat
                                 (@has_mul.mul.{0} rat
                                    (@no_zero_divisors.to_has_mul.{0} rat
                                       (@integral_domain.to_no_zero_divisors.{0} rat rat.integral_domain))
                                    q
                                    r)
                                 (@has_zero.zero.{0} rat rat.has_zero))
                              false
                              ((λ (a a_1 : rat) (e_1 : @eq.{1} rat a a_1) (a_2 a_3 : rat) (e_2 : @eq.{1} rat a_2 a_3),
                                  @congr.{1 1} rat Prop (@eq.{1} rat a) (@eq.{1} rat a_1) a_2 a_3
                                    (@congr_arg.{1 1} rat (rat → Prop) a a_1 (@eq.{1} rat) e_1)
                                    e_2)
                                 (@has_mul.mul.{0} rat
                                    (@no_zero_divisors.to_has_mul.{0} rat
                                       (@integral_domain.to_no_zero_divisors.{0} rat rat.integral_domain))
                                    q
                                    r)
                                 (@has_mul.mul.{0} rat
                                    (@no_zero_divisors.to_has_mul.{0} rat
                                       (@integral_domain.to_no_zero_divisors.{0} rat rat.integral_domain))
                                    q
                                    r)
                                 (@eq.refl.{1} rat
                                    (@has_mul.mul.{0} rat
                                       (@no_zero_divisors.to_has_mul.{0} rat
                                          (@integral_domain.to_no_zero_divisors.{0} rat rat.integral_domain))
                                       q
                                       r))
                                 (rat.mk (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
                                    (@has_mul.mul.{0} int int.has_mul
                                       (@coe.{1 1} nat int
                                          (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                          (q.denom))
                                       (@coe.{1 1} nat int
                                          (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                          (r.denom))))
                                 (@has_zero.zero.{0} rat rat.has_zero)
                                 (@eq.trans.{1} rat
                                    (rat.mk (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
                                       (@has_mul.mul.{0} int int.has_mul
                                          (@coe.{1 1} nat int
                                             (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                             (q.denom))
                                          (@coe.{1 1} nat int
                                             (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                             (r.denom))))
                                    (rat.mk (@has_zero.zero.{0} int int.has_zero)
                                       (@has_mul.mul.{0} int int.has_mul
                                          (@coe.{1 1} nat int
                                             (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                             (q.denom))
                                          (@coe.{1 1} nat int
                                             (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                             (r.denom))))
                                    (@has_zero.zero.{0} rat rat.has_zero)
                                    ((λ (a a_1 : int) (e_1 : @eq.{1} int a a_1) (a_2 a_3 : int)
                                      (e_2 : @eq.{1} int a_2 a_3),
                                        @congr.{1 1} int rat (rat.mk a) (rat.mk a_1) a_2 a_3
                                          (@congr_arg.{1 1} int (int → rat) a a_1 rat.mk e_1)
                                          e_2)
                                       (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
                                       (@has_zero.zero.{0} int int.has_zero)
                                       hn
                                       (@has_mul.mul.{0} int int.has_mul
                                          (@coe.{1 1} nat int
                                             (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                             (q.denom))
                                          (@coe.{1 1} nat int
                                             (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                             (r.denom)))
                                       (@has_mul.mul.{0} int int.has_mul
                                          (@coe.{1 1} nat int
                                             (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                             (q.denom))
                                          (@coe.{1 1} nat int
                                             (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                             (r.denom)))
                                       (@eq.refl.{1} int
                                          (@has_mul.mul.{0} int int.has_mul
                                             (@coe.{1 1} nat int
                                                (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                                (q.denom))
                                             (@coe.{1 1} nat int
                                                (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                                (r.denom)))))
                                    (rat.zero_mk
                                       (@has_mul.mul.{0} int int.has_mul
                                          (@coe.{1 1} nat int
                                             (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                             (q.denom))
                                          (@coe.{1 1} nat int
                                             (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                             (r.denom))))))
                              (@propext
                                 (@eq.{1} rat
                                    (@has_mul.mul.{0} rat
                                       (@no_zero_divisors.to_has_mul.{0} rat
                                          (@integral_domain.to_no_zero_divisors.{0} rat rat.integral_domain))
                                       q
                                       r)
                                    (@has_zero.zero.{0} rat rat.has_zero))
                                 false
                                 (@iff_false_intro
                                    (@eq.{1} rat
                                       (@has_mul.mul.{0} rat
                                          (@no_zero_divisors.to_has_mul.{0} rat
                                             (@integral_domain.to_no_zero_divisors.{0} rat rat.integral_domain))
                                          q
                                          r)
                                       (@has_zero.zero.{0} rat rat.has_zero))
                                    (@mul_ne_zero.{0} rat rat.integral_domain q r hq hr))))
                           this))))))
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
          (@roption.get.{0} nat
             (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                (@has_mul.mul.{0} int int.has_mul
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom))))
             (@iff.mpr
                (@multiplicity.finite.{0} int int.comm_semiring
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   (@has_mul.mul.{0} int int.has_mul
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                         (r.denom))))
                (and
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int
                      (@has_mul.mul.{0} int int.has_mul
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                            (q.denom))
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                            (r.denom)))
                      (@has_zero.zero.{0} int int.has_zero)))
                (@multiplicity.finite_int_iff
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   (@has_mul.mul.{0} int int.has_mul
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                         (r.denom))))
                (@and.intro
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int
                      (@has_mul.mul.{0} int int.has_mul
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                            (q.denom))
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                            (r.denom)))
                      (@has_zero.zero.{0} int int.has_zero))
                   (@ne.symm.{1} nat (@has_one.one.{0} nat nat.has_one)
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@ne_of_lt.{0} nat
                         (@partial_order.to_preorder.{0} nat
                            (@ordered_comm_monoid.to_partial_order.{0} nat
                               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
                         (@has_one.one.{0} nat nat.has_one)
                         (int.nat_abs
                            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                         (@nat.prime.one_lt p p_prime)))
                   (λ
                    (hd :
                      @eq.{1} int
                        (@has_mul.mul.{0} int int.has_mul
                           (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                              (q.denom))
                           (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                              (r.denom)))
                        (@has_zero.zero.{0} int int.has_zero)),
                      false.rec.{0} false
                        (@eq.mp.{0}
                           (@eq.{1} rat
                              (@has_mul.mul.{0} rat
                                 (@no_zero_divisors.to_has_mul.{0} rat
                                    (@integral_domain.to_no_zero_divisors.{0} rat rat.integral_domain))
                                 q
                                 r)
                              (rat.mk (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
                                 (@has_mul.mul.{0} int int.has_mul
                                    (@coe.{1 1} nat int
                                       (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                       (q.denom))
                                    (@coe.{1 1} nat int
                                       (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                       (r.denom)))))
                           false
                           (@eq.trans.{1} Prop
                              (@eq.{1} rat
                                 (@has_mul.mul.{0} rat
                                    (@no_zero_divisors.to_has_mul.{0} rat
                                       (@integral_domain.to_no_zero_divisors.{0} rat rat.integral_domain))
                                    q
                                    r)
                                 (rat.mk (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
                                    (@has_mul.mul.{0} int int.has_mul
                                       (@coe.{1 1} nat int
                                          (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                          (q.denom))
                                       (@coe.{1 1} nat int
                                          (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                          (r.denom)))))
                              (@eq.{1} rat
                                 (@has_mul.mul.{0} rat
                                    (@no_zero_divisors.to_has_mul.{0} rat
                                       (@integral_domain.to_no_zero_divisors.{0} rat rat.integral_domain))
                                    q
                                    r)
                                 (@has_zero.zero.{0} rat rat.has_zero))
                              false
                              ((λ (a a_1 : rat) (e_1 : @eq.{1} rat a a_1) (a_2 a_3 : rat) (e_2 : @eq.{1} rat a_2 a_3),
                                  @congr.{1 1} rat Prop (@eq.{1} rat a) (@eq.{1} rat a_1) a_2 a_3
                                    (@congr_arg.{1 1} rat (rat → Prop) a a_1 (@eq.{1} rat) e_1)
                                    e_2)
                                 (@has_mul.mul.{0} rat
                                    (@no_zero_divisors.to_has_mul.{0} rat
                                       (@integral_domain.to_no_zero_divisors.{0} rat rat.integral_domain))
                                    q
                                    r)
                                 (@has_mul.mul.{0} rat
                                    (@no_zero_divisors.to_has_mul.{0} rat
                                       (@integral_domain.to_no_zero_divisors.{0} rat rat.integral_domain))
                                    q
                                    r)
                                 (@eq.refl.{1} rat
                                    (@has_mul.mul.{0} rat
                                       (@no_zero_divisors.to_has_mul.{0} rat
                                          (@integral_domain.to_no_zero_divisors.{0} rat rat.integral_domain))
                                       q
                                       r))
                                 (rat.mk (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
                                    (@has_mul.mul.{0} int int.has_mul
                                       (@coe.{1 1} nat int
                                          (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                          (q.denom))
                                       (@coe.{1 1} nat int
                                          (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                          (r.denom))))
                                 (@has_zero.zero.{0} rat rat.has_zero)
                                 (@eq.trans.{1} rat
                                    (rat.mk (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
                                       (@has_mul.mul.{0} int int.has_mul
                                          (@coe.{1 1} nat int
                                             (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                             (q.denom))
                                          (@coe.{1 1} nat int
                                             (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                             (r.denom))))
                                    (rat.mk (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
                                       (@has_zero.zero.{0} int int.has_zero))
                                    (@has_zero.zero.{0} rat rat.has_zero)
                                    ((λ (a a_1 : int) (e_1 : @eq.{1} int a a_1) (a_2 a_3 : int)
                                      (e_2 : @eq.{1} int a_2 a_3),
                                        @congr.{1 1} int rat (rat.mk a) (rat.mk a_1) a_2 a_3
                                          (@congr_arg.{1 1} int (int → rat) a a_1 rat.mk e_1)
                                          e_2)
                                       (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
                                       (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
                                       (@eq.refl.{1} int (@has_mul.mul.{0} int int.has_mul (q.num) (r.num)))
                                       (@has_mul.mul.{0} int int.has_mul
                                          (@coe.{1 1} nat int
                                             (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                             (q.denom))
                                          (@coe.{1 1} nat int
                                             (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                             (r.denom)))
                                       (@has_zero.zero.{0} int int.has_zero)
                                       hd)
                                    (rat.mk_zero (@has_mul.mul.{0} int int.has_mul (q.num) (r.num)))))
                              (@propext
                                 (@eq.{1} rat
                                    (@has_mul.mul.{0} rat
                                       (@no_zero_divisors.to_has_mul.{0} rat
                                          (@integral_domain.to_no_zero_divisors.{0} rat rat.integral_domain))
                                       q
                                       r)
                                    (@has_zero.zero.{0} rat rat.has_zero))
                                 false
                                 (@iff_false_intro
                                    (@eq.{1} rat
                                       (@has_mul.mul.{0} rat
                                          (@no_zero_divisors.to_has_mul.{0} rat
                                             (@integral_domain.to_no_zero_divisors.{0} rat rat.integral_domain))
                                          q
                                          r)
                                       (@has_zero.zero.{0} rat rat.has_zero))
                                    (@mul_ne_zero.{0} rat rat.integral_domain q r hq hr))))
                           this)))))))
    (@has_add.add.{0} int int.has_add
       (@has_sub.sub.{0} int int.has_sub
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
             (@roption.get.{0} nat
                (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   (q.num))
                (@iff.mpr
                   (@multiplicity.finite.{0} int int.comm_semiring
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                      (q.num))
                   (and
                      (@ne.{1} nat
                         (int.nat_abs
                            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                         (@has_one.one.{0} nat nat.has_one))
                      (@ne.{1} int (q.num) (@has_zero.zero.{0} int int.has_zero)))
                   (@multiplicity.finite_int_iff
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                      (q.num))
                   (@and.intro
                      (@ne.{1} nat
                         (int.nat_abs
                            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                         (@has_one.one.{0} nat nat.has_one))
                      (@ne.{1} int (q.num) (@has_zero.zero.{0} int int.has_zero))
                      (@ne.symm.{1} nat (@has_one.one.{0} nat nat.has_one)
                         (int.nat_abs
                            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                         (@ne_of_lt.{0} nat
                            (@partial_order.to_preorder.{0} nat
                               (@ordered_comm_monoid.to_partial_order.{0} nat
                                  (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                                     (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
                            (@has_one.one.{0} nat nat.has_one)
                            (int.nat_abs
                               (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                  p))
                            (@nat.prime.one_lt p p_prime)))
                      (λ (hn : @eq.{1} int (q.num) (@has_zero.zero.{0} int int.has_zero)),
                         false.rec.{0} false
                           (@eq.mp.{0}
                              (@eq.{1} rat
                                 (rat.mk (q.num)
                                    (@coe.{1 1} nat int
                                       (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                       (q.denom)))
                                 (rat.mk (q.num)
                                    (@coe.{1 1} nat int
                                       (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                       (q.denom))))
                              false
                              (@eq.trans.{1} Prop
                                 (@eq.{1} rat
                                    (rat.mk (q.num)
                                       (@coe.{1 1} nat int
                                          (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                          (q.denom)))
                                    (rat.mk (q.num)
                                       (@coe.{1 1} nat int
                                          (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                          (q.denom))))
                                 (@eq.{1} rat
                                    (rat.mk (q.num)
                                       (@coe.{1 1} nat int
                                          (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                          (q.denom)))
                                    (@has_zero.zero.{0} rat rat.has_zero))
                                 false
                                 ((λ (a a_1 : rat) (e_1 : @eq.{1} rat a a_1) (a_2 a_3 : rat)
                                   (e_2 : @eq.{1} rat a_2 a_3),
                                     @congr.{1 1} rat Prop (@eq.{1} rat a) (@eq.{1} rat a_1) a_2 a_3
                                       (@congr_arg.{1 1} rat (rat → Prop) a a_1 (@eq.{1} rat) e_1)
                                       e_2)
                                    (rat.mk (q.num)
                                       (@coe.{1 1} nat int
                                          (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                          (q.denom)))
                                    (rat.mk (q.num)
                                       (@coe.{1 1} nat int
                                          (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                          (q.denom)))
                                    (@eq.refl.{1} rat
                                       (rat.mk (q.num)
                                          (@coe.{1 1} nat int
                                             (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                             (q.denom))))
                                    (rat.mk (q.num)
                                       (@coe.{1 1} nat int
                                          (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                          (q.denom)))
                                    (@has_zero.zero.{0} rat rat.has_zero)
                                    (@eq.trans.{1} rat
                                       (rat.mk (q.num)
                                          (@coe.{1 1} nat int
                                             (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                             (q.denom)))
                                       (rat.mk (@has_zero.zero.{0} int int.has_zero)
                                          (@coe.{1 1} nat int
                                             (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                             (q.denom)))
                                       (@has_zero.zero.{0} rat rat.has_zero)
                                       ((λ (a a_1 : int) (e_1 : @eq.{1} int a a_1) (a_2 a_3 : int)
                                         (e_2 : @eq.{1} int a_2 a_3),
                                           @congr.{1 1} int rat (rat.mk a) (rat.mk a_1) a_2 a_3
                                             (@congr_arg.{1 1} int (int → rat) a a_1 rat.mk e_1)
                                             e_2)
                                          (q.num)
                                          (@has_zero.zero.{0} int int.has_zero)
                                          hn
                                          (@coe.{1 1} nat int
                                             (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                             (q.denom))
                                          (@coe.{1 1} nat int
                                             (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                             (q.denom))
                                          (@eq.refl.{1} int
                                             (@coe.{1 1} nat int
                                                (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                                (q.denom))))
                                       (rat.zero_mk
                                          (@coe.{1 1} nat int
                                             (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                             (q.denom)))))
                                 (@propext
                                    (@eq.{1} rat
                                       (rat.mk (q.num)
                                          (@coe.{1 1} nat int
                                             (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                             (q.denom)))
                                       (@has_zero.zero.{0} rat rat.has_zero))
                                    false
                                    (@iff_false_intro
                                       (@eq.{1} rat
                                          (rat.mk (q.num)
                                             (@coe.{1 1} nat int
                                                (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                                (q.denom)))
                                          (@has_zero.zero.{0} rat rat.has_zero))
                                       hq&#x27;)))
                              (@eq.refl.{1} rat
                                 (rat.mk (q.num)
                                    (@coe.{1 1} nat int
                                       (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                       (q.denom))))))))))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
             (@roption.get.{0} nat
                (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))
                (@iff.mpr
                   (@multiplicity.finite.{0} int int.comm_semiring
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))
                   (and
                      (@ne.{1} nat
                         (int.nat_abs
                            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                         (@has_one.one.{0} nat nat.has_one))
                      (@ne.{1} int
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                            (q.denom))
                         (@has_zero.zero.{0} int int.has_zero)))
                   (@multiplicity.finite_int_iff
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))
                   (@and.intro
                      (@ne.{1} nat
                         (int.nat_abs
                            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                         (@has_one.one.{0} nat nat.has_one))
                      (@ne.{1} int
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                            (q.denom))
                         (@has_zero.zero.{0} int int.has_zero))
                      (@ne.symm.{1} nat (@has_one.one.{0} nat nat.has_one)
                         (int.nat_abs
                            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                         (@ne_of_lt.{0} nat
                            (@partial_order.to_preorder.{0} nat
                               (@ordered_comm_monoid.to_partial_order.{0} nat
                                  (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                                     (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
                            (@has_one.one.{0} nat nat.has_one)
                            (int.nat_abs
                               (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                  p))
                            (@nat.prime.one_lt p p_prime)))
                      (λ
                       (hd :
                         @eq.{1} int
                           (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                              (q.denom))
                           (@has_zero.zero.{0} int int.has_zero)),
                         false.rec.{0} false
                           (@eq.mp.{0}
                              (@eq.{1} rat
                                 (rat.mk (q.num)
                                    (@coe.{1 1} nat int
                                       (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                       (q.denom)))
                                 (rat.mk (q.num)
                                    (@coe.{1 1} nat int
                                       (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                       (q.denom))))
                              false
                              (@eq.trans.{1} Prop
                                 (@eq.{1} rat
                                    (rat.mk (q.num)
                                       (@coe.{1 1} nat int
                                          (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                          (q.denom)))
                                    (rat.mk (q.num)
                                       (@coe.{1 1} nat int
                                          (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                          (q.denom))))
                                 (@eq.{1} rat
                                    (rat.mk (q.num)
                                       (@coe.{1 1} nat int
                                          (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                          (q.denom)))
                                    (@has_zero.zero.{0} rat rat.has_zero))
                                 false
                                 ((λ (a a_1 : rat) (e_1 : @eq.{1} rat a a_1) (a_2 a_3 : rat)
                                   (e_2 : @eq.{1} rat a_2 a_3),
                                     @congr.{1 1} rat Prop (@eq.{1} rat a) (@eq.{1} rat a_1) a_2 a_3
                                       (@congr_arg.{1 1} rat (rat → Prop) a a_1 (@eq.{1} rat) e_1)
                                       e_2)
                                    (rat.mk (q.num)
                                       (@coe.{1 1} nat int
                                          (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                          (q.denom)))
                                    (rat.mk (q.num)
                                       (@coe.{1 1} nat int
                                          (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                          (q.denom)))
                                    (@eq.refl.{1} rat
                                       (rat.mk (q.num)
                                          (@coe.{1 1} nat int
                                             (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                             (q.denom))))
                                    (rat.mk (q.num)
                                       (@coe.{1 1} nat int
                                          (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                          (q.denom)))
                                    (@has_zero.zero.{0} rat rat.has_zero)
                                    (@eq.trans.{1} rat
                                       (rat.mk (q.num)
                                          (@coe.{1 1} nat int
                                             (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                             (q.denom)))
                                       (rat.mk (q.num) (@has_zero.zero.{0} int int.has_zero))
                                       (@has_zero.zero.{0} rat rat.has_zero)
                                       ((λ (a a_1 : int) (e_1 : @eq.{1} int a a_1) (a_2 a_3 : int)
                                         (e_2 : @eq.{1} int a_2 a_3),
                                           @congr.{1 1} int rat (rat.mk a) (rat.mk a_1) a_2 a_3
                                             (@congr_arg.{1 1} int (int → rat) a a_1 rat.mk e_1)
                                             e_2)
                                          (q.num)
                                          (q.num)
                                          (@eq.refl.{1} int (q.num))
                                          (@coe.{1 1} nat int
                                             (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                             (q.denom))
                                          (@has_zero.zero.{0} int int.has_zero)
                                          hd)
                                       (rat.mk_zero (q.num))))
                                 (@propext
                                    (@eq.{1} rat
                                       (rat.mk (q.num)
                                          (@coe.{1 1} nat int
                                             (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                             (q.denom)))
                                       (@has_zero.zero.{0} rat rat.has_zero))
                                    false
                                    (@iff_false_intro
                                       (@eq.{1} rat
                                          (rat.mk (q.num)
                                             (@coe.{1 1} nat int
                                                (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                                (q.denom)))
                                          (@has_zero.zero.{0} rat rat.has_zero))
                                       hq&#x27;)))
                              (@eq.refl.{1} rat
                                 (rat.mk (q.num)
                                    (@coe.{1 1} nat int
                                       (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                       (q.denom)))))))))))
       (@has_sub.sub.{0} int int.has_sub
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
             (@roption.get.{0} nat
                (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   (r.num))
                (@iff.mpr
                   (@multiplicity.finite.{0} int int.comm_semiring
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                      (r.num))
                   (and
                      (@ne.{1} nat
                         (int.nat_abs
                            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                         (@has_one.one.{0} nat nat.has_one))
                      (@ne.{1} int (r.num) (@has_zero.zero.{0} int int.has_zero)))
                   (@multiplicity.finite_int_iff
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                      (r.num))
                   (@and.intro
                      (@ne.{1} nat
                         (int.nat_abs
                            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                         (@has_one.one.{0} nat nat.has_one))
                      (@ne.{1} int (r.num) (@has_zero.zero.{0} int int.has_zero))
                      (… … …)
                      …))))
          …))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
p_prime : nat.prime p,
q r : rat,
hq : @ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero),
hr : @ne.{1} rat r (@has_zero.zero.{0} rat rat.has_zero),
this :
  @eq.{1} rat (@has_mul.mul.{0} rat rat.has_mul q r)
    (rat.mk (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
       (@has_mul.mul.{0} int int.has_mul
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))),
hq&#x27; :
  @ne.{1} rat
    (rat.mk (q.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))
    (@has_zero.zero.{0} rat rat.has_zero),
hr&#x27; :
  @ne.{1} rat
    (rat.mk (r.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
    (@has_zero.zero.{0} rat rat.has_zero),
hp&#x27; :
  @prime.{0} int int.comm_semiring
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
⊢ @eq.{1} int
    (@has_sub.sub.{0} int int.has_sub
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
          (@has_add.add.{0} nat nat.has_add
             (@roption.get.{0} nat
                (@multiplicity.{0} int
                   (@nonzero_comm_semiring.to_comm_semiring.{0} int
                      (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} int
                         (@integral_domain.to_nonzero_comm_ring.{0} int
                            (@normalization_domain.to_integral_domain.{0} int int.normalization_domain))))
                   (λ (a b : int), (λ (a b : int), int.decidable_dvd a b) a b)
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   (q.num))
                (@and.left
                   (@multiplicity.finite.{0} int
                      (@nonzero_comm_semiring.to_comm_semiring.{0} int
                         (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} int
                            (@integral_domain.to_nonzero_comm_ring.{0} int
                               (@normalization_domain.to_integral_domain.{0} int int.normalization_domain))))
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                      (q.num))
                   (@multiplicity.finite.{0} int
                      (@nonzero_comm_semiring.to_comm_semiring.{0} int
                         (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} int
                            (@integral_domain.to_nonzero_comm_ring.{0} int
                               (@normalization_domain.to_integral_domain.{0} int int.normalization_domain))))
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                      (r.num))
                   (@iff.mp
                      (@multiplicity.finite.{0} int
                         (@nonzero_comm_semiring.to_comm_semiring.{0} int
                            (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} int
                               (@integral_domain.to_nonzero_comm_ring.{0} int
                                  (@normalization_domain.to_integral_domain.{0} int int.normalization_domain))))
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                         (@has_mul.mul.{0} int
                            (@no_zero_divisors.to_has_mul.{0} int
                               (@domain.to_no_zero_divisors.{0} int
                                  (@integral_domain.to_domain.{0} int
                                     (@normalization_domain.to_integral_domain.{0} int int.normalization_domain))))
                            (q.num)
                            (r.num)))
                      (and
                         (@multiplicity.finite.{0} int
                            (@nonzero_comm_semiring.to_comm_semiring.{0} int
                               (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} int
                                  (@integral_domain.to_nonzero_comm_ring.{0} int
                                     (@normalization_domain.to_integral_domain.{0} int int.normalization_domain))))
                            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                            (q.num))
                         (@multiplicity.finite.{0} int
                            (@nonzero_comm_semiring.to_comm_semiring.{0} int
                               (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} int
                                  (@integral_domain.to_nonzero_comm_ring.{0} int
                                     (@normalization_domain.to_integral_domain.{0} int int.normalization_domain))))
                            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                            (r.num)))
                      (@multiplicity.finite_mul_iff.{0} int
                         (@normalization_domain.to_integral_domain.{0} int int.normalization_domain)
                         (λ (a b : int), (λ (a b : int), int.decidable_dvd a b) a b)
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                         (q.num)
                         (r.num)
                         hp&#x27;)
                      (@iff.mpr
                         (@multiplicity.finite.{0} int int.comm_semiring
                            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                            (@has_mul.mul.{0} int int.has_mul (q.num) (r.num)))
                         (and
                            (@ne.{1} nat
                               (int.nat_abs
                                  (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                     p))
                               (@has_one.one.{0} nat nat.has_one))
                            (@ne.{1} int (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
                               (@has_zero.zero.{0} int int.has_zero)))
                         (@multiplicity.finite_int_iff
                            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                            (@has_mul.mul.{0} int int.has_mul (q.num) (r.num)))
                         (@and.intro
                            (@ne.{1} nat
                               (int.nat_abs
                                  (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                     p))
                               (@has_one.one.{0} nat nat.has_one))
                            (@ne.{1} int (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
                               (@has_zero.zero.{0} int int.has_zero))
                            (@ne.symm.{1} nat (@has_one.one.{0} nat nat.has_one)
                               (int.nat_abs
                                  (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                     p))
                               (@ne_of_lt.{0} nat
                                  (@partial_order.to_preorder.{0} nat
                                     (@ordered_comm_monoid.to_partial_order.{0} nat
                                        (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                                           (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat
                                              nat.ordered_semiring))))
                                  (@has_one.one.{0} nat nat.has_one)
                                  (int.nat_abs
                                     (@coe.{1 1} nat int
                                        (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                        p))
                                  (@nat.prime.one_lt p p_prime)))
                            (λ
                             (hn :
                               @eq.{1} int (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
                                 (@has_zero.zero.{0} int int.has_zero)),
                               false.rec.{0} false
                                 (@eq.mp.{0}
                                    (@eq.{1} rat
                                       (@has_mul.mul.{0} rat
                                          (@no_zero_divisors.to_has_mul.{0} rat
                                             (@integral_domain.to_no_zero_divisors.{0} rat rat.integral_domain))
                                          q
                                          r)
                                       (rat.mk (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
                                          (@has_mul.mul.{0} int int.has_mul
                                             (@coe.{1 1} nat int
                                                (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                                (q.denom))
                                             (@coe.{1 1} nat int
                                                (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                                (r.denom)))))
                                    false
                                    (@eq.trans.{1} Prop
                                       (@eq.{1} rat
                                          (@has_mul.mul.{0} rat
                                             (@no_zero_divisors.to_has_mul.{0} rat
                                                (@integral_domain.to_no_zero_divisors.{0} rat rat.integral_domain))
                                             q
                                             r)
                                          (rat.mk (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
                                             (@has_mul.mul.{0} int int.has_mul
                                                (@coe.{1 1} nat int
                                                   (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                                   (q.denom))
                                                (@coe.{1 1} nat int
                                                   (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                                   (r.denom)))))
                                       (@eq.{1} rat
                                          (@has_mul.mul.{0} rat
                                             (@no_zero_divisors.to_has_mul.{0} rat
                                                (@integral_domain.to_no_zero_divisors.{0} rat rat.integral_domain))
                                             q
                                             r)
                                          (@has_zero.zero.{0} rat rat.has_zero))
                                       false
                                       ((λ (a a_1 : rat) (e_1 : @eq.{1} rat a a_1) (a_2 a_3 : rat)
                                         (e_2 : @eq.{1} rat a_2 a_3),
                                           @congr.{1 1} rat Prop (@eq.{1} rat a) (@eq.{1} rat a_1) a_2 a_3
                                             (@congr_arg.{1 1} rat (rat → Prop) a a_1 (@eq.{1} rat) e_1)
                                             e_2)
                                          (@has_mul.mul.{0} rat
                                             (@no_zero_divisors.to_has_mul.{0} rat
                                                (@integral_domain.to_no_zero_divisors.{0} rat rat.integral_domain))
                                             q
                                             r)
                                          (@has_mul.mul.{0} rat
                                             (@no_zero_divisors.to_has_mul.{0} rat
                                                (@integral_domain.to_no_zero_divisors.{0} rat rat.integral_domain))
                                             q
                                             r)
                                          (@eq.refl.{1} rat
                                             (@has_mul.mul.{0} rat
                                                (@no_zero_divisors.to_has_mul.{0} rat
                                                   (@integral_domain.to_no_zero_divisors.{0} rat rat.integral_domain))
                                                q
                                                r))
                                          (rat.mk (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
                                             (@has_mul.mul.{0} int int.has_mul
                                                (@coe.{1 1} nat int
                                                   (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                                   (q.denom))
                                                (@coe.{1 1} nat int
                                                   (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                                   (r.denom))))
                                          (@has_zero.zero.{0} rat rat.has_zero)
                                          (@eq.trans.{1} rat
                                             (rat.mk (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
                                                (@has_mul.mul.{0} int int.has_mul
                                                   (@coe.{1 1} nat int
                                                      (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                                      (q.denom))
                                                   (@coe.{1 1} nat int
                                                      (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                                      (r.denom))))
                                             (rat.mk (@has_zero.zero.{0} int int.has_zero)
                                                (@has_mul.mul.{0} int int.has_mul
                                                   (@coe.{1 1} nat int
                                                      (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                                      (q.denom))
                                                   (@coe.{1 1} nat int
                                                      (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                                      (r.denom))))
                                             (@has_zero.zero.{0} rat rat.has_zero)
                                             ((λ (a a_1 : int) (e_1 : @eq.{1} int a a_1) (a_2 a_3 : int)
                                               (e_2 : @eq.{1} int a_2 a_3),
                                                 @congr.{1 1} int rat (rat.mk a) (rat.mk a_1) a_2 a_3
                                                   (@congr_arg.{1 1} int (int → rat) a a_1 rat.mk e_1)
                                                   e_2)
                                                (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
                                                (@has_zero.zero.{0} int int.has_zero)
                                                hn
                                                (@has_mul.mul.{0} int int.has_mul
                                                   (@coe.{1 1} nat int
                                                      (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                                      (q.denom))
                                                   (@coe.{1 1} nat int
                                                      (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                                      (r.denom)))
                                                (@has_mul.mul.{0} int int.has_mul
                                                   (@coe.{1 1} nat int
                                                      (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                                      (q.denom))
                                                   (@coe.{1 1} nat int
                                                      (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                                      (r.denom)))
                                                (@eq.refl.{1} int
                                                   (@has_mul.mul.{0} int int.has_mul
                                                      (@coe.{1 1} nat int
                                                         (@coe_to_lift.{1 1} nat int
                                                            (@coe_base.{1 1} nat int int.has_coe))
                                                         (q.denom))
                                                      (@coe.{1 1} nat int
                                                         (@coe_to_lift.{1 1} nat int
                                                            (@coe_base.{1 1} nat int int.has_coe))
                                                         (r.denom)))))
                                             (rat.zero_mk
                                                (@has_mul.mul.{0} int int.has_mul
                                                   (@coe.{1 1} nat int
                                                      (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                                      (q.denom))
                                                   (@coe.{1 1} nat int
                                                      (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                                      (r.denom))))))
                                       (@propext
                                          (@eq.{1} rat
                                             (@has_mul.mul.{0} rat
                                                (@no_zero_divisors.to_has_mul.{0} rat
                                                   (@integral_domain.to_no_zero_divisors.{0} rat rat.integral_domain))
                                                q
                                                r)
                                             (@has_zero.zero.{0} rat rat.has_zero))
                                          false
                                          (@iff_false_intro
                                             (@eq.{1} rat
                                                (@has_mul.mul.{0} rat
                                                   (@no_zero_divisors.to_has_mul.{0} rat
                                                      (@integral_domain.to_no_zero_divisors.{0} rat
                                                         rat.integral_domain))
                                                   q
                                                   r)
                                                (@has_zero.zero.{0} rat rat.has_zero))
                                             (@mul_ne_zero.{0} rat rat.integral_domain q r hq hr))))
                                    this)))))))
             (@roption.get.{0} nat
                (@multiplicity.{0} int
                   (@nonzero_comm_semiring.to_comm_semiring.{0} int
                      (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} int
                         (@integral_domain.to_nonzero_comm_ring.{0} int
                            (@normalization_domain.to_integral_domain.{0} int int.normalization_domain))))
                   (λ (a b : int), (λ (a b : int), int.decidable_dvd a b) a b)
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   (r.num))
                (@and.right
                   (@multiplicity.finite.{0} int
                      (@nonzero_comm_semiring.to_comm_semiring.{0} int
                         (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} int
                            (@integral_domain.to_nonzero_comm_ring.{0} int
                               (@normalization_domain.to_integral_domain.{0} int int.normalization_domain))))
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                      (q.num))
                   (@multiplicity.finite.{0} int
                      (@nonzero_comm_semiring.to_comm_semiring.{0} int
                         (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} int
                            (@integral_domain.to_nonzero_comm_ring.{0} int
                               (@normalization_domain.to_integral_domain.{0} int int.normalization_domain))))
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                      (r.num))
                   (@iff.mp
                      (@multiplicity.finite.{0} int
                         (@nonzero_comm_semiring.to_comm_semiring.{0} int
                            (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} int
                               (@integral_domain.to_nonzero_comm_ring.{0} int
                                  (@normalization_domain.to_integral_domain.{0} int int.normalization_domain))))
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                         (@has_mul.mul.{0} int
                            (@no_zero_divisors.to_has_mul.{0} int
                               (@domain.to_no_zero_divisors.{0} int
                                  (@integral_domain.to_domain.{0} int
                                     (@normalization_domain.to_integral_domain.{0} int int.normalization_domain))))
                            (q.num)
                            (r.num)))
                      (and
                         (@multiplicity.finite.{0} int
                            (@nonzero_comm_semiring.to_comm_semiring.{0} int
                               (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} int
                                  (@integral_domain.to_nonzero_comm_ring.{0} int
                                     (@normalization_domain.to_integral_domain.{0} int int.normalization_domain))))
                            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                            (q.num))
                         (@multiplicity.finite.{0} int
                            (@nonzero_comm_semiring.to_comm_semiring.{0} int
                               (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} int
                                  (@integral_domain.to_nonzero_comm_ring.{0} int
                                     (@normalization_domain.to_integral_domain.{0} int int.normalization_domain))))
                            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                            (r.num)))
                      (@multiplicity.finite_mul_iff.{0} int
                         (@normalization_domain.to_integral_domain.{0} int int.normalization_domain)
                         (λ (a b : int), (λ (a b : int), int.decidable_dvd a b) a b)
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                         (q.num)
                         (r.num)
                         hp&#x27;)
                      (@iff.mpr
                         (@multiplicity.finite.{0} int int.comm_semiring
                            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                            (@has_mul.mul.{0} int int.has_mul (q.num) (r.num)))
                         (and
                            (@ne.{1} nat
                               (int.nat_abs
                                  (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                     p))
                               (@has_one.one.{0} nat nat.has_one))
                            (@ne.{1} int (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
                               (@has_zero.zero.{0} int int.has_zero)))
                         (@multiplicity.finite_int_iff
                            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                            (@has_mul.mul.{0} int int.has_mul (q.num) (r.num)))
                         (@and.intro
                            (@ne.{1} nat
                               (int.nat_abs
                                  (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                     p))
                               (@has_one.one.{0} nat nat.has_one))
                            (@ne.{1} int (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
                               (@has_zero.zero.{0} int int.has_zero))
                            (@ne.symm.{1} nat (@has_one.one.{0} nat nat.has_one)
                               (int.nat_abs
                                  (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                     p))
                               (@ne_of_lt.{0} nat
                                  (@partial_order.to_preorder.{0} nat
                                     (@ordered_comm_monoid.to_partial_order.{0} nat
                                        (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                                           (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat
                                              nat.ordered_semiring))))
                                  (@has_one.one.{0} nat nat.has_one)
                                  (int.nat_abs
                                     (@coe.{1 1} nat int
                                        (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                        p))
                                  (@nat.prime.one_lt p p_prime)))
                            (λ
                             (hn :
                               @eq.{1} int (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
                                 (@has_zero.zero.{0} int int.has_zero)),
                               false.rec.{0} false
                                 (@eq.mp.{0}
                                    (@eq.{1} rat
                                       (@has_mul.mul.{0} rat
                                          (@no_zero_divisors.to_has_mul.{0} rat
                                             (@integral_domain.to_no_zero_divisors.{0} rat rat.integral_domain))
                                          q
                                          r)
                                       (rat.mk (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
                                          (@has_mul.mul.{0} int int.has_mul
                                             (@coe.{1 1} nat int
                                                (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                                (q.denom))
                                             (@coe.{1 1} nat int
                                                (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                                (r.denom)))))
                                    false
                                    (@eq.trans.{1} Prop
                                       (@eq.{1} rat
                                          (@has_mul.mul.{0} rat
                                             (@no_zero_divisors.to_has_mul.{0} rat
                                                (@integral_domain.to_no_zero_divisors.{0} rat rat.integral_domain))
                                             q
                                             r)
                                          (rat.mk (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
                                             (@has_mul.mul.{0} int int.has_mul
                                                (@coe.{1 1} nat int
                                                   (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                                   (q.denom))
                                                (@coe.{1 1} nat int
                                                   (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                                   (r.denom)))))
                                       (@eq.{1} rat
                                          (@has_mul.mul.{0} rat
                                             (@no_zero_divisors.to_has_mul.{0} rat
                                                (@integral_domain.to_no_zero_divisors.{0} rat rat.integral_domain))
                                             q
                                             r)
                                          (@has_zero.zero.{0} rat rat.has_zero))
                                       false
                                       ((λ (a a_1 : rat) (e_1 : @eq.{1} rat a a_1) (a_2 a_3 : rat)
                                         (e_2 : @eq.{1} rat a_2 a_3),
                                           @congr.{1 1} rat Prop (@eq.{1} rat a) (@eq.{1} rat a_1) a_2 a_3
                                             (@congr_arg.{1 1} rat (rat → Prop) a a_1 (@eq.{1} rat) e_1)
                                             e_2)
                                          (@has_mul.mul.{0} rat
                                             (@no_zero_divisors.to_has_mul.{0} rat
                                                (@integral_domain.to_no_zero_divisors.{0} rat rat.integral_domain))
                                             q
                                             r)
                                          (@has_mul.mul.{0} rat
                                             (@no_zero_divisors.to_has_mul.{0} rat
                                                (@integral_domain.to_no_zero_divisors.{0} rat rat.integral_domain))
                                             q
                                             r)
                                          (@eq.refl.{1} rat
                                             (@has_mul.mul.{0} rat
                                                (@no_zero_divisors.to_has_mul.{0} rat
                                                   (@integral_domain.to_no_zero_divisors.{0} rat rat.integral_domain))
                                                q
                                                r))
                                          (rat.mk (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
                                             (@has_mul.mul.{0} int int.has_mul
                                                (@coe.{1 1} nat int
                                                   (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                                   (q.denom))
                                                (@coe.{1 1} nat int
                                                   (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                                   (r.denom))))
                                          (@has_zero.zero.{0} rat rat.has_zero)
                                          (@eq.trans.{1} rat
                                             (rat.mk (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
                                                (@has_mul.mul.{0} int int.has_mul
                                                   (@coe.{1 1} nat int
                                                      (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                                      (q.denom))
                                                   (@coe.{1 1} nat int
                                                      (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                                      (r.denom))))
                                             (rat.mk (@has_zero.zero.{0} int int.has_zero)
                                                (@has_mul.mul.{0} int int.has_mul
                                                   (@coe.{1 1} nat int
                                                      (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                                      (q.denom))
                                                   (@coe.{1 1} nat int
                                                      (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                                      (r.denom))))
                                             (@has_zero.zero.{0} rat rat.has_zero)
                                             ((λ (a a_1 : int) (e_1 : @eq.{1} int a a_1) (a_2 a_3 : int)
                                               (e_2 : @eq.{1} int a_2 a_3),
                                                 @congr.{1 1} int rat (rat.mk a) (rat.mk a_1) a_2 a_3
                                                   (@congr_arg.{1 1} int (int → rat) a a_1 rat.mk e_1)
                                                   e_2)
                                                (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
                                                (@has_zero.zero.{0} int int.has_zero)
                                                hn
                                                (@has_mul.mul.{0} int int.has_mul
                                                   (@coe.{1 1} nat int
                                                      (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                                      (q.denom))
                                                   (@coe.{1 1} nat int
                                                      (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                                      (r.denom)))
                                                (@has_mul.mul.{0} int int.has_mul
                                                   (@coe.{1 1} nat int
                                                      (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                                      (q.denom))
                                                   (@coe.{1 1} nat int
                                                      (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                                      (r.denom)))
                                                (@eq.refl.{1} int
                                                   (@has_mul.mul.{0} int int.has_mul
                                                      (@coe.{1 1} nat int
                                                         (@coe_to_lift.{1 1} nat int
                                                            (@coe_base.{1 1} nat int int.has_coe))
                                                         (q.denom))
                                                      (@coe.{1 1} nat int
                                                         (@coe_to_lift.{1 1} nat int
                                                            (@coe_base.{1 1} nat int int.has_coe))
                                                         (r.denom)))))
                                             (rat.zero_mk
                                                (@has_mul.mul.{0} int int.has_mul
                                                   (@coe.{1 1} nat int
                                                      (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                                      (q.denom))
                                                   (@coe.{1 1} nat int
                                                      (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                                      (r.denom))))))
                                       (@propext
                                          (@eq.{1} rat
                                             (@has_mul.mul.{0} rat
                                                (@no_zero_divisors.to_has_mul.{0} rat
                                                   (@integral_domain.to_no_zero_divisors.{0} rat rat.integral_domain))
                                                q
                                                r)
                                             (@has_zero.zero.{0} rat rat.has_zero))
                                          false
                                          (@iff_false_intro
                                             (@eq.{1} rat
                                                (@has_mul.mul.{0} rat
                                                   (@no_zero_divisors.to_has_mul.{0} rat
                                                      (@integral_domain.to_no_zero_divisors.{0} rat
                                                         rat.integral_domain))
                                                   q
                                                   r)
                                                (@has_zero.zero.{0} rat rat.has_zero))
                                             (@mul_ne_zero.{0} rat rat.integral_domain q r hq hr))))
                                    this)))))))))
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
          (@roption.get.{0} nat
             (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                (@has_mul.mul.{0} int int.has_mul
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom))))
             (@iff.mpr
                (@multiplicity.finite.{0} int int.comm_semiring
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   (@has_mul.mul.{0} int int.has_mul
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                         (r.denom))))
                (and
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int
                      (@has_mul.mul.{0} int int.has_mul
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                            (q.denom))
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                            (r.denom)))
                      (@has_zero.zero.{0} int int.has_zero)))
                (@multiplicity.finite_int_iff
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   (@has_mul.mul.{0} int int.has_mul
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                         (r.denom))))
                (@and.intro
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int
                      (@has_mul.mul.{0} int int.has_mul
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                            (q.denom))
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                            (r.denom)))
                      (@has_zero.zero.{0} int int.has_zero))
                   (@ne.symm.{1} nat (@has_one.one.{0} nat nat.has_one)
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@ne_of_lt.{0} nat
                         (@partial_order.to_preorder.{0} nat
                            (@ordered_comm_monoid.to_partial_order.{0} nat
                               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
                         (@has_one.one.{0} nat nat.has_one)
                         (int.nat_abs
                            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                         (@nat.prime.one_lt p p_prime)))
                   (λ
                    (hd :
                      @eq.{1} int
                        (@has_mul.mul.{0} int int.has_mul
                           (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                              (q.denom))
                           (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                              (r.denom)))
                        (@has_zero.zero.{0} int int.has_zero)),
                      false.rec.{0} false
                        (@eq.mp.{0}
                           (@eq.{1} rat
                              (@has_mul.mul.{0} rat
                                 (@no_zero_divisors.to_has_mul.{0} rat
                                    (@integral_domain.to_no_zero_divisors.{0} rat rat.integral_domain))
                                 q
                                 r)
                              (rat.mk (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
                                 (@has_mul.mul.{0} int int.has_mul
                                    (@coe.{1 1} nat int
                                       (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                       (q.denom))
                                    (@coe.{1 1} nat int
                                       (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                       (r.denom)))))
                           false
                           (@eq.trans.{1} Prop
                              (@eq.{1} rat
                                 (@has_mul.mul.{0} rat
                                    (@no_zero_divisors.to_has_mul.{0} rat
                                       (@integral_domain.to_no_zero_divisors.{0} rat rat.integral_domain))
                                    q
                                    r)
                                 (rat.mk (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
                                    (@has_mul.mul.{0} int int.has_mul
                                       (@coe.{1 1} nat int
                                          (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                          (q.denom))
                                       (@coe.{1 1} nat int
                                          (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                          (r.denom)))))
                              (@eq.{1} rat
                                 (@has_mul.mul.{0} rat
                                    (@no_zero_divisors.to_has_mul.{0} rat
                                       (@integral_domain.to_no_zero_divisors.{0} rat rat.integral_domain))
                                    q
                                    r)
                                 (@has_zero.zero.{0} rat rat.has_zero))
                              false
                              ((λ (a a_1 : rat) (e_1 : @eq.{1} rat a a_1) (a_2 a_3 : rat) (e_2 : @eq.{1} rat a_2 a_3),
                                  @congr.{1 1} rat Prop (@eq.{1} rat a) (@eq.{1} rat a_1) a_2 a_3
                                    (@congr_arg.{1 1} rat (rat → Prop) a a_1 (@eq.{1} rat) e_1)
                                    e_2)
                                 (@has_mul.mul.{0} rat
                                    (@no_zero_divisors.to_has_mul.{0} rat
                                       (@integral_domain.to_no_zero_divisors.{0} rat rat.integral_domain))
                                    q
                                    r)
                                 (@has_mul.mul.{0} rat
                                    (@no_zero_divisors.to_has_mul.{0} rat
                                       (@integral_domain.to_no_zero_divisors.{0} rat rat.integral_domain))
                                    q
                                    r)
                                 (@eq.refl.{1} rat
                                    (@has_mul.mul.{0} rat
                                       (@no_zero_divisors.to_has_mul.{0} rat
                                          (@integral_domain.to_no_zero_divisors.{0} rat rat.integral_domain))
                                       q
                                       r))
                                 (rat.mk (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
                                    (@has_mul.mul.{0} int int.has_mul
                                       (@coe.{1 1} nat int
                                          (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                          (q.denom))
                                       (@coe.{1 1} nat int
                                          (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                          (r.denom))))
                                 (@has_zero.zero.{0} rat rat.has_zero)
                                 (@eq.trans.{1} rat
                                    (rat.mk (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
                                       (@has_mul.mul.{0} int int.has_mul
                                          (@coe.{1 1} nat int
                                             (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                             (q.denom))
                                          (@coe.{1 1} nat int
                                             (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                             (r.denom))))
                                    (rat.mk (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
                                       (@has_zero.zero.{0} int int.has_zero))
                                    (@has_zero.zero.{0} rat rat.has_zero)
                                    ((λ (a a_1 : int) (e_1 : @eq.{1} int a a_1) (a_2 a_3 : int)
                                      (e_2 : @eq.{1} int a_2 a_3),
                                        @congr.{1 1} int rat (rat.mk a) (rat.mk a_1) a_2 a_3
                                          (@congr_arg.{1 1} int (int → rat) a a_1 rat.mk e_1)
                                          e_2)
                                       (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
                                       (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
                                       (@eq.refl.{1} int (@has_mul.mul.{0} int int.has_mul (q.num) (r.num)))
                                       (@has_mul.mul.{0} int int.has_mul
                                          (@coe.{1 1} nat int
                                             (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                             (q.denom))
                                          (@coe.{1 1} nat int
                                             (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                             (r.denom)))
                                       (@has_zero.zero.{0} int int.has_zero)
                                       hd)
                                    (rat.mk_zero (@has_mul.mul.{0} int int.has_mul (q.num) (r.num)))))
                              (@propext
                                 (@eq.{1} rat
                                    (@has_mul.mul.{0} rat
                                       (@no_zero_divisors.to_has_mul.{0} rat
                                          (@integral_domain.to_no_zero_divisors.{0} rat rat.integral_domain))
                                       q
                                       r)
                                    (@has_zero.zero.{0} rat rat.has_zero))
                                 false
                                 (@iff_false_intro
                                    (@eq.{1} rat
                                       (@has_mul.mul.{0} rat
                                          (@no_zero_divisors.to_has_mul.{0} rat
                                             (@integral_domain.to_no_zero_divisors.{0} rat rat.integral_domain))
                                          q
                                          r)
                                       (@has_zero.zero.{0} rat rat.has_zero))
                                    (@mul_ne_zero.{0} rat rat.integral_domain q r hq hr))))
                           this)))))))
    (@has_add.add.{0} int int.has_add
       (@has_sub.sub.{0} int int.has_sub
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
             (@roption.get.{0} nat
                (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   (q.num))
                (@iff.mpr
                   (@multiplicity.finite.{0} int int.comm_semiring
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                      (q.num))
                   (and
                      (@ne.{1} nat
                         (int.nat_abs
                            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                         (@has_one.one.{0} nat nat.has_one))
                      (@ne.{1} int (q.num) (@has_zero.zero.{0} int int.has_zero)))
                   (@multiplicity.finite_int_iff
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                      (q.num))
                   (@and.intro
                      (@ne.{1} nat
                         (int.nat_abs
                            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                         (@has_one.one.{0} nat nat.has_one))
                      (@ne.{1} int (q.num) (@has_zero.zero.{0} int int.has_zero))
                      (@ne.symm.{1} nat (@has_one.one.{0} nat nat.has_one)
                         (int.nat_abs
                            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                         (@ne_of_lt.{0} nat
                            (@partial_order.to_preorder.{0} nat
                               (@ordered_comm_monoid.to_partial_order.{0} nat
                                  (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                                     (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
                            (@has_one.one.{0} nat nat.has_one)
                            (int.nat_abs
                               (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                  p))
                            (@nat.prime.one_lt p p_prime)))
                      (λ (hn : @eq.{1} int (q.num) (@has_zero.zero.{0} int int.has_zero)),
                         false.rec.{0} false
                           (@eq.mp.{0}
                              (@eq.{1} rat
                                 (rat.mk (q.num)
                                    (@coe.{1 1} nat int
                                       (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                       (q.denom)))
                                 (rat.mk (q.num) (@coe.{1 1} nat int (… int …) …)))
                              false
                              …
                              …))))))
          …)
       …)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
p_prime : nat.prime p,
q r : rat,
hq : @ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero),
hr : @ne.{1} rat r (@has_zero.zero.{0} rat rat.has_zero),
this :
  @eq.{1} rat (@has_mul.mul.{0} rat rat.has_mul q r)
    (rat.mk (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
       (@has_mul.mul.{0} int int.has_mul
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))),
hq&#x27; :
  @ne.{1} rat
    (rat.mk (q.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))
    (@has_zero.zero.{0} rat rat.has_zero),
hr&#x27; :
  @ne.{1} rat
    (rat.mk (r.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
    (@has_zero.zero.{0} rat rat.has_zero),
hp&#x27; :
  @prime.{0} int int.comm_semiring
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
⊢ @eq.{1} int
    (@has_sub.sub.{0} int int.has_sub
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
          (@has_add.add.{0} nat nat.has_add
             (@roption.get.{0} nat
                (@multiplicity.{0} int
                   (@nonzero_comm_semiring.to_comm_semiring.{0} int
                      (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} int
                         (@integral_domain.to_nonzero_comm_ring.{0} int
                            (@normalization_domain.to_integral_domain.{0} int int.normalization_domain))))
                   (λ (a b : int), (λ (a b : int), int.decidable_dvd a b) a b)
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   (q.num))
                (@and.left
                   (@multiplicity.finite.{0} int
                      (@nonzero_comm_semiring.to_comm_semiring.{0} int
                         (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} int
                            (@integral_domain.to_nonzero_comm_ring.{0} int
                               (@normalization_domain.to_integral_domain.{0} int int.normalization_domain))))
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                      (q.num))
                   (@multiplicity.finite.{0} int
                      (@nonzero_comm_semiring.to_comm_semiring.{0} int
                         (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} int
                            (@integral_domain.to_nonzero_comm_ring.{0} int
                               (@normalization_domain.to_integral_domain.{0} int int.normalization_domain))))
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                      (r.num))
                   (@iff.mp
                      (@multiplicity.finite.{0} int
                         (@nonzero_comm_semiring.to_comm_semiring.{0} int
                            (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} int
                               (@integral_domain.to_nonzero_comm_ring.{0} int
                                  (@normalization_domain.to_integral_domain.{0} int int.normalization_domain))))
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                         (@has_mul.mul.{0} int
                            (@no_zero_divisors.to_has_mul.{0} int
                               (@domain.to_no_zero_divisors.{0} int
                                  (@integral_domain.to_domain.{0} int
                                     (@normalization_domain.to_integral_domain.{0} int int.normalization_domain))))
                            (q.num)
                            (r.num)))
                      (and
                         (@multiplicity.finite.{0} int
                            (@nonzero_comm_semiring.to_comm_semiring.{0} int
                               (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} int
                                  (@integral_domain.to_nonzero_comm_ring.{0} int
                                     (@normalization_domain.to_integral_domain.{0} int int.normalization_domain))))
                            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                            (q.num))
                         (@multiplicity.finite.{0} int
                            (@nonzero_comm_semiring.to_comm_semiring.{0} int
                               (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} int
                                  (@integral_domain.to_nonzero_comm_ring.{0} int
                                     (@normalization_domain.to_integral_domain.{0} int int.normalization_domain))))
                            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                            (r.num)))
                      (@multiplicity.finite_mul_iff.{0} int
                         (@normalization_domain.to_integral_domain.{0} int int.normalization_domain)
                         (λ (a b : int), (λ (a b : int), int.decidable_dvd a b) a b)
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                         (q.num)
                         (r.num)
                         hp&#x27;)
                      (@iff.mpr
                         (@multiplicity.finite.{0} int int.comm_semiring
                            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                            (@has_mul.mul.{0} int int.has_mul (q.num) (r.num)))
                         (and
                            (@ne.{1} nat
                               (int.nat_abs
                                  (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                     p))
                               (@has_one.one.{0} nat nat.has_one))
                            (@ne.{1} int (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
                               (@has_zero.zero.{0} int int.has_zero)))
                         (@multiplicity.finite_int_iff
                            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                            (@has_mul.mul.{0} int int.has_mul (q.num) (r.num)))
                         (@and.intro
                            (@ne.{1} nat
                               (int.nat_abs
                                  (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                     p))
                               (@has_one.one.{0} nat nat.has_one))
                            (@ne.{1} int (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
                               (@has_zero.zero.{0} int int.has_zero))
                            (@ne.symm.{1} nat (@has_one.one.{0} nat nat.has_one)
                               (int.nat_abs
                                  (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                     p))
                               (@ne_of_lt.{0} nat
                                  (@partial_order.to_preorder.{0} nat
                                     (@ordered_comm_monoid.to_partial_order.{0} nat
                                        (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                                           (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat
                                              nat.ordered_semiring))))
                                  (@has_one.one.{0} nat nat.has_one)
                                  (int.nat_abs
                                     (@coe.{1 1} nat int
                                        (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                        p))
                                  (@nat.prime.one_lt p p_prime)))
                            (λ
                             (hn :
                               @eq.{1} int (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
                                 (@has_zero.zero.{0} int int.has_zero)),
                               false.rec.{0} false
                                 (@eq.mp.{0}
                                    (@eq.{1} rat
                                       (@has_mul.mul.{0} rat
                                          (@no_zero_divisors.to_has_mul.{0} rat
                                             (@integral_domain.to_no_zero_divisors.{0} rat rat.integral_domain))
                                          q
                                          r)
                                       (rat.mk (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
                                          (@has_mul.mul.{0} int int.has_mul
                                             (@coe.{1 1} nat int
                                                (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                                (q.denom))
                                             (@coe.{1 1} nat int
                                                (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                                (r.denom)))))
                                    false
                                    (@eq.trans.{1} Prop
                                       (@eq.{1} rat
                                          (@has_mul.mul.{0} rat
                                             (@no_zero_divisors.to_has_mul.{0} rat
                                                (@integral_domain.to_no_zero_divisors.{0} rat rat.integral_domain))
                                             q
                                             r)
                                          (rat.mk (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
                                             (@has_mul.mul.{0} int int.has_mul
                                                (@coe.{1 1} nat int
                                                   (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                                   (q.denom))
                                                (@coe.{1 1} nat int
                                                   (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                                   (r.denom)))))
                                       (@eq.{1} rat
                                          (@has_mul.mul.{0} rat
                                             (@no_zero_divisors.to_has_mul.{0} rat
                                                (@integral_domain.to_no_zero_divisors.{0} rat rat.integral_domain))
                                             q
                                             r)
                                          (@has_zero.zero.{0} rat rat.has_zero))
                                       false
                                       ((λ (a a_1 : rat) (e_1 : @eq.{1} rat a a_1) (a_2 a_3 : rat)
                                         (e_2 : @eq.{1} rat a_2 a_3),
                                           @congr.{1 1} rat Prop (@eq.{1} rat a) (@eq.{1} rat a_1) a_2 a_3
                                             (@congr_arg.{1 1} rat (rat → Prop) a a_1 (@eq.{1} rat) e_1)
                                             e_2)
                                          (@has_mul.mul.{0} rat
                                             (@no_zero_divisors.to_has_mul.{0} rat
                                                (@integral_domain.to_no_zero_divisors.{0} rat rat.integral_domain))
                                             q
                                             r)
                                          (@has_mul.mul.{0} rat
                                             (@no_zero_divisors.to_has_mul.{0} rat
                                                (@integral_domain.to_no_zero_divisors.{0} rat rat.integral_domain))
                                             q
                                             r)
                                          (@eq.refl.{1} rat
                                             (@has_mul.mul.{0} rat
                                                (@no_zero_divisors.to_has_mul.{0} rat
                                                   (@integral_domain.to_no_zero_divisors.{0} rat rat.integral_domain))
                                                q
                                                r))
                                          (rat.mk (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
                                             (@has_mul.mul.{0} int int.has_mul
                                                (@coe.{1 1} nat int
                                                   (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                                   (q.denom))
                                                (@coe.{1 1} nat int
                                                   (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                                   (r.denom))))
                                          (@has_zero.zero.{0} rat rat.has_zero)
                                          (@eq.trans.{1} rat
                                             (rat.mk (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
                                                (@has_mul.mul.{0} int int.has_mul
                                                   (@coe.{1 1} nat int
                                                      (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                                      (q.denom))
                                                   (@coe.{1 1} nat int
                                                      (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                                      (r.denom))))
                                             (rat.mk (@has_zero.zero.{0} int int.has_zero)
                                                (@has_mul.mul.{0} int int.has_mul
                                                   (@coe.{1 1} nat int
                                                      (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                                      (q.denom))
                                                   (@coe.{1 1} nat int
                                                      (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                                      (r.denom))))
                                             (@has_zero.zero.{0} rat rat.has_zero)
                                             ((λ (a a_1 : int) (e_1 : @eq.{1} int a a_1) (a_2 a_3 : int)
                                               (e_2 : @eq.{1} int a_2 a_3),
                                                 @congr.{1 1} int rat (rat.mk a) (rat.mk a_1) a_2 a_3
                                                   (@congr_arg.{1 1} int (int → rat) a a_1 rat.mk e_1)
                                                   e_2)
                                                (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
                                                (@has_zero.zero.{0} int int.has_zero)
                                                hn
                                                (@has_mul.mul.{0} int int.has_mul
                                                   (@coe.{1 1} nat int
                                                      (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                                      (q.denom))
                                                   (@coe.{1 1} nat int
                                                      (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                                      (r.denom)))
                                                (@has_mul.mul.{0} int int.has_mul
                                                   (@coe.{1 1} nat int
                                                      (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                                      (q.denom))
                                                   (@coe.{1 1} nat int
                                                      (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                                      (r.denom)))
                                                (@eq.refl.{1} int
                                                   (@has_mul.mul.{0} int int.has_mul
                                                      (@coe.{1 1} nat int
                                                         (@coe_to_lift.{1 1} nat int
                                                            (@coe_base.{1 1} nat int int.has_coe))
                                                         (q.denom))
                                                      (@coe.{1 1} nat int
                                                         (@coe_to_lift.{1 1} nat int
                                                            (@coe_base.{1 1} nat int int.has_coe))
                                                         (r.denom)))))
                                             (rat.zero_mk
                                                (@has_mul.mul.{0} int int.has_mul
                                                   (@coe.{1 1} nat int
                                                      (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                                      (q.denom))
                                                   (@coe.{1 1} nat int
                                                      (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                                      (r.denom))))))
                                       (@propext
                                          (@eq.{1} rat
                                             (@has_mul.mul.{0} rat
                                                (@no_zero_divisors.to_has_mul.{0} rat
                                                   (@integral_domain.to_no_zero_divisors.{0} rat rat.integral_domain))
                                                q
                                                r)
                                             (@has_zero.zero.{0} rat rat.has_zero))
                                          false
                                          (@iff_false_intro
                                             (@eq.{1} rat
                                                (@has_mul.mul.{0} rat
                                                   (@no_zero_divisors.to_has_mul.{0} rat
                                                      (@integral_domain.to_no_zero_divisors.{0} rat
                                                         rat.integral_domain))
                                                   q
                                                   r)
                                                (@has_zero.zero.{0} rat rat.has_zero))
                                             (@mul_ne_zero.{0} rat rat.integral_domain q r hq hr))))
                                    this)))))))
             (@roption.get.{0} nat
                (@multiplicity.{0} int
                   (@nonzero_comm_semiring.to_comm_semiring.{0} int
                      (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} int
                         (@integral_domain.to_nonzero_comm_ring.{0} int
                            (@normalization_domain.to_integral_domain.{0} int int.normalization_domain))))
                   (λ (a b : int), (λ (a b : int), int.decidable_dvd a b) a b)
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   (r.num))
                (@and.right
                   (@multiplicity.finite.{0} int
                      (@nonzero_comm_semiring.to_comm_semiring.{0} int
                         (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} int
                            (@integral_domain.to_nonzero_comm_ring.{0} int
                               (@normalization_domain.to_integral_domain.{0} int int.normalization_domain))))
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                      (q.num))
                   (@multiplicity.finite.{0} int
                      (@nonzero_comm_semiring.to_comm_semiring.{0} int
                         (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} int
                            (@integral_domain.to_nonzero_comm_ring.{0} int
                               (@normalization_domain.to_integral_domain.{0} int int.normalization_domain))))
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                      (r.num))
                   (@iff.mp
                      (@multiplicity.finite.{0} int
                         (@nonzero_comm_semiring.to_comm_semiring.{0} int
                            (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} int
                               (@integral_domain.to_nonzero_comm_ring.{0} int
                                  (@normalization_domain.to_integral_domain.{0} int int.normalization_domain))))
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                         (@has_mul.mul.{0} int
                            (@no_zero_divisors.to_has_mul.{0} int
                               (@domain.to_no_zero_divisors.{0} int
                                  (@integral_domain.to_domain.{0} int
                                     (@normalization_domain.to_integral_domain.{0} int int.normalization_domain))))
                            (q.num)
                            (r.num)))
                      (and
                         (@multiplicity.finite.{0} int
                            (@nonzero_comm_semiring.to_comm_semiring.{0} int
                               (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} int
                                  (@integral_domain.to_nonzero_comm_ring.{0} int
                                     (@normalization_domain.to_integral_domain.{0} int int.normalization_domain))))
                            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                            (q.num))
                         (@multiplicity.finite.{0} int
                            (@nonzero_comm_semiring.to_comm_semiring.{0} int
                               (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} int
                                  (@integral_domain.to_nonzero_comm_ring.{0} int
                                     (@normalization_domain.to_integral_domain.{0} int int.normalization_domain))))
                            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                            (r.num)))
                      (@multiplicity.finite_mul_iff.{0} int
                         (@normalization_domain.to_integral_domain.{0} int int.normalization_domain)
                         (λ (a b : int), (λ (a b : int), int.decidable_dvd a b) a b)
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                         (q.num)
                         (r.num)
                         hp&#x27;)
                      (@iff.mpr
                         (@multiplicity.finite.{0} int int.comm_semiring
                            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                            (@has_mul.mul.{0} int int.has_mul (q.num) (r.num)))
                         (and
                            (@ne.{1} nat
                               (int.nat_abs
                                  (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                     p))
                               (@has_one.one.{0} nat nat.has_one))
                            (@ne.{1} int (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
                               (@has_zero.zero.{0} int int.has_zero)))
                         (@multiplicity.finite_int_iff
                            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                            (@has_mul.mul.{0} int int.has_mul (q.num) (r.num)))
                         (@and.intro
                            (@ne.{1} nat
                               (int.nat_abs
                                  (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                     p))
                               (@has_one.one.{0} nat nat.has_one))
                            (@ne.{1} int (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
                               (@has_zero.zero.{0} int int.has_zero))
                            (@ne.symm.{1} nat (@has_one.one.{0} nat nat.has_one)
                               (int.nat_abs
                                  (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                     p))
                               (@ne_of_lt.{0} nat
                                  (@partial_order.to_preorder.{0} nat
                                     (@ordered_comm_monoid.to_partial_order.{0} nat
                                        (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                                           (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat
                                              nat.ordered_semiring))))
                                  (@has_one.one.{0} nat nat.has_one)
                                  (int.nat_abs
                                     (@coe.{1 1} nat int
                                        (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                        p))
                                  (@nat.prime.one_lt p p_prime)))
                            (λ
                             (hn :
                               @eq.{1} int (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
                                 (@has_zero.zero.{0} int int.has_zero)),
                               false.rec.{0} false
                                 (@eq.mp.{0}
                                    (@eq.{1} rat
                                       (@has_mul.mul.{0} rat
                                          (@no_zero_divisors.to_has_mul.{0} rat
                                             (@integral_domain.to_no_zero_divisors.{0} rat rat.integral_domain))
                                          q
                                          r)
                                       (rat.mk (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
                                          (@has_mul.mul.{0} int int.has_mul
                                             (@coe.{1 1} nat int
                                                (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                                (q.denom))
                                             (@coe.{1 1} nat int
                                                (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                                (r.denom)))))
                                    false
                                    (@eq.trans.{1} Prop
                                       (@eq.{1} rat
                                          (@has_mul.mul.{0} rat
                                             (@no_zero_divisors.to_has_mul.{0} rat
                                                (@integral_domain.to_no_zero_divisors.{0} rat rat.integral_domain))
                                             q
                                             r)
                                          (rat.mk (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
                                             (@has_mul.mul.{0} int int.has_mul
                                                (@coe.{1 1} nat int
                                                   (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                                   (q.denom))
                                                (@coe.{1 1} nat int
                                                   (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                                   (r.denom)))))
                                       (@eq.{1} rat
                                          (@has_mul.mul.{0} rat
                                             (@no_zero_divisors.to_has_mul.{0} rat
                                                (@integral_domain.to_no_zero_divisors.{0} rat rat.integral_domain))
                                             q
                                             r)
                                          (@has_zero.zero.{0} rat rat.has_zero))
                                       false
                                       ((λ (a a_1 : rat) (e_1 : @eq.{1} rat a a_1) (a_2 a_3 : rat)
                                         (e_2 : @eq.{1} rat a_2 a_3),
                                           @congr.{1 1} rat Prop (@eq.{1} rat a) (@eq.{1} rat a_1) a_2 a_3
                                             (@congr_arg.{1 1} rat (rat → Prop) a a_1 (@eq.{1} rat) e_1)
                                             e_2)
                                          (@has_mul.mul.{0} rat
                                             (@no_zero_divisors.to_has_mul.{0} rat
                                                (@integral_domain.to_no_zero_divisors.{0} rat rat.integral_domain))
                                             q
                                             r)
                                          (@has_mul.mul.{0} rat
                                             (@no_zero_divisors.to_has_mul.{0} rat
                                                (@integral_domain.to_no_zero_divisors.{0} rat rat.integral_domain))
                                             q
                                             r)
                                          (@eq.refl.{1} rat
                                             (@has_mul.mul.{0} rat
                                                (@no_zero_divisors.to_has_mul.{0} rat
                                                   (@integral_domain.to_no_zero_divisors.{0} rat rat.integral_domain))
                                                q
                                                r))
                                          (rat.mk (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
                                             (@has_mul.mul.{0} int int.has_mul
                                                (@coe.{1 1} nat int
                                                   (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                                   (q.denom))
                                                (@coe.{1 1} nat int
                                                   (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                                   (r.denom))))
                                          (@has_zero.zero.{0} rat rat.has_zero)
                                          (@eq.trans.{1} rat
                                             (rat.mk (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
                                                (@has_mul.mul.{0} int int.has_mul
                                                   (@coe.{1 1} nat int
                                                      (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                                      (q.denom))
                                                   (@coe.{1 1} nat int
                                                      (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                                      (r.denom))))
                                             (rat.mk (@has_zero.zero.{0} int int.has_zero)
                                                (@has_mul.mul.{0} int int.has_mul
                                                   (@coe.{1 1} nat int
                                                      (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                                      (q.denom))
                                                   (@coe.{1 1} nat int
                                                      (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                                      (r.denom))))
                                             (@has_zero.zero.{0} rat rat.has_zero)
                                             ((λ (a a_1 : int) (e_1 : @eq.{1} int a a_1) (a_2 a_3 : int)
                                               (e_2 : @eq.{1} int a_2 a_3),
                                                 @congr.{1 1} int rat (rat.mk a) (rat.mk a_1) a_2 a_3
                                                   (@congr_arg.{1 1} int (int → rat) a a_1 rat.mk e_1)
                                                   e_2)
                                                (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
                                                (@has_zero.zero.{0} int int.has_zero)
                                                hn
                                                (@has_mul.mul.{0} int int.has_mul
                                                   (@coe.{1 1} nat int
                                                      (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                                      (q.denom))
                                                   (@coe.{1 1} nat int
                                                      (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                                      (r.denom)))
                                                (@has_mul.mul.{0} int int.has_mul
                                                   (@coe.{1 1} nat int
                                                      (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                                      (q.denom))
                                                   (@coe.{1 1} nat int
                                                      (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                                      (r.denom)))
                                                (@eq.refl.{1} int
                                                   (@has_mul.mul.{0} int int.has_mul
                                                      (@coe.{1 1} nat int
                                                         (@coe_to_lift.{1 1} nat int
                                                            (@coe_base.{1 1} nat int int.has_coe))
                                                         (q.denom))
                                                      (@coe.{1 1} nat int
                                                         (@coe_to_lift.{1 1} nat int
                                                            (@coe_base.{1 1} nat int int.has_coe))
                                                         (r.denom)))))
                                             (rat.zero_mk
                                                (@has_mul.mul.{0} int int.has_mul
                                                   (@coe.{1 1} nat int
                                                      (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                                      (q.denom))
                                                   (@coe.{1 1} nat int
                                                      (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                                      (r.denom))))))
                                       (@propext
                                          (@eq.{1} rat
                                             (@has_mul.mul.{0} rat
                                                (@no_zero_divisors.to_has_mul.{0} rat
                                                   (@integral_domain.to_no_zero_divisors.{0} rat rat.integral_domain))
                                                q
                                                r)
                                             (@has_zero.zero.{0} rat rat.has_zero))
                                          false
                                          (@iff_false_intro
                                             (@eq.{1} rat
                                                (@has_mul.mul.{0} rat
                                                   (@no_zero_divisors.to_has_mul.{0} rat
                                                      (@integral_domain.to_no_zero_divisors.{0} rat
                                                         rat.integral_domain))
                                                   q
                                                   r)
                                                (@has_zero.zero.{0} rat rat.has_zero))
                                             (@mul_ne_zero.{0} rat rat.integral_domain q r hq hr))))
                                    this)))))))))
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
          (@has_add.add.{0} nat nat.has_add
             (@roption.get.{0} nat
                (@multiplicity.{0} int
                   (@nonzero_comm_semiring.to_comm_semiring.{0} int
                      (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} int
                         (@integral_domain.to_nonzero_comm_ring.{0} int
                            (@normalization_domain.to_integral_domain.{0} int int.normalization_domain))))
                   (λ (a b : int), (λ (a b : int), int.decidable_dvd a b) a b)
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))
                (@and.left
                   (@multiplicity.finite.{0} int
                      (@nonzero_comm_semiring.to_comm_semiring.{0} int
                         (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} int
                            (@integral_domain.to_nonzero_comm_ring.{0} int
                               (@normalization_domain.to_integral_domain.{0} int int.normalization_domain))))
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))
                   (@multiplicity.finite.{0} int
                      (@nonzero_comm_semiring.to_comm_semiring.{0} int
                         (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} int
                            (@integral_domain.to_nonzero_comm_ring.{0} int
                               (@normalization_domain.to_integral_domain.{0} int int.normalization_domain))))
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
                   (@iff.mp
                      (@multiplicity.finite.{0} int
                         (@nonzero_comm_semiring.to_comm_semiring.{0} int
                            (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} int
                               (@integral_domain.to_nonzero_comm_ring.{0} int
                                  (@normalization_domain.to_integral_domain.{0} int int.normalization_domain))))
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                         (@has_mul.mul.{0} int
                            (@no_zero_divisors.to_has_mul.{0} int
                               (@domain.to_no_zero_divisors.{0} int
                                  (@integral_domain.to_domain.{0} int
                                     (@normalization_domain.to_integral_domain.{0} int int.normalization_domain))))
                            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                               (q.denom))
                            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                               (r.denom))))
                      (and
                         (@multiplicity.finite.{0} int
                            (@nonzero_comm_semiring.to_comm_semiring.{0} int
                               (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} int
                                  (@integral_domain.to_nonzero_comm_ring.{0} int
                                     (@normalization_domain.to_integral_domain.{0} int int.normalization_domain))))
                            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                               (q.denom)))
                         (@multiplicity.finite.{0} int
                            (@nonzero_comm_semiring.to_comm_semiring.{0} int
                               (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} int
                                  (@integral_domain.to_nonzero_comm_ring.{0} int
                                     (@normalization_domain.to_integral_domain.{0} int int.normalization_domain))))
                            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                               (r.denom))))
                      (@multiplicity.finite_mul_iff.{0} int
                         (@normalization_domain.to_integral_domain.{0} int int.normalization_domain)
                         (λ (a b : int), (λ (a b : int), int.decidable_dvd a b) a b)
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                            (q.denom))
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                            (r.denom))
                         hp&#x27;)
                      (@iff.mpr
                         (@multiplicity.finite.{0} int int.comm_semiring
                            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                            (@has_mul.mul.{0} int int.has_mul
                               (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                  (q.denom))
                               (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                  (r.denom))))
                         (and
                            (@ne.{1} nat
                               (int.nat_abs
                                  (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                     p))
                               (@has_one.one.{0} nat nat.has_one))
                            (@ne.{1} int
                               (@has_mul.mul.{0} int int.has_mul
                                  (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                     (q.denom))
                                  (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                     (r.denom)))
                               (@has_zero.zero.{0} int int.has_zero)))
                         (@multiplicity.finite_int_iff
                            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                            (@has_mul.mul.{0} int int.has_mul
                               (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                  (q.denom))
                               (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                  (r.denom))))
                         (@and.intro
                            (@ne.{1} nat
                               (int.nat_abs
                                  (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                     p))
                               (@has_one.one.{0} nat nat.has_one))
                            (@ne.{1} int
                               (@has_mul.mul.{0} int int.has_mul
                                  (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                     (q.denom))
                                  (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                     (r.denom)))
                               (@has_zero.zero.{0} int int.has_zero))
                            (@ne.symm.{1} nat (@has_one.one.{0} nat nat.has_one)
                               (int.nat_abs
                                  (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                     p))
                               (@ne_of_lt.{0} nat
                                  (@partial_order.to_preorder.{0} nat
                                     (@ordered_comm_monoid.to_partial_order.{0} nat
                                        (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                                           (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat
                                              nat.ordered_semiring))))
                                  (@has_one.one.{0} nat nat.has_one)
                                  (int.nat_abs
                                     (@coe.{1 1} nat int
                                        (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                        p))
                                  (@nat.prime.one_lt p p_prime)))
                            (λ
                             (hd :
                               @eq.{1} int
                                 (@has_mul.mul.{0} int int.has_mul
                                    (@coe.{1 1} nat int
                                       (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                       (q.denom))
                                    (@coe.{1 1} nat int
                                       (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                       (r.denom)))
                                 (@has_zero.zero.{0} int int.has_zero)),
                               false.rec.{0} false
                                 (@eq.mp.{0}
                                    (@eq.{1} rat
                                       (@has_mul.mul.{0} rat
                                          (@no_zero_divisors.to_has_mul.{0} rat
                                             (@integral_domain.to_no_zero_divisors.{0} rat rat.integral_domain))
                                          q
                                          r)
                                       (rat.mk (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
                                          (@has_mul.mul.{0} int int.has_mul
                                             (@coe.{1 1} nat int
                                                (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                                (q.denom))
                                             (@coe.{1 1} nat int
                                                (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                                (r.denom)))))
                                    false
                                    (@eq.trans.{1} Prop
                                       (@eq.{1} rat
                                          (@has_mul.mul.{0} rat
                                             (@no_zero_divisors.to_has_mul.{0} rat
                                                (@integral_domain.to_no_zero_divisors.{0} rat rat.integral_domain))
                                             q
                                             r)
                                          (rat.mk (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
                                             (@has_mul.mul.{0} int int.has_mul
                                                (@coe.{1 1} nat int
                                                   (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                                   (q.denom))
                                                (@coe.{1 1} nat int
                                                   (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                                   (r.denom)))))
                                       (@eq.{1} rat
                                          (@has_mul.mul.{0} rat
                                             (@no_zero_divisors.to_has_mul.{0} rat
                                                (@integral_domain.to_no_zero_divisors.{0} rat rat.integral_domain))
                                             q
                                             r)
                                          (@has_zero.zero.{0} rat rat.has_zero))
                                       false
                                       ((λ (a a_1 : rat) (e_1 : @eq.{1} rat a a_1) (a_2 a_3 : rat)
                                         (e_2 : @eq.{1} rat a_2 a_3),
                                           @congr.{1 1} rat Prop (@eq.{1} rat a) (@eq.{1} rat a_1) a_2 a_3
                                             (@congr_arg.{1 1} rat (rat → Prop) a a_1 (@eq.{1} rat) e_1)
                                             e_2)
                                          (@has_mul.mul.{0} rat
                                             (@no_zero_divisors.to_has_mul.{0} rat
                                                (@integral_domain.to_no_zero_divisors.{0} rat rat.integral_domain))
                                             q
                                             r)
                                          (@has_mul.mul.{0} rat
                                             (@no_zero_divisors.to_has_mul.{0} rat
                                                (@integral_domain.to_no_zero_divisors.{0} rat rat.integral_domain))
                                             q
                                             r)
                                          (@eq.refl.{1} rat
                                             (@has_mul.mul.{0} rat
                                                (@no_zero_divisors.to_has_mul.{0} rat
                                                   (@integral_domain.to_no_zero_divisors.{0} rat rat.integral_domain))
                                                q
                                                r))
                                          (rat.mk (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
                                             (@has_mul.mul.{0} int int.has_mul
                                                (@coe.{1 1} nat int
                                                   (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                                   (q.denom))
                                                (@coe.{1 1} nat int
                                                   (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                                   (r.denom))))
                                          (@has_zero.zero.{0} rat rat.has_zero)
                                          (@eq.trans.{1} rat
                                             (rat.mk (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
                                                (@has_mul.mul.{0} int int.has_mul
                                                   (@coe.{1 1} nat int
                                                      (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                                      (q.denom))
                                                   (@coe.{1 1} nat int
                                                      (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                                      (r.denom))))
                                             (rat.mk (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
                                                (@has_zero.zero.{0} int int.has_zero))
                                             (@has_zero.zero.{0} rat rat.has_zero)
                                             ((λ (a a_1 : int) (e_1 : @eq.{1} int a a_1) (a_2 a_3 : int)
                                               (e_2 : @eq.{1} int a_2 a_3),
                                                 @congr.{1 1} int rat (rat.mk a) (rat.mk a_1) a_2 a_3
                                                   (@congr_arg.{1 1} int (int → rat) a a_1 rat.mk e_1)
                                                   e_2)
                                                (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
                                                (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
                                                (@eq.refl.{1} int (@has_mul.mul.{0} int int.has_mul (q.num) (r.num)))
                                                (@has_mul.mul.{0} int int.has_mul
                                                   (@coe.{1 1} nat int
                                                      (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                                      (q.denom))
                                                   (@coe.{1 1} nat int
                                                      (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                                      (r.denom)))
                                                (@has_zero.zero.{0} int int.has_zero)
                                                hd)
                                             (rat.mk_zero (… … …))))
                                       …)
                                    this)))))))
             …)))
    …'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
p_prime : nat.prime p,
q r : rat,
hq : @ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero),
hr : @ne.{1} rat r (@has_zero.zero.{0} rat rat.has_zero),
this :
  @eq.{1} rat (@has_mul.mul.{0} rat rat.has_mul q r)
    (rat.mk (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
       (@has_mul.mul.{0} int int.has_mul
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))),
hq&#x27; :
  @ne.{1} rat
    (rat.mk (q.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))
    (@has_zero.zero.{0} rat rat.has_zero),
hr&#x27; :
  @ne.{1} rat
    (rat.mk (r.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
    (@has_zero.zero.{0} rat rat.has_zero),
hp&#x27; :
  @prime.{0} int int.comm_semiring
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
⊢ @eq.{1} int
    (@has_sub.sub.{0} int int.has_sub
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
          (@roption.get.{0} nat
             (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                (@has_mul.mul.{0} int int.has_mul (q.num) (r.num)))
             (@iff.mpr
                (@multiplicity.finite.{0} int int.comm_semiring
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   (@has_mul.mul.{0} int int.has_mul (q.num) (r.num)))
                (and
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
                      (@has_zero.zero.{0} int int.has_zero)))
                (@multiplicity.finite_int_iff
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   (@has_mul.mul.{0} int int.has_mul (q.num) (r.num)))
                (@and.intro
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
                      (@has_zero.zero.{0} int int.has_zero))
                   (@ne.symm.{1} nat (@has_one.one.{0} nat nat.has_one)
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@ne_of_lt.{0} nat
                         (@partial_order.to_preorder.{0} nat
                            (@ordered_comm_monoid.to_partial_order.{0} nat
                               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
                         (@has_one.one.{0} nat nat.has_one)
                         (int.nat_abs
                            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                         (@nat.prime.one_lt p p_prime)))
                   (λ
                    (hn :
                      @eq.{1} int (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
                        (@has_zero.zero.{0} int int.has_zero)),
                      false.rec.{0} false
                        (@eq.mp.{0}
                           (@eq.{1} rat
                              (@has_mul.mul.{0} rat
                                 (@no_zero_divisors.to_has_mul.{0} rat
                                    (@integral_domain.to_no_zero_divisors.{0} rat rat.integral_domain))
                                 q
                                 r)
                              (rat.mk (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
                                 (@has_mul.mul.{0} int int.has_mul
                                    (@coe.{1 1} nat int
                                       (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                       (q.denom))
                                    (@coe.{1 1} nat int
                                       (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                       (r.denom)))))
                           false
                           (@eq.trans.{1} Prop
                              (@eq.{1} rat
                                 (@has_mul.mul.{0} rat
                                    (@no_zero_divisors.to_has_mul.{0} rat
                                       (@integral_domain.to_no_zero_divisors.{0} rat rat.integral_domain))
                                    q
                                    r)
                                 (rat.mk (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
                                    (@has_mul.mul.{0} int int.has_mul
                                       (@coe.{1 1} nat int
                                          (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                          (q.denom))
                                       (@coe.{1 1} nat int
                                          (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                          (r.denom)))))
                              (@eq.{1} rat
                                 (@has_mul.mul.{0} rat
                                    (@no_zero_divisors.to_has_mul.{0} rat
                                       (@integral_domain.to_no_zero_divisors.{0} rat rat.integral_domain))
                                    q
                                    r)
                                 (@has_zero.zero.{0} rat rat.has_zero))
                              false
                              ((λ (a a_1 : rat) (e_1 : @eq.{1} rat a a_1) (a_2 a_3 : rat) (e_2 : @eq.{1} rat a_2 a_3),
                                  @congr.{1 1} rat Prop (@eq.{1} rat a) (@eq.{1} rat a_1) a_2 a_3
                                    (@congr_arg.{1 1} rat (rat → Prop) a a_1 (@eq.{1} rat) e_1)
                                    e_2)
                                 (@has_mul.mul.{0} rat
                                    (@no_zero_divisors.to_has_mul.{0} rat
                                       (@integral_domain.to_no_zero_divisors.{0} rat rat.integral_domain))
                                    q
                                    r)
                                 (@has_mul.mul.{0} rat
                                    (@no_zero_divisors.to_has_mul.{0} rat
                                       (@integral_domain.to_no_zero_divisors.{0} rat rat.integral_domain))
                                    q
                                    r)
                                 (@eq.refl.{1} rat
                                    (@has_mul.mul.{0} rat
                                       (@no_zero_divisors.to_has_mul.{0} rat
                                          (@integral_domain.to_no_zero_divisors.{0} rat rat.integral_domain))
                                       q
                                       r))
                                 (rat.mk (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
                                    (@has_mul.mul.{0} int int.has_mul
                                       (@coe.{1 1} nat int
                                          (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                          (q.denom))
                                       (@coe.{1 1} nat int
                                          (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                          (r.denom))))
                                 (@has_zero.zero.{0} rat rat.has_zero)
                                 (@eq.trans.{1} rat
                                    (rat.mk (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
                                       (@has_mul.mul.{0} int int.has_mul
                                          (@coe.{1 1} nat int
                                             (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                             (q.denom))
                                          (@coe.{1 1} nat int
                                             (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                             (r.denom))))
                                    (rat.mk (@has_zero.zero.{0} int int.has_zero)
                                       (@has_mul.mul.{0} int int.has_mul
                                          (@coe.{1 1} nat int
                                             (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                             (q.denom))
                                          (@coe.{1 1} nat int
                                             (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                             (r.denom))))
                                    (@has_zero.zero.{0} rat rat.has_zero)
                                    ((λ (a a_1 : int) (e_1 : @eq.{1} int a a_1) (a_2 a_3 : int)
                                      (e_2 : @eq.{1} int a_2 a_3),
                                        @congr.{1 1} int rat (rat.mk a) (rat.mk a_1) a_2 a_3
                                          (@congr_arg.{1 1} int (int → rat) a a_1 rat.mk e_1)
                                          e_2)
                                       (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
                                       (@has_zero.zero.{0} int int.has_zero)
                                       hn
                                       (@has_mul.mul.{0} int int.has_mul
                                          (@coe.{1 1} nat int
                                             (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                             (q.denom))
                                          (@coe.{1 1} nat int
                                             (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                             (r.denom)))
                                       (@has_mul.mul.{0} int int.has_mul
                                          (@coe.{1 1} nat int
                                             (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                             (q.denom))
                                          (@coe.{1 1} nat int
                                             (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                             (r.denom)))
                                       (@eq.refl.{1} int
                                          (@has_mul.mul.{0} int int.has_mul
                                             (@coe.{1 1} nat int
                                                (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                                (q.denom))
                                             (@coe.{1 1} nat int
                                                (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                                (r.denom)))))
                                    (rat.zero_mk
                                       (@has_mul.mul.{0} int int.has_mul
                                          (@coe.{1 1} nat int
                                             (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                             (q.denom))
                                          (@coe.{1 1} nat int
                                             (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                             (r.denom))))))
                              (@propext
                                 (@eq.{1} rat
                                    (@has_mul.mul.{0} rat
                                       (@no_zero_divisors.to_has_mul.{0} rat
                                          (@integral_domain.to_no_zero_divisors.{0} rat rat.integral_domain))
                                       q
                                       r)
                                    (@has_zero.zero.{0} rat rat.has_zero))
                                 false
                                 (@iff_false_intro
                                    (@eq.{1} rat
                                       (@has_mul.mul.{0} rat
                                          (@no_zero_divisors.to_has_mul.{0} rat
                                             (@integral_domain.to_no_zero_divisors.{0} rat rat.integral_domain))
                                          q
                                          r)
                                       (@has_zero.zero.{0} rat rat.has_zero))
                                    (@mul_ne_zero.{0} rat rat.integral_domain q r hq hr))))
                           this))))))
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
          (@roption.get.{0} nat
             (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                (@has_mul.mul.{0} int int.has_mul
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom))))
             (@iff.mpr
                (@multiplicity.finite.{0} int int.comm_semiring
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   (@has_mul.mul.{0} int int.has_mul
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                         (r.denom))))
                (and
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int
                      (@has_mul.mul.{0} int int.has_mul
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                            (q.denom))
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                            (r.denom)))
                      (@has_zero.zero.{0} int int.has_zero)))
                (@multiplicity.finite_int_iff
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   (@has_mul.mul.{0} int int.has_mul
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                         (r.denom))))
                (@and.intro
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int
                      (@has_mul.mul.{0} int int.has_mul
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                            (q.denom))
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                            (r.denom)))
                      (@has_zero.zero.{0} int int.has_zero))
                   (@ne.symm.{1} nat (@has_one.one.{0} nat nat.has_one)
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@ne_of_lt.{0} nat
                         (@partial_order.to_preorder.{0} nat
                            (@ordered_comm_monoid.to_partial_order.{0} nat
                               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
                         (@has_one.one.{0} nat nat.has_one)
                         (int.nat_abs
                            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                         (@nat.prime.one_lt p p_prime)))
                   (λ
                    (hd :
                      @eq.{1} int
                        (@has_mul.mul.{0} int int.has_mul
                           (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                              (q.denom))
                           (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                              (r.denom)))
                        (@has_zero.zero.{0} int int.has_zero)),
                      false.rec.{0} false
                        (@eq.mp.{0}
                           (@eq.{1} rat
                              (@has_mul.mul.{0} rat
                                 (@no_zero_divisors.to_has_mul.{0} rat
                                    (@integral_domain.to_no_zero_divisors.{0} rat rat.integral_domain))
                                 q
                                 r)
                              (rat.mk (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
                                 (@has_mul.mul.{0} int int.has_mul
                                    (@coe.{1 1} nat int
                                       (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                       (q.denom))
                                    (@coe.{1 1} nat int
                                       (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                       (r.denom)))))
                           false
                           (@eq.trans.{1} Prop
                              (@eq.{1} rat
                                 (@has_mul.mul.{0} rat
                                    (@no_zero_divisors.to_has_mul.{0} rat
                                       (@integral_domain.to_no_zero_divisors.{0} rat rat.integral_domain))
                                    q
                                    r)
                                 (rat.mk (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
                                    (@has_mul.mul.{0} int int.has_mul
                                       (@coe.{1 1} nat int
                                          (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                          (q.denom))
                                       (@coe.{1 1} nat int
                                          (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                          (r.denom)))))
                              (@eq.{1} rat
                                 (@has_mul.mul.{0} rat
                                    (@no_zero_divisors.to_has_mul.{0} rat
                                       (@integral_domain.to_no_zero_divisors.{0} rat rat.integral_domain))
                                    q
                                    r)
                                 (@has_zero.zero.{0} rat rat.has_zero))
                              false
                              ((λ (a a_1 : rat) (e_1 : @eq.{1} rat a a_1) (a_2 a_3 : rat) (e_2 : @eq.{1} rat a_2 a_3),
                                  @congr.{1 1} rat Prop (@eq.{1} rat a) (@eq.{1} rat a_1) a_2 a_3
                                    (@congr_arg.{1 1} rat (rat → Prop) a a_1 (@eq.{1} rat) e_1)
                                    e_2)
                                 (@has_mul.mul.{0} rat
                                    (@no_zero_divisors.to_has_mul.{0} rat
                                       (@integral_domain.to_no_zero_divisors.{0} rat rat.integral_domain))
                                    q
                                    r)
                                 (@has_mul.mul.{0} rat
                                    (@no_zero_divisors.to_has_mul.{0} rat
                                       (@integral_domain.to_no_zero_divisors.{0} rat rat.integral_domain))
                                    q
                                    r)
                                 (@eq.refl.{1} rat
                                    (@has_mul.mul.{0} rat
                                       (@no_zero_divisors.to_has_mul.{0} rat
                                          (@integral_domain.to_no_zero_divisors.{0} rat rat.integral_domain))
                                       q
                                       r))
                                 (rat.mk (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
                                    (@has_mul.mul.{0} int int.has_mul
                                       (@coe.{1 1} nat int
                                          (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                          (q.denom))
                                       (@coe.{1 1} nat int
                                          (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                          (r.denom))))
                                 (@has_zero.zero.{0} rat rat.has_zero)
                                 (@eq.trans.{1} rat
                                    (rat.mk (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
                                       (@has_mul.mul.{0} int int.has_mul
                                          (@coe.{1 1} nat int
                                             (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                             (q.denom))
                                          (@coe.{1 1} nat int
                                             (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                             (r.denom))))
                                    (rat.mk (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
                                       (@has_zero.zero.{0} int int.has_zero))
                                    (@has_zero.zero.{0} rat rat.has_zero)
                                    ((λ (a a_1 : int) (e_1 : @eq.{1} int a a_1) (a_2 a_3 : int)
                                      (e_2 : @eq.{1} int a_2 a_3),
                                        @congr.{1 1} int rat (rat.mk a) (rat.mk a_1) a_2 a_3
                                          (@congr_arg.{1 1} int (int → rat) a a_1 rat.mk e_1)
                                          e_2)
                                       (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
                                       (@has_mul.mul.{0} int int.has_mul (q.num) (r.num))
                                       (@eq.refl.{1} int (@has_mul.mul.{0} int int.has_mul (q.num) (r.num)))
                                       (@has_mul.mul.{0} int int.has_mul
                                          (@coe.{1 1} nat int
                                             (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                             (q.denom))
                                          (@coe.{1 1} nat int
                                             (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                             (r.denom)))
                                       (@has_zero.zero.{0} int int.has_zero)
                                       hd)
                                    (rat.mk_zero (@has_mul.mul.{0} int int.has_mul (q.num) (r.num)))))
                              (@propext
                                 (@eq.{1} rat
                                    (@has_mul.mul.{0} rat
                                       (@no_zero_divisors.to_has_mul.{0} rat
                                          (@integral_domain.to_no_zero_divisors.{0} rat rat.integral_domain))
                                       q
                                       r)
                                    (@has_zero.zero.{0} rat rat.has_zero))
                                 false
                                 (@iff_false_intro
                                    (@eq.{1} rat
                                       (@has_mul.mul.{0} rat
                                          (@no_zero_divisors.to_has_mul.{0} rat
                                             (@integral_domain.to_no_zero_divisors.{0} rat rat.integral_domain))
                                          q
                                          r)
                                       (@has_zero.zero.{0} rat rat.has_zero))
                                    (@mul_ne_zero.{0} rat rat.integral_domain q r hq hr))))
                           this)))))))
    (@has_add.add.{0} int int.has_add
       (@has_sub.sub.{0} int int.has_sub
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
             (@roption.get.{0} nat
                (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   (q.num))
                (@iff.mpr
                   (@multiplicity.finite.{0} int int.comm_semiring
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                      (q.num))
                   (and
                      (@ne.{1} nat
                         (int.nat_abs
                            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                         (@has_one.one.{0} nat nat.has_one))
                      (@ne.{1} int (q.num) (@has_zero.zero.{0} int int.has_zero)))
                   (@multiplicity.finite_int_iff
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                      (q.num))
                   (@and.intro
                      (@ne.{1} nat
                         (int.nat_abs
                            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                         (@has_one.one.{0} nat nat.has_one))
                      (@ne.{1} int (q.num) (@has_zero.zero.{0} int int.has_zero))
                      (@ne.symm.{1} nat (@has_one.one.{0} nat nat.has_one)
                         (int.nat_abs
                            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                         (@ne_of_lt.{0} nat
                            (@partial_order.to_preorder.{0} nat
                               (@ordered_comm_monoid.to_partial_order.{0} nat
                                  (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                                     (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
                            (@has_one.one.{0} nat nat.has_one)
                            (int.nat_abs
                               (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                  p))
                            (@nat.prime.one_lt p p_prime)))
                      (λ (hn : @eq.{1} int (q.num) (@has_zero.zero.{0} int int.has_zero)),
                         false.rec.{0} false
                           (@eq.mp.{0}
                              (@eq.{1} rat
                                 (rat.mk (q.num)
                                    (@coe.{1 1} nat int
                                       (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                       (q.denom)))
                                 (rat.mk (q.num)
                                    (@coe.{1 1} nat int
                                       (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                       (q.denom))))
                              false
                              (@eq.trans.{1} Prop
                                 (@eq.{1} rat
                                    (rat.mk (q.num)
                                       (@coe.{1 1} nat int
                                          (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                          (q.denom)))
                                    (rat.mk (q.num)
                                       (@coe.{1 1} nat int
                                          (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                          (q.denom))))
                                 (@eq.{1} rat
                                    (rat.mk (q.num)
                                       (@coe.{1 1} nat int
                                          (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                          (q.denom)))
                                    (@has_zero.zero.{0} rat rat.has_zero))
                                 false
                                 ((λ (a a_1 : rat) (e_1 : @eq.{1} rat a a_1) (a_2 a_3 : rat)
                                   (e_2 : @eq.{1} rat a_2 a_3),
                                     @congr.{1 1} rat Prop (@eq.{1} rat a) (@eq.{1} rat a_1) a_2 a_3
                                       (@congr_arg.{1 1} rat (rat → Prop) a a_1 (@eq.{1} rat) e_1)
                                       e_2)
                                    (rat.mk (q.num)
                                       (@coe.{1 1} nat int
                                          (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                          (q.denom)))
                                    (rat.mk (q.num)
                                       (@coe.{1 1} nat int
                                          (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                          (q.denom)))
                                    (@eq.refl.{1} rat
                                       (rat.mk (q.num)
                                          (@coe.{1 1} nat int
                                             (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                             (q.denom))))
                                    (rat.mk (q.num)
                                       (@coe.{1 1} nat int
                                          (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                          (q.denom)))
                                    (@has_zero.zero.{0} rat rat.has_zero)
                                    (@eq.trans.{1} rat
                                       (rat.mk (q.num)
                                          (@coe.{1 1} nat int
                                             (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                             (q.denom)))
                                       (rat.mk (@has_zero.zero.{0} int int.has_zero)
                                          (@coe.{1 1} nat int
                                             (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                             (q.denom)))
                                       (@has_zero.zero.{0} rat rat.has_zero)
                                       ((λ (a a_1 : int) (e_1 : @eq.{1} int a a_1) (a_2 a_3 : int)
                                         (e_2 : @eq.{1} int a_2 a_3),
                                           @congr.{1 1} int rat (rat.mk a) (rat.mk a_1) a_2 a_3
                                             (@congr_arg.{1 1} int (int → rat) a a_1 rat.mk e_1)
                                             e_2)
                                          (q.num)
                                          (@has_zero.zero.{0} int int.has_zero)
                                          hn
                                          (@coe.{1 1} nat int
                                             (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                             (q.denom))
                                          (@coe.{1 1} nat int
                                             (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                             (q.denom))
                                          (@eq.refl.{1} int
                                             (@coe.{1 1} nat int
                                                (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                                (q.denom))))
                                       (rat.zero_mk
                                          (@coe.{1 1} nat int
                                             (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                             (q.denom)))))
                                 (@propext
                                    (@eq.{1} rat
                                       (rat.mk (q.num)
                                          (@coe.{1 1} nat int
                                             (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                             (q.denom)))
                                       (@has_zero.zero.{0} rat rat.has_zero))
                                    false
                                    (@iff_false_intro
                                       (@eq.{1} rat
                                          (rat.mk (q.num)
                                             (@coe.{1 1} nat int
                                                (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                                (q.denom)))
                                          (@has_zero.zero.{0} rat rat.has_zero))
                                       hq&#x27;)))
                              (@eq.refl.{1} rat
                                 (rat.mk (q.num)
                                    (@coe.{1 1} nat int
                                       (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                       (q.denom))))))))))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
             (@roption.get.{0} nat
                (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))
                (@iff.mpr
                   (@multiplicity.finite.{0} int int.comm_semiring
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))
                   (and
                      (@ne.{1} nat
                         (int.nat_abs
                            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                         (@has_one.one.{0} nat nat.has_one))
                      (@ne.{1} int
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                            (q.denom))
                         (@has_zero.zero.{0} int int.has_zero)))
                   (@multiplicity.finite_int_iff
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))
                   (@and.intro
                      (@ne.{1} nat
                         (int.nat_abs
                            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                         (@has_one.one.{0} nat nat.has_one))
                      (@ne.{1} int
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                            (q.denom))
                         (@has_zero.zero.{0} int int.has_zero))
                      (@ne.symm.{1} nat (@has_one.one.{0} nat nat.has_one)
                         (int.nat_abs
                            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                         (@ne_of_lt.{0} nat
                            (@partial_order.to_preorder.{0} nat
                               (@ordered_comm_monoid.to_partial_order.{0} nat
                                  (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                                     (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
                            (@has_one.one.{0} nat nat.has_one)
                            (int.nat_abs
                               (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                  p))
                            (@nat.prime.one_lt p p_prime)))
                      (λ
                       (hd :
                         @eq.{1} int
                           (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                              (q.denom))
                           (@has_zero.zero.{0} int int.has_zero)),
                         false.rec.{0} false
                           (@eq.mp.{0}
                              (@eq.{1} rat
                                 (rat.mk (q.num)
                                    (@coe.{1 1} nat int
                                       (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                       (q.denom)))
                                 (rat.mk (q.num)
                                    (@coe.{1 1} nat int
                                       (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                       (q.denom))))
                              false
                              (@eq.trans.{1} Prop
                                 (@eq.{1} rat
                                    (rat.mk (q.num)
                                       (@coe.{1 1} nat int
                                          (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                          (q.denom)))
                                    (rat.mk (q.num)
                                       (@coe.{1 1} nat int
                                          (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                          (q.denom))))
                                 (@eq.{1} rat
                                    (rat.mk (q.num)
                                       (@coe.{1 1} nat int
                                          (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                          (q.denom)))
                                    (@has_zero.zero.{0} rat rat.has_zero))
                                 false
                                 ((λ (a a_1 : rat) (e_1 : @eq.{1} rat a a_1) (a_2 a_3 : rat)
                                   (e_2 : @eq.{1} rat a_2 a_3),
                                     @congr.{1 1} rat Prop (@eq.{1} rat a) (@eq.{1} rat a_1) a_2 a_3
                                       (@congr_arg.{1 1} rat (rat → Prop) a a_1 (@eq.{1} rat) e_1)
                                       e_2)
                                    (rat.mk (q.num)
                                       (@coe.{1 1} nat int
                                          (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                          (q.denom)))
                                    (rat.mk (q.num)
                                       (@coe.{1 1} nat int
                                          (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                          (q.denom)))
                                    (@eq.refl.{1} rat
                                       (rat.mk (q.num)
                                          (@coe.{1 1} nat int
                                             (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                             (q.denom))))
                                    (rat.mk (q.num)
                                       (@coe.{1 1} nat int
                                          (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                          (q.denom)))
                                    (@has_zero.zero.{0} rat rat.has_zero)
                                    (@eq.trans.{1} rat
                                       (rat.mk (q.num)
                                          (@coe.{1 1} nat int
                                             (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                             (q.denom)))
                                       (rat.mk (q.num) (@has_zero.zero.{0} int int.has_zero))
                                       (@has_zero.zero.{0} rat rat.has_zero)
                                       ((λ (a a_1 : int) (e_1 : @eq.{1} int a a_1) (a_2 a_3 : int)
                                         (e_2 : @eq.{1} int a_2 a_3),
                                           @congr.{1 1} int rat (rat.mk a) (rat.mk a_1) a_2 a_3
                                             (@congr_arg.{1 1} int (int → rat) a a_1 rat.mk e_1)
                                             e_2)
                                          (q.num)
                                          (q.num)
                                          (@eq.refl.{1} int (q.num))
                                          (@coe.{1 1} nat int
                                             (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                             (q.denom))
                                          (@has_zero.zero.{0} int int.has_zero)
                                          hd)
                                       (rat.mk_zero (q.num))))
                                 (@propext
                                    (@eq.{1} rat
                                       (rat.mk (q.num)
                                          (@coe.{1 1} nat int
                                             (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                             (q.denom)))
                                       (@has_zero.zero.{0} rat rat.has_zero))
                                    false
                                    (@iff_false_intro
                                       (@eq.{1} rat
                                          (rat.mk (q.num)
                                             (@coe.{1 1} nat int
                                                (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                                (q.denom)))
                                          (@has_zero.zero.{0} rat rat.has_zero))
                                       hq&#x27;)))
                              (@eq.refl.{1} rat
                                 (rat.mk (q.num)
                                    (@coe.{1 1} nat int
                                       (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                       (q.denom)))))))))))
       (@has_sub.sub.{0} int int.has_sub
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
             (@roption.get.{0} nat
                (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   (r.num))
                (@iff.mpr
                   (@multiplicity.finite.{0} int int.comm_semiring
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                      (r.num))
                   (and
                      (@ne.{1} nat
                         (int.nat_abs
                            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                         (@has_one.one.{0} nat nat.has_one))
                      (@ne.{1} int (r.num) (@has_zero.zero.{0} int int.has_zero)))
                   (@multiplicity.finite_int_iff
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                      (r.num))
                   (@and.intro
                      (@ne.{1} nat
                         (int.nat_abs
                            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                         (@has_one.one.{0} nat nat.has_one))
                      (@ne.{1} int (r.num) (@has_zero.zero.{0} int int.has_zero))
                      (… … …)
                      …))))
          …))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>158  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>159  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>160  /--</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>161  A rewrite lemma for `padic_val_rat p (q^k) with condition `q ≠ 0`.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>162  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>163  protected lemma pow {q : ℚ} (hq : q ≠ 0) {k : ℕ} :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='blue'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='q'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ne'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/rat/basic.lean&#x27;, &#x27;line&#x27;: 46, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 97, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 293, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='orange'><a title='`rat`, or `ℚ`, is the type of rational numbers. It is defined
 as the set of pairs ⟨n, d⟩ of integers such that `d` is positive and `n` and
 `d` are coprime. This representation is preferred to the quotient
 because without periodic reduction, the numerator and denominator can grow
 exponentially (for example, adding 1/2 to itself repeatedly).'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>164      padic_val_rat p (q ^ k) = k * padic_val_rat p q :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='padic_val_rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='q'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_pow.pow'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='k'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='k'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mul.mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='padic_val_rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='q'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 62, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 340, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 312, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 62, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='nat → rat → int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α β : Type} [c : has_pow.{0 0} α β], α → β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_mul.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat → rat → int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='For `p ≠ 1`, the p-adic valuation of an integer `z ≠ 0` is the largest natural number `n` such that
p^n divides z.

`padic_val_rat` defines the valuation of a rational `q` to be the valuation of `q.num` minus the
valuation of `q.denom`.
If `q = 0` or `p = 1`, then `padic_val_rat p q` defaults to 0.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='For `p ≠ 1`, the p-adic valuation of an integer `z ≠ 0` is the largest natural number `n` such that
p^n divides z.

`padic_val_rat` defines the valuation of a rational `q` to be the valuation of `q.num` minus the
valuation of `q.denom`.
If `q = 0` or `p = 1`, then `padic_val_rat p q` defaults to 0.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>165  by induction k; simp [*, padic_val_rat.mul _ hq (pow_ne_zero _ hq),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='k'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='padic_val_rat.mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='pow_ne_zero'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='hq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 528, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 147, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/group_power.lean&#x27;, &#x27;line&#x27;: 489, &#x27;column&#x27;: 23}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.using_ident → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} (list.{0} name)) (λ (a : option.{0} (list.{0} name)), @option.has_reflect (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) `(list.{0} name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative (list.{0} name) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit (list.{0} name) (lean.parser.tk (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident))) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (p : nat) [p_prime : nat.prime p] {q r : rat}, @ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero) → @ne.{1} rat r (@has_zero.zero.{0} rat rat.has_zero) → @eq.{1} int (padic_val_rat p (@has_mul.mul.{0} rat rat.has_mul q r)) (@has_add.add.{0} int int.has_add (padic_val_rat p q) (padic_val_rat p r))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type} [_inst_1 : domain.{0} α] {a : α} (n : nat), @ne.{1} α a (@has_zero.zero.{0} α (@no_zero_divisors.to_has_zero.{0} α (@domain.to_no_zero_divisors.{0} α _inst_1))) → @ne.{1} α (@has_pow.pow.{0 0} α nat (@monoid.has_pow.{0} α (@ring.to_monoid.{0} α (@domain.to_ring.{0} α _inst_1))) a n) (@has_zero.zero.{0} α (@no_zero_divisors.to_has_zero.{0} α (@domain.to_no_zero_divisors.{0} α _inst_1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor and an inductive hypothesis is added for each recursive argument to the constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the inductive hypothesis incorporates that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (nat.succ a)` and `ih₁ : P a → Q a` and target `Q (nat.succ a)`. Here the names `a` and `ih₁` ire chosen automatically.

`induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.

`induction e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors and inductive hypotheses, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically. Note that for long sequences of names, the `case` tactic provides a more convenient naming mechanism.

`induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables

`induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.

`induction h : t` will introduce an equality of the form `h : t = C x y`, asserting that the input term is equal to the current constructor case, to the context.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='A rewrite lemma for `padic_val_rat p (q * r)` with conditions `q ≠ 0`, `r ≠ 0`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='induction'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(using id)?&#x27;, &#x27;(with id*)?&#x27;, &#x27;(generalizing id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='p : nat,
p_prime : nat.prime p,
q : rat,
hq : @ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero),
k : nat
⊢ @eq.{1} int (padic_val_rat p (@has_pow.pow.{0 0} rat nat (@monoid.has_pow.{0} rat rat.monoid) q k))
    (@has_mul.mul.{0} int int.has_mul
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) k)
       (padic_val_rat p q))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>166    _root_.pow_succ, add_mul]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='pow_succ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='add_mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/group_power.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/ring.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} [_inst_1 : monoid.{?l_1} α] (a : α) (n : nat), @eq.{?l_1+1} α (@has_pow.pow.{?l_1 0} α nat (@monoid.has_pow.{?l_1} α _inst_1) a (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) (@has_mul.mul.{?l_1} α (@semigroup.to_has_mul.{?l_1} α (@monoid.to_semigroup.{?l_1} α _inst_1)) a (@has_pow.pow.{?l_1 0} α nat (@monoid.has_pow.{?l_1} α _inst_1) a n))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} [_inst_1 : distrib.{?l_1} α] (a b c : α), @eq.{?l_1+1} α (@has_mul.mul.{?l_1} α (@distrib.to_has_mul.{?l_1} α _inst_1) (@has_add.add.{?l_1} α (@distrib.to_has_add.{?l_1} α _inst_1) a b) c) (@has_add.add.{?l_1} α (@distrib.to_has_add.{?l_1} α _inst_1) (@has_mul.mul.{?l_1} α (@distrib.to_has_mul.{?l_1} α _inst_1) a c) (@has_mul.mul.{?l_1} α (@distrib.to_has_mul.{?l_1} α _inst_1) b c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
p_prime : nat.prime p,
q : rat,
hq : @ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero),
k : nat
⊢ @eq.{1} int (padic_val_rat p (@has_pow.pow.{0 0} rat nat (@monoid.has_pow.{0} rat rat.monoid) q k))
    (@has_mul.mul.{0} int int.has_mul
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) k)
       (padic_val_rat p q))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>167  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
p_prime : nat.prime p,
q : rat,
hq : @ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero),
k : nat
⊢ @eq.{1} int (padic_val_rat p (@has_pow.pow.{0 0} rat nat (@monoid.has_pow.{0} rat rat.monoid) q k))
    (@has_mul.mul.{0} int int.has_mul
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) k)
       (padic_val_rat p q))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>168  /--</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>169  A rewrite lemma for `padic_val_rat p (q⁻¹)` with condition `q ≠ 0`.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>170  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>171  protected lemma inv {q : ℚ} (hq : q ≠ 0) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='blue'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='q'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ne'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/rat/basic.lean&#x27;, &#x27;line&#x27;: 46, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 97, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='orange'><a title='`rat`, or `ℚ`, is the type of rational numbers. It is defined
 as the set of pairs ⟨n, d⟩ of integers such that `d` is positive and `n` and
 `d` are coprime. This representation is preferred to the quotient
 because without periodic reduction, the numerator and denominator can grow
 exponentially (for example, adding 1/2 to itself repeatedly).'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>172    padic_val_rat p (q⁻¹) = -padic_val_rat p q :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='padic_val_rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='q'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_inv.inv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_neg.neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='padic_val_rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='q'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 62, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 313, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 314, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 62, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='nat → rat → int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type} [c : has_inv.{0} α], α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_neg.{0} α], α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat → rat → int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='For `p ≠ 1`, the p-adic valuation of an integer `z ≠ 0` is the largest natural number `n` such that
p^n divides z.

`padic_val_rat` defines the valuation of a rational `q` to be the valuation of `q.num` minus the
valuation of `q.denom`.
If `q = 0` or `p = 1`, then `padic_val_rat p q` defaults to 0.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='For `p ≠ 1`, the p-adic valuation of an integer `z ≠ 0` is the largest natural number `n` such that
p^n divides z.

`padic_val_rat` defines the valuation of a rational `q` to be the valuation of `q.num` minus the
valuation of `q.denom`.
If `q = 0` or `p = 1`, then `padic_val_rat p q` defaults to 0.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>173  by rw [eq_neg_iff_add_eq_zero, ← padic_val_rat.mul p (inv_ne_zero hq) hq,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='eq_neg_iff_add_eq_zero'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='padic_val_rat.mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='inv_ne_zero'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='hq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/group/basic.lean&#x27;, &#x27;line&#x27;: 104, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 147, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/field.lean&#x27;, &#x27;line&#x27;: 79, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : add_group.{0} α] {a b : α}, iff (@eq.{1} α a (@has_neg.neg.{0} α (@add_group.to_has_neg.{0} α _inst_1) b)) (@eq.{1} α (@has_add.add.{0} α (@add_semigroup.to_has_add.{0} α (@add_monoid.to_add_semigroup.{0} α (@add_group.to_add_monoid.{0} α _inst_1))) a b) (@has_zero.zero.{0} α (@add_monoid.to_has_zero.{0} α (@add_group.to_add_monoid.{0} α _inst_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (p : nat) [p_prime : nat.prime p] {q r : rat}, @ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero) → @ne.{1} rat r (@has_zero.zero.{0} rat rat.has_zero) → @eq.{1} int (padic_val_rat p (@has_mul.mul.{0} rat rat.has_mul q r)) (@has_add.add.{0} int int.has_add (padic_val_rat p q) (padic_val_rat p r))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type} [_inst_1 : division_ring.{0} α] {a : α}, @ne.{1} α a (@has_zero.zero.{0} α (@zero_ne_one_class.to_has_zero.{0} α (@division_ring.to_zero_ne_one_class.{0} α _inst_1))) → @ne.{1} α (@has_inv.inv.{0} α (@division_ring.to_has_inv.{0} α _inst_1) a) (@has_zero.zero.{0} α (@zero_ne_one_class.to_has_zero.{0} α (@division_ring.to_zero_ne_one_class.{0} α _inst_1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='A rewrite lemma for `padic_val_rat p (q * r)` with conditions `q ≠ 0`, `r ≠ 0`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='p : nat,
p_prime : nat.prime p,
q : rat,
hq : @ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)
⊢ @eq.{1} int (padic_val_rat p (@has_inv.inv.{0} rat rat.has_inv q))
    (@has_neg.neg.{0} int int.has_neg (padic_val_rat p q))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
p_prime : nat.prime p,
q : rat,
hq : @ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)
⊢ @eq.{1} int
    (@has_add.add.{0} int
       (@add_semigroup.to_has_add.{0} int
          (@add_monoid.to_add_semigroup.{0} int
             (@add_group.to_add_monoid.{0} int
                (@add_comm_group.to_add_group.{0} int (@ring.to_add_comm_group.{0} int int.ring)))))
       (padic_val_rat p (@has_inv.inv.{0} rat rat.has_inv q))
       (padic_val_rat p q))
    (@has_zero.zero.{0} int
       (@add_monoid.to_has_zero.{0} int
          (@add_group.to_add_monoid.{0} int
             (@add_comm_group.to_add_group.{0} int (@ring.to_add_comm_group.{0} int int.ring)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
p_prime : nat.prime p,
q : rat,
hq : @ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)
⊢ @eq.{1} int
    (padic_val_rat p
       (@has_mul.mul.{0} rat rat.has_mul (@has_inv.inv.{0} rat (@division_ring.to_has_inv.{0} rat rat.division_ring) q)
          q))
    (@has_zero.zero.{0} int
       (@add_monoid.to_has_zero.{0} int
          (@add_group.to_add_monoid.{0} int
             (@add_comm_group.to_add_group.{0} int (@ring.to_add_comm_group.{0} int int.ring)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>174      inv_mul_cancel hq, padic_val_rat.one]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='inv_mul_cancel'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='padic_val_rat.one'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/field.lean&#x27;, &#x27;line&#x27;: 42, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 99, &#x27;column&#x27;: 24}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : division_ring.{0} α] {a : α}, @ne.{1} α a (@has_zero.zero.{0} α (@zero_ne_one_class.to_has_zero.{0} α (@division_ring.to_zero_ne_one_class.{0} α _inst_1))) → @eq.{1} α (@has_mul.mul.{0} α (@mul_zero_class.to_has_mul.{0} α (@semiring.to_mul_zero_class.{0} α (@ring.to_semiring.{0} α (@division_ring.to_ring.{0} α _inst_1)))) (@has_inv.inv.{0} α (@division_ring.to_has_inv.{0} α _inst_1) a) a) (@has_one.one.{0} α (@zero_ne_one_class.to_has_one.{0} α (@division_ring.to_zero_ne_one_class.{0} α _inst_1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {p : nat}, @eq.{1} int (padic_val_rat p (@has_one.one.{0} rat rat.has_one)) (@has_zero.zero.{0} int int.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`padic_val_rat p 1` is 0 for any `p`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
p_prime : nat.prime p,
q : rat,
hq : @ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)
⊢ @eq.{1} int
    (padic_val_rat p
       (@has_mul.mul.{0} rat rat.has_mul (@has_inv.inv.{0} rat (@division_ring.to_has_inv.{0} rat rat.division_ring) q)
          q))
    (@has_zero.zero.{0} int
       (@add_monoid.to_has_zero.{0} int
          (@add_group.to_add_monoid.{0} int
             (@add_comm_group.to_add_group.{0} int (@ring.to_add_comm_group.{0} int int.ring)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
p_prime : nat.prime p,
q : rat,
hq : @ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)
⊢ @eq.{1} int
    (padic_val_rat p
       (@has_one.one.{0} rat
          (@zero_ne_one_class.to_has_one.{0} rat (@division_ring.to_zero_ne_one_class.{0} rat rat.division_ring))))
    (@has_zero.zero.{0} int
       (@add_monoid.to_has_zero.{0} int
          (@add_group.to_add_monoid.{0} int
             (@add_comm_group.to_add_group.{0} int (@ring.to_add_comm_group.{0} int int.ring)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
p_prime : nat.prime p,
q : rat,
hq : @ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)
⊢ @eq.{1} int (padic_val_rat p (@has_inv.inv.{0} rat rat.has_inv q))
    (@has_neg.neg.{0} int int.has_neg (padic_val_rat p q))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>175  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
p_prime : nat.prime p,
q : rat,
hq : @ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)
⊢ @eq.{1} int (padic_val_rat p (@has_inv.inv.{0} rat rat.has_inv q))
    (@has_neg.neg.{0} int int.has_neg (padic_val_rat p q))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>176  /--</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>177  A rewrite lemma for `padic_val_rat p (q / r)` with conditions `q ≠ 0`, `r ≠ 0`.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>178  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>179  protected lemma div {q r : ℚ} (hq : q ≠ 0) (hr : r ≠ 0) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='blue'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='q'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ne'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='r'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ne'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/rat/basic.lean&#x27;, &#x27;line&#x27;: 46, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 97, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 97, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='orange'><a title='`rat`, or `ℚ`, is the type of rational numbers. It is defined
 as the set of pairs ⟨n, d⟩ of integers such that `d` is positive and `n` and
 `d` are coprime. This representation is preferred to the quotient
 because without periodic reduction, the numerator and denominator can grow
 exponentially (for example, adding 1/2 to itself repeatedly).'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>180    padic_val_rat p (q / r) = padic_val_rat p q - padic_val_rat p r :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='padic_val_rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='q'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_div.div'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='r'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='padic_val_rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='q'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_sub.sub'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='padic_val_rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='r'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 62, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 316, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 62, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 315, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 62, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='nat → rat → int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_div.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat → rat → int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_sub.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat → rat → int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='For `p ≠ 1`, the p-adic valuation of an integer `z ≠ 0` is the largest natural number `n` such that
p^n divides z.

`padic_val_rat` defines the valuation of a rational `q` to be the valuation of `q.num` minus the
valuation of `q.denom`.
If `q = 0` or `p = 1`, then `padic_val_rat p q` defaults to 0.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='For `p ≠ 1`, the p-adic valuation of an integer `z ≠ 0` is the largest natural number `n` such that
p^n divides z.

`padic_val_rat` defines the valuation of a rational `q` to be the valuation of `q.num` minus the
valuation of `q.denom`.
If `q = 0` or `p = 1`, then `padic_val_rat p q` defaults to 0.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='For `p ≠ 1`, the p-adic valuation of an integer `z ≠ 0` is the largest natural number `n` such that
p^n divides z.

`padic_val_rat` defines the valuation of a rational `q` to be the valuation of `q.num` minus the
valuation of `q.denom`.
If `q = 0` or `p = 1`, then `padic_val_rat p q` defaults to 0.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>181  by rw [div_eq_mul_inv, padic_val_rat.mul p hq (inv_ne_zero hr),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='div_eq_mul_inv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='padic_val_rat.mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='inv_ne_zero'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/field.lean&#x27;, &#x27;line&#x27;: 64, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 147, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/field.lean&#x27;, &#x27;line&#x27;: 79, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [s : division_ring.{0} α] {a b : α}, @eq.{1} α (@has_div.div.{0} α (@division_ring_has_div&#x27;.{0} α s) a b) (@has_mul.mul.{0} α (@no_zero_divisors.to_has_mul.{0} α (@domain.to_no_zero_divisors.{0} α (@division_ring.to_domain.{0} α s))) a (@has_inv.inv.{0} α (@division_ring.to_has_inv.{0} α s) b))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (p : nat) [p_prime : nat.prime p] {q r : rat}, @ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero) → @ne.{1} rat r (@has_zero.zero.{0} rat rat.has_zero) → @eq.{1} int (padic_val_rat p (@has_mul.mul.{0} rat rat.has_mul q r)) (@has_add.add.{0} int int.has_add (padic_val_rat p q) (padic_val_rat p r))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type} [_inst_1 : division_ring.{0} α] {a : α}, @ne.{1} α a (@has_zero.zero.{0} α (@zero_ne_one_class.to_has_zero.{0} α (@division_ring.to_zero_ne_one_class.{0} α _inst_1))) → @ne.{1} α (@has_inv.inv.{0} α (@division_ring.to_has_inv.{0} α _inst_1) a) (@has_zero.zero.{0} α (@zero_ne_one_class.to_has_zero.{0} α (@division_ring.to_zero_ne_one_class.{0} α _inst_1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@ne.{1} rat r (@has_zero.zero.{0} rat rat.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='A rewrite lemma for `padic_val_rat p (q * r)` with conditions `q ≠ 0`, `r ≠ 0`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='p : nat,
p_prime : nat.prime p,
q r : rat,
hq : @ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero),
hr : @ne.{1} rat r (@has_zero.zero.{0} rat rat.has_zero)
⊢ @eq.{1} int (padic_val_rat p (@has_div.div.{0} rat (@division_ring_has_div&#x27;.{0} rat rat.division_ring) q r))
    (@has_sub.sub.{0} int int.has_sub (padic_val_rat p q) (padic_val_rat p r))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
p_prime : nat.prime p,
q r : rat,
hq : @ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero),
hr : @ne.{1} rat r (@has_zero.zero.{0} rat rat.has_zero)
⊢ @eq.{1} int
    (padic_val_rat p
       (@has_mul.mul.{0} rat
          (@no_zero_divisors.to_has_mul.{0} rat
             (@domain.to_no_zero_divisors.{0} rat (@division_ring.to_domain.{0} rat rat.division_ring)))
          q
          (@has_inv.inv.{0} rat (@division_ring.to_has_inv.{0} rat rat.division_ring) r)))
    (@has_sub.sub.{0} int int.has_sub (padic_val_rat p q) (padic_val_rat p r))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
p_prime : nat.prime p,
q r : rat,
hq : @ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero),
hr : @ne.{1} rat r (@has_zero.zero.{0} rat rat.has_zero)
⊢ @eq.{1} int
    (@has_add.add.{0} int int.has_add (padic_val_rat p q)
       (padic_val_rat p (@has_inv.inv.{0} rat (@division_ring.to_has_inv.{0} rat rat.division_ring) r)))
    (@has_sub.sub.{0} int int.has_sub (padic_val_rat p q) (padic_val_rat p r))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>182      padic_val_rat.inv p hr, sub_eq_add_neg]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='padic_val_rat.inv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='sub_eq_add_neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 171, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 324, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (p : nat) [p_prime : nat.prime p] {q : rat}, @ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero) → @eq.{1} int (padic_val_rat p (@has_inv.inv.{0} rat rat.has_inv q)) (@has_neg.neg.{0} int int.has_neg (padic_val_rat p q))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@ne.{1} rat r (@has_zero.zero.{0} rat rat.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : add_group.{0} α] (a b : α), @eq.{1} α (@has_sub.sub.{0} α (@add_group_has_sub.{0} α _inst_1) a b) (@has_add.add.{0} α (@add_semigroup.to_has_add.{0} α (@add_monoid.to_add_semigroup.{0} α (@add_group.to_add_monoid.{0} α _inst_1))) a (@has_neg.neg.{0} α (@add_group.to_has_neg.{0} α _inst_1) b))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='A rewrite lemma for `padic_val_rat p (q⁻¹)` with condition `q ≠ 0`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
p_prime : nat.prime p,
q r : rat,
hq : @ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero),
hr : @ne.{1} rat r (@has_zero.zero.{0} rat rat.has_zero)
⊢ @eq.{1} int
    (@has_add.add.{0} int int.has_add (padic_val_rat p q)
       (padic_val_rat p (@has_inv.inv.{0} rat (@division_ring.to_has_inv.{0} rat rat.division_ring) r)))
    (@has_sub.sub.{0} int int.has_sub (padic_val_rat p q) (padic_val_rat p r))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
p_prime : nat.prime p,
q r : rat,
hq : @ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero),
hr : @ne.{1} rat r (@has_zero.zero.{0} rat rat.has_zero)
⊢ @eq.{1} int
    (@has_add.add.{0} int int.has_add (padic_val_rat p q) (@has_neg.neg.{0} int int.has_neg (padic_val_rat p r)))
    (@has_sub.sub.{0} int int.has_sub (padic_val_rat p q) (padic_val_rat p r))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
p_prime : nat.prime p,
q r : rat,
hq : @ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero),
hr : @ne.{1} rat r (@has_zero.zero.{0} rat rat.has_zero)
⊢ @eq.{1} int (padic_val_rat p (@has_div.div.{0} rat (@division_ring_has_div&#x27;.{0} rat rat.division_ring) q r))
    (@has_sub.sub.{0} int int.has_sub (padic_val_rat p q) (padic_val_rat p r))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>183  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
p_prime : nat.prime p,
q r : rat,
hq : @ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero),
hr : @ne.{1} rat r (@has_zero.zero.{0} rat rat.has_zero)
⊢ @eq.{1} int (padic_val_rat p (@has_div.div.{0} rat (@division_ring_has_div&#x27;.{0} rat rat.division_ring) q r))
    (@has_sub.sub.{0} int int.has_sub (padic_val_rat p q) (padic_val_rat p r))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>184  /--</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>185  A condition for `padic_val_rat p (n₁ / d₁) ≤ padic_val_rat p (n₂ / d₂),</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>186  in terms of divisibility by `p^n`.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>187  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>188  lemma padic_val_rat_le_padic_val_rat_iff {n₁ n₂ d₁ d₂ : ℤ}</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                        </code><font color='blue'><a title='int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/int/basic.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                        </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>189    (hn₁ : n₁ ≠ 0) (hn₂ : n₂ ≠ 0) (hd₁ : d₁ ≠ 0) (hd₂ : d₂ ≠ 0) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='n₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ne'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='n₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ne'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='d₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ne'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='d₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ne'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 97, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 97, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 97, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 97, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>190    padic_val_rat p (n₁ /. d₁) ≤ padic_val_rat p (n₂ /. d₂) ↔</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='padic_val_rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='n₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='rat.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='d₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_le.le'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='padic_val_rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='n₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='rat.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='d₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 62, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/rat/basic.lean&#x27;, &#x27;line&#x27;: 96, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 319, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 62, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/rat/basic.lean&#x27;, &#x27;line&#x27;: 96, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='nat → rat → int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='int → int → rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type} [c : has_le.{0} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat → rat → int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='int → int → rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='For `p ≠ 1`, the p-adic valuation of an integer `z ≠ 0` is the largest natural number `n` such that
p^n divides z.

`padic_val_rat` defines the valuation of a rational `q` to be the valuation of `q.num` minus the
valuation of `q.denom`.
If `q = 0` or `p = 1`, then `padic_val_rat p q` defaults to 0.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='Form the quotient `n / d` where `n d : ℤ`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='For `p ≠ 1`, the p-adic valuation of an integer `z ≠ 0` is the largest natural number `n` such that
p^n divides z.

`padic_val_rat` defines the valuation of a rational `q` to be the valuation of `q.num` minus the
valuation of `q.denom`.
If `q = 0` or `p = 1`, then `padic_val_rat p q` defaults to 0.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='Form the quotient `n / d` where `n d : ℤ`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>191    ∀ (n : ℕ), ↑p ^ n ∣ n₁ * d₂ → ↑p ^ n ∣ n₂ * d₁ :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='coe'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_pow.pow'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_dvd.dvd'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mul.mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='d₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='coe'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_pow.pow'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_dvd.dvd'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mul.mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='d₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 293, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/coe.lean&#x27;, &#x27;line&#x27;: 67, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 340, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 317, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 312, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/coe.lean&#x27;, &#x27;line&#x27;: 67, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 340, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 317, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 312, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {a b : Type} [_inst_1 : has_lift_t.{1 1} a b], a → b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α β : Type} [c : has_pow.{0 0} α β], α → β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_dvd.{0} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_mul.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {a b : Type} [_inst_1 : has_lift_t.{1 1} a b], a → b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α β : Type} [c : has_pow.{0 0} α β], α → β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_dvd.{0} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_mul.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>192  have hf1 : finite (p : ℤ) (n₁ * d₂),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='multiplicity.finite'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='n₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mul.mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='d₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/ring_theory/multiplicity.lean&#x27;, &#x27;line&#x27;: 29, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/int/basic.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 312, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Π {α : Type} [_inst_1 : comm_semiring.{0} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_mul.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>193    from finite_int_prime_iff.2 (mul_ne_zero hn₁ hd₂),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='padic_val_rat.finite_int_prime_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='iff.mpr'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='mul_ne_zero'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hn₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hd₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;line&#x27;: 126, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/ring.lean&#x27;, &#x27;line&#x27;: 287, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='∀ {p : nat} [p_prime : nat.prime p] {a : int}, iff (@multiplicity.finite.{0} int int.comm_semiring (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p) a) (@ne.{1} int a (@has_zero.zero.{0} int int.has_zero))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, iff a b → b → a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {α : Type} [_inst_1 : integral_domain.{0} α] {a b : α}, @ne.{1} α a (@has_zero.zero.{0} α (@no_zero_divisors.to_has_zero.{0} α (@integral_domain.to_no_zero_divisors.{0} α _inst_1))) → @ne.{1} α b (@has_zero.zero.{0} α (@no_zero_divisors.to_has_zero.{0} α (@integral_domain.to_no_zero_divisors.{0} α _inst_1))) → @ne.{1} α (@has_mul.mul.{0} α (@no_zero_divisors.to_has_mul.{0} α (@integral_domain.to_no_zero_divisors.{0} α _inst_1)) a b) (@has_zero.zero.{0} α (@no_zero_divisors.to_has_zero.{0} α (@integral_domain.to_no_zero_divisors.{0} α _inst_1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@ne.{1} int n₁ (@has_zero.zero.{0} int int.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@ne.{1} int d₂ (@has_zero.zero.{0} int int.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='The multiplicity of `p : ℕ` in `a : ℤ` is finite exactly when `a ≠ 0`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>194  have hf2 : finite (p : ℤ) (n₂ * d₁),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='multiplicity.finite'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='n₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mul.mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='d₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/ring_theory/multiplicity.lean&#x27;, &#x27;line&#x27;: 29, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/int/basic.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 312, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Π {α : Type} [_inst_1 : comm_semiring.{0} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_mul.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>195    from finite_int_prime_iff.2 (mul_ne_zero hn₂ hd₁),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='padic_val_rat.finite_int_prime_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='iff.mpr'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='mul_ne_zero'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hn₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hd₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;line&#x27;: 126, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/ring.lean&#x27;, &#x27;line&#x27;: 287, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='∀ {p : nat} [p_prime : nat.prime p] {a : int}, iff (@multiplicity.finite.{0} int int.comm_semiring (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p) a) (@ne.{1} int a (@has_zero.zero.{0} int int.has_zero))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, iff a b → b → a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {α : Type} [_inst_1 : integral_domain.{0} α] {a b : α}, @ne.{1} α a (@has_zero.zero.{0} α (@no_zero_divisors.to_has_zero.{0} α (@integral_domain.to_no_zero_divisors.{0} α _inst_1))) → @ne.{1} α b (@has_zero.zero.{0} α (@no_zero_divisors.to_has_zero.{0} α (@integral_domain.to_no_zero_divisors.{0} α _inst_1))) → @ne.{1} α (@has_mul.mul.{0} α (@no_zero_divisors.to_has_mul.{0} α (@integral_domain.to_no_zero_divisors.{0} α _inst_1)) a b) (@has_zero.zero.{0} α (@no_zero_divisors.to_has_zero.{0} α (@integral_domain.to_no_zero_divisors.{0} α _inst_1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@ne.{1} int n₂ (@has_zero.zero.{0} int int.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@ne.{1} int d₁ (@has_zero.zero.{0} int int.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='The multiplicity of `p : ℕ` in `a : ℤ` is finite exactly when `a ≠ 0`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>196    by conv {</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit name (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.ident)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) (lean.parser.pexpr std.prec.max))) → conv.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='conv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;(at id)?&#x27;, &#x27;(in expr)?&#x27;, &#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='lime'><a title='p : nat,
p_prime : nat.prime p,
n₁ n₂ d₁ d₂ : int,
hn₁ : @ne.{1} int n₁ (@has_zero.zero.{0} int int.has_zero),
hn₂ : @ne.{1} int n₂ (@has_zero.zero.{0} int int.has_zero),
hd₁ : @ne.{1} int d₁ (@has_zero.zero.{0} int int.has_zero),
hd₂ : @ne.{1} int d₂ (@has_zero.zero.{0} int int.has_zero),
hf1 :
  @multiplicity.finite.{0} int int.comm_semiring
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
    (@has_mul.mul.{0} int int.has_mul n₁ d₂),
hf2 :
  @multiplicity.finite.{0} int int.comm_semiring
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
    (@has_mul.mul.{0} int int.has_mul n₂ d₁)
⊢ iff (@has_le.le.{0} int int.has_le (padic_val_rat p (rat.mk n₁ d₁)) (padic_val_rat p (rat.mk n₂ d₂)))
    (∀ (n : nat),
       @has_dvd.dvd.{0} int (@comm_semiring_has_dvd.{0} int int.comm_semiring)
         (@has_pow.pow.{0 0} int nat (@monoid.has_pow.{0} int int.monoid)
            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
            n)
         (@has_mul.mul.{0} int int.has_mul n₁ d₂) →
       @has_dvd.dvd.{0} int (@comm_semiring_has_dvd.{0} int int.comm_semiring)
         (@has_pow.pow.{0 0} int nat (@monoid.has_pow.{0} int int.monoid)
            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
            n)
         (@has_mul.mul.{0} int int.has_mul n₂ d₁))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
p_prime : nat.prime p,
n₁ n₂ d₁ d₂ : int,
hn₁ : @ne.{1} int n₁ (@has_zero.zero.{0} int int.has_zero),
hn₂ : @ne.{1} int n₂ (@has_zero.zero.{0} int int.has_zero),
hd₁ : @ne.{1} int d₁ (@has_zero.zero.{0} int int.has_zero),
hd₂ : @ne.{1} int d₂ (@has_zero.zero.{0} int int.has_zero),
hf1 :
  @multiplicity.finite.{0} int int.comm_semiring
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
    (@has_mul.mul.{0} int int.has_mul n₁ d₂),
hf2 :
  @multiplicity.finite.{0} int int.comm_semiring
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
    (@has_mul.mul.{0} int int.has_mul n₂ d₁)
| iff (@has_le.le.{0} int int.has_le (padic_val_rat p (rat.mk n₁ d₁)) (padic_val_rat p (rat.mk n₂ d₂)))
    (∀ (n : nat),
       @has_dvd.dvd.{0} int (@comm_semiring_has_dvd.{0} int int.comm_semiring)
         (@has_pow.pow.{0 0} int nat (@monoid.has_pow.{0} int int.monoid)
            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
            n)
         (@has_mul.mul.{0} int int.has_mul n₁ d₂) →
       @has_dvd.dvd.{0} int (@comm_semiring_has_dvd.{0} int int.comm_semiring)
         (@has_pow.pow.{0 0} int nat (@monoid.has_pow.{0} int int.monoid)
            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
            n)
         (@has_mul.mul.{0} int int.has_mul n₂ d₁))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>197      to_lhs,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 65, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit name (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.ident)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) (lean.parser.pexpr std.prec.max))) → conv.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit name (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.ident)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) (lean.parser.pexpr std.prec.max))) → conv.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='conv'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='to_lhs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='conv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;(at id)?&#x27;, &#x27;(in expr)?&#x27;, &#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;(at id)?&#x27;, &#x27;(in expr)?&#x27;, &#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
p_prime : nat.prime p,
n₁ n₂ d₁ d₂ : int,
hn₁ : @ne.{1} int n₁ (@has_zero.zero.{0} int int.has_zero),
hn₂ : @ne.{1} int n₂ (@has_zero.zero.{0} int int.has_zero),
hd₁ : @ne.{1} int d₁ (@has_zero.zero.{0} int int.has_zero),
hd₂ : @ne.{1} int d₂ (@has_zero.zero.{0} int int.has_zero),
hf1 :
  @multiplicity.finite.{0} int int.comm_semiring
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
    (@has_mul.mul.{0} int int.has_mul n₁ d₂),
hf2 :
  @multiplicity.finite.{0} int int.comm_semiring
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
    (@has_mul.mul.{0} int int.has_mul n₂ d₁)
| iff (@has_le.le.{0} int int.has_le (padic_val_rat p (rat.mk n₁ d₁)) (padic_val_rat p (rat.mk n₂ d₂)))
    (∀ (n : nat),
       @has_dvd.dvd.{0} int (@comm_semiring_has_dvd.{0} int int.comm_semiring)
         (@has_pow.pow.{0 0} int nat (@monoid.has_pow.{0} int int.monoid)
            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
            n)
         (@has_mul.mul.{0} int int.has_mul n₁ d₂) →
       @has_dvd.dvd.{0} int (@comm_semiring_has_dvd.{0} int int.comm_semiring)
         (@has_pow.pow.{0 0} int nat (@monoid.has_pow.{0} int int.monoid)
            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
            n)
         (@has_mul.mul.{0} int int.has_mul n₂ d₁))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
p_prime : nat.prime p,
n₁ n₂ d₁ d₂ : int,
hn₁ : @ne.{1} int n₁ (@has_zero.zero.{0} int int.has_zero),
hn₂ : @ne.{1} int n₂ (@has_zero.zero.{0} int int.has_zero),
hd₁ : @ne.{1} int d₁ (@has_zero.zero.{0} int int.has_zero),
hd₂ : @ne.{1} int d₂ (@has_zero.zero.{0} int int.has_zero),
hf1 :
  @multiplicity.finite.{0} int int.comm_semiring
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
    (@has_mul.mul.{0} int int.has_mul n₁ d₂),
hf2 :
  @multiplicity.finite.{0} int int.comm_semiring
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
    (@has_mul.mul.{0} int int.has_mul n₂ d₁)
| @has_le.le.{0} int int.has_le (padic_val_rat p (rat.mk n₁ d₁)) (padic_val_rat p (rat.mk n₂ d₂))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>198      rw [padic_val_rat.defn p (rat.mk_ne_zero_of_ne_zero hn₁ hd₁) rfl,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='padic_val_rat.defn'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='rat.mk_ne_zero_of_ne_zero'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hn₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hd₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 132, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/rat/basic.lean&#x27;, &#x27;line&#x27;: 505, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit name (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.ident)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) (lean.parser.pexpr std.prec.max))) → conv.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (p : nat) [p_prime : nat.prime p] {q : rat} {n d : int} (hqz : @ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)) (qdf : @eq.{1} rat q (rat.mk n d)), @eq.{1} int (padic_val_rat p q) (@has_sub.sub.{0} int int.has_sub (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (@roption.get.{0} nat (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p) n) (@iff.mpr (@multiplicity.finite.{0} int int.comm_semiring (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p) n) (and (@ne.{1} nat (int.nat_abs (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)) (@has_one.one.{0} nat nat.has_one)) (@ne.{1} int n (@has_zero.zero.{0} int int.has_zero))) (@multiplicity.finite_int_iff (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p) n) (@and.intro (@ne.{1} nat (int.nat_abs (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)) (@has_one.one.{0} nat nat.has_one)) (@ne.{1} int n (@has_zero.zero.{0} int int.has_zero)) (@ne.symm.{1} nat (@has_one.one.{0} nat nat.has_one) (int.nat_abs (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)) (@ne_of_lt.{0} nat (@partial_order.to_preorder.{0} nat (@ordered_comm_monoid.to_partial_order.{0} nat (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))) (@has_one.one.{0} nat nat.has_one) (int.nat_abs (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)) (@nat.prime.one_lt p p_prime))) (λ (hn : @eq.{1} int n (@has_zero.zero.{0} int int.has_zero)), false.rec.{0} false (@eq.mp.{0} (@eq.{1} rat q (rat.mk n d)) false (@eq.trans.{1} Prop (@eq.{1} rat q (rat.mk n d)) (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)) false ((λ (a a_1 : rat) (e_1 : @eq.{1} rat a a_1) (a_2 a_3 : rat) (e_2 : @eq.{1} rat a_2 a_3), @congr.{1 1} rat Prop (@eq.{1} rat a) (@eq.{1} rat a_1) a_2 a_3 (@congr_arg.{1 1} rat (rat → Prop) a a_1 (@eq.{1} rat) e_1) e_2) q q (@eq.refl.{1} rat q) (rat.mk n d) (@has_zero.zero.{0} rat rat.has_zero) (@eq.trans.{1} rat (rat.mk n d) (rat.mk (@has_zero.zero.{0} int int.has_zero) d) (@has_zero.zero.{0} rat rat.has_zero) ((λ (a a_1 : int) (e_1 : @eq.{1} int a a_1) (a_2 a_3 : int) (e_2 : @eq.{1} int a_2 a_3), @congr.{1 1} int rat (rat.mk a) (rat.mk a_1) a_2 a_3 (@congr_arg.{1 1} int (int → rat) a a_1 rat.mk e_1) e_2) n (@has_zero.zero.{0} int int.has_zero) hn d d (@eq.refl.{1} int d)) (rat.zero_mk d))) (@propext (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)) false (@iff_false_intro (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)) hqz))) qdf)))))) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (@roption.get.{0} nat (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p) d) (@iff.mpr (@multiplicity.finite.{0} int int.comm_semiring (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p) d) (and (@ne.{1} nat (int.nat_abs (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)) (@has_one.one.{0} nat nat.has_one)) (@ne.{1} int d (@has_zero.zero.{0} int int.has_zero))) (@multiplicity.finite_int_iff (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p) d) (@and.intro (@ne.{1} nat (int.nat_abs (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)) (@has_one.one.{0} nat nat.has_one)) (@ne.{1} int d (@has_zero.zero.{0} int int.has_zero)) (@ne.symm.{1} nat (@has_one.one.{0} nat nat.has_one) (int.nat_abs (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)) (@ne_of_lt.{0} nat (@partial_order.to_preorder.{0} nat (@ordered_comm_monoid.to_partial_order.{0} nat (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))) (@has_one.one.{0} nat nat.has_one) (int.nat_abs (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)) (@nat.prime.one_lt p p_prime))) (λ (hd : @eq.{1} int d (@has_zero.zero.{0} int int.has_zero)), false.rec.{0} false (@eq.mp.{0} (@eq.{1} rat q (rat.mk n d)) false (@eq.trans.{1} Prop (@eq.{1} rat q (rat.mk n d)) (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)) false ((λ (a a_1 : rat) (e_1 : @eq.{1} rat a a_1) (a_2 a_3 : rat) (e_2 : @eq.{1} rat a_2 a_3), @congr.{1 1} rat Prop (@eq.{1} rat a) (@eq.{1} rat a_1) a_2 a_3 (@congr_arg.{1 1} rat (rat → Prop) a a_1 (@eq.{1} rat) e_1) e_2) q q (@eq.refl.{1} rat q) (rat.mk n d) (@has_zero.zero.{0} rat rat.has_zero) (@eq.trans.{1} rat (rat.mk n d) (rat.mk n (@has_zero.zero.{0} int int.has_zero)) (@has_zero.zero.{0} rat rat.has_zero) ((λ (a a_1 : int) (e_1 : @eq.{1} int a a_1) (a_2 a_3 : int) (e_2 : @eq.{1} int a_2 a_3), @congr.{1 1} int rat (rat.mk a) (rat.mk a_1) a_2 a_3 (@congr_arg.{1 1} int (int → rat) a a_1 rat.mk e_1) e_2) n n (@eq.refl.{1} int n) d (@has_zero.zero.{0} int int.has_zero) hd) (rat.mk_zero n))) (@propext (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)) false (@iff_false_intro (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)) hqz))) qdf)))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {n d : int}, @ne.{1} int n (@has_zero.zero.{0} int int.has_zero) → @ne.{1} int d (@has_zero.zero.{0} int int.has_zero) → @ne.{1} rat (rat.mk n d) (@has_zero.zero.{0} rat rat.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@ne.{1} int n₁ (@has_zero.zero.{0} int int.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@ne.{1} int d₁ (@has_zero.zero.{0} int int.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} {a : α}, @eq.{1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='A rewrite lemma for `padic_val_rat p q` when `q` is expressed in terms of `rat.mk`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='conv'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;(at id)?&#x27;, &#x27;(in expr)?&#x27;, &#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
p_prime : nat.prime p,
n₁ n₂ d₁ d₂ : int,
hn₁ : @ne.{1} int n₁ (@has_zero.zero.{0} int int.has_zero),
hn₂ : @ne.{1} int n₂ (@has_zero.zero.{0} int int.has_zero),
hd₁ : @ne.{1} int d₁ (@has_zero.zero.{0} int int.has_zero),
hd₂ : @ne.{1} int d₂ (@has_zero.zero.{0} int int.has_zero),
hf1 :
  @multiplicity.finite.{0} int int.comm_semiring
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
    (@has_mul.mul.{0} int int.has_mul n₁ d₂),
hf2 :
  @multiplicity.finite.{0} int int.comm_semiring
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
    (@has_mul.mul.{0} int int.has_mul n₂ d₁)
| @has_le.le.{0} int int.has_le (padic_val_rat p (rat.mk n₁ d₁)) (padic_val_rat p (rat.mk n₂ d₂))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
p_prime : nat.prime p,
n₁ n₂ d₁ d₂ : int,
hn₁ : @ne.{1} int n₁ (@has_zero.zero.{0} int int.has_zero),
hn₂ : @ne.{1} int n₂ (@has_zero.zero.{0} int int.has_zero),
hd₁ : @ne.{1} int d₁ (@has_zero.zero.{0} int int.has_zero),
hd₂ : @ne.{1} int d₂ (@has_zero.zero.{0} int int.has_zero),
hf1 :
  @multiplicity.finite.{0} int int.comm_semiring
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
    (@has_mul.mul.{0} int int.has_mul n₁ d₂),
hf2 :
  @multiplicity.finite.{0} int int.comm_semiring
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
    (@has_mul.mul.{0} int int.has_mul n₂ d₁)
| @has_le.le.{0} int int.has_le
    (@has_sub.sub.{0} int int.has_sub
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
          (@roption.get.{0} nat
             (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                n₁)
             (@iff.mpr
                (@multiplicity.finite.{0} int int.comm_semiring
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   n₁)
                (and
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int n₁ (@has_zero.zero.{0} int int.has_zero)))
                (@multiplicity.finite_int_iff
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   n₁)
                (@and.intro
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int n₁ (@has_zero.zero.{0} int int.has_zero))
                   (@ne.symm.{1} nat (@has_one.one.{0} nat nat.has_one)
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@ne_of_lt.{0} nat
                         (@partial_order.to_preorder.{0} nat
                            (@ordered_comm_monoid.to_partial_order.{0} nat
                               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
                         (@has_one.one.{0} nat nat.has_one)
                         (int.nat_abs
                            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                         (@nat.prime.one_lt p p_prime)))
                   (λ (hn : @eq.{1} int n₁ (@has_zero.zero.{0} int int.has_zero)),
                      false.rec.{0} false
                        (@eq.mp.{0} (@eq.{1} rat (rat.mk n₁ d₁) (rat.mk n₁ d₁)) false
                           (@eq.trans.{1} Prop (@eq.{1} rat (rat.mk n₁ d₁) (rat.mk n₁ d₁))
                              (@eq.{1} rat (rat.mk n₁ d₁) (@has_zero.zero.{0} rat rat.has_zero))
                              false
                              ((λ (a a_1 : rat) (e_1 : @eq.{1} rat a a_1) (a_2 a_3 : rat) (e_2 : @eq.{1} rat a_2 a_3),
                                  @congr.{1 1} rat Prop (@eq.{1} rat a) (@eq.{1} rat a_1) a_2 a_3
                                    (@congr_arg.{1 1} rat (rat → Prop) a a_1 (@eq.{1} rat) e_1)
                                    e_2)
                                 (rat.mk n₁ d₁)
                                 (rat.mk n₁ d₁)
                                 (@eq.refl.{1} rat (rat.mk n₁ d₁))
                                 (rat.mk n₁ d₁)
                                 (@has_zero.zero.{0} rat rat.has_zero)
                                 (@eq.trans.{1} rat (rat.mk n₁ d₁)
                                    (rat.mk (@has_zero.zero.{0} int int.has_zero) d₁)
                                    (@has_zero.zero.{0} rat rat.has_zero)
                                    ((λ (a a_1 : int) (e_1 : @eq.{1} int a a_1) (a_2 a_3 : int)
                                      (e_2 : @eq.{1} int a_2 a_3),
                                        @congr.{1 1} int rat (rat.mk a) (rat.mk a_1) a_2 a_3
                                          (@congr_arg.{1 1} int (int → rat) a a_1 rat.mk e_1)
                                          e_2)
                                       n₁
                                       (@has_zero.zero.{0} int int.has_zero)
                                       hn
                                       d₁
                                       d₁
                                       (@eq.refl.{1} int d₁))
                                    (rat.zero_mk d₁)))
                              (@propext (@eq.{1} rat (rat.mk n₁ d₁) (@has_zero.zero.{0} rat rat.has_zero)) false
                                 (@iff_false_intro
                                    (@eq.{1} rat (rat.mk n₁ d₁) (@has_zero.zero.{0} rat rat.has_zero))
                                    (@rat.mk_ne_zero_of_ne_zero n₁ d₁ hn₁ hd₁))))
                           (@rfl.{1} rat (rat.mk n₁ d₁))))))))
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
          (@roption.get.{0} nat
             (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                d₁)
             (@iff.mpr
                (@multiplicity.finite.{0} int int.comm_semiring
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   d₁)
                (and
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int d₁ (@has_zero.zero.{0} int int.has_zero)))
                (@multiplicity.finite_int_iff
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   d₁)
                (@and.intro
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int d₁ (@has_zero.zero.{0} int int.has_zero))
                   (@ne.symm.{1} nat (@has_one.one.{0} nat nat.has_one)
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@ne_of_lt.{0} nat
                         (@partial_order.to_preorder.{0} nat
                            (@ordered_comm_monoid.to_partial_order.{0} nat
                               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
                         (@has_one.one.{0} nat nat.has_one)
                         (int.nat_abs
                            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                         (@nat.prime.one_lt p p_prime)))
                   (λ (hd : @eq.{1} int d₁ (@has_zero.zero.{0} int int.has_zero)),
                      false.rec.{0} false
                        (@eq.mp.{0} (@eq.{1} rat (rat.mk n₁ d₁) (rat.mk n₁ d₁)) false
                           (@eq.trans.{1} Prop (@eq.{1} rat (rat.mk n₁ d₁) (rat.mk n₁ d₁))
                              (@eq.{1} rat (rat.mk n₁ d₁) (@has_zero.zero.{0} rat rat.has_zero))
                              false
                              ((λ (a a_1 : rat) (e_1 : @eq.{1} rat a a_1) (a_2 a_3 : rat) (e_2 : @eq.{1} rat a_2 a_3),
                                  @congr.{1 1} rat Prop (@eq.{1} rat a) (@eq.{1} rat a_1) a_2 a_3
                                    (@congr_arg.{1 1} rat (rat → Prop) a a_1 (@eq.{1} rat) e_1)
                                    e_2)
                                 (rat.mk n₁ d₁)
                                 (rat.mk n₁ d₁)
                                 (@eq.refl.{1} rat (rat.mk n₁ d₁))
                                 (rat.mk n₁ d₁)
                                 (@has_zero.zero.{0} rat rat.has_zero)
                                 (@eq.trans.{1} rat (rat.mk n₁ d₁)
                                    (rat.mk n₁ (@has_zero.zero.{0} int int.has_zero))
                                    (@has_zero.zero.{0} rat rat.has_zero)
                                    ((λ (a a_1 : int) (e_1 : @eq.{1} int a a_1) (a_2 a_3 : int)
                                      (e_2 : @eq.{1} int a_2 a_3),
                                        @congr.{1 1} int rat (rat.mk a) (rat.mk a_1) a_2 a_3
                                          (@congr_arg.{1 1} int (int → rat) a a_1 rat.mk e_1)
                                          e_2)
                                       n₁
                                       n₁
                                       (@eq.refl.{1} int n₁)
                                       d₁
                                       (@has_zero.zero.{0} int int.has_zero)
                                       hd)
                                    (rat.mk_zero n₁)))
                              (@propext (@eq.{1} rat (rat.mk n₁ d₁) (@has_zero.zero.{0} rat rat.has_zero)) false
                                 (@iff_false_intro
                                    (@eq.{1} rat (rat.mk n₁ d₁) (@has_zero.zero.{0} rat rat.has_zero))
                                    (@rat.mk_ne_zero_of_ne_zero n₁ d₁ hn₁ hd₁))))
                           (@rfl.{1} rat (rat.mk n₁ d₁)))))))))
    (padic_val_rat p (rat.mk n₂ d₂))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>199        padic_val_rat.defn p (rat.mk_ne_zero_of_ne_zero hn₂ hd₂) rfl,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='padic_val_rat.defn'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='rat.mk_ne_zero_of_ne_zero'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hn₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hd₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 132, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/rat/basic.lean&#x27;, &#x27;line&#x27;: 505, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (p : nat) [p_prime : nat.prime p] {q : rat} {n d : int} (hqz : @ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)) (qdf : @eq.{1} rat q (rat.mk n d)), @eq.{1} int (padic_val_rat p q) (@has_sub.sub.{0} int int.has_sub (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (@roption.get.{0} nat (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p) n) (@iff.mpr (@multiplicity.finite.{0} int int.comm_semiring (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p) n) (and (@ne.{1} nat (int.nat_abs (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)) (@has_one.one.{0} nat nat.has_one)) (@ne.{1} int n (@has_zero.zero.{0} int int.has_zero))) (@multiplicity.finite_int_iff (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p) n) (@and.intro (@ne.{1} nat (int.nat_abs (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)) (@has_one.one.{0} nat nat.has_one)) (@ne.{1} int n (@has_zero.zero.{0} int int.has_zero)) (@ne.symm.{1} nat (@has_one.one.{0} nat nat.has_one) (int.nat_abs (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)) (@ne_of_lt.{0} nat (@partial_order.to_preorder.{0} nat (@ordered_comm_monoid.to_partial_order.{0} nat (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))) (@has_one.one.{0} nat nat.has_one) (int.nat_abs (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)) (@nat.prime.one_lt p p_prime))) (λ (hn : @eq.{1} int n (@has_zero.zero.{0} int int.has_zero)), false.rec.{0} false (@eq.mp.{0} (@eq.{1} rat q (rat.mk n d)) false (@eq.trans.{1} Prop (@eq.{1} rat q (rat.mk n d)) (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)) false ((λ (a a_1 : rat) (e_1 : @eq.{1} rat a a_1) (a_2 a_3 : rat) (e_2 : @eq.{1} rat a_2 a_3), @congr.{1 1} rat Prop (@eq.{1} rat a) (@eq.{1} rat a_1) a_2 a_3 (@congr_arg.{1 1} rat (rat → Prop) a a_1 (@eq.{1} rat) e_1) e_2) q q (@eq.refl.{1} rat q) (rat.mk n d) (@has_zero.zero.{0} rat rat.has_zero) (@eq.trans.{1} rat (rat.mk n d) (rat.mk (@has_zero.zero.{0} int int.has_zero) d) (@has_zero.zero.{0} rat rat.has_zero) ((λ (a a_1 : int) (e_1 : @eq.{1} int a a_1) (a_2 a_3 : int) (e_2 : @eq.{1} int a_2 a_3), @congr.{1 1} int rat (rat.mk a) (rat.mk a_1) a_2 a_3 (@congr_arg.{1 1} int (int → rat) a a_1 rat.mk e_1) e_2) n (@has_zero.zero.{0} int int.has_zero) hn d d (@eq.refl.{1} int d)) (rat.zero_mk d))) (@propext (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)) false (@iff_false_intro (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)) hqz))) qdf)))))) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (@roption.get.{0} nat (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p) d) (@iff.mpr (@multiplicity.finite.{0} int int.comm_semiring (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p) d) (and (@ne.{1} nat (int.nat_abs (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)) (@has_one.one.{0} nat nat.has_one)) (@ne.{1} int d (@has_zero.zero.{0} int int.has_zero))) (@multiplicity.finite_int_iff (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p) d) (@and.intro (@ne.{1} nat (int.nat_abs (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)) (@has_one.one.{0} nat nat.has_one)) (@ne.{1} int d (@has_zero.zero.{0} int int.has_zero)) (@ne.symm.{1} nat (@has_one.one.{0} nat nat.has_one) (int.nat_abs (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)) (@ne_of_lt.{0} nat (@partial_order.to_preorder.{0} nat (@ordered_comm_monoid.to_partial_order.{0} nat (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))) (@has_one.one.{0} nat nat.has_one) (int.nat_abs (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)) (@nat.prime.one_lt p p_prime))) (λ (hd : @eq.{1} int d (@has_zero.zero.{0} int int.has_zero)), false.rec.{0} false (@eq.mp.{0} (@eq.{1} rat q (rat.mk n d)) false (@eq.trans.{1} Prop (@eq.{1} rat q (rat.mk n d)) (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)) false ((λ (a a_1 : rat) (e_1 : @eq.{1} rat a a_1) (a_2 a_3 : rat) (e_2 : @eq.{1} rat a_2 a_3), @congr.{1 1} rat Prop (@eq.{1} rat a) (@eq.{1} rat a_1) a_2 a_3 (@congr_arg.{1 1} rat (rat → Prop) a a_1 (@eq.{1} rat) e_1) e_2) q q (@eq.refl.{1} rat q) (rat.mk n d) (@has_zero.zero.{0} rat rat.has_zero) (@eq.trans.{1} rat (rat.mk n d) (rat.mk n (@has_zero.zero.{0} int int.has_zero)) (@has_zero.zero.{0} rat rat.has_zero) ((λ (a a_1 : int) (e_1 : @eq.{1} int a a_1) (a_2 a_3 : int) (e_2 : @eq.{1} int a_2 a_3), @congr.{1 1} int rat (rat.mk a) (rat.mk a_1) a_2 a_3 (@congr_arg.{1 1} int (int → rat) a a_1 rat.mk e_1) e_2) n n (@eq.refl.{1} int n) d (@has_zero.zero.{0} int int.has_zero) hd) (rat.mk_zero n))) (@propext (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)) false (@iff_false_intro (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)) hqz))) qdf)))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {n d : int}, @ne.{1} int n (@has_zero.zero.{0} int int.has_zero) → @ne.{1} int d (@has_zero.zero.{0} int int.has_zero) → @ne.{1} rat (rat.mk n d) (@has_zero.zero.{0} rat rat.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@ne.{1} int n₂ (@has_zero.zero.{0} int int.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@ne.{1} int d₂ (@has_zero.zero.{0} int int.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} {a : α}, @eq.{1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='A rewrite lemma for `padic_val_rat p q` when `q` is expressed in terms of `rat.mk`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
p_prime : nat.prime p,
n₁ n₂ d₁ d₂ : int,
hn₁ : @ne.{1} int n₁ (@has_zero.zero.{0} int int.has_zero),
hn₂ : @ne.{1} int n₂ (@has_zero.zero.{0} int int.has_zero),
hd₁ : @ne.{1} int d₁ (@has_zero.zero.{0} int int.has_zero),
hd₂ : @ne.{1} int d₂ (@has_zero.zero.{0} int int.has_zero),
hf1 :
  @multiplicity.finite.{0} int int.comm_semiring
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
    (@has_mul.mul.{0} int int.has_mul n₁ d₂),
hf2 :
  @multiplicity.finite.{0} int int.comm_semiring
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
    (@has_mul.mul.{0} int int.has_mul n₂ d₁)
| @has_le.le.{0} int int.has_le
    (@has_sub.sub.{0} int int.has_sub
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
          (@roption.get.{0} nat
             (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                n₁)
             (@iff.mpr
                (@multiplicity.finite.{0} int int.comm_semiring
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   n₁)
                (and
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int n₁ (@has_zero.zero.{0} int int.has_zero)))
                (@multiplicity.finite_int_iff
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   n₁)
                (@and.intro
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int n₁ (@has_zero.zero.{0} int int.has_zero))
                   (@ne.symm.{1} nat (@has_one.one.{0} nat nat.has_one)
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@ne_of_lt.{0} nat
                         (@partial_order.to_preorder.{0} nat
                            (@ordered_comm_monoid.to_partial_order.{0} nat
                               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
                         (@has_one.one.{0} nat nat.has_one)
                         (int.nat_abs
                            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                         (@nat.prime.one_lt p p_prime)))
                   (λ (hn : @eq.{1} int n₁ (@has_zero.zero.{0} int int.has_zero)),
                      false.rec.{0} false
                        (@eq.mp.{0} (@eq.{1} rat (rat.mk n₁ d₁) (rat.mk n₁ d₁)) false
                           (@eq.trans.{1} Prop (@eq.{1} rat (rat.mk n₁ d₁) (rat.mk n₁ d₁))
                              (@eq.{1} rat (rat.mk n₁ d₁) (@has_zero.zero.{0} rat rat.has_zero))
                              false
                              ((λ (a a_1 : rat) (e_1 : @eq.{1} rat a a_1) (a_2 a_3 : rat) (e_2 : @eq.{1} rat a_2 a_3),
                                  @congr.{1 1} rat Prop (@eq.{1} rat a) (@eq.{1} rat a_1) a_2 a_3
                                    (@congr_arg.{1 1} rat (rat → Prop) a a_1 (@eq.{1} rat) e_1)
                                    e_2)
                                 (rat.mk n₁ d₁)
                                 (rat.mk n₁ d₁)
                                 (@eq.refl.{1} rat (rat.mk n₁ d₁))
                                 (rat.mk n₁ d₁)
                                 (@has_zero.zero.{0} rat rat.has_zero)
                                 (@eq.trans.{1} rat (rat.mk n₁ d₁)
                                    (rat.mk (@has_zero.zero.{0} int int.has_zero) d₁)
                                    (@has_zero.zero.{0} rat rat.has_zero)
                                    ((λ (a a_1 : int) (e_1 : @eq.{1} int a a_1) (a_2 a_3 : int)
                                      (e_2 : @eq.{1} int a_2 a_3),
                                        @congr.{1 1} int rat (rat.mk a) (rat.mk a_1) a_2 a_3
                                          (@congr_arg.{1 1} int (int → rat) a a_1 rat.mk e_1)
                                          e_2)
                                       n₁
                                       (@has_zero.zero.{0} int int.has_zero)
                                       hn
                                       d₁
                                       d₁
                                       (@eq.refl.{1} int d₁))
                                    (rat.zero_mk d₁)))
                              (@propext (@eq.{1} rat (rat.mk n₁ d₁) (@has_zero.zero.{0} rat rat.has_zero)) false
                                 (@iff_false_intro
                                    (@eq.{1} rat (rat.mk n₁ d₁) (@has_zero.zero.{0} rat rat.has_zero))
                                    (@rat.mk_ne_zero_of_ne_zero n₁ d₁ hn₁ hd₁))))
                           (@rfl.{1} rat (rat.mk n₁ d₁))))))))
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
          (@roption.get.{0} nat
             (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                d₁)
             (@iff.mpr
                (@multiplicity.finite.{0} int int.comm_semiring
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   d₁)
                (and
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int d₁ (@has_zero.zero.{0} int int.has_zero)))
                (@multiplicity.finite_int_iff
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   d₁)
                (@and.intro
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int d₁ (@has_zero.zero.{0} int int.has_zero))
                   (@ne.symm.{1} nat (@has_one.one.{0} nat nat.has_one)
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@ne_of_lt.{0} nat
                         (@partial_order.to_preorder.{0} nat
                            (@ordered_comm_monoid.to_partial_order.{0} nat
                               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
                         (@has_one.one.{0} nat nat.has_one)
                         (int.nat_abs
                            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                         (@nat.prime.one_lt p p_prime)))
                   (λ (hd : @eq.{1} int d₁ (@has_zero.zero.{0} int int.has_zero)),
                      false.rec.{0} false
                        (@eq.mp.{0} (@eq.{1} rat (rat.mk n₁ d₁) (rat.mk n₁ d₁)) false
                           (@eq.trans.{1} Prop (@eq.{1} rat (rat.mk n₁ d₁) (rat.mk n₁ d₁))
                              (@eq.{1} rat (rat.mk n₁ d₁) (@has_zero.zero.{0} rat rat.has_zero))
                              false
                              ((λ (a a_1 : rat) (e_1 : @eq.{1} rat a a_1) (a_2 a_3 : rat) (e_2 : @eq.{1} rat a_2 a_3),
                                  @congr.{1 1} rat Prop (@eq.{1} rat a) (@eq.{1} rat a_1) a_2 a_3
                                    (@congr_arg.{1 1} rat (rat → Prop) a a_1 (@eq.{1} rat) e_1)
                                    e_2)
                                 (rat.mk n₁ d₁)
                                 (rat.mk n₁ d₁)
                                 (@eq.refl.{1} rat (rat.mk n₁ d₁))
                                 (rat.mk n₁ d₁)
                                 (@has_zero.zero.{0} rat rat.has_zero)
                                 (@eq.trans.{1} rat (rat.mk n₁ d₁)
                                    (rat.mk n₁ (@has_zero.zero.{0} int int.has_zero))
                                    (@has_zero.zero.{0} rat rat.has_zero)
                                    ((λ (a a_1 : int) (e_1 : @eq.{1} int a a_1) (a_2 a_3 : int)
                                      (e_2 : @eq.{1} int a_2 a_3),
                                        @congr.{1 1} int rat (rat.mk a) (rat.mk a_1) a_2 a_3
                                          (@congr_arg.{1 1} int (int → rat) a a_1 rat.mk e_1)
                                          e_2)
                                       n₁
                                       n₁
                                       (@eq.refl.{1} int n₁)
                                       d₁
                                       (@has_zero.zero.{0} int int.has_zero)
                                       hd)
                                    (rat.mk_zero n₁)))
                              (@propext (@eq.{1} rat (rat.mk n₁ d₁) (@has_zero.zero.{0} rat rat.has_zero)) false
                                 (@iff_false_intro
                                    (@eq.{1} rat (rat.mk n₁ d₁) (@has_zero.zero.{0} rat rat.has_zero))
                                    (@rat.mk_ne_zero_of_ne_zero n₁ d₁ hn₁ hd₁))))
                           (@rfl.{1} rat (rat.mk n₁ d₁)))))))))
    (padic_val_rat p (rat.mk n₂ d₂))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
p_prime : nat.prime p,
n₁ n₂ d₁ d₂ : int,
hn₁ : @ne.{1} int n₁ (@has_zero.zero.{0} int int.has_zero),
hn₂ : @ne.{1} int n₂ (@has_zero.zero.{0} int int.has_zero),
hd₁ : @ne.{1} int d₁ (@has_zero.zero.{0} int int.has_zero),
hd₂ : @ne.{1} int d₂ (@has_zero.zero.{0} int int.has_zero),
hf1 :
  @multiplicity.finite.{0} int int.comm_semiring
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
    (@has_mul.mul.{0} int int.has_mul n₁ d₂),
hf2 :
  @multiplicity.finite.{0} int int.comm_semiring
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
    (@has_mul.mul.{0} int int.has_mul n₂ d₁)
| @has_le.le.{0} int int.has_le
    (@has_sub.sub.{0} int int.has_sub
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
          (@roption.get.{0} nat
             (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                n₁)
             (@iff.mpr
                (@multiplicity.finite.{0} int int.comm_semiring
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   n₁)
                (and
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int n₁ (@has_zero.zero.{0} int int.has_zero)))
                (@multiplicity.finite_int_iff
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   n₁)
                (@and.intro
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int n₁ (@has_zero.zero.{0} int int.has_zero))
                   (@ne.symm.{1} nat (@has_one.one.{0} nat nat.has_one)
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@ne_of_lt.{0} nat
                         (@partial_order.to_preorder.{0} nat
                            (@ordered_comm_monoid.to_partial_order.{0} nat
                               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
                         (@has_one.one.{0} nat nat.has_one)
                         (int.nat_abs
                            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                         (@nat.prime.one_lt p p_prime)))
                   (λ (hn : @eq.{1} int n₁ (@has_zero.zero.{0} int int.has_zero)),
                      false.rec.{0} false
                        (@eq.mp.{0} (@eq.{1} rat (rat.mk n₁ d₁) (rat.mk n₁ d₁)) false
                           (@eq.trans.{1} Prop (@eq.{1} rat (rat.mk n₁ d₁) (rat.mk n₁ d₁))
                              (@eq.{1} rat (rat.mk n₁ d₁) (@has_zero.zero.{0} rat rat.has_zero))
                              false
                              ((λ (a a_1 : rat) (e_1 : @eq.{1} rat a a_1) (a_2 a_3 : rat) (e_2 : @eq.{1} rat a_2 a_3),
                                  @congr.{1 1} rat Prop (@eq.{1} rat a) (@eq.{1} rat a_1) a_2 a_3
                                    (@congr_arg.{1 1} rat (rat → Prop) a a_1 (@eq.{1} rat) e_1)
                                    e_2)
                                 (rat.mk n₁ d₁)
                                 (rat.mk n₁ d₁)
                                 (@eq.refl.{1} rat (rat.mk n₁ d₁))
                                 (rat.mk n₁ d₁)
                                 (@has_zero.zero.{0} rat rat.has_zero)
                                 (@eq.trans.{1} rat (rat.mk n₁ d₁)
                                    (rat.mk (@has_zero.zero.{0} int int.has_zero) d₁)
                                    (@has_zero.zero.{0} rat rat.has_zero)
                                    ((λ (a a_1 : int) (e_1 : @eq.{1} int a a_1) (a_2 a_3 : int)
                                      (e_2 : @eq.{1} int a_2 a_3),
                                        @congr.{1 1} int rat (rat.mk a) (rat.mk a_1) a_2 a_3
                                          (@congr_arg.{1 1} int (int → rat) a a_1 rat.mk e_1)
                                          e_2)
                                       n₁
                                       (@has_zero.zero.{0} int int.has_zero)
                                       hn
                                       d₁
                                       d₁
                                       (@eq.refl.{1} int d₁))
                                    (rat.zero_mk d₁)))
                              (@propext (@eq.{1} rat (rat.mk n₁ d₁) (@has_zero.zero.{0} rat rat.has_zero)) false
                                 (@iff_false_intro
                                    (@eq.{1} rat (rat.mk n₁ d₁) (@has_zero.zero.{0} rat rat.has_zero))
                                    (@rat.mk_ne_zero_of_ne_zero n₁ d₁ hn₁ hd₁))))
                           (@rfl.{1} rat (rat.mk n₁ d₁))))))))
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
          (@roption.get.{0} nat
             (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                d₁)
             (@iff.mpr
                (@multiplicity.finite.{0} int int.comm_semiring
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   d₁)
                (and
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int d₁ (@has_zero.zero.{0} int int.has_zero)))
                (@multiplicity.finite_int_iff
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   d₁)
                (@and.intro
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int d₁ (@has_zero.zero.{0} int int.has_zero))
                   (@ne.symm.{1} nat (@has_one.one.{0} nat nat.has_one)
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@ne_of_lt.{0} nat
                         (@partial_order.to_preorder.{0} nat
                            (@ordered_comm_monoid.to_partial_order.{0} nat
                               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
                         (@has_one.one.{0} nat nat.has_one)
                         (int.nat_abs
                            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                         (@nat.prime.one_lt p p_prime)))
                   (λ (hd : @eq.{1} int d₁ (@has_zero.zero.{0} int int.has_zero)),
                      false.rec.{0} false
                        (@eq.mp.{0} (@eq.{1} rat (rat.mk n₁ d₁) (rat.mk n₁ d₁)) false
                           (@eq.trans.{1} Prop (@eq.{1} rat (rat.mk n₁ d₁) (rat.mk n₁ d₁))
                              (@eq.{1} rat (rat.mk n₁ d₁) (@has_zero.zero.{0} rat rat.has_zero))
                              false
                              ((λ (a a_1 : rat) (e_1 : @eq.{1} rat a a_1) (a_2 a_3 : rat) (e_2 : @eq.{1} rat a_2 a_3),
                                  @congr.{1 1} rat Prop (@eq.{1} rat a) (@eq.{1} rat a_1) a_2 a_3
                                    (@congr_arg.{1 1} rat (rat → Prop) a a_1 (@eq.{1} rat) e_1)
                                    e_2)
                                 (rat.mk n₁ d₁)
                                 (rat.mk n₁ d₁)
                                 (@eq.refl.{1} rat (rat.mk n₁ d₁))
                                 (rat.mk n₁ d₁)
                                 (@has_zero.zero.{0} rat rat.has_zero)
                                 (@eq.trans.{1} rat (rat.mk n₁ d₁)
                                    (rat.mk n₁ (@has_zero.zero.{0} int int.has_zero))
                                    (@has_zero.zero.{0} rat rat.has_zero)
                                    ((λ (a a_1 : int) (e_1 : @eq.{1} int a a_1) (a_2 a_3 : int)
                                      (e_2 : @eq.{1} int a_2 a_3),
                                        @congr.{1 1} int rat (rat.mk a) (rat.mk a_1) a_2 a_3
                                          (@congr_arg.{1 1} int (int → rat) a a_1 rat.mk e_1)
                                          e_2)
                                       n₁
                                       n₁
                                       (@eq.refl.{1} int n₁)
                                       d₁
                                       (@has_zero.zero.{0} int int.has_zero)
                                       hd)
                                    (rat.mk_zero n₁)))
                              (@propext (@eq.{1} rat (rat.mk n₁ d₁) (@has_zero.zero.{0} rat rat.has_zero)) false
                                 (@iff_false_intro
                                    (@eq.{1} rat (rat.mk n₁ d₁) (@has_zero.zero.{0} rat rat.has_zero))
                                    (@rat.mk_ne_zero_of_ne_zero n₁ d₁ hn₁ hd₁))))
                           (@rfl.{1} rat (rat.mk n₁ d₁)))))))))
    (@has_sub.sub.{0} int int.has_sub
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
          (@roption.get.{0} nat
             (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                n₂)
             (@iff.mpr
                (@multiplicity.finite.{0} int int.comm_semiring
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   n₂)
                (and
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int n₂ (@has_zero.zero.{0} int int.has_zero)))
                (@multiplicity.finite_int_iff
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   n₂)
                (@and.intro
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int n₂ (@has_zero.zero.{0} int int.has_zero))
                   (@ne.symm.{1} nat (@has_one.one.{0} nat nat.has_one)
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@ne_of_lt.{0} nat
                         (@partial_order.to_preorder.{0} nat
                            (@ordered_comm_monoid.to_partial_order.{0} nat
                               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
                         (@has_one.one.{0} nat nat.has_one)
                         (int.nat_abs
                            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                         (@nat.prime.one_lt p p_prime)))
                   (λ (hn : @eq.{1} int n₂ (@has_zero.zero.{0} int int.has_zero)),
                      false.rec.{0} false
                        (@eq.mp.{0} (@eq.{1} rat (rat.mk n₂ d₂) (rat.mk n₂ d₂)) false
                           (@eq.trans.{1} Prop (@eq.{1} rat (rat.mk n₂ d₂) (rat.mk n₂ d₂))
                              (@eq.{1} rat (rat.mk n₂ d₂) (@has_zero.zero.{0} rat rat.has_zero))
                              false
                              ((λ (a a_1 : rat) (e_1 : @eq.{1} rat a a_1) (a_2 a_3 : rat) (e_2 : @eq.{1} rat a_2 a_3),
                                  @congr.{1 1} rat Prop (@eq.{1} rat a) (@eq.{1} rat a_1) a_2 a_3
                                    (@congr_arg.{1 1} rat (rat → Prop) a a_1 (@eq.{1} rat) e_1)
                                    e_2)
                                 (rat.mk n₂ d₂)
                                 (rat.mk n₂ d₂)
                                 (@eq.refl.{1} rat (rat.mk n₂ d₂))
                                 (rat.mk n₂ d₂)
                                 (@has_zero.zero.{0} rat rat.has_zero)
                                 (@eq.trans.{1} rat (rat.mk n₂ d₂)
                                    (rat.mk (@has_zero.zero.{0} int int.has_zero) d₂)
                                    (@has_zero.zero.{0} rat rat.has_zero)
                                    ((λ (a a_1 : int) (e_1 : @eq.{1} int a a_1) (a_2 a_3 : int)
                                      (e_2 : @eq.{1} int a_2 a_3),
                                        @congr.{1 1} int rat (rat.mk a) (rat.mk a_1) a_2 a_3
                                          (@congr_arg.{1 1} int (int → rat) a a_1 rat.mk e_1)
                                          e_2)
                                       n₂
                                       (@has_zero.zero.{0} int int.has_zero)
                                       hn
                                       d₂
                                       d₂
                                       (@eq.refl.{1} int d₂))
                                    (rat.zero_mk d₂)))
                              (@propext (@eq.{1} rat (rat.mk n₂ d₂) (@has_zero.zero.{0} rat rat.has_zero)) false
                                 (@iff_false_intro
                                    (@eq.{1} rat (rat.mk n₂ d₂) (@has_zero.zero.{0} rat rat.has_zero))
                                    (@rat.mk_ne_zero_of_ne_zero n₂ d₂ hn₂ hd₂))))
                           (@rfl.{1} rat (rat.mk n₂ d₂))))))))
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
          (@roption.get.{0} nat
             (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                d₂)
             (@iff.mpr
                (@multiplicity.finite.{0} int int.comm_semiring
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   d₂)
                (and
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int d₂ (@has_zero.zero.{0} int int.has_zero)))
                (@multiplicity.finite_int_iff
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   d₂)
                (@and.intro
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int d₂ (@has_zero.zero.{0} int int.has_zero))
                   (@ne.symm.{1} nat (@has_one.one.{0} nat nat.has_one)
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@ne_of_lt.{0} nat
                         (@partial_order.to_preorder.{0} nat
                            (@ordered_comm_monoid.to_partial_order.{0} nat
                               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
                         (@has_one.one.{0} nat nat.has_one)
                         (int.nat_abs
                            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                         (@nat.prime.one_lt p p_prime)))
                   (λ (hd : @eq.{1} int d₂ (@has_zero.zero.{0} int int.has_zero)),
                      false.rec.{0} false
                        (@eq.mp.{0} (@eq.{1} rat (rat.mk n₂ d₂) (rat.mk n₂ d₂)) false
                           (@eq.trans.{1} Prop (@eq.{1} rat (rat.mk n₂ d₂) (rat.mk n₂ d₂))
                              (@eq.{1} rat (rat.mk n₂ d₂) (@has_zero.zero.{0} rat rat.has_zero))
                              false
                              ((λ (a a_1 : rat) (e_1 : @eq.{1} rat a a_1) (a_2 a_3 : rat) (e_2 : @eq.{1} rat a_2 a_3),
                                  @congr.{1 1} rat Prop (@eq.{1} rat a) (@eq.{1} rat a_1) a_2 a_3
                                    (@congr_arg.{1 1} rat (rat → Prop) a a_1 (@eq.{1} rat) e_1)
                                    e_2)
                                 (rat.mk n₂ d₂)
                                 (rat.mk n₂ d₂)
                                 (@eq.refl.{1} rat (rat.mk n₂ d₂))
                                 (rat.mk n₂ d₂)
                                 (@has_zero.zero.{0} rat rat.has_zero)
                                 (@eq.trans.{1} rat (rat.mk n₂ d₂)
                                    (rat.mk n₂ (@has_zero.zero.{0} int int.has_zero))
                                    (@has_zero.zero.{0} rat rat.has_zero)
                                    ((λ (a a_1 : int) (e_1 : @eq.{1} int a a_1) (a_2 a_3 : int)
                                      (e_2 : @eq.{1} int a_2 a_3),
                                        @congr.{1 1} int rat (rat.mk a) (rat.mk a_1) a_2 a_3
                                          (@congr_arg.{1 1} int (int → rat) a a_1 rat.mk e_1)
                                          e_2)
                                       n₂
                                       n₂
                                       (@eq.refl.{1} int n₂)
                                       d₂
                                       (@has_zero.zero.{0} int int.has_zero)
                                       hd)
                                    (rat.mk_zero n₂)))
                              (@propext (@eq.{1} rat (rat.mk n₂ d₂) (@has_zero.zero.{0} rat rat.has_zero)) false
                                 (@iff_false_intro
                                    (@eq.{1} rat (rat.mk n₂ d₂) (@has_zero.zero.{0} rat rat.has_zero))
                                    (@rat.mk_ne_zero_of_ne_zero n₂ d₂ hn₂ hd₂))))
                           (@rfl.{1} rat (rat.mk n₂ d₂)))))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>200        sub_le_iff_le_add&#x27;,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='sub_le_iff_le_add&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/ordered_group.lean&#x27;, &#x27;line&#x27;: 596, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : ordered_comm_group.{0} α] {a b c : α}, iff (@has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@ordered_comm_monoid.to_partial_order.{0} α (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} α (@ordered_comm_group.to_ordered_cancel_comm_monoid.{0} α _inst_1))))) (@has_sub.sub.{0} α (@add_group_has_sub.{0} α (@add_comm_group.to_add_group.{0} α (@ordered_comm_group.to_add_comm_group.{0} α _inst_1))) a b) c) (@has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@ordered_comm_monoid.to_partial_order.{0} α (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} α (@ordered_comm_group.to_ordered_cancel_comm_monoid.{0} α _inst_1))))) a (@has_add.add.{0} α (@add_semigroup.to_has_add.{0} α (@add_monoid.to_add_semigroup.{0} α (@add_group.to_add_monoid.{0} α (@add_comm_group.to_add_group.{0} α (@ordered_comm_group.to_add_comm_group.{0} α _inst_1))))) b c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
p_prime : nat.prime p,
n₁ n₂ d₁ d₂ : int,
hn₁ : @ne.{1} int n₁ (@has_zero.zero.{0} int int.has_zero),
hn₂ : @ne.{1} int n₂ (@has_zero.zero.{0} int int.has_zero),
hd₁ : @ne.{1} int d₁ (@has_zero.zero.{0} int int.has_zero),
hd₂ : @ne.{1} int d₂ (@has_zero.zero.{0} int int.has_zero),
hf1 :
  @multiplicity.finite.{0} int int.comm_semiring
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
    (@has_mul.mul.{0} int int.has_mul n₁ d₂),
hf2 :
  @multiplicity.finite.{0} int int.comm_semiring
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
    (@has_mul.mul.{0} int int.has_mul n₂ d₁)
| @has_le.le.{0} int int.has_le
    (@has_sub.sub.{0} int int.has_sub
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
          (@roption.get.{0} nat
             (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                n₁)
             (@iff.mpr
                (@multiplicity.finite.{0} int int.comm_semiring
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   n₁)
                (and
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int n₁ (@has_zero.zero.{0} int int.has_zero)))
                (@multiplicity.finite_int_iff
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   n₁)
                (@and.intro
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int n₁ (@has_zero.zero.{0} int int.has_zero))
                   (@ne.symm.{1} nat (@has_one.one.{0} nat nat.has_one)
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@ne_of_lt.{0} nat
                         (@partial_order.to_preorder.{0} nat
                            (@ordered_comm_monoid.to_partial_order.{0} nat
                               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
                         (@has_one.one.{0} nat nat.has_one)
                         (int.nat_abs
                            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                         (@nat.prime.one_lt p p_prime)))
                   (λ (hn : @eq.{1} int n₁ (@has_zero.zero.{0} int int.has_zero)),
                      false.rec.{0} false
                        (@eq.mp.{0} (@eq.{1} rat (rat.mk n₁ d₁) (rat.mk n₁ d₁)) false
                           (@eq.trans.{1} Prop (@eq.{1} rat (rat.mk n₁ d₁) (rat.mk n₁ d₁))
                              (@eq.{1} rat (rat.mk n₁ d₁) (@has_zero.zero.{0} rat rat.has_zero))
                              false
                              ((λ (a a_1 : rat) (e_1 : @eq.{1} rat a a_1) (a_2 a_3 : rat) (e_2 : @eq.{1} rat a_2 a_3),
                                  @congr.{1 1} rat Prop (@eq.{1} rat a) (@eq.{1} rat a_1) a_2 a_3
                                    (@congr_arg.{1 1} rat (rat → Prop) a a_1 (@eq.{1} rat) e_1)
                                    e_2)
                                 (rat.mk n₁ d₁)
                                 (rat.mk n₁ d₁)
                                 (@eq.refl.{1} rat (rat.mk n₁ d₁))
                                 (rat.mk n₁ d₁)
                                 (@has_zero.zero.{0} rat rat.has_zero)
                                 (@eq.trans.{1} rat (rat.mk n₁ d₁)
                                    (rat.mk (@has_zero.zero.{0} int int.has_zero) d₁)
                                    (@has_zero.zero.{0} rat rat.has_zero)
                                    ((λ (a a_1 : int) (e_1 : @eq.{1} int a a_1) (a_2 a_3 : int)
                                      (e_2 : @eq.{1} int a_2 a_3),
                                        @congr.{1 1} int rat (rat.mk a) (rat.mk a_1) a_2 a_3
                                          (@congr_arg.{1 1} int (int → rat) a a_1 rat.mk e_1)
                                          e_2)
                                       n₁
                                       (@has_zero.zero.{0} int int.has_zero)
                                       hn
                                       d₁
                                       d₁
                                       (@eq.refl.{1} int d₁))
                                    (rat.zero_mk d₁)))
                              (@propext (@eq.{1} rat (rat.mk n₁ d₁) (@has_zero.zero.{0} rat rat.has_zero)) false
                                 (@iff_false_intro
                                    (@eq.{1} rat (rat.mk n₁ d₁) (@has_zero.zero.{0} rat rat.has_zero))
                                    (@rat.mk_ne_zero_of_ne_zero n₁ d₁ hn₁ hd₁))))
                           (@rfl.{1} rat (rat.mk n₁ d₁))))))))
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
          (@roption.get.{0} nat
             (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                d₁)
             (@iff.mpr
                (@multiplicity.finite.{0} int int.comm_semiring
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   d₁)
                (and
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int d₁ (@has_zero.zero.{0} int int.has_zero)))
                (@multiplicity.finite_int_iff
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   d₁)
                (@and.intro
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int d₁ (@has_zero.zero.{0} int int.has_zero))
                   (@ne.symm.{1} nat (@has_one.one.{0} nat nat.has_one)
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@ne_of_lt.{0} nat
                         (@partial_order.to_preorder.{0} nat
                            (@ordered_comm_monoid.to_partial_order.{0} nat
                               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
                         (@has_one.one.{0} nat nat.has_one)
                         (int.nat_abs
                            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                         (@nat.prime.one_lt p p_prime)))
                   (λ (hd : @eq.{1} int d₁ (@has_zero.zero.{0} int int.has_zero)),
                      false.rec.{0} false
                        (@eq.mp.{0} (@eq.{1} rat (rat.mk n₁ d₁) (rat.mk n₁ d₁)) false
                           (@eq.trans.{1} Prop (@eq.{1} rat (rat.mk n₁ d₁) (rat.mk n₁ d₁))
                              (@eq.{1} rat (rat.mk n₁ d₁) (@has_zero.zero.{0} rat rat.has_zero))
                              false
                              ((λ (a a_1 : rat) (e_1 : @eq.{1} rat a a_1) (a_2 a_3 : rat) (e_2 : @eq.{1} rat a_2 a_3),
                                  @congr.{1 1} rat Prop (@eq.{1} rat a) (@eq.{1} rat a_1) a_2 a_3
                                    (@congr_arg.{1 1} rat (rat → Prop) a a_1 (@eq.{1} rat) e_1)
                                    e_2)
                                 (rat.mk n₁ d₁)
                                 (rat.mk n₁ d₁)
                                 (@eq.refl.{1} rat (rat.mk n₁ d₁))
                                 (rat.mk n₁ d₁)
                                 (@has_zero.zero.{0} rat rat.has_zero)
                                 (@eq.trans.{1} rat (rat.mk n₁ d₁)
                                    (rat.mk n₁ (@has_zero.zero.{0} int int.has_zero))
                                    (@has_zero.zero.{0} rat rat.has_zero)
                                    ((λ (a a_1 : int) (e_1 : @eq.{1} int a a_1) (a_2 a_3 : int)
                                      (e_2 : @eq.{1} int a_2 a_3),
                                        @congr.{1 1} int rat (rat.mk a) (rat.mk a_1) a_2 a_3
                                          (@congr_arg.{1 1} int (int → rat) a a_1 rat.mk e_1)
                                          e_2)
                                       n₁
                                       n₁
                                       (@eq.refl.{1} int n₁)
                                       d₁
                                       (@has_zero.zero.{0} int int.has_zero)
                                       hd)
                                    (rat.mk_zero n₁)))
                              (@propext (@eq.{1} rat (rat.mk n₁ d₁) (@has_zero.zero.{0} rat rat.has_zero)) false
                                 (@iff_false_intro
                                    (@eq.{1} rat (rat.mk n₁ d₁) (@has_zero.zero.{0} rat rat.has_zero))
                                    (@rat.mk_ne_zero_of_ne_zero n₁ d₁ hn₁ hd₁))))
                           (@rfl.{1} rat (rat.mk n₁ d₁)))))))))
    (@has_sub.sub.{0} int int.has_sub
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
          (@roption.get.{0} nat
             (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                n₂)
             (@iff.mpr
                (@multiplicity.finite.{0} int int.comm_semiring
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   n₂)
                (and
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int n₂ (@has_zero.zero.{0} int int.has_zero)))
                (@multiplicity.finite_int_iff
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   n₂)
                (@and.intro
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int n₂ (@has_zero.zero.{0} int int.has_zero))
                   (@ne.symm.{1} nat (@has_one.one.{0} nat nat.has_one)
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@ne_of_lt.{0} nat
                         (@partial_order.to_preorder.{0} nat
                            (@ordered_comm_monoid.to_partial_order.{0} nat
                               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
                         (@has_one.one.{0} nat nat.has_one)
                         (int.nat_abs
                            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                         (@nat.prime.one_lt p p_prime)))
                   (λ (hn : @eq.{1} int n₂ (@has_zero.zero.{0} int int.has_zero)),
                      false.rec.{0} false
                        (@eq.mp.{0} (@eq.{1} rat (rat.mk n₂ d₂) (rat.mk n₂ d₂)) false
                           (@eq.trans.{1} Prop (@eq.{1} rat (rat.mk n₂ d₂) (rat.mk n₂ d₂))
                              (@eq.{1} rat (rat.mk n₂ d₂) (@has_zero.zero.{0} rat rat.has_zero))
                              false
                              ((λ (a a_1 : rat) (e_1 : @eq.{1} rat a a_1) (a_2 a_3 : rat) (e_2 : @eq.{1} rat a_2 a_3),
                                  @congr.{1 1} rat Prop (@eq.{1} rat a) (@eq.{1} rat a_1) a_2 a_3
                                    (@congr_arg.{1 1} rat (rat → Prop) a a_1 (@eq.{1} rat) e_1)
                                    e_2)
                                 (rat.mk n₂ d₂)
                                 (rat.mk n₂ d₂)
                                 (@eq.refl.{1} rat (rat.mk n₂ d₂))
                                 (rat.mk n₂ d₂)
                                 (@has_zero.zero.{0} rat rat.has_zero)
                                 (@eq.trans.{1} rat (rat.mk n₂ d₂)
                                    (rat.mk (@has_zero.zero.{0} int int.has_zero) d₂)
                                    (@has_zero.zero.{0} rat rat.has_zero)
                                    ((λ (a a_1 : int) (e_1 : @eq.{1} int a a_1) (a_2 a_3 : int)
                                      (e_2 : @eq.{1} int a_2 a_3),
                                        @congr.{1 1} int rat (rat.mk a) (rat.mk a_1) a_2 a_3
                                          (@congr_arg.{1 1} int (int → rat) a a_1 rat.mk e_1)
                                          e_2)
                                       n₂
                                       (@has_zero.zero.{0} int int.has_zero)
                                       hn
                                       d₂
                                       d₂
                                       (@eq.refl.{1} int d₂))
                                    (rat.zero_mk d₂)))
                              (@propext (@eq.{1} rat (rat.mk n₂ d₂) (@has_zero.zero.{0} rat rat.has_zero)) false
                                 (@iff_false_intro
                                    (@eq.{1} rat (rat.mk n₂ d₂) (@has_zero.zero.{0} rat rat.has_zero))
                                    (@rat.mk_ne_zero_of_ne_zero n₂ d₂ hn₂ hd₂))))
                           (@rfl.{1} rat (rat.mk n₂ d₂))))))))
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
          (@roption.get.{0} nat
             (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                d₂)
             (@iff.mpr
                (@multiplicity.finite.{0} int int.comm_semiring
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   d₂)
                (and
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int d₂ (@has_zero.zero.{0} int int.has_zero)))
                (@multiplicity.finite_int_iff
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   d₂)
                (@and.intro
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int d₂ (@has_zero.zero.{0} int int.has_zero))
                   (@ne.symm.{1} nat (@has_one.one.{0} nat nat.has_one)
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@ne_of_lt.{0} nat
                         (@partial_order.to_preorder.{0} nat
                            (@ordered_comm_monoid.to_partial_order.{0} nat
                               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
                         (@has_one.one.{0} nat nat.has_one)
                         (int.nat_abs
                            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                         (@nat.prime.one_lt p p_prime)))
                   (λ (hd : @eq.{1} int d₂ (@has_zero.zero.{0} int int.has_zero)),
                      false.rec.{0} false
                        (@eq.mp.{0} (@eq.{1} rat (rat.mk n₂ d₂) (rat.mk n₂ d₂)) false
                           (@eq.trans.{1} Prop (@eq.{1} rat (rat.mk n₂ d₂) (rat.mk n₂ d₂))
                              (@eq.{1} rat (rat.mk n₂ d₂) (@has_zero.zero.{0} rat rat.has_zero))
                              false
                              ((λ (a a_1 : rat) (e_1 : @eq.{1} rat a a_1) (a_2 a_3 : rat) (e_2 : @eq.{1} rat a_2 a_3),
                                  @congr.{1 1} rat Prop (@eq.{1} rat a) (@eq.{1} rat a_1) a_2 a_3
                                    (@congr_arg.{1 1} rat (rat → Prop) a a_1 (@eq.{1} rat) e_1)
                                    e_2)
                                 (rat.mk n₂ d₂)
                                 (rat.mk n₂ d₂)
                                 (@eq.refl.{1} rat (rat.mk n₂ d₂))
                                 (rat.mk n₂ d₂)
                                 (@has_zero.zero.{0} rat rat.has_zero)
                                 (@eq.trans.{1} rat (rat.mk n₂ d₂)
                                    (rat.mk n₂ (@has_zero.zero.{0} int int.has_zero))
                                    (@has_zero.zero.{0} rat rat.has_zero)
                                    ((λ (a a_1 : int) (e_1 : @eq.{1} int a a_1) (a_2 a_3 : int)
                                      (e_2 : @eq.{1} int a_2 a_3),
                                        @congr.{1 1} int rat (rat.mk a) (rat.mk a_1) a_2 a_3
                                          (@congr_arg.{1 1} int (int → rat) a a_1 rat.mk e_1)
                                          e_2)
                                       n₂
                                       n₂
                                       (@eq.refl.{1} int n₂)
                                       d₂
                                       (@has_zero.zero.{0} int int.has_zero)
                                       hd)
                                    (rat.mk_zero n₂)))
                              (@propext (@eq.{1} rat (rat.mk n₂ d₂) (@has_zero.zero.{0} rat rat.has_zero)) false
                                 (@iff_false_intro
                                    (@eq.{1} rat (rat.mk n₂ d₂) (@has_zero.zero.{0} rat rat.has_zero))
                                    (@rat.mk_ne_zero_of_ne_zero n₂ d₂ hn₂ hd₂))))
                           (@rfl.{1} rat (rat.mk n₂ d₂)))))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
p_prime : nat.prime p,
n₁ n₂ d₁ d₂ : int,
hn₁ : @ne.{1} int n₁ (@has_zero.zero.{0} int int.has_zero),
hn₂ : @ne.{1} int n₂ (@has_zero.zero.{0} int int.has_zero),
hd₁ : @ne.{1} int d₁ (@has_zero.zero.{0} int int.has_zero),
hd₂ : @ne.{1} int d₂ (@has_zero.zero.{0} int int.has_zero),
hf1 :
  @multiplicity.finite.{0} int int.comm_semiring
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
    (@has_mul.mul.{0} int int.has_mul n₁ d₂),
hf2 :
  @multiplicity.finite.{0} int int.comm_semiring
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
    (@has_mul.mul.{0} int int.has_mul n₂ d₁)
| @has_le.le.{0} int
    (@preorder.to_has_le.{0} int
       (@partial_order.to_preorder.{0} int
          (@ordered_comm_monoid.to_partial_order.{0} int
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} int
                (@ordered_comm_group.to_ordered_cancel_comm_monoid.{0} int
                   (@ordered_ring.to_ordered_comm_group.{0} int
                      (@linear_ordered_ring.to_ordered_ring.{0} int
                         (@linear_ordered_comm_ring.to_linear_ordered_ring.{0} int
                            (@decidable_linear_ordered_comm_ring.to_linear_ordered_comm_ring.{0} int
                               int.decidable_linear_ordered_comm_ring)))))))))
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
       (@roption.get.{0} nat
          (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
             n₁)
          (@iff.mpr
             (@multiplicity.finite.{0} int int.comm_semiring
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                n₁)
             (and
                (@ne.{1} nat
                   (int.nat_abs
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                   (@has_one.one.{0} nat nat.has_one))
                (@ne.{1} int n₁ (@has_zero.zero.{0} int int.has_zero)))
             (@multiplicity.finite_int_iff
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                n₁)
             (@and.intro
                (@ne.{1} nat
                   (int.nat_abs
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                   (@has_one.one.{0} nat nat.has_one))
                (@ne.{1} int n₁ (@has_zero.zero.{0} int int.has_zero))
                (@ne.symm.{1} nat (@has_one.one.{0} nat nat.has_one)
                   (int.nat_abs
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                   (@ne_of_lt.{0} nat
                      (@partial_order.to_preorder.{0} nat
                         (@ordered_comm_monoid.to_partial_order.{0} nat
                            (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                               (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
                      (@has_one.one.{0} nat nat.has_one)
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@nat.prime.one_lt p p_prime)))
                (λ (hn : @eq.{1} int n₁ (@has_zero.zero.{0} int int.has_zero)),
                   false.rec.{0} false
                     (@eq.mp.{0} (@eq.{1} rat (rat.mk n₁ d₁) (rat.mk n₁ d₁)) false
                        (@eq.trans.{1} Prop (@eq.{1} rat (rat.mk n₁ d₁) (rat.mk n₁ d₁))
                           (@eq.{1} rat (rat.mk n₁ d₁) (@has_zero.zero.{0} rat rat.has_zero))
                           false
                           ((λ (a a_1 : rat) (e_1 : @eq.{1} rat a a_1) (a_2 a_3 : rat) (e_2 : @eq.{1} rat a_2 a_3),
                               @congr.{1 1} rat Prop (@eq.{1} rat a) (@eq.{1} rat a_1) a_2 a_3
                                 (@congr_arg.{1 1} rat (rat → Prop) a a_1 (@eq.{1} rat) e_1)
                                 e_2)
                              (rat.mk n₁ d₁)
                              (rat.mk n₁ d₁)
                              (@eq.refl.{1} rat (rat.mk n₁ d₁))
                              (rat.mk n₁ d₁)
                              (@has_zero.zero.{0} rat rat.has_zero)
                              (@eq.trans.{1} rat (rat.mk n₁ d₁) (rat.mk (@has_zero.zero.{0} int int.has_zero) d₁)
                                 (@has_zero.zero.{0} rat rat.has_zero)
                                 ((λ (a a_1 : int) (e_1 : @eq.{1} int a a_1) (a_2 a_3 : int)
                                   (e_2 : @eq.{1} int a_2 a_3),
                                     @congr.{1 1} int rat (rat.mk a) (rat.mk a_1) a_2 a_3
                                       (@congr_arg.{1 1} int (int → rat) a a_1 rat.mk e_1)
                                       e_2)
                                    n₁
                                    (@has_zero.zero.{0} int int.has_zero)
                                    hn
                                    d₁
                                    d₁
                                    (@eq.refl.{1} int d₁))
                                 (rat.zero_mk d₁)))
                           (@propext (@eq.{1} rat (rat.mk n₁ d₁) (@has_zero.zero.{0} rat rat.has_zero)) false
                              (@iff_false_intro (@eq.{1} rat (rat.mk n₁ d₁) (@has_zero.zero.{0} rat rat.has_zero))
                                 (@rat.mk_ne_zero_of_ne_zero n₁ d₁ hn₁ hd₁))))
                        (@rfl.{1} rat (rat.mk n₁ d₁))))))))
    (@has_add.add.{0} int
       (@add_semigroup.to_has_add.{0} int
          (@add_monoid.to_add_semigroup.{0} int
             (@add_group.to_add_monoid.{0} int
                (@add_comm_group.to_add_group.{0} int
                   (@ordered_comm_group.to_add_comm_group.{0} int
                      (@ordered_ring.to_ordered_comm_group.{0} int
                         (@linear_ordered_ring.to_ordered_ring.{0} int
                            (@linear_ordered_comm_ring.to_linear_ordered_ring.{0} int
                               (@decidable_linear_ordered_comm_ring.to_linear_ordered_comm_ring.{0} int
                                  int.decidable_linear_ordered_comm_ring)))))))))
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
          (@roption.get.{0} nat
             (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                d₁)
             (@iff.mpr
                (@multiplicity.finite.{0} int int.comm_semiring
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   d₁)
                (and
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int d₁ (@has_zero.zero.{0} int int.has_zero)))
                (@multiplicity.finite_int_iff
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   d₁)
                (@and.intro
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int d₁ (@has_zero.zero.{0} int int.has_zero))
                   (@ne.symm.{1} nat (@has_one.one.{0} nat nat.has_one)
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@ne_of_lt.{0} nat
                         (@partial_order.to_preorder.{0} nat
                            (@ordered_comm_monoid.to_partial_order.{0} nat
                               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
                         (@has_one.one.{0} nat nat.has_one)
                         (int.nat_abs
                            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                         (@nat.prime.one_lt p p_prime)))
                   (λ (hd : @eq.{1} int d₁ (@has_zero.zero.{0} int int.has_zero)),
                      false.rec.{0} false
                        (@eq.mp.{0} (@eq.{1} rat (rat.mk n₁ d₁) (rat.mk n₁ d₁)) false
                           (@eq.trans.{1} Prop (@eq.{1} rat (rat.mk n₁ d₁) (rat.mk n₁ d₁))
                              (@eq.{1} rat (rat.mk n₁ d₁) (@has_zero.zero.{0} rat rat.has_zero))
                              false
                              ((λ (a a_1 : rat) (e_1 : @eq.{1} rat a a_1) (a_2 a_3 : rat) (e_2 : @eq.{1} rat a_2 a_3),
                                  @congr.{1 1} rat Prop (@eq.{1} rat a) (@eq.{1} rat a_1) a_2 a_3
                                    (@congr_arg.{1 1} rat (rat → Prop) a a_1 (@eq.{1} rat) e_1)
                                    e_2)
                                 (rat.mk n₁ d₁)
                                 (rat.mk n₁ d₁)
                                 (@eq.refl.{1} rat (rat.mk n₁ d₁))
                                 (rat.mk n₁ d₁)
                                 (@has_zero.zero.{0} rat rat.has_zero)
                                 (@eq.trans.{1} rat (rat.mk n₁ d₁)
                                    (rat.mk n₁ (@has_zero.zero.{0} int int.has_zero))
                                    (@has_zero.zero.{0} rat rat.has_zero)
                                    ((λ (a a_1 : int) (e_1 : @eq.{1} int a a_1) (a_2 a_3 : int)
                                      (e_2 : @eq.{1} int a_2 a_3),
                                        @congr.{1 1} int rat (rat.mk a) (rat.mk a_1) a_2 a_3
                                          (@congr_arg.{1 1} int (int → rat) a a_1 rat.mk e_1)
                                          e_2)
                                       n₁
                                       n₁
                                       (@eq.refl.{1} int n₁)
                                       d₁
                                       (@has_zero.zero.{0} int int.has_zero)
                                       hd)
                                    (rat.mk_zero n₁)))
                              (@propext (@eq.{1} rat (rat.mk n₁ d₁) (@has_zero.zero.{0} rat rat.has_zero)) false
                                 (@iff_false_intro
                                    (@eq.{1} rat (rat.mk n₁ d₁) (@has_zero.zero.{0} rat rat.has_zero))
                                    (@rat.mk_ne_zero_of_ne_zero n₁ d₁ hn₁ hd₁))))
                           (@rfl.{1} rat (rat.mk n₁ d₁))))))))
       (@has_sub.sub.{0} int int.has_sub
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
             (@roption.get.{0} nat
                (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   n₂)
                (@iff.mpr
                   (@multiplicity.finite.{0} int int.comm_semiring
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                      n₂)
                   (and
                      (@ne.{1} nat
                         (int.nat_abs
                            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                         (@has_one.one.{0} nat nat.has_one))
                      (@ne.{1} int n₂ (@has_zero.zero.{0} int int.has_zero)))
                   (@multiplicity.finite_int_iff
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                      n₂)
                   (@and.intro
                      (@ne.{1} nat
                         (int.nat_abs
                            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                         (@has_one.one.{0} nat nat.has_one))
                      (@ne.{1} int n₂ (@has_zero.zero.{0} int int.has_zero))
                      (@ne.symm.{1} nat (@has_one.one.{0} nat nat.has_one)
                         (int.nat_abs
                            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                         (@ne_of_lt.{0} nat
                            (@partial_order.to_preorder.{0} nat
                               (@ordered_comm_monoid.to_partial_order.{0} nat
                                  (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                                     (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
                            (@has_one.one.{0} nat nat.has_one)
                            (int.nat_abs
                               (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                  p))
                            (@nat.prime.one_lt p p_prime)))
                      (λ (hn : @eq.{1} int n₂ (@has_zero.zero.{0} int int.has_zero)),
                         false.rec.{0} false
                           (@eq.mp.{0} (@eq.{1} rat (rat.mk n₂ d₂) (rat.mk n₂ d₂)) false
                              (@eq.trans.{1} Prop (@eq.{1} rat (rat.mk n₂ d₂) (rat.mk n₂ d₂))
                                 (@eq.{1} rat (rat.mk n₂ d₂) (@has_zero.zero.{0} rat rat.has_zero))
                                 false
                                 ((λ (a a_1 : rat) (e_1 : @eq.{1} rat a a_1) (a_2 a_3 : rat)
                                   (e_2 : @eq.{1} rat a_2 a_3),
                                     @congr.{1 1} rat Prop (@eq.{1} rat a) (@eq.{1} rat a_1) a_2 a_3
                                       (@congr_arg.{1 1} rat (rat → Prop) a a_1 (@eq.{1} rat) e_1)
                                       e_2)
                                    (rat.mk n₂ d₂)
                                    (rat.mk n₂ d₂)
                                    (@eq.refl.{1} rat (rat.mk n₂ d₂))
                                    (rat.mk n₂ d₂)
                                    (@has_zero.zero.{0} rat rat.has_zero)
                                    (@eq.trans.{1} rat (rat.mk n₂ d₂)
                                       (rat.mk (@has_zero.zero.{0} int int.has_zero) d₂)
                                       (@has_zero.zero.{0} rat rat.has_zero)
                                       ((λ (a a_1 : int) (e_1 : @eq.{1} int a a_1) (a_2 a_3 : int)
                                         (e_2 : @eq.{1} int a_2 a_3),
                                           @congr.{1 1} int rat (rat.mk a) (rat.mk a_1) a_2 a_3
                                             (@congr_arg.{1 1} int (int → rat) a a_1 rat.mk e_1)
                                             e_2)
                                          n₂
                                          (@has_zero.zero.{0} int int.has_zero)
                                          hn
                                          d₂
                                          d₂
                                          (@eq.refl.{1} int d₂))
                                       (rat.zero_mk d₂)))
                                 (@propext (@eq.{1} rat (rat.mk n₂ d₂) (@has_zero.zero.{0} rat rat.has_zero)) false
                                    (@iff_false_intro
                                       (@eq.{1} rat (rat.mk n₂ d₂) (@has_zero.zero.{0} rat rat.has_zero))
                                       (@rat.mk_ne_zero_of_ne_zero n₂ d₂ hn₂ hd₂))))
                              (@rfl.{1} rat (rat.mk n₂ d₂))))))))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
             (@roption.get.{0} nat
                (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   d₂)
                (@iff.mpr
                   (@multiplicity.finite.{0} int int.comm_semiring
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                      d₂)
                   (and
                      (@ne.{1} nat
                         (int.nat_abs
                            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                         (@has_one.one.{0} nat nat.has_one))
                      (@ne.{1} int d₂ (@has_zero.zero.{0} int int.has_zero)))
                   (@multiplicity.finite_int_iff
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                      d₂)
                   (@and.intro
                      (@ne.{1} nat
                         (int.nat_abs
                            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                         (@has_one.one.{0} nat nat.has_one))
                      (@ne.{1} int d₂ (@has_zero.zero.{0} int int.has_zero))
                      (@ne.symm.{1} nat (@has_one.one.{0} nat nat.has_one)
                         (int.nat_abs
                            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                         (@ne_of_lt.{0} nat
                            (@partial_order.to_preorder.{0} nat
                               (@ordered_comm_monoid.to_partial_order.{0} nat
                                  (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                                     (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
                            (@has_one.one.{0} nat nat.has_one)
                            (int.nat_abs
                               (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                  p))
                            (@nat.prime.one_lt p p_prime)))
                      (λ (hd : @eq.{1} int d₂ (@has_zero.zero.{0} int int.has_zero)),
                         false.rec.{0} false
                           (@eq.mp.{0} (@eq.{1} rat (rat.mk n₂ d₂) (rat.mk n₂ d₂)) false
                              (@eq.trans.{1} Prop (@eq.{1} rat (rat.mk n₂ d₂) (rat.mk n₂ d₂))
                                 (@eq.{1} rat (rat.mk n₂ d₂) (@has_zero.zero.{0} rat rat.has_zero))
                                 false
                                 ((λ (a a_1 : rat) (e_1 : @eq.{1} rat a a_1) (a_2 a_3 : rat)
                                   (e_2 : @eq.{1} rat a_2 a_3),
                                     @congr.{1 1} rat Prop (@eq.{1} rat a) (@eq.{1} rat a_1) a_2 a_3
                                       (@congr_arg.{1 1} rat (rat → Prop) a a_1 (@eq.{1} rat) e_1)
                                       e_2)
                                    (rat.mk n₂ d₂)
                                    (rat.mk n₂ d₂)
                                    (@eq.refl.{1} rat (rat.mk n₂ d₂))
                                    (rat.mk n₂ d₂)
                                    (@has_zero.zero.{0} rat rat.has_zero)
                                    (@eq.trans.{1} rat (rat.mk n₂ d₂)
                                       (rat.mk n₂ (@has_zero.zero.{0} int int.has_zero))
                                       (@has_zero.zero.{0} rat rat.has_zero)
                                       ((λ (a a_1 : int) (e_1 : @eq.{1} int a a_1) (a_2 a_3 : int)
                                         (e_2 : @eq.{1} int a_2 a_3),
                                           @congr.{1 1} int rat (rat.mk a) (rat.mk a_1) a_2 a_3
                                             (@congr_arg.{1 1} int (int → rat) a a_1 rat.mk e_1)
                                             e_2)
                                          n₂
                                          n₂
                                          (@eq.refl.{1} int n₂)
                                          d₂
                                          (@has_zero.zero.{0} int int.has_zero)
                                          hd)
                                       (rat.mk_zero n₂)))
                                 (@propext (@eq.{1} rat (rat.mk n₂ d₂) (@has_zero.zero.{0} rat rat.has_zero)) false
                                    (@iff_false_intro
                                       (@eq.{1} rat (rat.mk n₂ d₂) (@has_zero.zero.{0} rat rat.has_zero))
                                       (@rat.mk_ne_zero_of_ne_zero n₂ d₂ hn₂ hd₂))))
                              (@rfl.{1} rat (rat.mk n₂ d₂))))))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>201        ← add_sub_assoc,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='add_sub_assoc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 336, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : add_group.{0} α] (a b c : α), @eq.{1} α (@has_sub.sub.{0} α (@add_group_has_sub.{0} α _inst_1) (@has_add.add.{0} α (@add_semigroup.to_has_add.{0} α (@add_monoid.to_add_semigroup.{0} α (@add_group.to_add_monoid.{0} α _inst_1))) a b) c) (@has_add.add.{0} α (@add_semigroup.to_has_add.{0} α (@add_monoid.to_add_semigroup.{0} α (@add_group.to_add_monoid.{0} α _inst_1))) a (@has_sub.sub.{0} α (@add_group_has_sub.{0} α _inst_1) b c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
p_prime : nat.prime p,
n₁ n₂ d₁ d₂ : int,
hn₁ : @ne.{1} int n₁ (@has_zero.zero.{0} int int.has_zero),
hn₂ : @ne.{1} int n₂ (@has_zero.zero.{0} int int.has_zero),
hd₁ : @ne.{1} int d₁ (@has_zero.zero.{0} int int.has_zero),
hd₂ : @ne.{1} int d₂ (@has_zero.zero.{0} int int.has_zero),
hf1 :
  @multiplicity.finite.{0} int int.comm_semiring
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
    (@has_mul.mul.{0} int int.has_mul n₁ d₂),
hf2 :
  @multiplicity.finite.{0} int int.comm_semiring
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
    (@has_mul.mul.{0} int int.has_mul n₂ d₁)
| @has_le.le.{0} int
    (@preorder.to_has_le.{0} int
       (@partial_order.to_preorder.{0} int
          (@ordered_comm_monoid.to_partial_order.{0} int
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} int
                (@ordered_comm_group.to_ordered_cancel_comm_monoid.{0} int
                   (@ordered_ring.to_ordered_comm_group.{0} int
                      (@linear_ordered_ring.to_ordered_ring.{0} int
                         (@linear_ordered_comm_ring.to_linear_ordered_ring.{0} int
                            (@decidable_linear_ordered_comm_ring.to_linear_ordered_comm_ring.{0} int
                               int.decidable_linear_ordered_comm_ring)))))))))
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
       (@roption.get.{0} nat
          (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
             n₁)
          (@iff.mpr
             (@multiplicity.finite.{0} int int.comm_semiring
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                n₁)
             (and
                (@ne.{1} nat
                   (int.nat_abs
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                   (@has_one.one.{0} nat nat.has_one))
                (@ne.{1} int n₁ (@has_zero.zero.{0} int int.has_zero)))
             (@multiplicity.finite_int_iff
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                n₁)
             (@and.intro
                (@ne.{1} nat
                   (int.nat_abs
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                   (@has_one.one.{0} nat nat.has_one))
                (@ne.{1} int n₁ (@has_zero.zero.{0} int int.has_zero))
                (@ne.symm.{1} nat (@has_one.one.{0} nat nat.has_one)
                   (int.nat_abs
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                   (@ne_of_lt.{0} nat
                      (@partial_order.to_preorder.{0} nat
                         (@ordered_comm_monoid.to_partial_order.{0} nat
                            (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                               (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
                      (@has_one.one.{0} nat nat.has_one)
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@nat.prime.one_lt p p_prime)))
                (λ (hn : @eq.{1} int n₁ (@has_zero.zero.{0} int int.has_zero)),
                   false.rec.{0} false
                     (@eq.mp.{0} (@eq.{1} rat (rat.mk n₁ d₁) (rat.mk n₁ d₁)) false
                        (@eq.trans.{1} Prop (@eq.{1} rat (rat.mk n₁ d₁) (rat.mk n₁ d₁))
                           (@eq.{1} rat (rat.mk n₁ d₁) (@has_zero.zero.{0} rat rat.has_zero))
                           false
                           ((λ (a a_1 : rat) (e_1 : @eq.{1} rat a a_1) (a_2 a_3 : rat) (e_2 : @eq.{1} rat a_2 a_3),
                               @congr.{1 1} rat Prop (@eq.{1} rat a) (@eq.{1} rat a_1) a_2 a_3
                                 (@congr_arg.{1 1} rat (rat → Prop) a a_1 (@eq.{1} rat) e_1)
                                 e_2)
                              (rat.mk n₁ d₁)
                              (rat.mk n₁ d₁)
                              (@eq.refl.{1} rat (rat.mk n₁ d₁))
                              (rat.mk n₁ d₁)
                              (@has_zero.zero.{0} rat rat.has_zero)
                              (@eq.trans.{1} rat (rat.mk n₁ d₁) (rat.mk (@has_zero.zero.{0} int int.has_zero) d₁)
                                 (@has_zero.zero.{0} rat rat.has_zero)
                                 ((λ (a a_1 : int) (e_1 : @eq.{1} int a a_1) (a_2 a_3 : int)
                                   (e_2 : @eq.{1} int a_2 a_3),
                                     @congr.{1 1} int rat (rat.mk a) (rat.mk a_1) a_2 a_3
                                       (@congr_arg.{1 1} int (int → rat) a a_1 rat.mk e_1)
                                       e_2)
                                    n₁
                                    (@has_zero.zero.{0} int int.has_zero)
                                    hn
                                    d₁
                                    d₁
                                    (@eq.refl.{1} int d₁))
                                 (rat.zero_mk d₁)))
                           (@propext (@eq.{1} rat (rat.mk n₁ d₁) (@has_zero.zero.{0} rat rat.has_zero)) false
                              (@iff_false_intro (@eq.{1} rat (rat.mk n₁ d₁) (@has_zero.zero.{0} rat rat.has_zero))
                                 (@rat.mk_ne_zero_of_ne_zero n₁ d₁ hn₁ hd₁))))
                        (@rfl.{1} rat (rat.mk n₁ d₁))))))))
    (@has_add.add.{0} int
       (@add_semigroup.to_has_add.{0} int
          (@add_monoid.to_add_semigroup.{0} int
             (@add_group.to_add_monoid.{0} int
                (@add_comm_group.to_add_group.{0} int
                   (@ordered_comm_group.to_add_comm_group.{0} int
                      (@ordered_ring.to_ordered_comm_group.{0} int
                         (@linear_ordered_ring.to_ordered_ring.{0} int
                            (@linear_ordered_comm_ring.to_linear_ordered_ring.{0} int
                               (@decidable_linear_ordered_comm_ring.to_linear_ordered_comm_ring.{0} int
                                  int.decidable_linear_ordered_comm_ring)))))))))
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
          (@roption.get.{0} nat
             (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                d₁)
             (@iff.mpr
                (@multiplicity.finite.{0} int int.comm_semiring
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   d₁)
                (and
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int d₁ (@has_zero.zero.{0} int int.has_zero)))
                (@multiplicity.finite_int_iff
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   d₁)
                (@and.intro
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int d₁ (@has_zero.zero.{0} int int.has_zero))
                   (@ne.symm.{1} nat (@has_one.one.{0} nat nat.has_one)
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@ne_of_lt.{0} nat
                         (@partial_order.to_preorder.{0} nat
                            (@ordered_comm_monoid.to_partial_order.{0} nat
                               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
                         (@has_one.one.{0} nat nat.has_one)
                         (int.nat_abs
                            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                         (@nat.prime.one_lt p p_prime)))
                   (λ (hd : @eq.{1} int d₁ (@has_zero.zero.{0} int int.has_zero)),
                      false.rec.{0} false
                        (@eq.mp.{0} (@eq.{1} rat (rat.mk n₁ d₁) (rat.mk n₁ d₁)) false
                           (@eq.trans.{1} Prop (@eq.{1} rat (rat.mk n₁ d₁) (rat.mk n₁ d₁))
                              (@eq.{1} rat (rat.mk n₁ d₁) (@has_zero.zero.{0} rat rat.has_zero))
                              false
                              ((λ (a a_1 : rat) (e_1 : @eq.{1} rat a a_1) (a_2 a_3 : rat) (e_2 : @eq.{1} rat a_2 a_3),
                                  @congr.{1 1} rat Prop (@eq.{1} rat a) (@eq.{1} rat a_1) a_2 a_3
                                    (@congr_arg.{1 1} rat (rat → Prop) a a_1 (@eq.{1} rat) e_1)
                                    e_2)
                                 (rat.mk n₁ d₁)
                                 (rat.mk n₁ d₁)
                                 (@eq.refl.{1} rat (rat.mk n₁ d₁))
                                 (rat.mk n₁ d₁)
                                 (@has_zero.zero.{0} rat rat.has_zero)
                                 (@eq.trans.{1} rat (rat.mk n₁ d₁)
                                    (rat.mk n₁ (@has_zero.zero.{0} int int.has_zero))
                                    (@has_zero.zero.{0} rat rat.has_zero)
                                    ((λ (a a_1 : int) (e_1 : @eq.{1} int a a_1) (a_2 a_3 : int)
                                      (e_2 : @eq.{1} int a_2 a_3),
                                        @congr.{1 1} int rat (rat.mk a) (rat.mk a_1) a_2 a_3
                                          (@congr_arg.{1 1} int (int → rat) a a_1 rat.mk e_1)
                                          e_2)
                                       n₁
                                       n₁
                                       (@eq.refl.{1} int n₁)
                                       d₁
                                       (@has_zero.zero.{0} int int.has_zero)
                                       hd)
                                    (rat.mk_zero n₁)))
                              (@propext (@eq.{1} rat (rat.mk n₁ d₁) (@has_zero.zero.{0} rat rat.has_zero)) false
                                 (@iff_false_intro
                                    (@eq.{1} rat (rat.mk n₁ d₁) (@has_zero.zero.{0} rat rat.has_zero))
                                    (@rat.mk_ne_zero_of_ne_zero n₁ d₁ hn₁ hd₁))))
                           (@rfl.{1} rat (rat.mk n₁ d₁))))))))
       (@has_sub.sub.{0} int int.has_sub
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
             (@roption.get.{0} nat
                (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   n₂)
                (@iff.mpr
                   (@multiplicity.finite.{0} int int.comm_semiring
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                      n₂)
                   (and
                      (@ne.{1} nat
                         (int.nat_abs
                            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                         (@has_one.one.{0} nat nat.has_one))
                      (@ne.{1} int n₂ (@has_zero.zero.{0} int int.has_zero)))
                   (@multiplicity.finite_int_iff
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                      n₂)
                   (@and.intro
                      (@ne.{1} nat
                         (int.nat_abs
                            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                         (@has_one.one.{0} nat nat.has_one))
                      (@ne.{1} int n₂ (@has_zero.zero.{0} int int.has_zero))
                      (@ne.symm.{1} nat (@has_one.one.{0} nat nat.has_one)
                         (int.nat_abs
                            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                         (@ne_of_lt.{0} nat
                            (@partial_order.to_preorder.{0} nat
                               (@ordered_comm_monoid.to_partial_order.{0} nat
                                  (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                                     (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
                            (@has_one.one.{0} nat nat.has_one)
                            (int.nat_abs
                               (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                  p))
                            (@nat.prime.one_lt p p_prime)))
                      (λ (hn : @eq.{1} int n₂ (@has_zero.zero.{0} int int.has_zero)),
                         false.rec.{0} false
                           (@eq.mp.{0} (@eq.{1} rat (rat.mk n₂ d₂) (rat.mk n₂ d₂)) false
                              (@eq.trans.{1} Prop (@eq.{1} rat (rat.mk n₂ d₂) (rat.mk n₂ d₂))
                                 (@eq.{1} rat (rat.mk n₂ d₂) (@has_zero.zero.{0} rat rat.has_zero))
                                 false
                                 ((λ (a a_1 : rat) (e_1 : @eq.{1} rat a a_1) (a_2 a_3 : rat)
                                   (e_2 : @eq.{1} rat a_2 a_3),
                                     @congr.{1 1} rat Prop (@eq.{1} rat a) (@eq.{1} rat a_1) a_2 a_3
                                       (@congr_arg.{1 1} rat (rat → Prop) a a_1 (@eq.{1} rat) e_1)
                                       e_2)
                                    (rat.mk n₂ d₂)
                                    (rat.mk n₂ d₂)
                                    (@eq.refl.{1} rat (rat.mk n₂ d₂))
                                    (rat.mk n₂ d₂)
                                    (@has_zero.zero.{0} rat rat.has_zero)
                                    (@eq.trans.{1} rat (rat.mk n₂ d₂)
                                       (rat.mk (@has_zero.zero.{0} int int.has_zero) d₂)
                                       (@has_zero.zero.{0} rat rat.has_zero)
                                       ((λ (a a_1 : int) (e_1 : @eq.{1} int a a_1) (a_2 a_3 : int)
                                         (e_2 : @eq.{1} int a_2 a_3),
                                           @congr.{1 1} int rat (rat.mk a) (rat.mk a_1) a_2 a_3
                                             (@congr_arg.{1 1} int (int → rat) a a_1 rat.mk e_1)
                                             e_2)
                                          n₂
                                          (@has_zero.zero.{0} int int.has_zero)
                                          hn
                                          d₂
                                          d₂
                                          (@eq.refl.{1} int d₂))
                                       (rat.zero_mk d₂)))
                                 (@propext (@eq.{1} rat (rat.mk n₂ d₂) (@has_zero.zero.{0} rat rat.has_zero)) false
                                    (@iff_false_intro
                                       (@eq.{1} rat (rat.mk n₂ d₂) (@has_zero.zero.{0} rat rat.has_zero))
                                       (@rat.mk_ne_zero_of_ne_zero n₂ d₂ hn₂ hd₂))))
                              (@rfl.{1} rat (rat.mk n₂ d₂))))))))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
             (@roption.get.{0} nat
                (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   d₂)
                (@iff.mpr
                   (@multiplicity.finite.{0} int int.comm_semiring
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                      d₂)
                   (and
                      (@ne.{1} nat
                         (int.nat_abs
                            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                         (@has_one.one.{0} nat nat.has_one))
                      (@ne.{1} int d₂ (@has_zero.zero.{0} int int.has_zero)))
                   (@multiplicity.finite_int_iff
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                      d₂)
                   (@and.intro
                      (@ne.{1} nat
                         (int.nat_abs
                            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                         (@has_one.one.{0} nat nat.has_one))
                      (@ne.{1} int d₂ (@has_zero.zero.{0} int int.has_zero))
                      (@ne.symm.{1} nat (@has_one.one.{0} nat nat.has_one)
                         (int.nat_abs
                            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                         (@ne_of_lt.{0} nat
                            (@partial_order.to_preorder.{0} nat
                               (@ordered_comm_monoid.to_partial_order.{0} nat
                                  (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                                     (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
                            (@has_one.one.{0} nat nat.has_one)
                            (int.nat_abs
                               (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                  p))
                            (@nat.prime.one_lt p p_prime)))
                      (λ (hd : @eq.{1} int d₂ (@has_zero.zero.{0} int int.has_zero)),
                         false.rec.{0} false
                           (@eq.mp.{0} (@eq.{1} rat (rat.mk n₂ d₂) (rat.mk n₂ d₂)) false
                              (@eq.trans.{1} Prop (@eq.{1} rat (rat.mk n₂ d₂) (rat.mk n₂ d₂))
                                 (@eq.{1} rat (rat.mk n₂ d₂) (@has_zero.zero.{0} rat rat.has_zero))
                                 false
                                 ((λ (a a_1 : rat) (e_1 : @eq.{1} rat a a_1) (a_2 a_3 : rat)
                                   (e_2 : @eq.{1} rat a_2 a_3),
                                     @congr.{1 1} rat Prop (@eq.{1} rat a) (@eq.{1} rat a_1) a_2 a_3
                                       (@congr_arg.{1 1} rat (rat → Prop) a a_1 (@eq.{1} rat) e_1)
                                       e_2)
                                    (rat.mk n₂ d₂)
                                    (rat.mk n₂ d₂)
                                    (@eq.refl.{1} rat (rat.mk n₂ d₂))
                                    (rat.mk n₂ d₂)
                                    (@has_zero.zero.{0} rat rat.has_zero)
                                    (@eq.trans.{1} rat (rat.mk n₂ d₂)
                                       (rat.mk n₂ (@has_zero.zero.{0} int int.has_zero))
                                       (@has_zero.zero.{0} rat rat.has_zero)
                                       ((λ (a a_1 : int) (e_1 : @eq.{1} int a a_1) (a_2 a_3 : int)
                                         (e_2 : @eq.{1} int a_2 a_3),
                                           @congr.{1 1} int rat (rat.mk a) (rat.mk a_1) a_2 a_3
                                             (@congr_arg.{1 1} int (int → rat) a a_1 rat.mk e_1)
                                             e_2)
                                          n₂
                                          n₂
                                          (@eq.refl.{1} int n₂)
                                          d₂
                                          (@has_zero.zero.{0} int int.has_zero)
                                          hd)
                                       (rat.mk_zero n₂)))
                                 (@propext (@eq.{1} rat (rat.mk n₂ d₂) (@has_zero.zero.{0} rat rat.has_zero)) false
                                    (@iff_false_intro
                                       (@eq.{1} rat (rat.mk n₂ d₂) (@has_zero.zero.{0} rat rat.has_zero))
                                       (@rat.mk_ne_zero_of_ne_zero n₂ d₂ hn₂ hd₂))))
                              (@rfl.{1} rat (rat.mk n₂ d₂))))))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
p_prime : nat.prime p,
n₁ n₂ d₁ d₂ : int,
hn₁ : @ne.{1} int n₁ (@has_zero.zero.{0} int int.has_zero),
hn₂ : @ne.{1} int n₂ (@has_zero.zero.{0} int int.has_zero),
hd₁ : @ne.{1} int d₁ (@has_zero.zero.{0} int int.has_zero),
hd₂ : @ne.{1} int d₂ (@has_zero.zero.{0} int int.has_zero),
hf1 :
  @multiplicity.finite.{0} int int.comm_semiring
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
    (@has_mul.mul.{0} int int.has_mul n₁ d₂),
hf2 :
  @multiplicity.finite.{0} int int.comm_semiring
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
    (@has_mul.mul.{0} int int.has_mul n₂ d₁)
| @has_le.le.{0} int
    (@preorder.to_has_le.{0} int
       (@partial_order.to_preorder.{0} int
          (@ordered_comm_monoid.to_partial_order.{0} int
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} int
                (@ordered_comm_group.to_ordered_cancel_comm_monoid.{0} int
                   (@ordered_ring.to_ordered_comm_group.{0} int
                      (@linear_ordered_ring.to_ordered_ring.{0} int
                         (@linear_ordered_comm_ring.to_linear_ordered_ring.{0} int
                            (@decidable_linear_ordered_comm_ring.to_linear_ordered_comm_ring.{0} int
                               int.decidable_linear_ordered_comm_ring)))))))))
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
       (@roption.get.{0} nat
          (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
             n₁)
          (@iff.mpr
             (@multiplicity.finite.{0} int int.comm_semiring
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                n₁)
             (and
                (@ne.{1} nat
                   (int.nat_abs
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                   (@has_one.one.{0} nat nat.has_one))
                (@ne.{1} int n₁ (@has_zero.zero.{0} int int.has_zero)))
             (@multiplicity.finite_int_iff
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                n₁)
             (@and.intro
                (@ne.{1} nat
                   (int.nat_abs
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                   (@has_one.one.{0} nat nat.has_one))
                (@ne.{1} int n₁ (@has_zero.zero.{0} int int.has_zero))
                (@ne.symm.{1} nat (@has_one.one.{0} nat nat.has_one)
                   (int.nat_abs
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                   (@ne_of_lt.{0} nat
                      (@partial_order.to_preorder.{0} nat
                         (@ordered_comm_monoid.to_partial_order.{0} nat
                            (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                               (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
                      (@has_one.one.{0} nat nat.has_one)
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@nat.prime.one_lt p p_prime)))
                (λ (hn : @eq.{1} int n₁ (@has_zero.zero.{0} int int.has_zero)),
                   false.rec.{0} false
                     (@eq.mp.{0} (@eq.{1} rat (rat.mk n₁ d₁) (rat.mk n₁ d₁)) false
                        (@eq.trans.{1} Prop (@eq.{1} rat (rat.mk n₁ d₁) (rat.mk n₁ d₁))
                           (@eq.{1} rat (rat.mk n₁ d₁) (@has_zero.zero.{0} rat rat.has_zero))
                           false
                           ((λ (a a_1 : rat) (e_1 : @eq.{1} rat a a_1) (a_2 a_3 : rat) (e_2 : @eq.{1} rat a_2 a_3),
                               @congr.{1 1} rat Prop (@eq.{1} rat a) (@eq.{1} rat a_1) a_2 a_3
                                 (@congr_arg.{1 1} rat (rat → Prop) a a_1 (@eq.{1} rat) e_1)
                                 e_2)
                              (rat.mk n₁ d₁)
                              (rat.mk n₁ d₁)
                              (@eq.refl.{1} rat (rat.mk n₁ d₁))
                              (rat.mk n₁ d₁)
                              (@has_zero.zero.{0} rat rat.has_zero)
                              (@eq.trans.{1} rat (rat.mk n₁ d₁) (rat.mk (@has_zero.zero.{0} int int.has_zero) d₁)
                                 (@has_zero.zero.{0} rat rat.has_zero)
                                 ((λ (a a_1 : int) (e_1 : @eq.{1} int a a_1) (a_2 a_3 : int)
                                   (e_2 : @eq.{1} int a_2 a_3),
                                     @congr.{1 1} int rat (rat.mk a) (rat.mk a_1) a_2 a_3
                                       (@congr_arg.{1 1} int (int → rat) a a_1 rat.mk e_1)
                                       e_2)
                                    n₁
                                    (@has_zero.zero.{0} int int.has_zero)
                                    hn
                                    d₁
                                    d₁
                                    (@eq.refl.{1} int d₁))
                                 (rat.zero_mk d₁)))
                           (@propext (@eq.{1} rat (rat.mk n₁ d₁) (@has_zero.zero.{0} rat rat.has_zero)) false
                              (@iff_false_intro (@eq.{1} rat (rat.mk n₁ d₁) (@has_zero.zero.{0} rat rat.has_zero))
                                 (@rat.mk_ne_zero_of_ne_zero n₁ d₁ hn₁ hd₁))))
                        (@rfl.{1} rat (rat.mk n₁ d₁))))))))
    (@has_sub.sub.{0} int
       (@add_group_has_sub.{0} int (@add_comm_group.to_add_group.{0} int (@ring.to_add_comm_group.{0} int int.ring)))
       (@has_add.add.{0} int
          (@add_semigroup.to_has_add.{0} int
             (@add_monoid.to_add_semigroup.{0} int
                (@add_group.to_add_monoid.{0} int
                   (@add_comm_group.to_add_group.{0} int (@ring.to_add_comm_group.{0} int int.ring)))))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
             (@roption.get.{0} nat
                (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   d₁)
                (@iff.mpr
                   (@multiplicity.finite.{0} int int.comm_semiring
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                      d₁)
                   (and
                      (@ne.{1} nat
                         (int.nat_abs
                            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                         (@has_one.one.{0} nat nat.has_one))
                      (@ne.{1} int d₁ (@has_zero.zero.{0} int int.has_zero)))
                   (@multiplicity.finite_int_iff
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                      d₁)
                   (@and.intro
                      (@ne.{1} nat
                         (int.nat_abs
                            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                         (@has_one.one.{0} nat nat.has_one))
                      (@ne.{1} int d₁ (@has_zero.zero.{0} int int.has_zero))
                      (@ne.symm.{1} nat (@has_one.one.{0} nat nat.has_one)
                         (int.nat_abs
                            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                         (@ne_of_lt.{0} nat
                            (@partial_order.to_preorder.{0} nat
                               (@ordered_comm_monoid.to_partial_order.{0} nat
                                  (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                                     (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
                            (@has_one.one.{0} nat nat.has_one)
                            (int.nat_abs
                               (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                  p))
                            (@nat.prime.one_lt p p_prime)))
                      (λ (hd : @eq.{1} int d₁ (@has_zero.zero.{0} int int.has_zero)),
                         false.rec.{0} false
                           (@eq.mp.{0} (@eq.{1} rat (rat.mk n₁ d₁) (rat.mk n₁ d₁)) false
                              (@eq.trans.{1} Prop (@eq.{1} rat (rat.mk n₁ d₁) (rat.mk n₁ d₁))
                                 (@eq.{1} rat (rat.mk n₁ d₁) (@has_zero.zero.{0} rat rat.has_zero))
                                 false
                                 ((λ (a a_1 : rat) (e_1 : @eq.{1} rat a a_1) (a_2 a_3 : rat)
                                   (e_2 : @eq.{1} rat a_2 a_3),
                                     @congr.{1 1} rat Prop (@eq.{1} rat a) (@eq.{1} rat a_1) a_2 a_3
                                       (@congr_arg.{1 1} rat (rat → Prop) a a_1 (@eq.{1} rat) e_1)
                                       e_2)
                                    (rat.mk n₁ d₁)
                                    (rat.mk n₁ d₁)
                                    (@eq.refl.{1} rat (rat.mk n₁ d₁))
                                    (rat.mk n₁ d₁)
                                    (@has_zero.zero.{0} rat rat.has_zero)
                                    (@eq.trans.{1} rat (rat.mk n₁ d₁)
                                       (rat.mk n₁ (@has_zero.zero.{0} int int.has_zero))
                                       (@has_zero.zero.{0} rat rat.has_zero)
                                       ((λ (a a_1 : int) (e_1 : @eq.{1} int a a_1) (a_2 a_3 : int)
                                         (e_2 : @eq.{1} int a_2 a_3),
                                           @congr.{1 1} int rat (rat.mk a) (rat.mk a_1) a_2 a_3
                                             (@congr_arg.{1 1} int (int → rat) a a_1 rat.mk e_1)
                                             e_2)
                                          n₁
                                          n₁
                                          (@eq.refl.{1} int n₁)
                                          d₁
                                          (@has_zero.zero.{0} int int.has_zero)
                                          hd)
                                       (rat.mk_zero n₁)))
                                 (@propext (@eq.{1} rat (rat.mk n₁ d₁) (@has_zero.zero.{0} rat rat.has_zero)) false
                                    (@iff_false_intro
                                       (@eq.{1} rat (rat.mk n₁ d₁) (@has_zero.zero.{0} rat rat.has_zero))
                                       (@rat.mk_ne_zero_of_ne_zero n₁ d₁ hn₁ hd₁))))
                              (@rfl.{1} rat (rat.mk n₁ d₁))))))))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
             (@roption.get.{0} nat
                (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   n₂)
                (@iff.mpr
                   (@multiplicity.finite.{0} int int.comm_semiring
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                      n₂)
                   (and
                      (@ne.{1} nat
                         (int.nat_abs
                            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                         (@has_one.one.{0} nat nat.has_one))
                      (@ne.{1} int n₂ (@has_zero.zero.{0} int int.has_zero)))
                   (@multiplicity.finite_int_iff
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                      n₂)
                   (@and.intro
                      (@ne.{1} nat
                         (int.nat_abs
                            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                         (@has_one.one.{0} nat nat.has_one))
                      (@ne.{1} int n₂ (@has_zero.zero.{0} int int.has_zero))
                      (@ne.symm.{1} nat (@has_one.one.{0} nat nat.has_one)
                         (int.nat_abs
                            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                         (@ne_of_lt.{0} nat
                            (@partial_order.to_preorder.{0} nat
                               (@ordered_comm_monoid.to_partial_order.{0} nat
                                  (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                                     (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
                            (@has_one.one.{0} nat nat.has_one)
                            (int.nat_abs
                               (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                  p))
                            (@nat.prime.one_lt p p_prime)))
                      (λ (hn : @eq.{1} int n₂ (@has_zero.zero.{0} int int.has_zero)),
                         false.rec.{0} false
                           (@eq.mp.{0} (@eq.{1} rat (rat.mk n₂ d₂) (rat.mk n₂ d₂)) false
                              (@eq.trans.{1} Prop (@eq.{1} rat (rat.mk n₂ d₂) (rat.mk n₂ d₂))
                                 (@eq.{1} rat (rat.mk n₂ d₂) (@has_zero.zero.{0} rat rat.has_zero))
                                 false
                                 ((λ (a a_1 : rat) (e_1 : @eq.{1} rat a a_1) (a_2 a_3 : rat)
                                   (e_2 : @eq.{1} rat a_2 a_3),
                                     @congr.{1 1} rat Prop (@eq.{1} rat a) (@eq.{1} rat a_1) a_2 a_3
                                       (@congr_arg.{1 1} rat (rat → Prop) a a_1 (@eq.{1} rat) e_1)
                                       e_2)
                                    (rat.mk n₂ d₂)
                                    (rat.mk n₂ d₂)
                                    (@eq.refl.{1} rat (rat.mk n₂ d₂))
                                    (rat.mk n₂ d₂)
                                    (@has_zero.zero.{0} rat rat.has_zero)
                                    (@eq.trans.{1} rat (rat.mk n₂ d₂)
                                       (rat.mk (@has_zero.zero.{0} int int.has_zero) d₂)
                                       (@has_zero.zero.{0} rat rat.has_zero)
                                       ((λ (a a_1 : int) (e_1 : @eq.{1} int a a_1) (a_2 a_3 : int)
                                         (e_2 : @eq.{1} int a_2 a_3),
                                           @congr.{1 1} int rat (rat.mk a) (rat.mk a_1) a_2 a_3
                                             (@congr_arg.{1 1} int (int → rat) a a_1 rat.mk e_1)
                                             e_2)
                                          n₂
                                          (@has_zero.zero.{0} int int.has_zero)
                                          hn
                                          d₂
                                          d₂
                                          (@eq.refl.{1} int d₂))
                                       (rat.zero_mk d₂)))
                                 (@propext (@eq.{1} rat (rat.mk n₂ d₂) (@has_zero.zero.{0} rat rat.has_zero)) false
                                    (@iff_false_intro
                                       (@eq.{1} rat (rat.mk n₂ d₂) (@has_zero.zero.{0} rat rat.has_zero))
                                       (@rat.mk_ne_zero_of_ne_zero n₂ d₂ hn₂ hd₂))))
                              (@rfl.{1} rat (rat.mk n₂ d₂)))))))))
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
          (@roption.get.{0} nat
             (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                d₂)
             (@iff.mpr
                (@multiplicity.finite.{0} int int.comm_semiring
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   d₂)
                (and
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int d₂ (@has_zero.zero.{0} int int.has_zero)))
                (@multiplicity.finite_int_iff
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   d₂)
                (@and.intro
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int d₂ (@has_zero.zero.{0} int int.has_zero))
                   (@ne.symm.{1} nat (@has_one.one.{0} nat nat.has_one)
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@ne_of_lt.{0} nat
                         (@partial_order.to_preorder.{0} nat
                            (@ordered_comm_monoid.to_partial_order.{0} nat
                               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
                         (@has_one.one.{0} nat nat.has_one)
                         (int.nat_abs
                            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                         (@nat.prime.one_lt p p_prime)))
                   (λ (hd : @eq.{1} int d₂ (@has_zero.zero.{0} int int.has_zero)),
                      false.rec.{0} false
                        (@eq.mp.{0} (@eq.{1} rat (rat.mk n₂ d₂) (rat.mk n₂ d₂)) false
                           (@eq.trans.{1} Prop (@eq.{1} rat (rat.mk n₂ d₂) (rat.mk n₂ d₂))
                              (@eq.{1} rat (rat.mk n₂ d₂) (@has_zero.zero.{0} rat rat.has_zero))
                              false
                              ((λ (a a_1 : rat) (e_1 : @eq.{1} rat a a_1) (a_2 a_3 : rat) (e_2 : @eq.{1} rat a_2 a_3),
                                  @congr.{1 1} rat Prop (@eq.{1} rat a) (@eq.{1} rat a_1) a_2 a_3
                                    (@congr_arg.{1 1} rat (rat → Prop) a a_1 (@eq.{1} rat) e_1)
                                    e_2)
                                 (rat.mk n₂ d₂)
                                 (rat.mk n₂ d₂)
                                 (@eq.refl.{1} rat (rat.mk n₂ d₂))
                                 (rat.mk n₂ d₂)
                                 (@has_zero.zero.{0} rat rat.has_zero)
                                 (@eq.trans.{1} rat (rat.mk n₂ d₂)
                                    (rat.mk n₂ (@has_zero.zero.{0} int int.has_zero))
                                    (@has_zero.zero.{0} rat rat.has_zero)
                                    ((λ (a a_1 : int) (e_1 : @eq.{1} int a a_1) (a_2 a_3 : int)
                                      (e_2 : @eq.{1} int a_2 a_3),
                                        @congr.{1 1} int rat (rat.mk a) (rat.mk a_1) a_2 a_3
                                          (@congr_arg.{1 1} int (int → rat) a a_1 rat.mk e_1)
                                          e_2)
                                       n₂
                                       n₂
                                       (@eq.refl.{1} int n₂)
                                       d₂
                                       (@has_zero.zero.{0} int int.has_zero)
                                       hd)
                                    (rat.mk_zero n₂)))
                              (@propext (@eq.{1} rat (rat.mk n₂ d₂) (@has_zero.zero.{0} rat rat.has_zero)) false
                                 (@iff_false_intro
                                    (@eq.{1} rat (rat.mk n₂ d₂) (@has_zero.zero.{0} rat rat.has_zero))
                                    (@rat.mk_ne_zero_of_ne_zero n₂ d₂ hn₂ hd₂))))
                           (@rfl.{1} rat (rat.mk n₂ d₂)))))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>202        le_sub_iff_add_le],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='le_sub_iff_add_le'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/ordered_group.lean&#x27;, &#x27;line&#x27;: 589, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : ordered_comm_group.{0} α] {a b c : α}, iff (@has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@ordered_comm_monoid.to_partial_order.{0} α (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} α (@ordered_comm_group.to_ordered_cancel_comm_monoid.{0} α _inst_1))))) a (@has_sub.sub.{0} α (@add_group_has_sub.{0} α (@add_comm_group.to_add_group.{0} α (@ordered_comm_group.to_add_comm_group.{0} α _inst_1))) c b)) (@has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@ordered_comm_monoid.to_partial_order.{0} α (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} α (@ordered_comm_group.to_ordered_cancel_comm_monoid.{0} α _inst_1))))) (@has_add.add.{0} α (@add_semigroup.to_has_add.{0} α (@add_monoid.to_add_semigroup.{0} α (@add_group.to_add_monoid.{0} α (@add_comm_group.to_add_group.{0} α (@ordered_comm_group.to_add_comm_group.{0} α _inst_1))))) a b) c)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit name (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.ident)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) (lean.parser.pexpr std.prec.max))) → conv.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='conv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;(at id)?&#x27;, &#x27;(in expr)?&#x27;, &#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
p_prime : nat.prime p,
n₁ n₂ d₁ d₂ : int,
hn₁ : @ne.{1} int n₁ (@has_zero.zero.{0} int int.has_zero),
hn₂ : @ne.{1} int n₂ (@has_zero.zero.{0} int int.has_zero),
hd₁ : @ne.{1} int d₁ (@has_zero.zero.{0} int int.has_zero),
hd₂ : @ne.{1} int d₂ (@has_zero.zero.{0} int int.has_zero),
hf1 :
  @multiplicity.finite.{0} int int.comm_semiring
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
    (@has_mul.mul.{0} int int.has_mul n₁ d₂),
hf2 :
  @multiplicity.finite.{0} int int.comm_semiring
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
    (@has_mul.mul.{0} int int.has_mul n₂ d₁)
| @has_le.le.{0} int
    (@preorder.to_has_le.{0} int
       (@partial_order.to_preorder.{0} int
          (@ordered_comm_monoid.to_partial_order.{0} int
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} int
                (@ordered_comm_group.to_ordered_cancel_comm_monoid.{0} int
                   (@ordered_ring.to_ordered_comm_group.{0} int
                      (@linear_ordered_ring.to_ordered_ring.{0} int
                         (@linear_ordered_comm_ring.to_linear_ordered_ring.{0} int
                            (@decidable_linear_ordered_comm_ring.to_linear_ordered_comm_ring.{0} int
                               int.decidable_linear_ordered_comm_ring)))))))))
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
       (@roption.get.{0} nat
          (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
             n₁)
          (@iff.mpr
             (@multiplicity.finite.{0} int int.comm_semiring
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                n₁)
             (and
                (@ne.{1} nat
                   (int.nat_abs
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                   (@has_one.one.{0} nat nat.has_one))
                (@ne.{1} int n₁ (@has_zero.zero.{0} int int.has_zero)))
             (@multiplicity.finite_int_iff
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                n₁)
             (@and.intro
                (@ne.{1} nat
                   (int.nat_abs
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                   (@has_one.one.{0} nat nat.has_one))
                (@ne.{1} int n₁ (@has_zero.zero.{0} int int.has_zero))
                (@ne.symm.{1} nat (@has_one.one.{0} nat nat.has_one)
                   (int.nat_abs
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                   (@ne_of_lt.{0} nat
                      (@partial_order.to_preorder.{0} nat
                         (@ordered_comm_monoid.to_partial_order.{0} nat
                            (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                               (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
                      (@has_one.one.{0} nat nat.has_one)
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@nat.prime.one_lt p p_prime)))
                (λ (hn : @eq.{1} int n₁ (@has_zero.zero.{0} int int.has_zero)),
                   false.rec.{0} false
                     (@eq.mp.{0} (@eq.{1} rat (rat.mk n₁ d₁) (rat.mk n₁ d₁)) false
                        (@eq.trans.{1} Prop (@eq.{1} rat (rat.mk n₁ d₁) (rat.mk n₁ d₁))
                           (@eq.{1} rat (rat.mk n₁ d₁) (@has_zero.zero.{0} rat rat.has_zero))
                           false
                           ((λ (a a_1 : rat) (e_1 : @eq.{1} rat a a_1) (a_2 a_3 : rat) (e_2 : @eq.{1} rat a_2 a_3),
                               @congr.{1 1} rat Prop (@eq.{1} rat a) (@eq.{1} rat a_1) a_2 a_3
                                 (@congr_arg.{1 1} rat (rat → Prop) a a_1 (@eq.{1} rat) e_1)
                                 e_2)
                              (rat.mk n₁ d₁)
                              (rat.mk n₁ d₁)
                              (@eq.refl.{1} rat (rat.mk n₁ d₁))
                              (rat.mk n₁ d₁)
                              (@has_zero.zero.{0} rat rat.has_zero)
                              (@eq.trans.{1} rat (rat.mk n₁ d₁) (rat.mk (@has_zero.zero.{0} int int.has_zero) d₁)
                                 (@has_zero.zero.{0} rat rat.has_zero)
                                 ((λ (a a_1 : int) (e_1 : @eq.{1} int a a_1) (a_2 a_3 : int)
                                   (e_2 : @eq.{1} int a_2 a_3),
                                     @congr.{1 1} int rat (rat.mk a) (rat.mk a_1) a_2 a_3
                                       (@congr_arg.{1 1} int (int → rat) a a_1 rat.mk e_1)
                                       e_2)
                                    n₁
                                    (@has_zero.zero.{0} int int.has_zero)
                                    hn
                                    d₁
                                    d₁
                                    (@eq.refl.{1} int d₁))
                                 (rat.zero_mk d₁)))
                           (@propext (@eq.{1} rat (rat.mk n₁ d₁) (@has_zero.zero.{0} rat rat.has_zero)) false
                              (@iff_false_intro (@eq.{1} rat (rat.mk n₁ d₁) (@has_zero.zero.{0} rat rat.has_zero))
                                 (@rat.mk_ne_zero_of_ne_zero n₁ d₁ hn₁ hd₁))))
                        (@rfl.{1} rat (rat.mk n₁ d₁))))))))
    (@has_sub.sub.{0} int
       (@add_group_has_sub.{0} int (@add_comm_group.to_add_group.{0} int (@ring.to_add_comm_group.{0} int int.ring)))
       (@has_add.add.{0} int
          (@add_semigroup.to_has_add.{0} int
             (@add_monoid.to_add_semigroup.{0} int
                (@add_group.to_add_monoid.{0} int
                   (@add_comm_group.to_add_group.{0} int (@ring.to_add_comm_group.{0} int int.ring)))))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
             (@roption.get.{0} nat
                (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   d₁)
                (@iff.mpr
                   (@multiplicity.finite.{0} int int.comm_semiring
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                      d₁)
                   (and
                      (@ne.{1} nat
                         (int.nat_abs
                            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                         (@has_one.one.{0} nat nat.has_one))
                      (@ne.{1} int d₁ (@has_zero.zero.{0} int int.has_zero)))
                   (@multiplicity.finite_int_iff
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                      d₁)
                   (@and.intro
                      (@ne.{1} nat
                         (int.nat_abs
                            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                         (@has_one.one.{0} nat nat.has_one))
                      (@ne.{1} int d₁ (@has_zero.zero.{0} int int.has_zero))
                      (@ne.symm.{1} nat (@has_one.one.{0} nat nat.has_one)
                         (int.nat_abs
                            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                         (@ne_of_lt.{0} nat
                            (@partial_order.to_preorder.{0} nat
                               (@ordered_comm_monoid.to_partial_order.{0} nat
                                  (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                                     (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
                            (@has_one.one.{0} nat nat.has_one)
                            (int.nat_abs
                               (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                  p))
                            (@nat.prime.one_lt p p_prime)))
                      (λ (hd : @eq.{1} int d₁ (@has_zero.zero.{0} int int.has_zero)),
                         false.rec.{0} false
                           (@eq.mp.{0} (@eq.{1} rat (rat.mk n₁ d₁) (rat.mk n₁ d₁)) false
                              (@eq.trans.{1} Prop (@eq.{1} rat (rat.mk n₁ d₁) (rat.mk n₁ d₁))
                                 (@eq.{1} rat (rat.mk n₁ d₁) (@has_zero.zero.{0} rat rat.has_zero))
                                 false
                                 ((λ (a a_1 : rat) (e_1 : @eq.{1} rat a a_1) (a_2 a_3 : rat)
                                   (e_2 : @eq.{1} rat a_2 a_3),
                                     @congr.{1 1} rat Prop (@eq.{1} rat a) (@eq.{1} rat a_1) a_2 a_3
                                       (@congr_arg.{1 1} rat (rat → Prop) a a_1 (@eq.{1} rat) e_1)
                                       e_2)
                                    (rat.mk n₁ d₁)
                                    (rat.mk n₁ d₁)
                                    (@eq.refl.{1} rat (rat.mk n₁ d₁))
                                    (rat.mk n₁ d₁)
                                    (@has_zero.zero.{0} rat rat.has_zero)
                                    (@eq.trans.{1} rat (rat.mk n₁ d₁)
                                       (rat.mk n₁ (@has_zero.zero.{0} int int.has_zero))
                                       (@has_zero.zero.{0} rat rat.has_zero)
                                       ((λ (a a_1 : int) (e_1 : @eq.{1} int a a_1) (a_2 a_3 : int)
                                         (e_2 : @eq.{1} int a_2 a_3),
                                           @congr.{1 1} int rat (rat.mk a) (rat.mk a_1) a_2 a_3
                                             (@congr_arg.{1 1} int (int → rat) a a_1 rat.mk e_1)
                                             e_2)
                                          n₁
                                          n₁
                                          (@eq.refl.{1} int n₁)
                                          d₁
                                          (@has_zero.zero.{0} int int.has_zero)
                                          hd)
                                       (rat.mk_zero n₁)))
                                 (@propext (@eq.{1} rat (rat.mk n₁ d₁) (@has_zero.zero.{0} rat rat.has_zero)) false
                                    (@iff_false_intro
                                       (@eq.{1} rat (rat.mk n₁ d₁) (@has_zero.zero.{0} rat rat.has_zero))
                                       (@rat.mk_ne_zero_of_ne_zero n₁ d₁ hn₁ hd₁))))
                              (@rfl.{1} rat (rat.mk n₁ d₁))))))))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
             (@roption.get.{0} nat
                (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   n₂)
                (@iff.mpr
                   (@multiplicity.finite.{0} int int.comm_semiring
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                      n₂)
                   (and
                      (@ne.{1} nat
                         (int.nat_abs
                            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                         (@has_one.one.{0} nat nat.has_one))
                      (@ne.{1} int n₂ (@has_zero.zero.{0} int int.has_zero)))
                   (@multiplicity.finite_int_iff
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                      n₂)
                   (@and.intro
                      (@ne.{1} nat
                         (int.nat_abs
                            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                         (@has_one.one.{0} nat nat.has_one))
                      (@ne.{1} int n₂ (@has_zero.zero.{0} int int.has_zero))
                      (@ne.symm.{1} nat (@has_one.one.{0} nat nat.has_one)
                         (int.nat_abs
                            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                         (@ne_of_lt.{0} nat
                            (@partial_order.to_preorder.{0} nat
                               (@ordered_comm_monoid.to_partial_order.{0} nat
                                  (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                                     (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
                            (@has_one.one.{0} nat nat.has_one)
                            (int.nat_abs
                               (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
                                  p))
                            (@nat.prime.one_lt p p_prime)))
                      (λ (hn : @eq.{1} int n₂ (@has_zero.zero.{0} int int.has_zero)),
                         false.rec.{0} false
                           (@eq.mp.{0} (@eq.{1} rat (rat.mk n₂ d₂) (rat.mk n₂ d₂)) false
                              (@eq.trans.{1} Prop (@eq.{1} rat (rat.mk n₂ d₂) (rat.mk n₂ d₂))
                                 (@eq.{1} rat (rat.mk n₂ d₂) (@has_zero.zero.{0} rat rat.has_zero))
                                 false
                                 ((λ (a a_1 : rat) (e_1 : @eq.{1} rat a a_1) (a_2 a_3 : rat)
                                   (e_2 : @eq.{1} rat a_2 a_3),
                                     @congr.{1 1} rat Prop (@eq.{1} rat a) (@eq.{1} rat a_1) a_2 a_3
                                       (@congr_arg.{1 1} rat (rat → Prop) a a_1 (@eq.{1} rat) e_1)
                                       e_2)
                                    (rat.mk n₂ d₂)
                                    (rat.mk n₂ d₂)
                                    (@eq.refl.{1} rat (rat.mk n₂ d₂))
                                    (rat.mk n₂ d₂)
                                    (@has_zero.zero.{0} rat rat.has_zero)
                                    (@eq.trans.{1} rat (rat.mk n₂ d₂)
                                       (rat.mk (@has_zero.zero.{0} int int.has_zero) d₂)
                                       (@has_zero.zero.{0} rat rat.has_zero)
                                       ((λ (a a_1 : int) (e_1 : @eq.{1} int a a_1) (a_2 a_3 : int)
                                         (e_2 : @eq.{1} int a_2 a_3),
                                           @congr.{1 1} int rat (rat.mk a) (rat.mk a_1) a_2 a_3
                                             (@congr_arg.{1 1} int (int → rat) a a_1 rat.mk e_1)
                                             e_2)
                                          n₂
                                          (@has_zero.zero.{0} int int.has_zero)
                                          hn
                                          d₂
                                          d₂
                                          (@eq.refl.{1} int d₂))
                                       (rat.zero_mk d₂)))
                                 (@propext (@eq.{1} rat (rat.mk n₂ d₂) (@has_zero.zero.{0} rat rat.has_zero)) false
                                    (@iff_false_intro
                                       (@eq.{1} rat (rat.mk n₂ d₂) (@has_zero.zero.{0} rat rat.has_zero))
                                       (@rat.mk_ne_zero_of_ne_zero n₂ d₂ hn₂ hd₂))))
                              (@rfl.{1} rat (rat.mk n₂ d₂)))))))))
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
          (@roption.get.{0} nat
             (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                d₂)
             (@iff.mpr
                (@multiplicity.finite.{0} int int.comm_semiring
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   d₂)
                (and
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int d₂ (@has_zero.zero.{0} int int.has_zero)))
                (@multiplicity.finite_int_iff
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   d₂)
                (@and.intro
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int d₂ (@has_zero.zero.{0} int int.has_zero))
                   (@ne.symm.{1} nat (@has_one.one.{0} nat nat.has_one)
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@ne_of_lt.{0} nat
                         (@partial_order.to_preorder.{0} nat
                            (@ordered_comm_monoid.to_partial_order.{0} nat
                               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
                         (@has_one.one.{0} nat nat.has_one)
                         (int.nat_abs
                            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                         (@nat.prime.one_lt p p_prime)))
                   (λ (hd : @eq.{1} int d₂ (@has_zero.zero.{0} int int.has_zero)),
                      false.rec.{0} false
                        (@eq.mp.{0} (@eq.{1} rat (rat.mk n₂ d₂) (rat.mk n₂ d₂)) false
                           (@eq.trans.{1} Prop (@eq.{1} rat (rat.mk n₂ d₂) (rat.mk n₂ d₂))
                              (@eq.{1} rat (rat.mk n₂ d₂) (@has_zero.zero.{0} rat rat.has_zero))
                              false
                              ((λ (a a_1 : rat) (e_1 : @eq.{1} rat a a_1) (a_2 a_3 : rat) (e_2 : @eq.{1} rat a_2 a_3),
                                  @congr.{1 1} rat Prop (@eq.{1} rat a) (@eq.{1} rat a_1) a_2 a_3
                                    (@congr_arg.{1 1} rat (rat → Prop) a a_1 (@eq.{1} rat) e_1)
                                    e_2)
                                 (rat.mk n₂ d₂)
                                 (rat.mk n₂ d₂)
                                 (@eq.refl.{1} rat (rat.mk n₂ d₂))
                                 (rat.mk n₂ d₂)
                                 (@has_zero.zero.{0} rat rat.has_zero)
                                 (@eq.trans.{1} rat (rat.mk n₂ d₂)
                                    (rat.mk n₂ (@has_zero.zero.{0} int int.has_zero))
                                    (@has_zero.zero.{0} rat rat.has_zero)
                                    ((λ (a a_1 : int) (e_1 : @eq.{1} int a a_1) (a_2 a_3 : int)
                                      (e_2 : @eq.{1} int a_2 a_3),
                                        @congr.{1 1} int rat (rat.mk a) (rat.mk a_1) a_2 a_3
                                          (@congr_arg.{1 1} int (int → rat) a a_1 rat.mk e_1)
                                          e_2)
                                       n₂
                                       n₂
                                       (@eq.refl.{1} int n₂)
                                       d₂
                                       (@has_zero.zero.{0} int int.has_zero)
                                       hd)
                                    (rat.mk_zero n₂)))
                              (@propext (@eq.{1} rat (rat.mk n₂ d₂) (@has_zero.zero.{0} rat rat.has_zero)) false
                                 (@iff_false_intro
                                    (@eq.{1} rat (rat.mk n₂ d₂) (@has_zero.zero.{0} rat rat.has_zero))
                                    (@rat.mk_ne_zero_of_ne_zero n₂ d₂ hn₂ hd₂))))
                           (@rfl.{1} rat (rat.mk n₂ d₂)))))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='lime'><a title='p : nat,
p_prime : nat.prime p,
n₁ n₂ d₁ d₂ : int,
hn₁ : @ne.{1} int n₁ (@has_zero.zero.{0} int int.has_zero),
hn₂ : @ne.{1} int n₂ (@has_zero.zero.{0} int int.has_zero),
hd₁ : @ne.{1} int d₁ (@has_zero.zero.{0} int int.has_zero),
hd₂ : @ne.{1} int d₂ (@has_zero.zero.{0} int int.has_zero),
hf1 :
  @multiplicity.finite.{0} int int.comm_semiring
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
    (@has_mul.mul.{0} int int.has_mul n₁ d₂),
hf2 :
  @multiplicity.finite.{0} int int.comm_semiring
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
    (@has_mul.mul.{0} int int.has_mul n₂ d₁)
| @has_le.le.{0} int
    (@preorder.to_has_le.{0} int
       (@partial_order.to_preorder.{0} int
          (@ordered_comm_monoid.to_partial_order.{0} int
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} int
                (@ordered_comm_group.to_ordered_cancel_comm_monoid.{0} int
                   (@ordered_ring.to_ordered_comm_group.{0} int
                      (@linear_ordered_ring.to_ordered_ring.{0} int
                         (@linear_ordered_comm_ring.to_linear_ordered_ring.{0} int
                            (@decidable_linear_ordered_comm_ring.to_linear_ordered_comm_ring.{0} int
                               int.decidable_linear_ordered_comm_ring)))))))))
    (@has_add.add.{0} int
       (@add_semigroup.to_has_add.{0} int
          (@add_monoid.to_add_semigroup.{0} int
             (@add_group.to_add_monoid.{0} int
                (@add_comm_group.to_add_group.{0} int
                   (@ordered_comm_group.to_add_comm_group.{0} int
                      (@ordered_ring.to_ordered_comm_group.{0} int
                         (@linear_ordered_ring.to_ordered_ring.{0} int
                            (@linear_ordered_comm_ring.to_linear_ordered_ring.{0} int
                               (@decidable_linear_ordered_comm_ring.to_linear_ordered_comm_ring.{0} int
                                  int.decidable_linear_ordered_comm_ring)))))))))
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
          (@roption.get.{0} nat
             (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                n₁)
             (@iff.mpr
                (@multiplicity.finite.{0} int int.comm_semiring
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   n₁)
                (and
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int n₁ (@has_zero.zero.{0} int int.has_zero)))
                (@multiplicity.finite_int_iff
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   n₁)
                (@and.intro
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int n₁ (@has_zero.zero.{0} int int.has_zero))
                   (@ne.symm.{1} nat (@has_one.one.{0} nat nat.has_one)
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@ne_of_lt.{0} nat
                         (@partial_order.to_preorder.{0} nat
                            (@ordered_comm_monoid.to_partial_order.{0} nat
                               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
                         (@has_one.one.{0} nat nat.has_one)
                         (int.nat_abs
                            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                         (@nat.prime.one_lt p p_prime)))
                   (λ (hn : @eq.{1} int n₁ (@has_zero.zero.{0} int int.has_zero)),
                      false.rec.{0} false
                        (@eq.mp.{0} (@eq.{1} rat (rat.mk n₁ d₁) (rat.mk n₁ d₁)) false
                           (@eq.trans.{1} Prop (@eq.{1} rat (rat.mk n₁ d₁) (rat.mk n₁ d₁))
                              (@eq.{1} rat (rat.mk n₁ d₁) (@has_zero.zero.{0} rat rat.has_zero))
                              false
                              ((λ (a a_1 : rat) (e_1 : @eq.{1} rat a a_1) (a_2 a_3 : rat) (e_2 : @eq.{1} rat a_2 a_3),
                                  @congr.{1 1} rat Prop (@eq.{1} rat a) (@eq.{1} rat a_1) a_2 a_3
                                    (@congr_arg.{1 1} rat (rat → Prop) a a_1 (@eq.{1} rat) e_1)
                                    e_2)
                                 (rat.mk n₁ d₁)
                                 (rat.mk n₁ d₁)
                                 (@eq.refl.{1} rat (rat.mk n₁ d₁))
                                 (rat.mk n₁ d₁)
                                 (@has_zero.zero.{0} rat rat.has_zero)
                                 (@eq.trans.{1} rat (rat.mk n₁ d₁)
                                    (rat.mk (@has_zero.zero.{0} int int.has_zero) d₁)
                                    (@has_zero.zero.{0} rat rat.has_zero)
                                    ((λ (a a_1 : int) (e_1 : @eq.{1} int a a_1) (a_2 a_3 : int)
                                      (e_2 : @eq.{1} int a_2 a_3),
                                        @congr.{1 1} int rat (rat.mk a) (rat.mk a_1) a_2 a_3
                                          (@congr_arg.{1 1} int (int → rat) a a_1 rat.mk e_1)
                                          e_2)
                                       n₁
                                       (@has_zero.zero.{0} int int.has_zero)
                                       hn
                                       d₁
                                       d₁
                                       (@eq.refl.{1} int d₁))
                                    (rat.zero_mk d₁)))
                              (@propext (@eq.{1} rat (rat.mk n₁ d₁) (@has_zero.zero.{0} rat rat.has_zero)) false
                                 (@iff_false_intro
                                    (@eq.{1} rat (rat.mk n₁ d₁) (@has_zero.zero.{0} rat rat.has_zero))
                                    (@rat.mk_ne_zero_of_ne_zero n₁ d₁ hn₁ hd₁))))
                           (@rfl.{1} rat (rat.mk n₁ d₁))))))))
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
          (@roption.get.{0} nat
             (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                d₂)
             (@iff.mpr
                (@multiplicity.finite.{0} int int.comm_semiring
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   d₂)
                (and
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int d₂ (@has_zero.zero.{0} int int.has_zero)))
                (@multiplicity.finite_int_iff
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   d₂)
                (@and.intro
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int d₂ (@has_zero.zero.{0} int int.has_zero))
                   (@ne.symm.{1} nat (@has_one.one.{0} nat nat.has_one)
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@ne_of_lt.{0} nat
                         (@partial_order.to_preorder.{0} nat
                            (@ordered_comm_monoid.to_partial_order.{0} nat
                               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
                         (@has_one.one.{0} nat nat.has_one)
                         (int.nat_abs
                            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                         (@nat.prime.one_lt p p_prime)))
                   (λ (hd : @eq.{1} int d₂ (@has_zero.zero.{0} int int.has_zero)),
                      false.rec.{0} false
                        (@eq.mp.{0} (@eq.{1} rat (rat.mk n₂ d₂) (rat.mk n₂ d₂)) false
                           (@eq.trans.{1} Prop (@eq.{1} rat (rat.mk n₂ d₂) (rat.mk n₂ d₂))
                              (@eq.{1} rat (rat.mk n₂ d₂) (@has_zero.zero.{0} rat rat.has_zero))
                              false
                              ((λ (a a_1 : rat) (e_1 : @eq.{1} rat a a_1) (a_2 a_3 : rat) (e_2 : @eq.{1} rat a_2 a_3),
                                  @congr.{1 1} rat Prop (@eq.{1} rat a) (@eq.{1} rat a_1) a_2 a_3
                                    (@congr_arg.{1 1} rat (rat → Prop) a a_1 (@eq.{1} rat) e_1)
                                    e_2)
                                 (rat.mk n₂ d₂)
                                 (rat.mk n₂ d₂)
                                 (@eq.refl.{1} rat (rat.mk n₂ d₂))
                                 (rat.mk n₂ d₂)
                                 (@has_zero.zero.{0} rat rat.has_zero)
                                 (@eq.trans.{1} rat (rat.mk n₂ d₂)
                                    (rat.mk n₂ (@has_zero.zero.{0} int int.has_zero))
                                    (@has_zero.zero.{0} rat rat.has_zero)
                                    ((λ (a a_1 : int) (e_1 : @eq.{1} int a a_1) (a_2 a_3 : int)
                                      (e_2 : @eq.{1} int a_2 a_3),
                                        @congr.{1 1} int rat (rat.mk a) (rat.mk a_1) a_2 a_3
                                          (@congr_arg.{1 1} int (int → rat) a a_1 rat.mk e_1)
                                          e_2)
                                       n₂
                                       n₂
                                       (@eq.refl.{1} int n₂)
                                       d₂
                                       (@has_zero.zero.{0} int int.has_zero)
                                       hd)
                                    (rat.mk_zero n₂)))
                              (@propext (@eq.{1} rat (rat.mk n₂ d₂) (@has_zero.zero.{0} rat rat.has_zero)) false
                                 (@iff_false_intro
                                    (@eq.{1} rat (rat.mk n₂ d₂) (@has_zero.zero.{0} rat rat.has_zero))
                                    (@rat.mk_ne_zero_of_ne_zero n₂ d₂ hn₂ hd₂))))
                           (@rfl.{1} rat (rat.mk n₂ d₂)))))))))
    (@has_add.add.{0} int
       (@add_semigroup.to_has_add.{0} int
          (@add_monoid.to_add_semigroup.{0} int
             (@add_group.to_add_monoid.{0} int
                (@add_comm_group.to_add_group.{0} int (@ring.to_add_comm_group.{0} int int.ring)))))
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
          (@roption.get.{0} nat
             (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                d₁)
             (@iff.mpr
                (@multiplicity.finite.{0} int int.comm_semiring
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   d₁)
                (and
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int d₁ (@has_zero.zero.{0} int int.has_zero)))
                (@multiplicity.finite_int_iff
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   d₁)
                (@and.intro
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int d₁ (@has_zero.zero.{0} int int.has_zero))
                   (@ne.symm.{1} nat (@has_one.one.{0} nat nat.has_one)
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@ne_of_lt.{0} nat
                         (@partial_order.to_preorder.{0} nat
                            (@ordered_comm_monoid.to_partial_order.{0} nat
                               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
                         (@has_one.one.{0} nat nat.has_one)
                         (int.nat_abs
                            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                         (@nat.prime.one_lt p p_prime)))
                   (λ (hd : @eq.{1} int d₁ (@has_zero.zero.{0} int int.has_zero)),
                      false.rec.{0} false
                        (@eq.mp.{0} (@eq.{1} rat (rat.mk n₁ d₁) (rat.mk n₁ d₁)) false
                           (@eq.trans.{1} Prop (@eq.{1} rat (rat.mk n₁ d₁) (rat.mk n₁ d₁))
                              (@eq.{1} rat (rat.mk n₁ d₁) (@has_zero.zero.{0} rat rat.has_zero))
                              false
                              ((λ (a a_1 : rat) (e_1 : @eq.{1} rat a a_1) (a_2 a_3 : rat) (e_2 : @eq.{1} rat a_2 a_3),
                                  @congr.{1 1} rat Prop (@eq.{1} rat a) (@eq.{1} rat a_1) a_2 a_3
                                    (@congr_arg.{1 1} rat (rat → Prop) a a_1 (@eq.{1} rat) e_1)
                                    e_2)
                                 (rat.mk n₁ d₁)
                                 (rat.mk n₁ d₁)
                                 (@eq.refl.{1} rat (rat.mk n₁ d₁))
                                 (rat.mk n₁ d₁)
                                 (@has_zero.zero.{0} rat rat.has_zero)
                                 (@eq.trans.{1} rat (rat.mk n₁ d₁)
                                    (rat.mk n₁ (@has_zero.zero.{0} int int.has_zero))
                                    (@has_zero.zero.{0} rat rat.has_zero)
                                    ((λ (a a_1 : int) (e_1 : @eq.{1} int a a_1) (a_2 a_3 : int)
                                      (e_2 : @eq.{1} int a_2 a_3),
                                        @congr.{1 1} int rat (rat.mk a) (rat.mk a_1) a_2 a_3
                                          (@congr_arg.{1 1} int (int → rat) a a_1 rat.mk e_1)
                                          e_2)
                                       n₁
                                       n₁
                                       (@eq.refl.{1} int n₁)
                                       d₁
                                       (@has_zero.zero.{0} int int.has_zero)
                                       hd)
                                    (rat.mk_zero n₁)))
                              (@propext (@eq.{1} rat (rat.mk n₁ d₁) (@has_zero.zero.{0} rat rat.has_zero)) false
                                 (@iff_false_intro
                                    (@eq.{1} rat (rat.mk n₁ d₁) (@has_zero.zero.{0} rat rat.has_zero))
                                    (@rat.mk_ne_zero_of_ne_zero n₁ d₁ hn₁ hd₁))))
                           (@rfl.{1} rat (rat.mk n₁ d₁))))))))
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
          (@roption.get.{0} nat
             (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                n₂)
             (@iff.mpr
                (@multiplicity.finite.{0} int int.comm_semiring
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   n₂)
                (and
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int n₂ (@has_zero.zero.{0} int int.has_zero)))
                (@multiplicity.finite_int_iff
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   n₂)
                (@and.intro
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int n₂ (@has_zero.zero.{0} int int.has_zero))
                   (@ne.symm.{1} nat (@has_one.one.{0} nat nat.has_one)
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@ne_of_lt.{0} nat
                         (@partial_order.to_preorder.{0} nat
                            (@ordered_comm_monoid.to_partial_order.{0} nat
                               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
                         (@has_one.one.{0} nat nat.has_one)
                         (int.nat_abs
                            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                         (@nat.prime.one_lt p p_prime)))
                   (λ (hn : @eq.{1} int n₂ (@has_zero.zero.{0} int int.has_zero)),
                      false.rec.{0} false
                        (@eq.mp.{0} (@eq.{1} rat (rat.mk n₂ d₂) (rat.mk n₂ d₂)) false
                           (@eq.trans.{1} Prop (@eq.{1} rat (rat.mk n₂ d₂) (rat.mk n₂ d₂))
                              (@eq.{1} rat (rat.mk n₂ d₂) (@has_zero.zero.{0} rat rat.has_zero))
                              false
                              ((λ (a a_1 : rat) (e_1 : @eq.{1} rat a a_1) (a_2 a_3 : rat) (e_2 : @eq.{1} rat a_2 a_3),
                                  @congr.{1 1} rat Prop (@eq.{1} rat a) (@eq.{1} rat a_1) a_2 a_3
                                    (@congr_arg.{1 1} rat (rat → Prop) a a_1 (@eq.{1} rat) e_1)
                                    e_2)
                                 (rat.mk n₂ d₂)
                                 (rat.mk n₂ d₂)
                                 (@eq.refl.{1} rat (rat.mk n₂ d₂))
                                 (rat.mk n₂ d₂)
                                 (@has_zero.zero.{0} rat rat.has_zero)
                                 (@eq.trans.{1} rat (rat.mk n₂ d₂)
                                    (rat.mk (@has_zero.zero.{0} int int.has_zero) d₂)
                                    (@has_zero.zero.{0} rat rat.has_zero)
                                    ((λ (a a_1 : int) (e_1 : @eq.{1} int a a_1) (a_2 a_3 : int)
                                      (e_2 : @eq.{1} int a_2 a_3),
                                        @congr.{1 1} int rat (rat.mk a) (rat.mk a_1) a_2 a_3
                                          (@congr_arg.{1 1} int (int → rat) a a_1 rat.mk e_1)
                                          e_2)
                                       n₂
                                       (@has_zero.zero.{0} int int.has_zero)
                                       hn
                                       d₂
                                       d₂
                                       (@eq.refl.{1} int d₂))
                                    (rat.zero_mk d₂)))
                              (@propext (@eq.{1} rat (rat.mk n₂ d₂) (@has_zero.zero.{0} rat rat.has_zero)) false
                                 (@iff_false_intro
                                    (@eq.{1} rat (rat.mk n₂ d₂) (@has_zero.zero.{0} rat rat.has_zero))
                                    (@rat.mk_ne_zero_of_ne_zero n₂ d₂ hn₂ hd₂))))
                           (@rfl.{1} rat (rat.mk n₂ d₂)))))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>203      norm_cast,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/norm_cast.lean&#x27;, &#x27;line&#x27;: 377, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit name (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.ident)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) (lean.parser.pexpr std.prec.max))) → conv.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit name (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.ident)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) (lean.parser.pexpr std.prec.max))) → conv.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='conv'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='norm_cast'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='conv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;(at id)?&#x27;, &#x27;(in expr)?&#x27;, &#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;(at id)?&#x27;, &#x27;(in expr)?&#x27;, &#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
p_prime : nat.prime p,
n₁ n₂ d₁ d₂ : int,
hn₁ : @ne.{1} int n₁ (@has_zero.zero.{0} int int.has_zero),
hn₂ : @ne.{1} int n₂ (@has_zero.zero.{0} int int.has_zero),
hd₁ : @ne.{1} int d₁ (@has_zero.zero.{0} int int.has_zero),
hd₂ : @ne.{1} int d₂ (@has_zero.zero.{0} int int.has_zero),
hf1 :
  @multiplicity.finite.{0} int int.comm_semiring
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
    (@has_mul.mul.{0} int int.has_mul n₁ d₂),
hf2 :
  @multiplicity.finite.{0} int int.comm_semiring
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
    (@has_mul.mul.{0} int int.has_mul n₂ d₁)
| @has_le.le.{0} int
    (@preorder.to_has_le.{0} int
       (@partial_order.to_preorder.{0} int
          (@ordered_comm_monoid.to_partial_order.{0} int
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} int
                (@ordered_comm_group.to_ordered_cancel_comm_monoid.{0} int
                   (@ordered_ring.to_ordered_comm_group.{0} int
                      (@linear_ordered_ring.to_ordered_ring.{0} int
                         (@linear_ordered_comm_ring.to_linear_ordered_ring.{0} int
                            (@decidable_linear_ordered_comm_ring.to_linear_ordered_comm_ring.{0} int
                               int.decidable_linear_ordered_comm_ring)))))))))
    (@has_add.add.{0} int
       (@add_semigroup.to_has_add.{0} int
          (@add_monoid.to_add_semigroup.{0} int
             (@add_group.to_add_monoid.{0} int
                (@add_comm_group.to_add_group.{0} int
                   (@ordered_comm_group.to_add_comm_group.{0} int
                      (@ordered_ring.to_ordered_comm_group.{0} int
                         (@linear_ordered_ring.to_ordered_ring.{0} int
                            (@linear_ordered_comm_ring.to_linear_ordered_ring.{0} int
                               (@decidable_linear_ordered_comm_ring.to_linear_ordered_comm_ring.{0} int
                                  int.decidable_linear_ordered_comm_ring)))))))))
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
          (@roption.get.{0} nat
             (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                n₁)
             (@iff.mpr
                (@multiplicity.finite.{0} int int.comm_semiring
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   n₁)
                (and
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int n₁ (@has_zero.zero.{0} int int.has_zero)))
                (@multiplicity.finite_int_iff
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   n₁)
                (@and.intro
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int n₁ (@has_zero.zero.{0} int int.has_zero))
                   (@ne.symm.{1} nat (@has_one.one.{0} nat nat.has_one)
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@ne_of_lt.{0} nat
                         (@partial_order.to_preorder.{0} nat
                            (@ordered_comm_monoid.to_partial_order.{0} nat
                               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
                         (@has_one.one.{0} nat nat.has_one)
                         (int.nat_abs
                            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                         (@nat.prime.one_lt p p_prime)))
                   (λ (hn : @eq.{1} int n₁ (@has_zero.zero.{0} int int.has_zero)),
                      false.rec.{0} false
                        (@eq.mp.{0} (@eq.{1} rat (rat.mk n₁ d₁) (rat.mk n₁ d₁)) false
                           (@eq.trans.{1} Prop (@eq.{1} rat (rat.mk n₁ d₁) (rat.mk n₁ d₁))
                              (@eq.{1} rat (rat.mk n₁ d₁) (@has_zero.zero.{0} rat rat.has_zero))
                              false
                              ((λ (a a_1 : rat) (e_1 : @eq.{1} rat a a_1) (a_2 a_3 : rat) (e_2 : @eq.{1} rat a_2 a_3),
                                  @congr.{1 1} rat Prop (@eq.{1} rat a) (@eq.{1} rat a_1) a_2 a_3
                                    (@congr_arg.{1 1} rat (rat → Prop) a a_1 (@eq.{1} rat) e_1)
                                    e_2)
                                 (rat.mk n₁ d₁)
                                 (rat.mk n₁ d₁)
                                 (@eq.refl.{1} rat (rat.mk n₁ d₁))
                                 (rat.mk n₁ d₁)
                                 (@has_zero.zero.{0} rat rat.has_zero)
                                 (@eq.trans.{1} rat (rat.mk n₁ d₁)
                                    (rat.mk (@has_zero.zero.{0} int int.has_zero) d₁)
                                    (@has_zero.zero.{0} rat rat.has_zero)
                                    ((λ (a a_1 : int) (e_1 : @eq.{1} int a a_1) (a_2 a_3 : int)
                                      (e_2 : @eq.{1} int a_2 a_3),
                                        @congr.{1 1} int rat (rat.mk a) (rat.mk a_1) a_2 a_3
                                          (@congr_arg.{1 1} int (int → rat) a a_1 rat.mk e_1)
                                          e_2)
                                       n₁
                                       (@has_zero.zero.{0} int int.has_zero)
                                       hn
                                       d₁
                                       d₁
                                       (@eq.refl.{1} int d₁))
                                    (rat.zero_mk d₁)))
                              (@propext (@eq.{1} rat (rat.mk n₁ d₁) (@has_zero.zero.{0} rat rat.has_zero)) false
                                 (@iff_false_intro
                                    (@eq.{1} rat (rat.mk n₁ d₁) (@has_zero.zero.{0} rat rat.has_zero))
                                    (@rat.mk_ne_zero_of_ne_zero n₁ d₁ hn₁ hd₁))))
                           (@rfl.{1} rat (rat.mk n₁ d₁))))))))
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
          (@roption.get.{0} nat
             (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                d₂)
             (@iff.mpr
                (@multiplicity.finite.{0} int int.comm_semiring
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   d₂)
                (and
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int d₂ (@has_zero.zero.{0} int int.has_zero)))
                (@multiplicity.finite_int_iff
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   d₂)
                (@and.intro
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int d₂ (@has_zero.zero.{0} int int.has_zero))
                   (@ne.symm.{1} nat (@has_one.one.{0} nat nat.has_one)
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@ne_of_lt.{0} nat
                         (@partial_order.to_preorder.{0} nat
                            (@ordered_comm_monoid.to_partial_order.{0} nat
                               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
                         (@has_one.one.{0} nat nat.has_one)
                         (int.nat_abs
                            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                         (@nat.prime.one_lt p p_prime)))
                   (λ (hd : @eq.{1} int d₂ (@has_zero.zero.{0} int int.has_zero)),
                      false.rec.{0} false
                        (@eq.mp.{0} (@eq.{1} rat (rat.mk n₂ d₂) (rat.mk n₂ d₂)) false
                           (@eq.trans.{1} Prop (@eq.{1} rat (rat.mk n₂ d₂) (rat.mk n₂ d₂))
                              (@eq.{1} rat (rat.mk n₂ d₂) (@has_zero.zero.{0} rat rat.has_zero))
                              false
                              ((λ (a a_1 : rat) (e_1 : @eq.{1} rat a a_1) (a_2 a_3 : rat) (e_2 : @eq.{1} rat a_2 a_3),
                                  @congr.{1 1} rat Prop (@eq.{1} rat a) (@eq.{1} rat a_1) a_2 a_3
                                    (@congr_arg.{1 1} rat (rat → Prop) a a_1 (@eq.{1} rat) e_1)
                                    e_2)
                                 (rat.mk n₂ d₂)
                                 (rat.mk n₂ d₂)
                                 (@eq.refl.{1} rat (rat.mk n₂ d₂))
                                 (rat.mk n₂ d₂)
                                 (@has_zero.zero.{0} rat rat.has_zero)
                                 (@eq.trans.{1} rat (rat.mk n₂ d₂)
                                    (rat.mk n₂ (@has_zero.zero.{0} int int.has_zero))
                                    (@has_zero.zero.{0} rat rat.has_zero)
                                    ((λ (a a_1 : int) (e_1 : @eq.{1} int a a_1) (a_2 a_3 : int)
                                      (e_2 : @eq.{1} int a_2 a_3),
                                        @congr.{1 1} int rat (rat.mk a) (rat.mk a_1) a_2 a_3
                                          (@congr_arg.{1 1} int (int → rat) a a_1 rat.mk e_1)
                                          e_2)
                                       n₂
                                       n₂
                                       (@eq.refl.{1} int n₂)
                                       d₂
                                       (@has_zero.zero.{0} int int.has_zero)
                                       hd)
                                    (rat.mk_zero n₂)))
                              (@propext (@eq.{1} rat (rat.mk n₂ d₂) (@has_zero.zero.{0} rat rat.has_zero)) false
                                 (@iff_false_intro
                                    (@eq.{1} rat (rat.mk n₂ d₂) (@has_zero.zero.{0} rat rat.has_zero))
                                    (@rat.mk_ne_zero_of_ne_zero n₂ d₂ hn₂ hd₂))))
                           (@rfl.{1} rat (rat.mk n₂ d₂)))))))))
    (@has_add.add.{0} int
       (@add_semigroup.to_has_add.{0} int
          (@add_monoid.to_add_semigroup.{0} int
             (@add_group.to_add_monoid.{0} int
                (@add_comm_group.to_add_group.{0} int (@ring.to_add_comm_group.{0} int int.ring)))))
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
          (@roption.get.{0} nat
             (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                d₁)
             (@iff.mpr
                (@multiplicity.finite.{0} int int.comm_semiring
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   d₁)
                (and
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int d₁ (@has_zero.zero.{0} int int.has_zero)))
                (@multiplicity.finite_int_iff
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   d₁)
                (@and.intro
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int d₁ (@has_zero.zero.{0} int int.has_zero))
                   (@ne.symm.{1} nat (@has_one.one.{0} nat nat.has_one)
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@ne_of_lt.{0} nat
                         (@partial_order.to_preorder.{0} nat
                            (@ordered_comm_monoid.to_partial_order.{0} nat
                               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
                         (@has_one.one.{0} nat nat.has_one)
                         (int.nat_abs
                            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                         (@nat.prime.one_lt p p_prime)))
                   (λ (hd : @eq.{1} int d₁ (@has_zero.zero.{0} int int.has_zero)),
                      false.rec.{0} false
                        (@eq.mp.{0} (@eq.{1} rat (rat.mk n₁ d₁) (rat.mk n₁ d₁)) false
                           (@eq.trans.{1} Prop (@eq.{1} rat (rat.mk n₁ d₁) (rat.mk n₁ d₁))
                              (@eq.{1} rat (rat.mk n₁ d₁) (@has_zero.zero.{0} rat rat.has_zero))
                              false
                              ((λ (a a_1 : rat) (e_1 : @eq.{1} rat a a_1) (a_2 a_3 : rat) (e_2 : @eq.{1} rat a_2 a_3),
                                  @congr.{1 1} rat Prop (@eq.{1} rat a) (@eq.{1} rat a_1) a_2 a_3
                                    (@congr_arg.{1 1} rat (rat → Prop) a a_1 (@eq.{1} rat) e_1)
                                    e_2)
                                 (rat.mk n₁ d₁)
                                 (rat.mk n₁ d₁)
                                 (@eq.refl.{1} rat (rat.mk n₁ d₁))
                                 (rat.mk n₁ d₁)
                                 (@has_zero.zero.{0} rat rat.has_zero)
                                 (@eq.trans.{1} rat (rat.mk n₁ d₁)
                                    (rat.mk n₁ (@has_zero.zero.{0} int int.has_zero))
                                    (@has_zero.zero.{0} rat rat.has_zero)
                                    ((λ (a a_1 : int) (e_1 : @eq.{1} int a a_1) (a_2 a_3 : int)
                                      (e_2 : @eq.{1} int a_2 a_3),
                                        @congr.{1 1} int rat (rat.mk a) (rat.mk a_1) a_2 a_3
                                          (@congr_arg.{1 1} int (int → rat) a a_1 rat.mk e_1)
                                          e_2)
                                       n₁
                                       n₁
                                       (@eq.refl.{1} int n₁)
                                       d₁
                                       (@has_zero.zero.{0} int int.has_zero)
                                       hd)
                                    (rat.mk_zero n₁)))
                              (@propext (@eq.{1} rat (rat.mk n₁ d₁) (@has_zero.zero.{0} rat rat.has_zero)) false
                                 (@iff_false_intro
                                    (@eq.{1} rat (rat.mk n₁ d₁) (@has_zero.zero.{0} rat rat.has_zero))
                                    (@rat.mk_ne_zero_of_ne_zero n₁ d₁ hn₁ hd₁))))
                           (@rfl.{1} rat (rat.mk n₁ d₁))))))))
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
          (@roption.get.{0} nat
             (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                n₂)
             (@iff.mpr
                (@multiplicity.finite.{0} int int.comm_semiring
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   n₂)
                (and
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int n₂ (@has_zero.zero.{0} int int.has_zero)))
                (@multiplicity.finite_int_iff
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   n₂)
                (@and.intro
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int n₂ (@has_zero.zero.{0} int int.has_zero))
                   (@ne.symm.{1} nat (@has_one.one.{0} nat nat.has_one)
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@ne_of_lt.{0} nat
                         (@partial_order.to_preorder.{0} nat
                            (@ordered_comm_monoid.to_partial_order.{0} nat
                               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
                         (@has_one.one.{0} nat nat.has_one)
                         (int.nat_abs
                            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                         (@nat.prime.one_lt p p_prime)))
                   (λ (hn : @eq.{1} int n₂ (@has_zero.zero.{0} int int.has_zero)),
                      false.rec.{0} false
                        (@eq.mp.{0} (@eq.{1} rat (rat.mk n₂ d₂) (rat.mk n₂ d₂)) false
                           (@eq.trans.{1} Prop (@eq.{1} rat (rat.mk n₂ d₂) (rat.mk n₂ d₂))
                              (@eq.{1} rat (rat.mk n₂ d₂) (@has_zero.zero.{0} rat rat.has_zero))
                              false
                              ((λ (a a_1 : rat) (e_1 : @eq.{1} rat a a_1) (a_2 a_3 : rat) (e_2 : @eq.{1} rat a_2 a_3),
                                  @congr.{1 1} rat Prop (@eq.{1} rat a) (@eq.{1} rat a_1) a_2 a_3
                                    (@congr_arg.{1 1} rat (rat → Prop) a a_1 (@eq.{1} rat) e_1)
                                    e_2)
                                 (rat.mk n₂ d₂)
                                 (rat.mk n₂ d₂)
                                 (@eq.refl.{1} rat (rat.mk n₂ d₂))
                                 (rat.mk n₂ d₂)
                                 (@has_zero.zero.{0} rat rat.has_zero)
                                 (@eq.trans.{1} rat (rat.mk n₂ d₂)
                                    (rat.mk (@has_zero.zero.{0} int int.has_zero) d₂)
                                    (@has_zero.zero.{0} rat rat.has_zero)
                                    ((λ (a a_1 : int) (e_1 : @eq.{1} int a a_1) (a_2 a_3 : int)
                                      (e_2 : @eq.{1} int a_2 a_3),
                                        @congr.{1 1} int rat (rat.mk a) (rat.mk a_1) a_2 a_3
                                          (@congr_arg.{1 1} int (int → rat) a a_1 rat.mk e_1)
                                          e_2)
                                       n₂
                                       (@has_zero.zero.{0} int int.has_zero)
                                       hn
                                       d₂
                                       d₂
                                       (@eq.refl.{1} int d₂))
                                    (rat.zero_mk d₂)))
                              (@propext (@eq.{1} rat (rat.mk n₂ d₂) (@has_zero.zero.{0} rat rat.has_zero)) false
                                 (@iff_false_intro
                                    (@eq.{1} rat (rat.mk n₂ d₂) (@has_zero.zero.{0} rat rat.has_zero))
                                    (@rat.mk_ne_zero_of_ne_zero n₂ d₂ hn₂ hd₂))))
                           (@rfl.{1} rat (rat.mk n₂ d₂)))))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
p_prime : nat.prime p,
n₁ n₂ d₁ d₂ : int,
hn₁ : @ne.{1} int n₁ (@has_zero.zero.{0} int int.has_zero),
hn₂ : @ne.{1} int n₂ (@has_zero.zero.{0} int int.has_zero),
hd₁ : @ne.{1} int d₁ (@has_zero.zero.{0} int int.has_zero),
hd₂ : @ne.{1} int d₂ (@has_zero.zero.{0} int int.has_zero),
hf1 :
  @multiplicity.finite.{0} int int.comm_semiring
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
    (@has_mul.mul.{0} int int.has_mul n₁ d₂),
hf2 :
  @multiplicity.finite.{0} int int.comm_semiring
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
    (@has_mul.mul.{0} int int.has_mul n₂ d₁)
| @has_le.le.{0} nat nat.has_le
    (@has_add.add.{0} nat nat.has_add
       (@roption.get.{0} nat
          (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
             n₁)
          (@iff.mpr
             (@multiplicity.finite.{0} int int.comm_semiring
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                n₁)
             (and
                (@ne.{1} nat
                   (int.nat_abs
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                   (@has_one.one.{0} nat nat.has_one))
                (@ne.{1} int n₁ (@has_zero.zero.{0} int int.has_zero)))
             (@multiplicity.finite_int_iff
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                n₁)
             (@and.intro
                (@ne.{1} nat
                   (int.nat_abs
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                   (@has_one.one.{0} nat nat.has_one))
                (@ne.{1} int n₁ (@has_zero.zero.{0} int int.has_zero))
                (@ne.symm.{1} nat (@has_one.one.{0} nat nat.has_one)
                   (int.nat_abs
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                   (@ne_of_lt.{0} nat
                      (@partial_order.to_preorder.{0} nat
                         (@ordered_comm_monoid.to_partial_order.{0} nat
                            (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                               (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
                      (@has_one.one.{0} nat nat.has_one)
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@nat.prime.one_lt p p_prime)))
                (λ (hn : @eq.{1} int n₁ (@has_zero.zero.{0} int int.has_zero)),
                   false.rec.{0} false
                     (@eq.mp.{0} (@eq.{1} rat (rat.mk n₁ d₁) (rat.mk n₁ d₁)) false
                        (@eq.trans.{1} Prop (@eq.{1} rat (rat.mk n₁ d₁) (rat.mk n₁ d₁))
                           (@eq.{1} rat (rat.mk n₁ d₁) (@has_zero.zero.{0} rat rat.has_zero))
                           false
                           ((λ (a a_1 : rat) (e_1 : @eq.{1} rat a a_1) (a_2 a_3 : rat) (e_2 : @eq.{1} rat a_2 a_3),
                               @congr.{1 1} rat Prop (@eq.{1} rat a) (@eq.{1} rat a_1) a_2 a_3
                                 (@congr_arg.{1 1} rat (rat → Prop) a a_1 (@eq.{1} rat) e_1)
                                 e_2)
                              (rat.mk n₁ d₁)
                              (rat.mk n₁ d₁)
                              (@eq.refl.{1} rat (rat.mk n₁ d₁))
                              (rat.mk n₁ d₁)
                              (@has_zero.zero.{0} rat rat.has_zero)
                              (@eq.trans.{1} rat (rat.mk n₁ d₁) (rat.mk (@has_zero.zero.{0} int int.has_zero) d₁)
                                 (@has_zero.zero.{0} rat rat.has_zero)
                                 ((λ (a a_1 : int) (e_1 : @eq.{1} int a a_1) (a_2 a_3 : int)
                                   (e_2 : @eq.{1} int a_2 a_3),
                                     @congr.{1 1} int rat (rat.mk a) (rat.mk a_1) a_2 a_3
                                       (@congr_arg.{1 1} int (int → rat) a a_1 rat.mk e_1)
                                       e_2)
                                    n₁
                                    (@has_zero.zero.{0} int int.has_zero)
                                    hn
                                    d₁
                                    d₁
                                    (@eq.refl.{1} int d₁))
                                 (rat.zero_mk d₁)))
                           (@propext (@eq.{1} rat (rat.mk n₁ d₁) (@has_zero.zero.{0} rat rat.has_zero)) false
                              (@iff_false_intro (@eq.{1} rat (rat.mk n₁ d₁) (@has_zero.zero.{0} rat rat.has_zero))
                                 (@rat.mk_ne_zero_of_ne_zero n₁ d₁ hn₁ hd₁))))
                        (@rfl.{1} rat (rat.mk n₁ d₁)))))))
       (@roption.get.{0} nat
          (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
             d₂)
          (@iff.mpr
             (@multiplicity.finite.{0} int int.comm_semiring
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                d₂)
             (and
                (@ne.{1} nat
                   (int.nat_abs
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                   (@has_one.one.{0} nat nat.has_one))
                (@ne.{1} int d₂ (@has_zero.zero.{0} int int.has_zero)))
             (@multiplicity.finite_int_iff
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                d₂)
             (@and.intro
                (@ne.{1} nat
                   (int.nat_abs
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                   (@has_one.one.{0} nat nat.has_one))
                (@ne.{1} int d₂ (@has_zero.zero.{0} int int.has_zero))
                (@ne.symm.{1} nat (@has_one.one.{0} nat nat.has_one)
                   (int.nat_abs
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                   (@ne_of_lt.{0} nat
                      (@partial_order.to_preorder.{0} nat
                         (@ordered_comm_monoid.to_partial_order.{0} nat
                            (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                               (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
                      (@has_one.one.{0} nat nat.has_one)
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@nat.prime.one_lt p p_prime)))
                (λ (hd : @eq.{1} int d₂ (@has_zero.zero.{0} int int.has_zero)),
                   false.rec.{0} false
                     (@eq.mp.{0} (@eq.{1} rat (rat.mk n₂ d₂) (rat.mk n₂ d₂)) false
                        (@eq.trans.{1} Prop (@eq.{1} rat (rat.mk n₂ d₂) (rat.mk n₂ d₂))
                           (@eq.{1} rat (rat.mk n₂ d₂) (@has_zero.zero.{0} rat rat.has_zero))
                           false
                           ((λ (a a_1 : rat) (e_1 : @eq.{1} rat a a_1) (a_2 a_3 : rat) (e_2 : @eq.{1} rat a_2 a_3),
                               @congr.{1 1} rat Prop (@eq.{1} rat a) (@eq.{1} rat a_1) a_2 a_3
                                 (@congr_arg.{1 1} rat (rat → Prop) a a_1 (@eq.{1} rat) e_1)
                                 e_2)
                              (rat.mk n₂ d₂)
                              (rat.mk n₂ d₂)
                              (@eq.refl.{1} rat (rat.mk n₂ d₂))
                              (rat.mk n₂ d₂)
                              (@has_zero.zero.{0} rat rat.has_zero)
                              (@eq.trans.{1} rat (rat.mk n₂ d₂) (rat.mk n₂ (@has_zero.zero.{0} int int.has_zero))
                                 (@has_zero.zero.{0} rat rat.has_zero)
                                 ((λ (a a_1 : int) (e_1 : @eq.{1} int a a_1) (a_2 a_3 : int)
                                   (e_2 : @eq.{1} int a_2 a_3),
                                     @congr.{1 1} int rat (rat.mk a) (rat.mk a_1) a_2 a_3
                                       (@congr_arg.{1 1} int (int → rat) a a_1 rat.mk e_1)
                                       e_2)
                                    n₂
                                    n₂
                                    (@eq.refl.{1} int n₂)
                                    d₂
                                    (@has_zero.zero.{0} int int.has_zero)
                                    hd)
                                 (rat.mk_zero n₂)))
                           (@propext (@eq.{1} rat (rat.mk n₂ d₂) (@has_zero.zero.{0} rat rat.has_zero)) false
                              (@iff_false_intro (@eq.{1} rat (rat.mk n₂ d₂) (@has_zero.zero.{0} rat rat.has_zero))
                                 (@rat.mk_ne_zero_of_ne_zero n₂ d₂ hn₂ hd₂))))
                        (@rfl.{1} rat (rat.mk n₂ d₂))))))))
    (@has_add.add.{0} nat nat.has_add
       (@roption.get.{0} nat
          (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
             d₁)
          (@iff.mpr
             (@multiplicity.finite.{0} int int.comm_semiring
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                d₁)
             (and
                (@ne.{1} nat
                   (int.nat_abs
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                   (@has_one.one.{0} nat nat.has_one))
                (@ne.{1} int d₁ (@has_zero.zero.{0} int int.has_zero)))
             (@multiplicity.finite_int_iff
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                d₁)
             (@and.intro
                (@ne.{1} nat
                   (int.nat_abs
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                   (@has_one.one.{0} nat nat.has_one))
                (@ne.{1} int d₁ (@has_zero.zero.{0} int int.has_zero))
                (@ne.symm.{1} nat (@has_one.one.{0} nat nat.has_one)
                   (int.nat_abs
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                   (@ne_of_lt.{0} nat
                      (@partial_order.to_preorder.{0} nat
                         (@ordered_comm_monoid.to_partial_order.{0} nat
                            (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                               (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
                      (@has_one.one.{0} nat nat.has_one)
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@nat.prime.one_lt p p_prime)))
                (λ (hd : @eq.{1} int d₁ (@has_zero.zero.{0} int int.has_zero)),
                   false.rec.{0} false
                     (@eq.mp.{0} (@eq.{1} rat (rat.mk n₁ d₁) (rat.mk n₁ d₁)) false
                        (@eq.trans.{1} Prop (@eq.{1} rat (rat.mk n₁ d₁) (rat.mk n₁ d₁))
                           (@eq.{1} rat (rat.mk n₁ d₁) (@has_zero.zero.{0} rat rat.has_zero))
                           false
                           ((λ (a a_1 : rat) (e_1 : @eq.{1} rat a a_1) (a_2 a_3 : rat) (e_2 : @eq.{1} rat a_2 a_3),
                               @congr.{1 1} rat Prop (@eq.{1} rat a) (@eq.{1} rat a_1) a_2 a_3
                                 (@congr_arg.{1 1} rat (rat → Prop) a a_1 (@eq.{1} rat) e_1)
                                 e_2)
                              (rat.mk n₁ d₁)
                              (rat.mk n₁ d₁)
                              (@eq.refl.{1} rat (rat.mk n₁ d₁))
                              (rat.mk n₁ d₁)
                              (@has_zero.zero.{0} rat rat.has_zero)
                              (@eq.trans.{1} rat (rat.mk n₁ d₁) (rat.mk n₁ (@has_zero.zero.{0} int int.has_zero))
                                 (@has_zero.zero.{0} rat rat.has_zero)
                                 ((λ (a a_1 : int) (e_1 : @eq.{1} int a a_1) (a_2 a_3 : int)
                                   (e_2 : @eq.{1} int a_2 a_3),
                                     @congr.{1 1} int rat (rat.mk a) (rat.mk a_1) a_2 a_3
                                       (@congr_arg.{1 1} int (int → rat) a a_1 rat.mk e_1)
                                       e_2)
                                    n₁
                                    n₁
                                    (@eq.refl.{1} int n₁)
                                    d₁
                                    (@has_zero.zero.{0} int int.has_zero)
                                    hd)
                                 (rat.mk_zero n₁)))
                           (@propext (@eq.{1} rat (rat.mk n₁ d₁) (@has_zero.zero.{0} rat rat.has_zero)) false
                              (@iff_false_intro (@eq.{1} rat (rat.mk n₁ d₁) (@has_zero.zero.{0} rat rat.has_zero))
                                 (@rat.mk_ne_zero_of_ne_zero n₁ d₁ hn₁ hd₁))))
                        (@rfl.{1} rat (rat.mk n₁ d₁)))))))
       (@roption.get.{0} nat
          (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
             n₂)
          (@iff.mpr
             (@multiplicity.finite.{0} int int.comm_semiring
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                n₂)
             (and
                (@ne.{1} nat
                   (int.nat_abs
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                   (@has_one.one.{0} nat nat.has_one))
                (@ne.{1} int n₂ (@has_zero.zero.{0} int int.has_zero)))
             (@multiplicity.finite_int_iff
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                n₂)
             (@and.intro
                (@ne.{1} nat
                   (int.nat_abs
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                   (@has_one.one.{0} nat nat.has_one))
                (@ne.{1} int n₂ (@has_zero.zero.{0} int int.has_zero))
                (@ne.symm.{1} nat (@has_one.one.{0} nat nat.has_one)
                   (int.nat_abs
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                   (@ne_of_lt.{0} nat
                      (@partial_order.to_preorder.{0} nat
                         (@ordered_comm_monoid.to_partial_order.{0} nat
                            (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                               (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
                      (@has_one.one.{0} nat nat.has_one)
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@nat.prime.one_lt p p_prime)))
                (λ (hn : @eq.{1} int n₂ (@has_zero.zero.{0} int int.has_zero)),
                   false.rec.{0} false
                     (@eq.mp.{0} (@eq.{1} rat (rat.mk n₂ d₂) (rat.mk n₂ d₂)) false
                        (@eq.trans.{1} Prop (@eq.{1} rat (rat.mk n₂ d₂) (rat.mk n₂ d₂))
                           (@eq.{1} rat (rat.mk n₂ d₂) (@has_zero.zero.{0} rat rat.has_zero))
                           false
                           ((λ (a a_1 : rat) (e_1 : @eq.{1} rat a a_1) (a_2 a_3 : rat) (e_2 : @eq.{1} rat a_2 a_3),
                               @congr.{1 1} rat Prop (@eq.{1} rat a) (@eq.{1} rat a_1) a_2 a_3
                                 (@congr_arg.{1 1} rat (rat → Prop) a a_1 (@eq.{1} rat) e_1)
                                 e_2)
                              (rat.mk n₂ d₂)
                              (rat.mk n₂ d₂)
                              (@eq.refl.{1} rat (rat.mk n₂ d₂))
                              (rat.mk n₂ d₂)
                              (@has_zero.zero.{0} rat rat.has_zero)
                              (@eq.trans.{1} rat (rat.mk n₂ d₂) (rat.mk (@has_zero.zero.{0} int int.has_zero) d₂)
                                 (@has_zero.zero.{0} rat rat.has_zero)
                                 ((λ (a a_1 : int) (e_1 : @eq.{1} int a a_1) (a_2 a_3 : int)
                                   (e_2 : @eq.{1} int a_2 a_3),
                                     @congr.{1 1} int rat (rat.mk a) (rat.mk a_1) a_2 a_3
                                       (@congr_arg.{1 1} int (int → rat) a a_1 rat.mk e_1)
                                       e_2)
                                    n₂
                                    (@has_zero.zero.{0} int int.has_zero)
                                    hn
                                    d₂
                                    d₂
                                    (@eq.refl.{1} int d₂))
                                 (rat.zero_mk d₂)))
                           (@propext (@eq.{1} rat (rat.mk n₂ d₂) (@has_zero.zero.{0} rat rat.has_zero)) false
                              (@iff_false_intro (@eq.{1} rat (rat.mk n₂ d₂) (@has_zero.zero.{0} rat rat.has_zero))
                                 (@rat.mk_ne_zero_of_ne_zero n₂ d₂ hn₂ hd₂))))
                        (@rfl.{1} rat (rat.mk n₂ d₂))))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>204      rw [← multiplicity.mul&#x27; (nat.prime_iff_prime_int.1 p_prime) hf1, add_comm,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='multiplicity.mul&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='nat.prime_iff_prime_int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='p_prime'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hf1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='add_comm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/ring_theory/multiplicity.lean&#x27;, &#x27;line&#x27;: 302, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/gcd_domain.lean&#x27;, &#x27;line&#x27;: 579, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 226, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit name (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.ident)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) (lean.parser.pexpr std.prec.max))) → conv.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : integral_domain.{0} α] [_inst_2 : @decidable_rel.{1} α (@has_dvd.dvd.{0} α (@comm_semiring_has_dvd.{0} α (@nonzero_comm_semiring.to_comm_semiring.{0} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} α (@integral_domain.to_nonzero_comm_ring.{0} α _inst_1)))))] {p a b : α} (hp : @prime.{0} α (@nonzero_comm_semiring.to_comm_semiring.{0} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} α (@integral_domain.to_nonzero_comm_ring.{0} α _inst_1))) p) (h : @roption.dom.{0} nat (@multiplicity.{0} α (@nonzero_comm_semiring.to_comm_semiring.{0} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} α (@integral_domain.to_nonzero_comm_ring.{0} α _inst_1))) (λ (a b : α), _inst_2 a b) p (@has_mul.mul.{0} α (@no_zero_divisors.to_has_mul.{0} α (@domain.to_no_zero_divisors.{0} α (@integral_domain.to_domain.{0} α _inst_1))) a b))), @eq.{1} nat (@roption.get.{0} nat (@multiplicity.{0} α (@nonzero_comm_semiring.to_comm_semiring.{0} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} α (@integral_domain.to_nonzero_comm_ring.{0} α _inst_1))) (λ (a b : α), _inst_2 a b) p (@has_mul.mul.{0} α (@no_zero_divisors.to_has_mul.{0} α (@domain.to_no_zero_divisors.{0} α (@integral_domain.to_domain.{0} α _inst_1))) a b)) h) (@has_add.add.{0} nat nat.has_add (@roption.get.{0} nat (@multiplicity.{0} α (@nonzero_comm_semiring.to_comm_semiring.{0} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} α (@integral_domain.to_nonzero_comm_ring.{0} α _inst_1))) (λ (a b : α), _inst_2 a b) p a) (@and.left (@multiplicity.finite.{0} α (@nonzero_comm_semiring.to_comm_semiring.{0} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} α (@integral_domain.to_nonzero_comm_ring.{0} α _inst_1))) p a) (@multiplicity.finite.{0} α (@nonzero_comm_semiring.to_comm_semiring.{0} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} α (@integral_domain.to_nonzero_comm_ring.{0} α _inst_1))) p b) (@iff.mp (@multiplicity.finite.{0} α (@nonzero_comm_semiring.to_comm_semiring.{0} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} α (@integral_domain.to_nonzero_comm_ring.{0} α _inst_1))) p (@has_mul.mul.{0} α (@no_zero_divisors.to_has_mul.{0} α (@domain.to_no_zero_divisors.{0} α (@integral_domain.to_domain.{0} α _inst_1))) a b)) (and (@multiplicity.finite.{0} α (@nonzero_comm_semiring.to_comm_semiring.{0} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} α (@integral_domain.to_nonzero_comm_ring.{0} α _inst_1))) p a) (@multiplicity.finite.{0} α (@nonzero_comm_semiring.to_comm_semiring.{0} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} α (@integral_domain.to_nonzero_comm_ring.{0} α _inst_1))) p b)) (@multiplicity.finite_mul_iff.{0} α _inst_1 (λ (a b : α), _inst_2 a b) p a b hp) h))) (@roption.get.{0} nat (@multiplicity.{0} α (@nonzero_comm_semiring.to_comm_semiring.{0} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} α (@integral_domain.to_nonzero_comm_ring.{0} α _inst_1))) (λ (a b : α), _inst_2 a b) p b) (@and.right (@multiplicity.finite.{0} α (@nonzero_comm_semiring.to_comm_semiring.{0} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} α (@integral_domain.to_nonzero_comm_ring.{0} α _inst_1))) p a) (@multiplicity.finite.{0} α (@nonzero_comm_semiring.to_comm_semiring.{0} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} α (@integral_domain.to_nonzero_comm_ring.{0} α _inst_1))) p b) (@iff.mp (@multiplicity.finite.{0} α (@nonzero_comm_semiring.to_comm_semiring.{0} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} α (@integral_domain.to_nonzero_comm_ring.{0} α _inst_1))) p (@has_mul.mul.{0} α (@no_zero_divisors.to_has_mul.{0} α (@domain.to_no_zero_divisors.{0} α (@integral_domain.to_domain.{0} α _inst_1))) a b)) (and (@multiplicity.finite.{0} α (@nonzero_comm_semiring.to_comm_semiring.{0} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} α (@integral_domain.to_nonzero_comm_ring.{0} α _inst_1))) p a) (@multiplicity.finite.{0} α (@nonzero_comm_semiring.to_comm_semiring.{0} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} α (@integral_domain.to_nonzero_comm_ring.{0} α _inst_1))) p b)) (@multiplicity.finite_mul_iff.{0} α _inst_1 (λ (a b : α), _inst_2 a b) p a b hp) h))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {p : nat}, iff (nat.prime p) (@prime.{0} int int.comm_semiring (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat.prime p'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@multiplicity.finite.{0} int int.comm_semiring (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p) (@has_mul.mul.{0} int int.has_mul n₁ d₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : add_comm_semigroup.{0} α] (a b : α), @eq.{1} α (@has_add.add.{0} α (@add_semigroup.to_has_add.{0} α (@add_comm_semigroup.to_add_semigroup.{0} α _inst_1)) a b) (@has_add.add.{0} α (@add_semigroup.to_has_add.{0} α (@add_comm_semigroup.to_add_semigroup.{0} α _inst_1)) b a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='conv'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;(at id)?&#x27;, &#x27;(in expr)?&#x27;, &#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
p_prime : nat.prime p,
n₁ n₂ d₁ d₂ : int,
hn₁ : @ne.{1} int n₁ (@has_zero.zero.{0} int int.has_zero),
hn₂ : @ne.{1} int n₂ (@has_zero.zero.{0} int int.has_zero),
hd₁ : @ne.{1} int d₁ (@has_zero.zero.{0} int int.has_zero),
hd₂ : @ne.{1} int d₂ (@has_zero.zero.{0} int int.has_zero),
hf1 :
  @multiplicity.finite.{0} int int.comm_semiring
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
    (@has_mul.mul.{0} int int.has_mul n₁ d₂),
hf2 :
  @multiplicity.finite.{0} int int.comm_semiring
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
    (@has_mul.mul.{0} int int.has_mul n₂ d₁)
| @has_le.le.{0} nat nat.has_le
    (@has_add.add.{0} nat nat.has_add
       (@roption.get.{0} nat
          (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
             n₁)
          (@iff.mpr
             (@multiplicity.finite.{0} int int.comm_semiring
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                n₁)
             (and
                (@ne.{1} nat
                   (int.nat_abs
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                   (@has_one.one.{0} nat nat.has_one))
                (@ne.{1} int n₁ (@has_zero.zero.{0} int int.has_zero)))
             (@multiplicity.finite_int_iff
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                n₁)
             (@and.intro
                (@ne.{1} nat
                   (int.nat_abs
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                   (@has_one.one.{0} nat nat.has_one))
                (@ne.{1} int n₁ (@has_zero.zero.{0} int int.has_zero))
                (@ne.symm.{1} nat (@has_one.one.{0} nat nat.has_one)
                   (int.nat_abs
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                   (@ne_of_lt.{0} nat
                      (@partial_order.to_preorder.{0} nat
                         (@ordered_comm_monoid.to_partial_order.{0} nat
                            (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                               (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
                      (@has_one.one.{0} nat nat.has_one)
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@nat.prime.one_lt p p_prime)))
                (λ (hn : @eq.{1} int n₁ (@has_zero.zero.{0} int int.has_zero)),
                   false.rec.{0} false
                     (@eq.mp.{0} (@eq.{1} rat (rat.mk n₁ d₁) (rat.mk n₁ d₁)) false
                        (@eq.trans.{1} Prop (@eq.{1} rat (rat.mk n₁ d₁) (rat.mk n₁ d₁))
                           (@eq.{1} rat (rat.mk n₁ d₁) (@has_zero.zero.{0} rat rat.has_zero))
                           false
                           ((λ (a a_1 : rat) (e_1 : @eq.{1} rat a a_1) (a_2 a_3 : rat) (e_2 : @eq.{1} rat a_2 a_3),
                               @congr.{1 1} rat Prop (@eq.{1} rat a) (@eq.{1} rat a_1) a_2 a_3
                                 (@congr_arg.{1 1} rat (rat → Prop) a a_1 (@eq.{1} rat) e_1)
                                 e_2)
                              (rat.mk n₁ d₁)
                              (rat.mk n₁ d₁)
                              (@eq.refl.{1} rat (rat.mk n₁ d₁))
                              (rat.mk n₁ d₁)
                              (@has_zero.zero.{0} rat rat.has_zero)
                              (@eq.trans.{1} rat (rat.mk n₁ d₁) (rat.mk (@has_zero.zero.{0} int int.has_zero) d₁)
                                 (@has_zero.zero.{0} rat rat.has_zero)
                                 ((λ (a a_1 : int) (e_1 : @eq.{1} int a a_1) (a_2 a_3 : int)
                                   (e_2 : @eq.{1} int a_2 a_3),
                                     @congr.{1 1} int rat (rat.mk a) (rat.mk a_1) a_2 a_3
                                       (@congr_arg.{1 1} int (int → rat) a a_1 rat.mk e_1)
                                       e_2)
                                    n₁
                                    (@has_zero.zero.{0} int int.has_zero)
                                    hn
                                    d₁
                                    d₁
                                    (@eq.refl.{1} int d₁))
                                 (rat.zero_mk d₁)))
                           (@propext (@eq.{1} rat (rat.mk n₁ d₁) (@has_zero.zero.{0} rat rat.has_zero)) false
                              (@iff_false_intro (@eq.{1} rat (rat.mk n₁ d₁) (@has_zero.zero.{0} rat rat.has_zero))
                                 (@rat.mk_ne_zero_of_ne_zero n₁ d₁ hn₁ hd₁))))
                        (@rfl.{1} rat (rat.mk n₁ d₁)))))))
       (@roption.get.{0} nat
          (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
             d₂)
          (@iff.mpr
             (@multiplicity.finite.{0} int int.comm_semiring
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                d₂)
             (and
                (@ne.{1} nat
                   (int.nat_abs
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                   (@has_one.one.{0} nat nat.has_one))
                (@ne.{1} int d₂ (@has_zero.zero.{0} int int.has_zero)))
             (@multiplicity.finite_int_iff
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                d₂)
             (@and.intro
                (@ne.{1} nat
                   (int.nat_abs
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                   (@has_one.one.{0} nat nat.has_one))
                (@ne.{1} int d₂ (@has_zero.zero.{0} int int.has_zero))
                (@ne.symm.{1} nat (@has_one.one.{0} nat nat.has_one)
                   (int.nat_abs
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                   (@ne_of_lt.{0} nat
                      (@partial_order.to_preorder.{0} nat
                         (@ordered_comm_monoid.to_partial_order.{0} nat
                            (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                               (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
                      (@has_one.one.{0} nat nat.has_one)
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@nat.prime.one_lt p p_prime)))
                (λ (hd : @eq.{1} int d₂ (@has_zero.zero.{0} int int.has_zero)),
                   false.rec.{0} false
                     (@eq.mp.{0} (@eq.{1} rat (rat.mk n₂ d₂) (rat.mk n₂ d₂)) false
                        (@eq.trans.{1} Prop (@eq.{1} rat (rat.mk n₂ d₂) (rat.mk n₂ d₂))
                           (@eq.{1} rat (rat.mk n₂ d₂) (@has_zero.zero.{0} rat rat.has_zero))
                           false
                           ((λ (a a_1 : rat) (e_1 : @eq.{1} rat a a_1) (a_2 a_3 : rat) (e_2 : @eq.{1} rat a_2 a_3),
                               @congr.{1 1} rat Prop (@eq.{1} rat a) (@eq.{1} rat a_1) a_2 a_3
                                 (@congr_arg.{1 1} rat (rat → Prop) a a_1 (@eq.{1} rat) e_1)
                                 e_2)
                              (rat.mk n₂ d₂)
                              (rat.mk n₂ d₂)
                              (@eq.refl.{1} rat (rat.mk n₂ d₂))
                              (rat.mk n₂ d₂)
                              (@has_zero.zero.{0} rat rat.has_zero)
                              (@eq.trans.{1} rat (rat.mk n₂ d₂) (rat.mk n₂ (@has_zero.zero.{0} int int.has_zero))
                                 (@has_zero.zero.{0} rat rat.has_zero)
                                 ((λ (a a_1 : int) (e_1 : @eq.{1} int a a_1) (a_2 a_3 : int)
                                   (e_2 : @eq.{1} int a_2 a_3),
                                     @congr.{1 1} int rat (rat.mk a) (rat.mk a_1) a_2 a_3
                                       (@congr_arg.{1 1} int (int → rat) a a_1 rat.mk e_1)
                                       e_2)
                                    n₂
                                    n₂
                                    (@eq.refl.{1} int n₂)
                                    d₂
                                    (@has_zero.zero.{0} int int.has_zero)
                                    hd)
                                 (rat.mk_zero n₂)))
                           (@propext (@eq.{1} rat (rat.mk n₂ d₂) (@has_zero.zero.{0} rat rat.has_zero)) false
                              (@iff_false_intro (@eq.{1} rat (rat.mk n₂ d₂) (@has_zero.zero.{0} rat rat.has_zero))
                                 (@rat.mk_ne_zero_of_ne_zero n₂ d₂ hn₂ hd₂))))
                        (@rfl.{1} rat (rat.mk n₂ d₂))))))))
    (@has_add.add.{0} nat nat.has_add
       (@roption.get.{0} nat
          (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
             d₁)
          (@iff.mpr
             (@multiplicity.finite.{0} int int.comm_semiring
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                d₁)
             (and
                (@ne.{1} nat
                   (int.nat_abs
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                   (@has_one.one.{0} nat nat.has_one))
                (@ne.{1} int d₁ (@has_zero.zero.{0} int int.has_zero)))
             (@multiplicity.finite_int_iff
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                d₁)
             (@and.intro
                (@ne.{1} nat
                   (int.nat_abs
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                   (@has_one.one.{0} nat nat.has_one))
                (@ne.{1} int d₁ (@has_zero.zero.{0} int int.has_zero))
                (@ne.symm.{1} nat (@has_one.one.{0} nat nat.has_one)
                   (int.nat_abs
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                   (@ne_of_lt.{0} nat
                      (@partial_order.to_preorder.{0} nat
                         (@ordered_comm_monoid.to_partial_order.{0} nat
                            (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                               (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
                      (@has_one.one.{0} nat nat.has_one)
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@nat.prime.one_lt p p_prime)))
                (λ (hd : @eq.{1} int d₁ (@has_zero.zero.{0} int int.has_zero)),
                   false.rec.{0} false
                     (@eq.mp.{0} (@eq.{1} rat (rat.mk n₁ d₁) (rat.mk n₁ d₁)) false
                        (@eq.trans.{1} Prop (@eq.{1} rat (rat.mk n₁ d₁) (rat.mk n₁ d₁))
                           (@eq.{1} rat (rat.mk n₁ d₁) (@has_zero.zero.{0} rat rat.has_zero))
                           false
                           ((λ (a a_1 : rat) (e_1 : @eq.{1} rat a a_1) (a_2 a_3 : rat) (e_2 : @eq.{1} rat a_2 a_3),
                               @congr.{1 1} rat Prop (@eq.{1} rat a) (@eq.{1} rat a_1) a_2 a_3
                                 (@congr_arg.{1 1} rat (rat → Prop) a a_1 (@eq.{1} rat) e_1)
                                 e_2)
                              (rat.mk n₁ d₁)
                              (rat.mk n₁ d₁)
                              (@eq.refl.{1} rat (rat.mk n₁ d₁))
                              (rat.mk n₁ d₁)
                              (@has_zero.zero.{0} rat rat.has_zero)
                              (@eq.trans.{1} rat (rat.mk n₁ d₁) (rat.mk n₁ (@has_zero.zero.{0} int int.has_zero))
                                 (@has_zero.zero.{0} rat rat.has_zero)
                                 ((λ (a a_1 : int) (e_1 : @eq.{1} int a a_1) (a_2 a_3 : int)
                                   (e_2 : @eq.{1} int a_2 a_3),
                                     @congr.{1 1} int rat (rat.mk a) (rat.mk a_1) a_2 a_3
                                       (@congr_arg.{1 1} int (int → rat) a a_1 rat.mk e_1)
                                       e_2)
                                    n₁
                                    n₁
                                    (@eq.refl.{1} int n₁)
                                    d₁
                                    (@has_zero.zero.{0} int int.has_zero)
                                    hd)
                                 (rat.mk_zero n₁)))
                           (@propext (@eq.{1} rat (rat.mk n₁ d₁) (@has_zero.zero.{0} rat rat.has_zero)) false
                              (@iff_false_intro (@eq.{1} rat (rat.mk n₁ d₁) (@has_zero.zero.{0} rat rat.has_zero))
                                 (@rat.mk_ne_zero_of_ne_zero n₁ d₁ hn₁ hd₁))))
                        (@rfl.{1} rat (rat.mk n₁ d₁)))))))
       (@roption.get.{0} nat
          (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
             n₂)
          (@iff.mpr
             (@multiplicity.finite.{0} int int.comm_semiring
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                n₂)
             (and
                (@ne.{1} nat
                   (int.nat_abs
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                   (@has_one.one.{0} nat nat.has_one))
                (@ne.{1} int n₂ (@has_zero.zero.{0} int int.has_zero)))
             (@multiplicity.finite_int_iff
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                n₂)
             (@and.intro
                (@ne.{1} nat
                   (int.nat_abs
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                   (@has_one.one.{0} nat nat.has_one))
                (@ne.{1} int n₂ (@has_zero.zero.{0} int int.has_zero))
                (@ne.symm.{1} nat (@has_one.one.{0} nat nat.has_one)
                   (int.nat_abs
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                   (@ne_of_lt.{0} nat
                      (@partial_order.to_preorder.{0} nat
                         (@ordered_comm_monoid.to_partial_order.{0} nat
                            (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                               (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
                      (@has_one.one.{0} nat nat.has_one)
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@nat.prime.one_lt p p_prime)))
                (λ (hn : @eq.{1} int n₂ (@has_zero.zero.{0} int int.has_zero)),
                   false.rec.{0} false
                     (@eq.mp.{0} (@eq.{1} rat (rat.mk n₂ d₂) (rat.mk n₂ d₂)) false
                        (@eq.trans.{1} Prop (@eq.{1} rat (rat.mk n₂ d₂) (rat.mk n₂ d₂))
                           (@eq.{1} rat (rat.mk n₂ d₂) (@has_zero.zero.{0} rat rat.has_zero))
                           false
                           ((λ (a a_1 : rat) (e_1 : @eq.{1} rat a a_1) (a_2 a_3 : rat) (e_2 : @eq.{1} rat a_2 a_3),
                               @congr.{1 1} rat Prop (@eq.{1} rat a) (@eq.{1} rat a_1) a_2 a_3
                                 (@congr_arg.{1 1} rat (rat → Prop) a a_1 (@eq.{1} rat) e_1)
                                 e_2)
                              (rat.mk n₂ d₂)
                              (rat.mk n₂ d₂)
                              (@eq.refl.{1} rat (rat.mk n₂ d₂))
                              (rat.mk n₂ d₂)
                              (@has_zero.zero.{0} rat rat.has_zero)
                              (@eq.trans.{1} rat (rat.mk n₂ d₂) (rat.mk (@has_zero.zero.{0} int int.has_zero) d₂)
                                 (@has_zero.zero.{0} rat rat.has_zero)
                                 ((λ (a a_1 : int) (e_1 : @eq.{1} int a a_1) (a_2 a_3 : int)
                                   (e_2 : @eq.{1} int a_2 a_3),
                                     @congr.{1 1} int rat (rat.mk a) (rat.mk a_1) a_2 a_3
                                       (@congr_arg.{1 1} int (int → rat) a a_1 rat.mk e_1)
                                       e_2)
                                    n₂
                                    (@has_zero.zero.{0} int int.has_zero)
                                    hn
                                    d₂
                                    d₂
                                    (@eq.refl.{1} int d₂))
                                 (rat.zero_mk d₂)))
                           (@propext (@eq.{1} rat (rat.mk n₂ d₂) (@has_zero.zero.{0} rat rat.has_zero)) false
                              (@iff_false_intro (@eq.{1} rat (rat.mk n₂ d₂) (@has_zero.zero.{0} rat rat.has_zero))
                                 (@rat.mk_ne_zero_of_ne_zero n₂ d₂ hn₂ hd₂))))
                        (@rfl.{1} rat (rat.mk n₂ d₂))))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
p_prime : nat.prime p,
n₁ n₂ d₁ d₂ : int,
hn₁ : @ne.{1} int n₁ (@has_zero.zero.{0} int int.has_zero),
hn₂ : @ne.{1} int n₂ (@has_zero.zero.{0} int int.has_zero),
hd₁ : @ne.{1} int d₁ (@has_zero.zero.{0} int int.has_zero),
hd₂ : @ne.{1} int d₂ (@has_zero.zero.{0} int int.has_zero),
hf1 :
  @multiplicity.finite.{0} int int.comm_semiring
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
    (@has_mul.mul.{0} int int.has_mul n₁ d₂),
hf2 :
  @multiplicity.finite.{0} int int.comm_semiring
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
    (@has_mul.mul.{0} int int.has_mul n₂ d₁)
| @has_le.le.{0} nat nat.has_le
    (@roption.get.{0} nat
       (@multiplicity.{0} int
          (@nonzero_comm_semiring.to_comm_semiring.{0} int
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} int
                (@integral_domain.to_nonzero_comm_ring.{0} int
                   (@normalization_domain.to_integral_domain.{0} int int.normalization_domain))))
          (λ (a b : int), (λ (a b : int), int.decidable_dvd a b) a b)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
          (@has_mul.mul.{0} int
             (@no_zero_divisors.to_has_mul.{0} int
                (@domain.to_no_zero_divisors.{0} int
                   (@integral_domain.to_domain.{0} int
                      (@normalization_domain.to_integral_domain.{0} int int.normalization_domain))))
             n₁
             d₂))
       hf1)
    (@has_add.add.{0} nat nat.has_add
       (@roption.get.{0} nat
          (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
             d₁)
          (@iff.mpr
             (@multiplicity.finite.{0} int int.comm_semiring
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                d₁)
             (and
                (@ne.{1} nat
                   (int.nat_abs
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                   (@has_one.one.{0} nat nat.has_one))
                (@ne.{1} int d₁ (@has_zero.zero.{0} int int.has_zero)))
             (@multiplicity.finite_int_iff
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                d₁)
             (@and.intro
                (@ne.{1} nat
                   (int.nat_abs
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                   (@has_one.one.{0} nat nat.has_one))
                (@ne.{1} int d₁ (@has_zero.zero.{0} int int.has_zero))
                (@ne.symm.{1} nat (@has_one.one.{0} nat nat.has_one)
                   (int.nat_abs
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                   (@ne_of_lt.{0} nat
                      (@partial_order.to_preorder.{0} nat
                         (@ordered_comm_monoid.to_partial_order.{0} nat
                            (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                               (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
                      (@has_one.one.{0} nat nat.has_one)
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@nat.prime.one_lt p p_prime)))
                (λ (hd : @eq.{1} int d₁ (@has_zero.zero.{0} int int.has_zero)),
                   false.rec.{0} false
                     (@eq.mp.{0} (@eq.{1} rat (rat.mk n₁ d₁) (rat.mk n₁ d₁)) false
                        (@eq.trans.{1} Prop (@eq.{1} rat (rat.mk n₁ d₁) (rat.mk n₁ d₁))
                           (@eq.{1} rat (rat.mk n₁ d₁) (@has_zero.zero.{0} rat rat.has_zero))
                           false
                           ((λ (a a_1 : rat) (e_1 : @eq.{1} rat a a_1) (a_2 a_3 : rat) (e_2 : @eq.{1} rat a_2 a_3),
                               @congr.{1 1} rat Prop (@eq.{1} rat a) (@eq.{1} rat a_1) a_2 a_3
                                 (@congr_arg.{1 1} rat (rat → Prop) a a_1 (@eq.{1} rat) e_1)
                                 e_2)
                              (rat.mk n₁ d₁)
                              (rat.mk n₁ d₁)
                              (@eq.refl.{1} rat (rat.mk n₁ d₁))
                              (rat.mk n₁ d₁)
                              (@has_zero.zero.{0} rat rat.has_zero)
                              (@eq.trans.{1} rat (rat.mk n₁ d₁) (rat.mk n₁ (@has_zero.zero.{0} int int.has_zero))
                                 (@has_zero.zero.{0} rat rat.has_zero)
                                 ((λ (a a_1 : int) (e_1 : @eq.{1} int a a_1) (a_2 a_3 : int)
                                   (e_2 : @eq.{1} int a_2 a_3),
                                     @congr.{1 1} int rat (rat.mk a) (rat.mk a_1) a_2 a_3
                                       (@congr_arg.{1 1} int (int → rat) a a_1 rat.mk e_1)
                                       e_2)
                                    n₁
                                    n₁
                                    (@eq.refl.{1} int n₁)
                                    d₁
                                    (@has_zero.zero.{0} int int.has_zero)
                                    hd)
                                 (rat.mk_zero n₁)))
                           (@propext (@eq.{1} rat (rat.mk n₁ d₁) (@has_zero.zero.{0} rat rat.has_zero)) false
                              (@iff_false_intro (@eq.{1} rat (rat.mk n₁ d₁) (@has_zero.zero.{0} rat rat.has_zero))
                                 (@rat.mk_ne_zero_of_ne_zero n₁ d₁ hn₁ hd₁))))
                        (@rfl.{1} rat (rat.mk n₁ d₁)))))))
       (@roption.get.{0} nat
          (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
             n₂)
          (@iff.mpr
             (@multiplicity.finite.{0} int int.comm_semiring
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                n₂)
             (and
                (@ne.{1} nat
                   (int.nat_abs
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                   (@has_one.one.{0} nat nat.has_one))
                (@ne.{1} int n₂ (@has_zero.zero.{0} int int.has_zero)))
             (@multiplicity.finite_int_iff
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                n₂)
             (@and.intro
                (@ne.{1} nat
                   (int.nat_abs
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                   (@has_one.one.{0} nat nat.has_one))
                (@ne.{1} int n₂ (@has_zero.zero.{0} int int.has_zero))
                (@ne.symm.{1} nat (@has_one.one.{0} nat nat.has_one)
                   (int.nat_abs
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                   (@ne_of_lt.{0} nat
                      (@partial_order.to_preorder.{0} nat
                         (@ordered_comm_monoid.to_partial_order.{0} nat
                            (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                               (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
                      (@has_one.one.{0} nat nat.has_one)
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@nat.prime.one_lt p p_prime)))
                (λ (hn : @eq.{1} int n₂ (@has_zero.zero.{0} int int.has_zero)),
                   false.rec.{0} false
                     (@eq.mp.{0} (@eq.{1} rat (rat.mk n₂ d₂) (rat.mk n₂ d₂)) false
                        (@eq.trans.{1} Prop (@eq.{1} rat (rat.mk n₂ d₂) (rat.mk n₂ d₂))
                           (@eq.{1} rat (rat.mk n₂ d₂) (@has_zero.zero.{0} rat rat.has_zero))
                           false
                           ((λ (a a_1 : rat) (e_1 : @eq.{1} rat a a_1) (a_2 a_3 : rat) (e_2 : @eq.{1} rat a_2 a_3),
                               @congr.{1 1} rat Prop (@eq.{1} rat a) (@eq.{1} rat a_1) a_2 a_3
                                 (@congr_arg.{1 1} rat (rat → Prop) a a_1 (@eq.{1} rat) e_1)
                                 e_2)
                              (rat.mk n₂ d₂)
                              (rat.mk n₂ d₂)
                              (@eq.refl.{1} rat (rat.mk n₂ d₂))
                              (rat.mk n₂ d₂)
                              (@has_zero.zero.{0} rat rat.has_zero)
                              (@eq.trans.{1} rat (rat.mk n₂ d₂) (rat.mk (@has_zero.zero.{0} int int.has_zero) d₂)
                                 (@has_zero.zero.{0} rat rat.has_zero)
                                 ((λ (a a_1 : int) (e_1 : @eq.{1} int a a_1) (a_2 a_3 : int)
                                   (e_2 : @eq.{1} int a_2 a_3),
                                     @congr.{1 1} int rat (rat.mk a) (rat.mk a_1) a_2 a_3
                                       (@congr_arg.{1 1} int (int → rat) a a_1 rat.mk e_1)
                                       e_2)
                                    n₂
                                    (@has_zero.zero.{0} int int.has_zero)
                                    hn
                                    d₂
                                    d₂
                                    (@eq.refl.{1} int d₂))
                                 (rat.zero_mk d₂)))
                           (@propext (@eq.{1} rat (rat.mk n₂ d₂) (@has_zero.zero.{0} rat rat.has_zero)) false
                              (@iff_false_intro (@eq.{1} rat (rat.mk n₂ d₂) (@has_zero.zero.{0} rat rat.has_zero))
                                 (@rat.mk_ne_zero_of_ne_zero n₂ d₂ hn₂ hd₂))))
                        (@rfl.{1} rat (rat.mk n₂ d₂))))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
p_prime : nat.prime p,
n₁ n₂ d₁ d₂ : int,
hn₁ : @ne.{1} int n₁ (@has_zero.zero.{0} int int.has_zero),
hn₂ : @ne.{1} int n₂ (@has_zero.zero.{0} int int.has_zero),
hd₁ : @ne.{1} int d₁ (@has_zero.zero.{0} int int.has_zero),
hd₂ : @ne.{1} int d₂ (@has_zero.zero.{0} int int.has_zero),
hf1 :
  @multiplicity.finite.{0} int int.comm_semiring
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
    (@has_mul.mul.{0} int int.has_mul n₁ d₂),
hf2 :
  @multiplicity.finite.{0} int int.comm_semiring
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
    (@has_mul.mul.{0} int int.has_mul n₂ d₁)
| @has_le.le.{0} nat nat.has_le
    (@roption.get.{0} nat
       (@multiplicity.{0} int
          (@nonzero_comm_semiring.to_comm_semiring.{0} int
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} int
                (@integral_domain.to_nonzero_comm_ring.{0} int
                   (@normalization_domain.to_integral_domain.{0} int int.normalization_domain))))
          (λ (a b : int), (λ (a b : int), int.decidable_dvd a b) a b)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
          (@has_mul.mul.{0} int
             (@no_zero_divisors.to_has_mul.{0} int
                (@domain.to_no_zero_divisors.{0} int
                   (@integral_domain.to_domain.{0} int
                      (@normalization_domain.to_integral_domain.{0} int int.normalization_domain))))
             n₁
             d₂))
       hf1)
    (@has_add.add.{0} nat
       (@add_semigroup.to_has_add.{0} nat (@add_comm_semigroup.to_add_semigroup.{0} nat nat.add_comm_semigroup))
       (@roption.get.{0} nat
          (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
             n₂)
          (@iff.mpr
             (@multiplicity.finite.{0} int int.comm_semiring
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                n₂)
             (and
                (@ne.{1} nat
                   (int.nat_abs
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                   (@has_one.one.{0} nat nat.has_one))
                (@ne.{1} int n₂ (@has_zero.zero.{0} int int.has_zero)))
             (@multiplicity.finite_int_iff
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                n₂)
             (@and.intro
                (@ne.{1} nat
                   (int.nat_abs
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                   (@has_one.one.{0} nat nat.has_one))
                (@ne.{1} int n₂ (@has_zero.zero.{0} int int.has_zero))
                (@ne.symm.{1} nat (@has_one.one.{0} nat nat.has_one)
                   (int.nat_abs
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                   (@ne_of_lt.{0} nat
                      (@partial_order.to_preorder.{0} nat
                         (@ordered_comm_monoid.to_partial_order.{0} nat
                            (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                               (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
                      (@has_one.one.{0} nat nat.has_one)
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@nat.prime.one_lt p p_prime)))
                (λ (hn : @eq.{1} int n₂ (@has_zero.zero.{0} int int.has_zero)),
                   false.rec.{0} false
                     (@eq.mp.{0} (@eq.{1} rat (rat.mk n₂ d₂) (rat.mk n₂ d₂)) false
                        (@eq.trans.{1} Prop (@eq.{1} rat (rat.mk n₂ d₂) (rat.mk n₂ d₂))
                           (@eq.{1} rat (rat.mk n₂ d₂) (@has_zero.zero.{0} rat rat.has_zero))
                           false
                           ((λ (a a_1 : rat) (e_1 : @eq.{1} rat a a_1) (a_2 a_3 : rat) (e_2 : @eq.{1} rat a_2 a_3),
                               @congr.{1 1} rat Prop (@eq.{1} rat a) (@eq.{1} rat a_1) a_2 a_3
                                 (@congr_arg.{1 1} rat (rat → Prop) a a_1 (@eq.{1} rat) e_1)
                                 e_2)
                              (rat.mk n₂ d₂)
                              (rat.mk n₂ d₂)
                              (@eq.refl.{1} rat (rat.mk n₂ d₂))
                              (rat.mk n₂ d₂)
                              (@has_zero.zero.{0} rat rat.has_zero)
                              (@eq.trans.{1} rat (rat.mk n₂ d₂) (rat.mk (@has_zero.zero.{0} int int.has_zero) d₂)
                                 (@has_zero.zero.{0} rat rat.has_zero)
                                 ((λ (a a_1 : int) (e_1 : @eq.{1} int a a_1) (a_2 a_3 : int)
                                   (e_2 : @eq.{1} int a_2 a_3),
                                     @congr.{1 1} int rat (rat.mk a) (rat.mk a_1) a_2 a_3
                                       (@congr_arg.{1 1} int (int → rat) a a_1 rat.mk e_1)
                                       e_2)
                                    n₂
                                    (@has_zero.zero.{0} int int.has_zero)
                                    hn
                                    d₂
                                    d₂
                                    (@eq.refl.{1} int d₂))
                                 (rat.zero_mk d₂)))
                           (@propext (@eq.{1} rat (rat.mk n₂ d₂) (@has_zero.zero.{0} rat rat.has_zero)) false
                              (@iff_false_intro (@eq.{1} rat (rat.mk n₂ d₂) (@has_zero.zero.{0} rat rat.has_zero))
                                 (@rat.mk_ne_zero_of_ne_zero n₂ d₂ hn₂ hd₂))))
                        (@rfl.{1} rat (rat.mk n₂ d₂)))))))
       (@roption.get.{0} nat
          (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
             d₁)
          (@iff.mpr
             (@multiplicity.finite.{0} int int.comm_semiring
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                d₁)
             (and
                (@ne.{1} nat
                   (int.nat_abs
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                   (@has_one.one.{0} nat nat.has_one))
                (@ne.{1} int d₁ (@has_zero.zero.{0} int int.has_zero)))
             (@multiplicity.finite_int_iff
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                d₁)
             (@and.intro
                (@ne.{1} nat
                   (int.nat_abs
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                   (@has_one.one.{0} nat nat.has_one))
                (@ne.{1} int d₁ (@has_zero.zero.{0} int int.has_zero))
                (@ne.symm.{1} nat (@has_one.one.{0} nat nat.has_one)
                   (int.nat_abs
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                   (@ne_of_lt.{0} nat
                      (@partial_order.to_preorder.{0} nat
                         (@ordered_comm_monoid.to_partial_order.{0} nat
                            (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                               (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
                      (@has_one.one.{0} nat nat.has_one)
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@nat.prime.one_lt p p_prime)))
                (λ (hd : @eq.{1} int d₁ (@has_zero.zero.{0} int int.has_zero)),
                   false.rec.{0} false
                     (@eq.mp.{0} (@eq.{1} rat (rat.mk n₁ d₁) (rat.mk n₁ d₁)) false
                        (@eq.trans.{1} Prop (@eq.{1} rat (rat.mk n₁ d₁) (rat.mk n₁ d₁))
                           (@eq.{1} rat (rat.mk n₁ d₁) (@has_zero.zero.{0} rat rat.has_zero))
                           false
                           ((λ (a a_1 : rat) (e_1 : @eq.{1} rat a a_1) (a_2 a_3 : rat) (e_2 : @eq.{1} rat a_2 a_3),
                               @congr.{1 1} rat Prop (@eq.{1} rat a) (@eq.{1} rat a_1) a_2 a_3
                                 (@congr_arg.{1 1} rat (rat → Prop) a a_1 (@eq.{1} rat) e_1)
                                 e_2)
                              (rat.mk n₁ d₁)
                              (rat.mk n₁ d₁)
                              (@eq.refl.{1} rat (rat.mk n₁ d₁))
                              (rat.mk n₁ d₁)
                              (@has_zero.zero.{0} rat rat.has_zero)
                              (@eq.trans.{1} rat (rat.mk n₁ d₁) (rat.mk n₁ (@has_zero.zero.{0} int int.has_zero))
                                 (@has_zero.zero.{0} rat rat.has_zero)
                                 ((λ (a a_1 : int) (e_1 : @eq.{1} int a a_1) (a_2 a_3 : int)
                                   (e_2 : @eq.{1} int a_2 a_3),
                                     @congr.{1 1} int rat (rat.mk a) (rat.mk a_1) a_2 a_3
                                       (@congr_arg.{1 1} int (int → rat) a a_1 rat.mk e_1)
                                       e_2)
                                    n₁
                                    n₁
                                    (@eq.refl.{1} int n₁)
                                    d₁
                                    (@has_zero.zero.{0} int int.has_zero)
                                    hd)
                                 (rat.mk_zero n₁)))
                           (@propext (@eq.{1} rat (rat.mk n₁ d₁) (@has_zero.zero.{0} rat rat.has_zero)) false
                              (@iff_false_intro (@eq.{1} rat (rat.mk n₁ d₁) (@has_zero.zero.{0} rat rat.has_zero))
                                 (@rat.mk_ne_zero_of_ne_zero n₁ d₁ hn₁ hd₁))))
                        (@rfl.{1} rat (rat.mk n₁ d₁))))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>205        ← multiplicity.mul&#x27; (nat.prime_iff_prime_int.1 p_prime) hf2,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='multiplicity.mul&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='nat.prime_iff_prime_int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='p_prime'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hf2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/ring_theory/multiplicity.lean&#x27;, &#x27;line&#x27;: 302, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/gcd_domain.lean&#x27;, &#x27;line&#x27;: 579, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : integral_domain.{0} α] [_inst_2 : @decidable_rel.{1} α (@has_dvd.dvd.{0} α (@comm_semiring_has_dvd.{0} α (@nonzero_comm_semiring.to_comm_semiring.{0} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} α (@integral_domain.to_nonzero_comm_ring.{0} α _inst_1)))))] {p a b : α} (hp : @prime.{0} α (@nonzero_comm_semiring.to_comm_semiring.{0} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} α (@integral_domain.to_nonzero_comm_ring.{0} α _inst_1))) p) (h : @roption.dom.{0} nat (@multiplicity.{0} α (@nonzero_comm_semiring.to_comm_semiring.{0} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} α (@integral_domain.to_nonzero_comm_ring.{0} α _inst_1))) (λ (a b : α), _inst_2 a b) p (@has_mul.mul.{0} α (@no_zero_divisors.to_has_mul.{0} α (@domain.to_no_zero_divisors.{0} α (@integral_domain.to_domain.{0} α _inst_1))) a b))), @eq.{1} nat (@roption.get.{0} nat (@multiplicity.{0} α (@nonzero_comm_semiring.to_comm_semiring.{0} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} α (@integral_domain.to_nonzero_comm_ring.{0} α _inst_1))) (λ (a b : α), _inst_2 a b) p (@has_mul.mul.{0} α (@no_zero_divisors.to_has_mul.{0} α (@domain.to_no_zero_divisors.{0} α (@integral_domain.to_domain.{0} α _inst_1))) a b)) h) (@has_add.add.{0} nat nat.has_add (@roption.get.{0} nat (@multiplicity.{0} α (@nonzero_comm_semiring.to_comm_semiring.{0} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} α (@integral_domain.to_nonzero_comm_ring.{0} α _inst_1))) (λ (a b : α), _inst_2 a b) p a) (@and.left (@multiplicity.finite.{0} α (@nonzero_comm_semiring.to_comm_semiring.{0} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} α (@integral_domain.to_nonzero_comm_ring.{0} α _inst_1))) p a) (@multiplicity.finite.{0} α (@nonzero_comm_semiring.to_comm_semiring.{0} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} α (@integral_domain.to_nonzero_comm_ring.{0} α _inst_1))) p b) (@iff.mp (@multiplicity.finite.{0} α (@nonzero_comm_semiring.to_comm_semiring.{0} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} α (@integral_domain.to_nonzero_comm_ring.{0} α _inst_1))) p (@has_mul.mul.{0} α (@no_zero_divisors.to_has_mul.{0} α (@domain.to_no_zero_divisors.{0} α (@integral_domain.to_domain.{0} α _inst_1))) a b)) (and (@multiplicity.finite.{0} α (@nonzero_comm_semiring.to_comm_semiring.{0} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} α (@integral_domain.to_nonzero_comm_ring.{0} α _inst_1))) p a) (@multiplicity.finite.{0} α (@nonzero_comm_semiring.to_comm_semiring.{0} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} α (@integral_domain.to_nonzero_comm_ring.{0} α _inst_1))) p b)) (@multiplicity.finite_mul_iff.{0} α _inst_1 (λ (a b : α), _inst_2 a b) p a b hp) h))) (@roption.get.{0} nat (@multiplicity.{0} α (@nonzero_comm_semiring.to_comm_semiring.{0} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} α (@integral_domain.to_nonzero_comm_ring.{0} α _inst_1))) (λ (a b : α), _inst_2 a b) p b) (@and.right (@multiplicity.finite.{0} α (@nonzero_comm_semiring.to_comm_semiring.{0} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} α (@integral_domain.to_nonzero_comm_ring.{0} α _inst_1))) p a) (@multiplicity.finite.{0} α (@nonzero_comm_semiring.to_comm_semiring.{0} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} α (@integral_domain.to_nonzero_comm_ring.{0} α _inst_1))) p b) (@iff.mp (@multiplicity.finite.{0} α (@nonzero_comm_semiring.to_comm_semiring.{0} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} α (@integral_domain.to_nonzero_comm_ring.{0} α _inst_1))) p (@has_mul.mul.{0} α (@no_zero_divisors.to_has_mul.{0} α (@domain.to_no_zero_divisors.{0} α (@integral_domain.to_domain.{0} α _inst_1))) a b)) (and (@multiplicity.finite.{0} α (@nonzero_comm_semiring.to_comm_semiring.{0} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} α (@integral_domain.to_nonzero_comm_ring.{0} α _inst_1))) p a) (@multiplicity.finite.{0} α (@nonzero_comm_semiring.to_comm_semiring.{0} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} α (@integral_domain.to_nonzero_comm_ring.{0} α _inst_1))) p b)) (@multiplicity.finite_mul_iff.{0} α _inst_1 (λ (a b : α), _inst_2 a b) p a b hp) h))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {p : nat}, iff (nat.prime p) (@prime.{0} int int.comm_semiring (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat.prime p'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@multiplicity.finite.{0} int int.comm_semiring (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p) (@has_mul.mul.{0} int int.has_mul n₂ d₁)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
p_prime : nat.prime p,
n₁ n₂ d₁ d₂ : int,
hn₁ : @ne.{1} int n₁ (@has_zero.zero.{0} int int.has_zero),
hn₂ : @ne.{1} int n₂ (@has_zero.zero.{0} int int.has_zero),
hd₁ : @ne.{1} int d₁ (@has_zero.zero.{0} int int.has_zero),
hd₂ : @ne.{1} int d₂ (@has_zero.zero.{0} int int.has_zero),
hf1 :
  @multiplicity.finite.{0} int int.comm_semiring
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
    (@has_mul.mul.{0} int int.has_mul n₁ d₂),
hf2 :
  @multiplicity.finite.{0} int int.comm_semiring
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
    (@has_mul.mul.{0} int int.has_mul n₂ d₁)
| @has_le.le.{0} nat nat.has_le
    (@roption.get.{0} nat
       (@multiplicity.{0} int
          (@nonzero_comm_semiring.to_comm_semiring.{0} int
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} int
                (@integral_domain.to_nonzero_comm_ring.{0} int
                   (@normalization_domain.to_integral_domain.{0} int int.normalization_domain))))
          (λ (a b : int), (λ (a b : int), int.decidable_dvd a b) a b)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
          (@has_mul.mul.{0} int
             (@no_zero_divisors.to_has_mul.{0} int
                (@domain.to_no_zero_divisors.{0} int
                   (@integral_domain.to_domain.{0} int
                      (@normalization_domain.to_integral_domain.{0} int int.normalization_domain))))
             n₁
             d₂))
       hf1)
    (@has_add.add.{0} nat
       (@add_semigroup.to_has_add.{0} nat (@add_comm_semigroup.to_add_semigroup.{0} nat nat.add_comm_semigroup))
       (@roption.get.{0} nat
          (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
             n₂)
          (@iff.mpr
             (@multiplicity.finite.{0} int int.comm_semiring
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                n₂)
             (and
                (@ne.{1} nat
                   (int.nat_abs
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                   (@has_one.one.{0} nat nat.has_one))
                (@ne.{1} int n₂ (@has_zero.zero.{0} int int.has_zero)))
             (@multiplicity.finite_int_iff
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                n₂)
             (@and.intro
                (@ne.{1} nat
                   (int.nat_abs
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                   (@has_one.one.{0} nat nat.has_one))
                (@ne.{1} int n₂ (@has_zero.zero.{0} int int.has_zero))
                (@ne.symm.{1} nat (@has_one.one.{0} nat nat.has_one)
                   (int.nat_abs
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                   (@ne_of_lt.{0} nat
                      (@partial_order.to_preorder.{0} nat
                         (@ordered_comm_monoid.to_partial_order.{0} nat
                            (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                               (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
                      (@has_one.one.{0} nat nat.has_one)
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@nat.prime.one_lt p p_prime)))
                (λ (hn : @eq.{1} int n₂ (@has_zero.zero.{0} int int.has_zero)),
                   false.rec.{0} false
                     (@eq.mp.{0} (@eq.{1} rat (rat.mk n₂ d₂) (rat.mk n₂ d₂)) false
                        (@eq.trans.{1} Prop (@eq.{1} rat (rat.mk n₂ d₂) (rat.mk n₂ d₂))
                           (@eq.{1} rat (rat.mk n₂ d₂) (@has_zero.zero.{0} rat rat.has_zero))
                           false
                           ((λ (a a_1 : rat) (e_1 : @eq.{1} rat a a_1) (a_2 a_3 : rat) (e_2 : @eq.{1} rat a_2 a_3),
                               @congr.{1 1} rat Prop (@eq.{1} rat a) (@eq.{1} rat a_1) a_2 a_3
                                 (@congr_arg.{1 1} rat (rat → Prop) a a_1 (@eq.{1} rat) e_1)
                                 e_2)
                              (rat.mk n₂ d₂)
                              (rat.mk n₂ d₂)
                              (@eq.refl.{1} rat (rat.mk n₂ d₂))
                              (rat.mk n₂ d₂)
                              (@has_zero.zero.{0} rat rat.has_zero)
                              (@eq.trans.{1} rat (rat.mk n₂ d₂) (rat.mk (@has_zero.zero.{0} int int.has_zero) d₂)
                                 (@has_zero.zero.{0} rat rat.has_zero)
                                 ((λ (a a_1 : int) (e_1 : @eq.{1} int a a_1) (a_2 a_3 : int)
                                   (e_2 : @eq.{1} int a_2 a_3),
                                     @congr.{1 1} int rat (rat.mk a) (rat.mk a_1) a_2 a_3
                                       (@congr_arg.{1 1} int (int → rat) a a_1 rat.mk e_1)
                                       e_2)
                                    n₂
                                    (@has_zero.zero.{0} int int.has_zero)
                                    hn
                                    d₂
                                    d₂
                                    (@eq.refl.{1} int d₂))
                                 (rat.zero_mk d₂)))
                           (@propext (@eq.{1} rat (rat.mk n₂ d₂) (@has_zero.zero.{0} rat rat.has_zero)) false
                              (@iff_false_intro (@eq.{1} rat (rat.mk n₂ d₂) (@has_zero.zero.{0} rat rat.has_zero))
                                 (@rat.mk_ne_zero_of_ne_zero n₂ d₂ hn₂ hd₂))))
                        (@rfl.{1} rat (rat.mk n₂ d₂)))))))
       (@roption.get.{0} nat
          (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
             d₁)
          (@iff.mpr
             (@multiplicity.finite.{0} int int.comm_semiring
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                d₁)
             (and
                (@ne.{1} nat
                   (int.nat_abs
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                   (@has_one.one.{0} nat nat.has_one))
                (@ne.{1} int d₁ (@has_zero.zero.{0} int int.has_zero)))
             (@multiplicity.finite_int_iff
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                d₁)
             (@and.intro
                (@ne.{1} nat
                   (int.nat_abs
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                   (@has_one.one.{0} nat nat.has_one))
                (@ne.{1} int d₁ (@has_zero.zero.{0} int int.has_zero))
                (@ne.symm.{1} nat (@has_one.one.{0} nat nat.has_one)
                   (int.nat_abs
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                   (@ne_of_lt.{0} nat
                      (@partial_order.to_preorder.{0} nat
                         (@ordered_comm_monoid.to_partial_order.{0} nat
                            (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                               (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
                      (@has_one.one.{0} nat nat.has_one)
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@nat.prime.one_lt p p_prime)))
                (λ (hd : @eq.{1} int d₁ (@has_zero.zero.{0} int int.has_zero)),
                   false.rec.{0} false
                     (@eq.mp.{0} (@eq.{1} rat (rat.mk n₁ d₁) (rat.mk n₁ d₁)) false
                        (@eq.trans.{1} Prop (@eq.{1} rat (rat.mk n₁ d₁) (rat.mk n₁ d₁))
                           (@eq.{1} rat (rat.mk n₁ d₁) (@has_zero.zero.{0} rat rat.has_zero))
                           false
                           ((λ (a a_1 : rat) (e_1 : @eq.{1} rat a a_1) (a_2 a_3 : rat) (e_2 : @eq.{1} rat a_2 a_3),
                               @congr.{1 1} rat Prop (@eq.{1} rat a) (@eq.{1} rat a_1) a_2 a_3
                                 (@congr_arg.{1 1} rat (rat → Prop) a a_1 (@eq.{1} rat) e_1)
                                 e_2)
                              (rat.mk n₁ d₁)
                              (rat.mk n₁ d₁)
                              (@eq.refl.{1} rat (rat.mk n₁ d₁))
                              (rat.mk n₁ d₁)
                              (@has_zero.zero.{0} rat rat.has_zero)
                              (@eq.trans.{1} rat (rat.mk n₁ d₁) (rat.mk n₁ (@has_zero.zero.{0} int int.has_zero))
                                 (@has_zero.zero.{0} rat rat.has_zero)
                                 ((λ (a a_1 : int) (e_1 : @eq.{1} int a a_1) (a_2 a_3 : int)
                                   (e_2 : @eq.{1} int a_2 a_3),
                                     @congr.{1 1} int rat (rat.mk a) (rat.mk a_1) a_2 a_3
                                       (@congr_arg.{1 1} int (int → rat) a a_1 rat.mk e_1)
                                       e_2)
                                    n₁
                                    n₁
                                    (@eq.refl.{1} int n₁)
                                    d₁
                                    (@has_zero.zero.{0} int int.has_zero)
                                    hd)
                                 (rat.mk_zero n₁)))
                           (@propext (@eq.{1} rat (rat.mk n₁ d₁) (@has_zero.zero.{0} rat rat.has_zero)) false
                              (@iff_false_intro (@eq.{1} rat (rat.mk n₁ d₁) (@has_zero.zero.{0} rat rat.has_zero))
                                 (@rat.mk_ne_zero_of_ne_zero n₁ d₁ hn₁ hd₁))))
                        (@rfl.{1} rat (rat.mk n₁ d₁))))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
p_prime : nat.prime p,
n₁ n₂ d₁ d₂ : int,
hn₁ : @ne.{1} int n₁ (@has_zero.zero.{0} int int.has_zero),
hn₂ : @ne.{1} int n₂ (@has_zero.zero.{0} int int.has_zero),
hd₁ : @ne.{1} int d₁ (@has_zero.zero.{0} int int.has_zero),
hd₂ : @ne.{1} int d₂ (@has_zero.zero.{0} int int.has_zero),
hf1 :
  @multiplicity.finite.{0} int int.comm_semiring
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
    (@has_mul.mul.{0} int int.has_mul n₁ d₂),
hf2 :
  @multiplicity.finite.{0} int int.comm_semiring
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
    (@has_mul.mul.{0} int int.has_mul n₂ d₁)
| @has_le.le.{0} nat nat.has_le
    (@roption.get.{0} nat
       (@multiplicity.{0} int
          (@nonzero_comm_semiring.to_comm_semiring.{0} int
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} int
                (@integral_domain.to_nonzero_comm_ring.{0} int
                   (@normalization_domain.to_integral_domain.{0} int int.normalization_domain))))
          (λ (a b : int), (λ (a b : int), int.decidable_dvd a b) a b)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
          (@has_mul.mul.{0} int
             (@no_zero_divisors.to_has_mul.{0} int
                (@domain.to_no_zero_divisors.{0} int
                   (@integral_domain.to_domain.{0} int
                      (@normalization_domain.to_integral_domain.{0} int int.normalization_domain))))
             n₁
             d₂))
       hf1)
    (@roption.get.{0} nat
       (@multiplicity.{0} int
          (@nonzero_comm_semiring.to_comm_semiring.{0} int
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} int
                (@integral_domain.to_nonzero_comm_ring.{0} int
                   (@normalization_domain.to_integral_domain.{0} int int.normalization_domain))))
          (λ (a b : int), (λ (a b : int), int.decidable_dvd a b) a b)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
          (@has_mul.mul.{0} int
             (@no_zero_divisors.to_has_mul.{0} int
                (@domain.to_no_zero_divisors.{0} int
                   (@integral_domain.to_domain.{0} int
                      (@normalization_domain.to_integral_domain.{0} int int.normalization_domain))))
             n₂
             d₁))
       hf2)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>206        enat.get_le_get, multiplicity_le_multiplicity_iff]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='enat.get_le_get'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='multiplicity.multiplicity_le_multiplicity_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/nat/enat.lean&#x27;, &#x27;line&#x27;: 86, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/ring_theory/multiplicity.lean&#x27;, &#x27;line&#x27;: 141, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {x y : enat} {hx : @roption.dom.{0} nat x} {hy : @roption.dom.{0} nat y}, iff (@has_le.le.{0} nat nat.has_le (@roption.get.{0} nat x hx) (@roption.get.{0} nat y hy)) (@has_le.le.{0} enat enat.has_le x y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : comm_semiring.{0} α] [_inst_2 : @decidable_rel.{1} α (@has_dvd.dvd.{0} α (@comm_semiring_has_dvd.{0} α _inst_1))] {a b c d : α}, iff (@has_le.le.{0} enat enat.has_le (@multiplicity.{0} α _inst_1 (λ (a b : α), _inst_2 a b) a b) (@multiplicity.{0} α _inst_1 (λ (a b : α), _inst_2 a b) c d)) (∀ (n : nat), @has_dvd.dvd.{0} α (@comm_semiring_has_dvd.{0} α _inst_1) (@has_pow.pow.{0 0} α nat (@monoid.has_pow.{0} α (@semiring.to_monoid.{0} α (@comm_semiring.to_semiring.{0} α _inst_1))) a n) b → @has_dvd.dvd.{0} α (@comm_semiring_has_dvd.{0} α _inst_1) (@has_pow.pow.{0 0} α nat (@monoid.has_pow.{0} α (@semiring.to_monoid.{0} α (@comm_semiring.to_semiring.{0} α _inst_1))) c n) d)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
p_prime : nat.prime p,
n₁ n₂ d₁ d₂ : int,
hn₁ : @ne.{1} int n₁ (@has_zero.zero.{0} int int.has_zero),
hn₂ : @ne.{1} int n₂ (@has_zero.zero.{0} int int.has_zero),
hd₁ : @ne.{1} int d₁ (@has_zero.zero.{0} int int.has_zero),
hd₂ : @ne.{1} int d₂ (@has_zero.zero.{0} int int.has_zero),
hf1 :
  @multiplicity.finite.{0} int int.comm_semiring
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
    (@has_mul.mul.{0} int int.has_mul n₁ d₂),
hf2 :
  @multiplicity.finite.{0} int int.comm_semiring
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
    (@has_mul.mul.{0} int int.has_mul n₂ d₁)
| @has_le.le.{0} nat nat.has_le
    (@roption.get.{0} nat
       (@multiplicity.{0} int
          (@nonzero_comm_semiring.to_comm_semiring.{0} int
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} int
                (@integral_domain.to_nonzero_comm_ring.{0} int
                   (@normalization_domain.to_integral_domain.{0} int int.normalization_domain))))
          (λ (a b : int), (λ (a b : int), int.decidable_dvd a b) a b)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
          (@has_mul.mul.{0} int
             (@no_zero_divisors.to_has_mul.{0} int
                (@domain.to_no_zero_divisors.{0} int
                   (@integral_domain.to_domain.{0} int
                      (@normalization_domain.to_integral_domain.{0} int int.normalization_domain))))
             n₁
             d₂))
       hf1)
    (@roption.get.{0} nat
       (@multiplicity.{0} int
          (@nonzero_comm_semiring.to_comm_semiring.{0} int
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} int
                (@integral_domain.to_nonzero_comm_ring.{0} int
                   (@normalization_domain.to_integral_domain.{0} int int.normalization_domain))))
          (λ (a b : int), (λ (a b : int), int.decidable_dvd a b) a b)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
          (@has_mul.mul.{0} int
             (@no_zero_divisors.to_has_mul.{0} int
                (@domain.to_no_zero_divisors.{0} int
                   (@integral_domain.to_domain.{0} int
                      (@normalization_domain.to_integral_domain.{0} int int.normalization_domain))))
             n₂
             d₁))
       hf2)'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
p_prime : nat.prime p,
n₁ n₂ d₁ d₂ : int,
hn₁ : @ne.{1} int n₁ (@has_zero.zero.{0} int int.has_zero),
hn₂ : @ne.{1} int n₂ (@has_zero.zero.{0} int int.has_zero),
hd₁ : @ne.{1} int d₁ (@has_zero.zero.{0} int int.has_zero),
hd₂ : @ne.{1} int d₂ (@has_zero.zero.{0} int int.has_zero),
hf1 :
  @multiplicity.finite.{0} int int.comm_semiring
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
    (@has_mul.mul.{0} int int.has_mul n₁ d₂),
hf2 :
  @multiplicity.finite.{0} int int.comm_semiring
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
    (@has_mul.mul.{0} int int.has_mul n₂ d₁)
| @has_le.le.{0} enat enat.has_le
    (@multiplicity.{0} int
       (@nonzero_comm_semiring.to_comm_semiring.{0} int
          (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} int
             (@integral_domain.to_nonzero_comm_ring.{0} int
                (@normalization_domain.to_integral_domain.{0} int int.normalization_domain))))
       (λ (a b : int), (λ (a b : int), int.decidable_dvd a b) a b)
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
       (@has_mul.mul.{0} int
          (@no_zero_divisors.to_has_mul.{0} int
             (@domain.to_no_zero_divisors.{0} int
                (@integral_domain.to_domain.{0} int
                   (@normalization_domain.to_integral_domain.{0} int int.normalization_domain))))
          n₁
          d₂))
    (@multiplicity.{0} int
       (@nonzero_comm_semiring.to_comm_semiring.{0} int
          (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} int
             (@integral_domain.to_nonzero_comm_ring.{0} int
                (@normalization_domain.to_integral_domain.{0} int int.normalization_domain))))
       (λ (a b : int), (λ (a b : int), int.decidable_dvd a b) a b)
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
       (@has_mul.mul.{0} int
          (@no_zero_divisors.to_has_mul.{0} int
             (@domain.to_no_zero_divisors.{0} int
                (@integral_domain.to_domain.{0} int
                   (@normalization_domain.to_integral_domain.{0} int int.normalization_domain))))
          n₂
          d₁))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='lime'><a title='p : nat,
p_prime : nat.prime p,
n₁ n₂ d₁ d₂ : int,
hn₁ : @ne.{1} int n₁ (@has_zero.zero.{0} int int.has_zero),
hn₂ : @ne.{1} int n₂ (@has_zero.zero.{0} int int.has_zero),
hd₁ : @ne.{1} int d₁ (@has_zero.zero.{0} int int.has_zero),
hd₂ : @ne.{1} int d₂ (@has_zero.zero.{0} int int.has_zero),
hf1 :
  @multiplicity.finite.{0} int int.comm_semiring
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
    (@has_mul.mul.{0} int int.has_mul n₁ d₂),
hf2 :
  @multiplicity.finite.{0} int int.comm_semiring
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
    (@has_mul.mul.{0} int int.has_mul n₂ d₁)
| @has_le.le.{0} nat nat.has_le
    (@has_add.add.{0} nat nat.has_add
       (@roption.get.{0} nat
          (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
             n₁)
          (@iff.mpr
             (@multiplicity.finite.{0} int int.comm_semiring
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                n₁)
             (and
                (@ne.{1} nat
                   (int.nat_abs
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                   (@has_one.one.{0} nat nat.has_one))
                (@ne.{1} int n₁ (@has_zero.zero.{0} int int.has_zero)))
             (@multiplicity.finite_int_iff
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                n₁)
             (@and.intro
                (@ne.{1} nat
                   (int.nat_abs
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                   (@has_one.one.{0} nat nat.has_one))
                (@ne.{1} int n₁ (@has_zero.zero.{0} int int.has_zero))
                (@ne.symm.{1} nat (@has_one.one.{0} nat nat.has_one)
                   (int.nat_abs
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                   (@ne_of_lt.{0} nat
                      (@partial_order.to_preorder.{0} nat
                         (@ordered_comm_monoid.to_partial_order.{0} nat
                            (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                               (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
                      (@has_one.one.{0} nat nat.has_one)
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@nat.prime.one_lt p p_prime)))
                (λ (hn : @eq.{1} int n₁ (@has_zero.zero.{0} int int.has_zero)),
                   false.rec.{0} false
                     (@eq.mp.{0} (@eq.{1} rat (rat.mk n₁ d₁) (rat.mk n₁ d₁)) false
                        (@eq.trans.{1} Prop (@eq.{1} rat (rat.mk n₁ d₁) (rat.mk n₁ d₁))
                           (@eq.{1} rat (rat.mk n₁ d₁) (@has_zero.zero.{0} rat rat.has_zero))
                           false
                           ((λ (a a_1 : rat) (e_1 : @eq.{1} rat a a_1) (a_2 a_3 : rat) (e_2 : @eq.{1} rat a_2 a_3),
                               @congr.{1 1} rat Prop (@eq.{1} rat a) (@eq.{1} rat a_1) a_2 a_3
                                 (@congr_arg.{1 1} rat (rat → Prop) a a_1 (@eq.{1} rat) e_1)
                                 e_2)
                              (rat.mk n₁ d₁)
                              (rat.mk n₁ d₁)
                              (@eq.refl.{1} rat (rat.mk n₁ d₁))
                              (rat.mk n₁ d₁)
                              (@has_zero.zero.{0} rat rat.has_zero)
                              (@eq.trans.{1} rat (rat.mk n₁ d₁) (rat.mk (@has_zero.zero.{0} int int.has_zero) d₁)
                                 (@has_zero.zero.{0} rat rat.has_zero)
                                 ((λ (a a_1 : int) (e_1 : @eq.{1} int a a_1) (a_2 a_3 : int)
                                   (e_2 : @eq.{1} int a_2 a_3),
                                     @congr.{1 1} int rat (rat.mk a) (rat.mk a_1) a_2 a_3
                                       (@congr_arg.{1 1} int (int → rat) a a_1 rat.mk e_1)
                                       e_2)
                                    n₁
                                    (@has_zero.zero.{0} int int.has_zero)
                                    hn
                                    d₁
                                    d₁
                                    (@eq.refl.{1} int d₁))
                                 (rat.zero_mk d₁)))
                           (@propext (@eq.{1} rat (rat.mk n₁ d₁) (@has_zero.zero.{0} rat rat.has_zero)) false
                              (@iff_false_intro (@eq.{1} rat (rat.mk n₁ d₁) (@has_zero.zero.{0} rat rat.has_zero))
                                 (@rat.mk_ne_zero_of_ne_zero n₁ d₁ hn₁ hd₁))))
                        (@rfl.{1} rat (rat.mk n₁ d₁)))))))
       (@roption.get.{0} nat
          (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
             d₂)
          (@iff.mpr
             (@multiplicity.finite.{0} int int.comm_semiring
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                d₂)
             (and
                (@ne.{1} nat
                   (int.nat_abs
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                   (@has_one.one.{0} nat nat.has_one))
                (@ne.{1} int d₂ (@has_zero.zero.{0} int int.has_zero)))
             (@multiplicity.finite_int_iff
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                d₂)
             (@and.intro
                (@ne.{1} nat
                   (int.nat_abs
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                   (@has_one.one.{0} nat nat.has_one))
                (@ne.{1} int d₂ (@has_zero.zero.{0} int int.has_zero))
                (@ne.symm.{1} nat (@has_one.one.{0} nat nat.has_one)
                   (int.nat_abs
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                   (@ne_of_lt.{0} nat
                      (@partial_order.to_preorder.{0} nat
                         (@ordered_comm_monoid.to_partial_order.{0} nat
                            (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                               (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
                      (@has_one.one.{0} nat nat.has_one)
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@nat.prime.one_lt p p_prime)))
                (λ (hd : @eq.{1} int d₂ (@has_zero.zero.{0} int int.has_zero)),
                   false.rec.{0} false
                     (@eq.mp.{0} (@eq.{1} rat (rat.mk n₂ d₂) (rat.mk n₂ d₂)) false
                        (@eq.trans.{1} Prop (@eq.{1} rat (rat.mk n₂ d₂) (rat.mk n₂ d₂))
                           (@eq.{1} rat (rat.mk n₂ d₂) (@has_zero.zero.{0} rat rat.has_zero))
                           false
                           ((λ (a a_1 : rat) (e_1 : @eq.{1} rat a a_1) (a_2 a_3 : rat) (e_2 : @eq.{1} rat a_2 a_3),
                               @congr.{1 1} rat Prop (@eq.{1} rat a) (@eq.{1} rat a_1) a_2 a_3
                                 (@congr_arg.{1 1} rat (rat → Prop) a a_1 (@eq.{1} rat) e_1)
                                 e_2)
                              (rat.mk n₂ d₂)
                              (rat.mk n₂ d₂)
                              (@eq.refl.{1} rat (rat.mk n₂ d₂))
                              (rat.mk n₂ d₂)
                              (@has_zero.zero.{0} rat rat.has_zero)
                              (@eq.trans.{1} rat (rat.mk n₂ d₂) (rat.mk n₂ (@has_zero.zero.{0} int int.has_zero))
                                 (@has_zero.zero.{0} rat rat.has_zero)
                                 ((λ (a a_1 : int) (e_1 : @eq.{1} int a a_1) (a_2 a_3 : int)
                                   (e_2 : @eq.{1} int a_2 a_3),
                                     @congr.{1 1} int rat (rat.mk a) (rat.mk a_1) a_2 a_3
                                       (@congr_arg.{1 1} int (int → rat) a a_1 rat.mk e_1)
                                       e_2)
                                    n₂
                                    n₂
                                    (@eq.refl.{1} int n₂)
                                    d₂
                                    (@has_zero.zero.{0} int int.has_zero)
                                    hd)
                                 (rat.mk_zero n₂)))
                           (@propext (@eq.{1} rat (rat.mk n₂ d₂) (@has_zero.zero.{0} rat rat.has_zero)) false
                              (@iff_false_intro (@eq.{1} rat (rat.mk n₂ d₂) (@has_zero.zero.{0} rat rat.has_zero))
                                 (@rat.mk_ne_zero_of_ne_zero n₂ d₂ hn₂ hd₂))))
                        (@rfl.{1} rat (rat.mk n₂ d₂))))))))
    (@has_add.add.{0} nat nat.has_add
       (@roption.get.{0} nat
          (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
             d₁)
          (@iff.mpr
             (@multiplicity.finite.{0} int int.comm_semiring
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                d₁)
             (and
                (@ne.{1} nat
                   (int.nat_abs
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                   (@has_one.one.{0} nat nat.has_one))
                (@ne.{1} int d₁ (@has_zero.zero.{0} int int.has_zero)))
             (@multiplicity.finite_int_iff
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                d₁)
             (@and.intro
                (@ne.{1} nat
                   (int.nat_abs
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                   (@has_one.one.{0} nat nat.has_one))
                (@ne.{1} int d₁ (@has_zero.zero.{0} int int.has_zero))
                (@ne.symm.{1} nat (@has_one.one.{0} nat nat.has_one)
                   (int.nat_abs
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                   (@ne_of_lt.{0} nat
                      (@partial_order.to_preorder.{0} nat
                         (@ordered_comm_monoid.to_partial_order.{0} nat
                            (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                               (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
                      (@has_one.one.{0} nat nat.has_one)
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@nat.prime.one_lt p p_prime)))
                (λ (hd : @eq.{1} int d₁ (@has_zero.zero.{0} int int.has_zero)),
                   false.rec.{0} false
                     (@eq.mp.{0} (@eq.{1} rat (rat.mk n₁ d₁) (rat.mk n₁ d₁)) false
                        (@eq.trans.{1} Prop (@eq.{1} rat (rat.mk n₁ d₁) (rat.mk n₁ d₁))
                           (@eq.{1} rat (rat.mk n₁ d₁) (@has_zero.zero.{0} rat rat.has_zero))
                           false
                           ((λ (a a_1 : rat) (e_1 : @eq.{1} rat a a_1) (a_2 a_3 : rat) (e_2 : @eq.{1} rat a_2 a_3),
                               @congr.{1 1} rat Prop (@eq.{1} rat a) (@eq.{1} rat a_1) a_2 a_3
                                 (@congr_arg.{1 1} rat (rat → Prop) a a_1 (@eq.{1} rat) e_1)
                                 e_2)
                              (rat.mk n₁ d₁)
                              (rat.mk n₁ d₁)
                              (@eq.refl.{1} rat (rat.mk n₁ d₁))
                              (rat.mk n₁ d₁)
                              (@has_zero.zero.{0} rat rat.has_zero)
                              (@eq.trans.{1} rat (rat.mk n₁ d₁) (rat.mk n₁ (@has_zero.zero.{0} int int.has_zero))
                                 (@has_zero.zero.{0} rat rat.has_zero)
                                 ((λ (a a_1 : int) (e_1 : @eq.{1} int a a_1) (a_2 a_3 : int)
                                   (e_2 : @eq.{1} int a_2 a_3),
                                     @congr.{1 1} int rat (rat.mk a) (rat.mk a_1) a_2 a_3
                                       (@congr_arg.{1 1} int (int → rat) a a_1 rat.mk e_1)
                                       e_2)
                                    n₁
                                    n₁
                                    (@eq.refl.{1} int n₁)
                                    d₁
                                    (@has_zero.zero.{0} int int.has_zero)
                                    hd)
                                 (rat.mk_zero n₁)))
                           (@propext (@eq.{1} rat (rat.mk n₁ d₁) (@has_zero.zero.{0} rat rat.has_zero)) false
                              (@iff_false_intro (@eq.{1} rat (rat.mk n₁ d₁) (@has_zero.zero.{0} rat rat.has_zero))
                                 (@rat.mk_ne_zero_of_ne_zero n₁ d₁ hn₁ hd₁))))
                        (@rfl.{1} rat (rat.mk n₁ d₁)))))))
       (@roption.get.{0} nat
          (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
             n₂)
          (@iff.mpr
             (@multiplicity.finite.{0} int int.comm_semiring
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                n₂)
             (and
                (@ne.{1} nat
                   (int.nat_abs
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                   (@has_one.one.{0} nat nat.has_one))
                (@ne.{1} int n₂ (@has_zero.zero.{0} int int.has_zero)))
             (@multiplicity.finite_int_iff
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                n₂)
             (@and.intro
                (@ne.{1} nat
                   (int.nat_abs
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                   (@has_one.one.{0} nat nat.has_one))
                (@ne.{1} int n₂ (@has_zero.zero.{0} int int.has_zero))
                (@ne.symm.{1} nat (@has_one.one.{0} nat nat.has_one)
                   (int.nat_abs
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                   (@ne_of_lt.{0} nat
                      (@partial_order.to_preorder.{0} nat
                         (@ordered_comm_monoid.to_partial_order.{0} nat
                            (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                               (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
                      (@has_one.one.{0} nat nat.has_one)
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@nat.prime.one_lt p p_prime)))
                (λ (hn : @eq.{1} int n₂ (@has_zero.zero.{0} int int.has_zero)),
                   false.rec.{0} false
                     (@eq.mp.{0} (@eq.{1} rat (rat.mk n₂ d₂) (rat.mk n₂ d₂)) false
                        (@eq.trans.{1} Prop (@eq.{1} rat (rat.mk n₂ d₂) (rat.mk n₂ d₂))
                           (@eq.{1} rat (rat.mk n₂ d₂) (@has_zero.zero.{0} rat rat.has_zero))
                           false
                           ((λ (a a_1 : rat) (e_1 : @eq.{1} rat a a_1) (a_2 a_3 : rat) (e_2 : @eq.{1} rat a_2 a_3),
                               @congr.{1 1} rat Prop (@eq.{1} rat a) (@eq.{1} rat a_1) a_2 a_3
                                 (@congr_arg.{1 1} rat (rat → Prop) a a_1 (@eq.{1} rat) e_1)
                                 e_2)
                              (rat.mk n₂ d₂)
                              (rat.mk n₂ d₂)
                              (@eq.refl.{1} rat (rat.mk n₂ d₂))
                              (rat.mk n₂ d₂)
                              (@has_zero.zero.{0} rat rat.has_zero)
                              (@eq.trans.{1} rat (rat.mk n₂ d₂) (rat.mk (@has_zero.zero.{0} int int.has_zero) d₂)
                                 (@has_zero.zero.{0} rat rat.has_zero)
                                 ((λ (a a_1 : int) (e_1 : @eq.{1} int a a_1) (a_2 a_3 : int)
                                   (e_2 : @eq.{1} int a_2 a_3),
                                     @congr.{1 1} int rat (rat.mk a) (rat.mk a_1) a_2 a_3
                                       (@congr_arg.{1 1} int (int → rat) a a_1 rat.mk e_1)
                                       e_2)
                                    n₂
                                    (@has_zero.zero.{0} int int.has_zero)
                                    hn
                                    d₂
                                    d₂
                                    (@eq.refl.{1} int d₂))
                                 (rat.zero_mk d₂)))
                           (@propext (@eq.{1} rat (rat.mk n₂ d₂) (@has_zero.zero.{0} rat rat.has_zero)) false
                              (@iff_false_intro (@eq.{1} rat (rat.mk n₂ d₂) (@has_zero.zero.{0} rat rat.has_zero))
                                 (@rat.mk_ne_zero_of_ne_zero n₂ d₂ hn₂ hd₂))))
                        (@rfl.{1} rat (rat.mk n₂ d₂))))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>207    }</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit name (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.ident)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) (lean.parser.pexpr std.prec.max))) → conv.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='conv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;(at id)?&#x27;, &#x27;(in expr)?&#x27;, &#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
p_prime : nat.prime p,
n₁ n₂ d₁ d₂ : int,
hn₁ : @ne.{1} int n₁ (@has_zero.zero.{0} int int.has_zero),
hn₂ : @ne.{1} int n₂ (@has_zero.zero.{0} int int.has_zero),
hd₁ : @ne.{1} int d₁ (@has_zero.zero.{0} int int.has_zero),
hd₂ : @ne.{1} int d₂ (@has_zero.zero.{0} int int.has_zero),
hf1 :
  @multiplicity.finite.{0} int int.comm_semiring
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
    (@has_mul.mul.{0} int int.has_mul n₁ d₂),
hf2 :
  @multiplicity.finite.{0} int int.comm_semiring
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
    (@has_mul.mul.{0} int int.has_mul n₂ d₁)
| @has_le.le.{0} nat nat.has_le
    (@has_add.add.{0} nat nat.has_add
       (@roption.get.{0} nat
          (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
             n₁)
          (@iff.mpr
             (@multiplicity.finite.{0} int int.comm_semiring
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                n₁)
             (and
                (@ne.{1} nat
                   (int.nat_abs
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                   (@has_one.one.{0} nat nat.has_one))
                (@ne.{1} int n₁ (@has_zero.zero.{0} int int.has_zero)))
             (@multiplicity.finite_int_iff
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                n₁)
             (@and.intro
                (@ne.{1} nat
                   (int.nat_abs
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                   (@has_one.one.{0} nat nat.has_one))
                (@ne.{1} int n₁ (@has_zero.zero.{0} int int.has_zero))
                (@ne.symm.{1} nat (@has_one.one.{0} nat nat.has_one)
                   (int.nat_abs
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                   (@ne_of_lt.{0} nat
                      (@partial_order.to_preorder.{0} nat
                         (@ordered_comm_monoid.to_partial_order.{0} nat
                            (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                               (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
                      (@has_one.one.{0} nat nat.has_one)
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@nat.prime.one_lt p p_prime)))
                (λ (hn : @eq.{1} int n₁ (@has_zero.zero.{0} int int.has_zero)),
                   false.rec.{0} false
                     (@eq.mp.{0} (@eq.{1} rat (rat.mk n₁ d₁) (rat.mk n₁ d₁)) false
                        (@eq.trans.{1} Prop (@eq.{1} rat (rat.mk n₁ d₁) (rat.mk n₁ d₁))
                           (@eq.{1} rat (rat.mk n₁ d₁) (@has_zero.zero.{0} rat rat.has_zero))
                           false
                           ((λ (a a_1 : rat) (e_1 : @eq.{1} rat a a_1) (a_2 a_3 : rat) (e_2 : @eq.{1} rat a_2 a_3),
                               @congr.{1 1} rat Prop (@eq.{1} rat a) (@eq.{1} rat a_1) a_2 a_3
                                 (@congr_arg.{1 1} rat (rat → Prop) a a_1 (@eq.{1} rat) e_1)
                                 e_2)
                              (rat.mk n₁ d₁)
                              (rat.mk n₁ d₁)
                              (@eq.refl.{1} rat (rat.mk n₁ d₁))
                              (rat.mk n₁ d₁)
                              (@has_zero.zero.{0} rat rat.has_zero)
                              (@eq.trans.{1} rat (rat.mk n₁ d₁) (rat.mk (@has_zero.zero.{0} int int.has_zero) d₁)
                                 (@has_zero.zero.{0} rat rat.has_zero)
                                 ((λ (a a_1 : int) (e_1 : @eq.{1} int a a_1) (a_2 a_3 : int)
                                   (e_2 : @eq.{1} int a_2 a_3),
                                     @congr.{1 1} int rat (rat.mk a) (rat.mk a_1) a_2 a_3
                                       (@congr_arg.{1 1} int (int → rat) a a_1 rat.mk e_1)
                                       e_2)
                                    n₁
                                    (@has_zero.zero.{0} int int.has_zero)
                                    hn
                                    d₁
                                    d₁
                                    (@eq.refl.{1} int d₁))
                                 (rat.zero_mk d₁)))
                           (@propext (@eq.{1} rat (rat.mk n₁ d₁) (@has_zero.zero.{0} rat rat.has_zero)) false
                              (@iff_false_intro (@eq.{1} rat (rat.mk n₁ d₁) (@has_zero.zero.{0} rat rat.has_zero))
                                 (@rat.mk_ne_zero_of_ne_zero n₁ d₁ hn₁ hd₁))))
                        (@rfl.{1} rat (rat.mk n₁ d₁)))))))
       (@roption.get.{0} nat
          (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
             d₂)
          (@iff.mpr
             (@multiplicity.finite.{0} int int.comm_semiring
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                d₂)
             (and
                (@ne.{1} nat
                   (int.nat_abs
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                   (@has_one.one.{0} nat nat.has_one))
                (@ne.{1} int d₂ (@has_zero.zero.{0} int int.has_zero)))
             (@multiplicity.finite_int_iff
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                d₂)
             (@and.intro
                (@ne.{1} nat
                   (int.nat_abs
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                   (@has_one.one.{0} nat nat.has_one))
                (@ne.{1} int d₂ (@has_zero.zero.{0} int int.has_zero))
                (@ne.symm.{1} nat (@has_one.one.{0} nat nat.has_one)
                   (int.nat_abs
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                   (@ne_of_lt.{0} nat
                      (@partial_order.to_preorder.{0} nat
                         (@ordered_comm_monoid.to_partial_order.{0} nat
                            (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                               (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
                      (@has_one.one.{0} nat nat.has_one)
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@nat.prime.one_lt p p_prime)))
                (λ (hd : @eq.{1} int d₂ (@has_zero.zero.{0} int int.has_zero)),
                   false.rec.{0} false
                     (@eq.mp.{0} (@eq.{1} rat (rat.mk n₂ d₂) (rat.mk n₂ d₂)) false
                        (@eq.trans.{1} Prop (@eq.{1} rat (rat.mk n₂ d₂) (rat.mk n₂ d₂))
                           (@eq.{1} rat (rat.mk n₂ d₂) (@has_zero.zero.{0} rat rat.has_zero))
                           false
                           ((λ (a a_1 : rat) (e_1 : @eq.{1} rat a a_1) (a_2 a_3 : rat) (e_2 : @eq.{1} rat a_2 a_3),
                               @congr.{1 1} rat Prop (@eq.{1} rat a) (@eq.{1} rat a_1) a_2 a_3
                                 (@congr_arg.{1 1} rat (rat → Prop) a a_1 (@eq.{1} rat) e_1)
                                 e_2)
                              (rat.mk n₂ d₂)
                              (rat.mk n₂ d₂)
                              (@eq.refl.{1} rat (rat.mk n₂ d₂))
                              (rat.mk n₂ d₂)
                              (@has_zero.zero.{0} rat rat.has_zero)
                              (@eq.trans.{1} rat (rat.mk n₂ d₂) (rat.mk n₂ (@has_zero.zero.{0} int int.has_zero))
                                 (@has_zero.zero.{0} rat rat.has_zero)
                                 ((λ (a a_1 : int) (e_1 : @eq.{1} int a a_1) (a_2 a_3 : int)
                                   (e_2 : @eq.{1} int a_2 a_3),
                                     @congr.{1 1} int rat (rat.mk a) (rat.mk a_1) a_2 a_3
                                       (@congr_arg.{1 1} int (int → rat) a a_1 rat.mk e_1)
                                       e_2)
                                    n₂
                                    n₂
                                    (@eq.refl.{1} int n₂)
                                    d₂
                                    (@has_zero.zero.{0} int int.has_zero)
                                    hd)
                                 (rat.mk_zero n₂)))
                           (@propext (@eq.{1} rat (rat.mk n₂ d₂) (@has_zero.zero.{0} rat rat.has_zero)) false
                              (@iff_false_intro (@eq.{1} rat (rat.mk n₂ d₂) (@has_zero.zero.{0} rat rat.has_zero))
                                 (@rat.mk_ne_zero_of_ne_zero n₂ d₂ hn₂ hd₂))))
                        (@rfl.{1} rat (rat.mk n₂ d₂))))))))
    (@has_add.add.{0} nat nat.has_add
       (@roption.get.{0} nat
          (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
             d₁)
          (@iff.mpr
             (@multiplicity.finite.{0} int int.comm_semiring
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                d₁)
             (and
                (@ne.{1} nat
                   (int.nat_abs
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                   (@has_one.one.{0} nat nat.has_one))
                (@ne.{1} int d₁ (@has_zero.zero.{0} int int.has_zero)))
             (@multiplicity.finite_int_iff
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                d₁)
             (@and.intro
                (@ne.{1} nat
                   (int.nat_abs
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                   (@has_one.one.{0} nat nat.has_one))
                (@ne.{1} int d₁ (@has_zero.zero.{0} int int.has_zero))
                (@ne.symm.{1} nat (@has_one.one.{0} nat nat.has_one)
                   (int.nat_abs
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                   (@ne_of_lt.{0} nat
                      (@partial_order.to_preorder.{0} nat
                         (@ordered_comm_monoid.to_partial_order.{0} nat
                            (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                               (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
                      (@has_one.one.{0} nat nat.has_one)
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@nat.prime.one_lt p p_prime)))
                (λ (hd : @eq.{1} int d₁ (@has_zero.zero.{0} int int.has_zero)),
                   false.rec.{0} false
                     (@eq.mp.{0} (@eq.{1} rat (rat.mk n₁ d₁) (rat.mk n₁ d₁)) false
                        (@eq.trans.{1} Prop (@eq.{1} rat (rat.mk n₁ d₁) (rat.mk n₁ d₁))
                           (@eq.{1} rat (rat.mk n₁ d₁) (@has_zero.zero.{0} rat rat.has_zero))
                           false
                           ((λ (a a_1 : rat) (e_1 : @eq.{1} rat a a_1) (a_2 a_3 : rat) (e_2 : @eq.{1} rat a_2 a_3),
                               @congr.{1 1} rat Prop (@eq.{1} rat a) (@eq.{1} rat a_1) a_2 a_3
                                 (@congr_arg.{1 1} rat (rat → Prop) a a_1 (@eq.{1} rat) e_1)
                                 e_2)
                              (rat.mk n₁ d₁)
                              (rat.mk n₁ d₁)
                              (@eq.refl.{1} rat (rat.mk n₁ d₁))
                              (rat.mk n₁ d₁)
                              (@has_zero.zero.{0} rat rat.has_zero)
                              (@eq.trans.{1} rat (rat.mk n₁ d₁) (rat.mk n₁ (@has_zero.zero.{0} int int.has_zero))
                                 (@has_zero.zero.{0} rat rat.has_zero)
                                 ((λ (a a_1 : int) (e_1 : @eq.{1} int a a_1) (a_2 a_3 : int)
                                   (e_2 : @eq.{1} int a_2 a_3),
                                     @congr.{1 1} int rat (rat.mk a) (rat.mk a_1) a_2 a_3
                                       (@congr_arg.{1 1} int (int → rat) a a_1 rat.mk e_1)
                                       e_2)
                                    n₁
                                    n₁
                                    (@eq.refl.{1} int n₁)
                                    d₁
                                    (@has_zero.zero.{0} int int.has_zero)
                                    hd)
                                 (rat.mk_zero n₁)))
                           (@propext (@eq.{1} rat (rat.mk n₁ d₁) (@has_zero.zero.{0} rat rat.has_zero)) false
                              (@iff_false_intro (@eq.{1} rat (rat.mk n₁ d₁) (@has_zero.zero.{0} rat rat.has_zero))
                                 (@rat.mk_ne_zero_of_ne_zero n₁ d₁ hn₁ hd₁))))
                        (@rfl.{1} rat (rat.mk n₁ d₁)))))))
       (@roption.get.{0} nat
          (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
             n₂)
          (@iff.mpr
             (@multiplicity.finite.{0} int int.comm_semiring
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                n₂)
             (and
                (@ne.{1} nat
                   (int.nat_abs
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                   (@has_one.one.{0} nat nat.has_one))
                (@ne.{1} int n₂ (@has_zero.zero.{0} int int.has_zero)))
             (@multiplicity.finite_int_iff
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                n₂)
             (@and.intro
                (@ne.{1} nat
                   (int.nat_abs
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                   (@has_one.one.{0} nat nat.has_one))
                (@ne.{1} int n₂ (@has_zero.zero.{0} int int.has_zero))
                (@ne.symm.{1} nat (@has_one.one.{0} nat nat.has_one)
                   (int.nat_abs
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                   (@ne_of_lt.{0} nat
                      (@partial_order.to_preorder.{0} nat
                         (@ordered_comm_monoid.to_partial_order.{0} nat
                            (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                               (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
                      (@has_one.one.{0} nat nat.has_one)
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@nat.prime.one_lt p p_prime)))
                (λ (hn : @eq.{1} int n₂ (@has_zero.zero.{0} int int.has_zero)),
                   false.rec.{0} false
                     (@eq.mp.{0} (@eq.{1} rat (rat.mk n₂ d₂) (rat.mk n₂ d₂)) false
                        (@eq.trans.{1} Prop (@eq.{1} rat (rat.mk n₂ d₂) (rat.mk n₂ d₂))
                           (@eq.{1} rat (rat.mk n₂ d₂) (@has_zero.zero.{0} rat rat.has_zero))
                           false
                           ((λ (a a_1 : rat) (e_1 : @eq.{1} rat a a_1) (a_2 a_3 : rat) (e_2 : @eq.{1} rat a_2 a_3),
                               @congr.{1 1} rat Prop (@eq.{1} rat a) (@eq.{1} rat a_1) a_2 a_3
                                 (@congr_arg.{1 1} rat (rat → Prop) a a_1 (@eq.{1} rat) e_1)
                                 e_2)
                              (rat.mk n₂ d₂)
                              (rat.mk n₂ d₂)
                              (@eq.refl.{1} rat (rat.mk n₂ d₂))
                              (rat.mk n₂ d₂)
                              (@has_zero.zero.{0} rat rat.has_zero)
                              (@eq.trans.{1} rat (rat.mk n₂ d₂) (rat.mk (@has_zero.zero.{0} int int.has_zero) d₂)
                                 (@has_zero.zero.{0} rat rat.has_zero)
                                 ((λ (a a_1 : int) (e_1 : @eq.{1} int a a_1) (a_2 a_3 : int)
                                   (e_2 : @eq.{1} int a_2 a_3),
                                     @congr.{1 1} int rat (rat.mk a) (rat.mk a_1) a_2 a_3
                                       (@congr_arg.{1 1} int (int → rat) a a_1 rat.mk e_1)
                                       e_2)
                                    n₂
                                    (@has_zero.zero.{0} int int.has_zero)
                                    hn
                                    d₂
                                    d₂
                                    (@eq.refl.{1} int d₂))
                                 (rat.zero_mk d₂)))
                           (@propext (@eq.{1} rat (rat.mk n₂ d₂) (@has_zero.zero.{0} rat rat.has_zero)) false
                              (@iff_false_intro (@eq.{1} rat (rat.mk n₂ d₂) (@has_zero.zero.{0} rat rat.has_zero))
                                 (@rat.mk_ne_zero_of_ne_zero n₂ d₂ hn₂ hd₂))))
                        (@rfl.{1} rat (rat.mk n₂ d₂))))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
p_prime : nat.prime p,
n₁ n₂ d₁ d₂ : int,
hn₁ : @ne.{1} int n₁ (@has_zero.zero.{0} int int.has_zero),
hn₂ : @ne.{1} int n₂ (@has_zero.zero.{0} int int.has_zero),
hd₁ : @ne.{1} int d₁ (@has_zero.zero.{0} int int.has_zero),
hd₂ : @ne.{1} int d₂ (@has_zero.zero.{0} int int.has_zero),
hf1 :
  @multiplicity.finite.{0} int int.comm_semiring
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
    (@has_mul.mul.{0} int int.has_mul n₁ d₂),
hf2 :
  @multiplicity.finite.{0} int int.comm_semiring
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
    (@has_mul.mul.{0} int int.has_mul n₂ d₁)
| ∀ (n : nat),
    @has_dvd.dvd.{0} int
      (@comm_semiring_has_dvd.{0} int
         (@nonzero_comm_semiring.to_comm_semiring.{0} int
            (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} int
               (@integral_domain.to_nonzero_comm_ring.{0} int
                  (@normalization_domain.to_integral_domain.{0} int int.normalization_domain)))))
      (@has_pow.pow.{0 0} int nat
         (@monoid.has_pow.{0} int
            (@semiring.to_monoid.{0} int
               (@comm_semiring.to_semiring.{0} int
                  (@nonzero_comm_semiring.to_comm_semiring.{0} int
                     (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} int
                        (@integral_domain.to_nonzero_comm_ring.{0} int
                           (@normalization_domain.to_integral_domain.{0} int int.normalization_domain)))))))
         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
         n)
      (@has_mul.mul.{0} int
         (@no_zero_divisors.to_has_mul.{0} int
            (@domain.to_no_zero_divisors.{0} int
               (@integral_domain.to_domain.{0} int
                  (@normalization_domain.to_integral_domain.{0} int int.normalization_domain))))
         n₁
         d₂) →
    @has_dvd.dvd.{0} int
      (@comm_semiring_has_dvd.{0} int
         (@nonzero_comm_semiring.to_comm_semiring.{0} int
            (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} int
               (@integral_domain.to_nonzero_comm_ring.{0} int
                  (@normalization_domain.to_integral_domain.{0} int int.normalization_domain)))))
      (@has_pow.pow.{0 0} int nat
         (@monoid.has_pow.{0} int
            (@semiring.to_monoid.{0} int
               (@comm_semiring.to_semiring.{0} int
                  (@nonzero_comm_semiring.to_comm_semiring.{0} int
                     (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} int
                        (@integral_domain.to_nonzero_comm_ring.{0} int
                           (@normalization_domain.to_integral_domain.{0} int int.normalization_domain)))))))
         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
         n)
      (@has_mul.mul.{0} int
         (@no_zero_divisors.to_has_mul.{0} int
            (@domain.to_no_zero_divisors.{0} int
               (@integral_domain.to_domain.{0} int
                  (@normalization_domain.to_integral_domain.{0} int int.normalization_domain))))
         n₂
         d₁)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
p_prime : nat.prime p,
n₁ n₂ d₁ d₂ : int,
hn₁ : @ne.{1} int n₁ (@has_zero.zero.{0} int int.has_zero),
hn₂ : @ne.{1} int n₂ (@has_zero.zero.{0} int int.has_zero),
hd₁ : @ne.{1} int d₁ (@has_zero.zero.{0} int int.has_zero),
hd₂ : @ne.{1} int d₂ (@has_zero.zero.{0} int int.has_zero),
hf1 :
  @multiplicity.finite.{0} int int.comm_semiring
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
    (@has_mul.mul.{0} int int.has_mul n₁ d₂),
hf2 :
  @multiplicity.finite.{0} int int.comm_semiring
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
    (@has_mul.mul.{0} int int.has_mul n₂ d₁)
⊢ iff (@has_le.le.{0} int int.has_le (padic_val_rat p (rat.mk n₁ d₁)) (padic_val_rat p (rat.mk n₂ d₂)))
    (∀ (n : nat),
       @has_dvd.dvd.{0} int (@comm_semiring_has_dvd.{0} int int.comm_semiring)
         (@has_pow.pow.{0 0} int nat (@monoid.has_pow.{0} int int.monoid)
            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
            n)
         (@has_mul.mul.{0} int int.has_mul n₁ d₂) →
       @has_dvd.dvd.{0} int (@comm_semiring_has_dvd.{0} int int.comm_semiring)
         (@has_pow.pow.{0 0} int nat (@monoid.has_pow.{0} int int.monoid)
            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
            n)
         (@has_mul.mul.{0} int int.has_mul n₂ d₁))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>208  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit name (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.ident)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) (lean.parser.pexpr std.prec.max))) → conv.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='conv'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;(at id)?&#x27;, &#x27;(in expr)?&#x27;, &#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
p_prime : nat.prime p,
n₁ n₂ d₁ d₂ : int,
hn₁ : @ne.{1} int n₁ (@has_zero.zero.{0} int int.has_zero),
hn₂ : @ne.{1} int n₂ (@has_zero.zero.{0} int int.has_zero),
hd₁ : @ne.{1} int d₁ (@has_zero.zero.{0} int int.has_zero),
hd₂ : @ne.{1} int d₂ (@has_zero.zero.{0} int int.has_zero),
hf1 :
  @multiplicity.finite.{0} int int.comm_semiring
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
    (@has_mul.mul.{0} int int.has_mul n₁ d₂),
hf2 :
  @multiplicity.finite.{0} int int.comm_semiring
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
    (@has_mul.mul.{0} int int.has_mul n₂ d₁)
⊢ iff (@has_le.le.{0} int int.has_le (padic_val_rat p (rat.mk n₁ d₁)) (padic_val_rat p (rat.mk n₂ d₂)))
    (∀ (n : nat),
       @has_dvd.dvd.{0} int (@comm_semiring_has_dvd.{0} int int.comm_semiring)
         (@has_pow.pow.{0 0} int nat (@monoid.has_pow.{0} int int.monoid)
            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
            n)
         (@has_mul.mul.{0} int int.has_mul n₁ d₂) →
       @has_dvd.dvd.{0} int (@comm_semiring_has_dvd.{0} int int.comm_semiring)
         (@has_pow.pow.{0 0} int nat (@monoid.has_pow.{0} int int.monoid)
            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
            n)
         (@has_mul.mul.{0} int int.has_mul n₂ d₁))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>209  /--</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>210  Sufficient conditions to show that the p-adic valuation of `q` is less than or equal to the</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>211  p-adic vlauation of `q + r`.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>212  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>213  theorem le_padic_val_rat_add_of_le {q r : ℚ}</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                          </code><font color='blue'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/rat/basic.lean&#x27;, &#x27;line&#x27;: 46, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                          </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                          </code><font color='orange'><a title='`rat`, or `ℚ`, is the type of rational numbers. It is defined
 as the set of pairs ⟨n, d⟩ of integers such that `d` is positive and `n` and
 `d` are coprime. This representation is preferred to the quotient
 because without periodic reduction, the numerator and denominator can grow
 exponentially (for example, adding 1/2 to itself repeatedly).'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>214    (hq : q ≠ 0) (hr : r ≠ 0) (hqr : q + r ≠ 0)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='q'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ne'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='r'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ne'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='q'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='r'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ne'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 97, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 97, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 97, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_add.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>215    (h : padic_val_rat p q ≤ padic_val_rat p r) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='padic_val_rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='q'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_le.le'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='padic_val_rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='r'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;line&#x27;: 62, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 319, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 62, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='nat → rat → int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_le.{0} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat → rat → int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='For `p ≠ 1`, the p-adic valuation of an integer `z ≠ 0` is the largest natural number `n` such that
p^n divides z.

`padic_val_rat` defines the valuation of a rational `q` to be the valuation of `q.num` minus the
valuation of `q.denom`.
If `q = 0` or `p = 1`, then `padic_val_rat p q` defaults to 0.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='For `p ≠ 1`, the p-adic valuation of an integer `z ≠ 0` is the largest natural number `n` such that
p^n divides z.

`padic_val_rat` defines the valuation of a rational `q` to be the valuation of `q.num` minus the
valuation of `q.denom`.
If `q = 0` or `p = 1`, then `padic_val_rat p q` defaults to 0.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>216    padic_val_rat p q ≤ padic_val_rat p (q + r) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='padic_val_rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='q'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_le.le'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='padic_val_rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='q'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='r'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 62, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 319, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 62, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='nat → rat → int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_le.{0} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat → rat → int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_add.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='For `p ≠ 1`, the p-adic valuation of an integer `z ≠ 0` is the largest natural number `n` such that
p^n divides z.

`padic_val_rat` defines the valuation of a rational `q` to be the valuation of `q.num` minus the
valuation of `q.denom`.
If `q = 0` or `p = 1`, then `padic_val_rat p q` defaults to 0.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='For `p ≠ 1`, the p-adic valuation of an integer `z ≠ 0` is the largest natural number `n` such that
p^n divides z.

`padic_val_rat` defines the valuation of a rational `q` to be the valuation of `q.num` minus the
valuation of `q.denom`.
If `q = 0` or `p = 1`, then `padic_val_rat p q` defaults to 0.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>217  have hqn : q.num ≠ 0, from rat.num_ne_zero_of_ne_zero hq,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='q'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='rat.num'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ne'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='rat.num_ne_zero_of_ne_zero'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/rat/basic.lean&#x27;, &#x27;line&#x27;: 46, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 97, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/rat/basic.lean&#x27;, &#x27;line&#x27;: 480, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='rat → int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='∀ {q : rat}, @ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero) → @ne.{1} int (q.num) (@has_zero.zero.{0} int int.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>218  have hqd : (q.denom : ℤ) ≠ 0, by exact_mod_cast rat.denom_ne_zero _,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='q'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='rat.denom'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ne'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='blue'><a title='rat.denom_ne_zero'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/rat/basic.lean&#x27;, &#x27;line&#x27;: 46, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/int/basic.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 97, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/norm_cast.lean&#x27;, &#x27;line&#x27;: 335, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/rat/basic.lean&#x27;, &#x27;line&#x27;: 488, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/norm_cast.lean&#x27;, &#x27;line&#x27;: 335, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='rat → nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (q : rat), @ne.{1} nat (q.denom) (@has_zero.zero.{0} nat nat.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='orange'><a title='Normalize the goal and the given expression,
then close the goal with exact.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='Normalize the goal and the given expression,
then close the goal with exact.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='teal'><a title='exact_mod_cast'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='exact_mod_cast'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='lime'><a title='p : nat,
p_prime : nat.prime p,
q r : rat,
hq : @ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero),
hr : @ne.{1} rat r (@has_zero.zero.{0} rat rat.has_zero),
hqr : @ne.{1} rat (@has_add.add.{0} rat rat.has_add q r) (@has_zero.zero.{0} rat rat.has_zero),
h : @has_le.le.{0} int int.has_le (padic_val_rat p q) (padic_val_rat p r),
hqn : @ne.{1} int (q.num) (@has_zero.zero.{0} int int.has_zero)
⊢ @ne.{1} int (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
    (@has_zero.zero.{0} int int.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>219  have hrn : r.num ≠ 0, from rat.num_ne_zero_of_ne_zero hr,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='r'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='rat.num'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ne'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='rat.num_ne_zero_of_ne_zero'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/rat/basic.lean&#x27;, &#x27;line&#x27;: 46, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 97, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/rat/basic.lean&#x27;, &#x27;line&#x27;: 480, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='rat → int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='∀ {q : rat}, @ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero) → @ne.{1} int (q.num) (@has_zero.zero.{0} int int.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@ne.{1} rat r (@has_zero.zero.{0} rat rat.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>220  have hrd : (r.denom : ℤ) ≠ 0, by exact_mod_cast rat.denom_ne_zero _,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='r'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='rat.denom'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ne'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='blue'><a title='rat.denom_ne_zero'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/rat/basic.lean&#x27;, &#x27;line&#x27;: 46, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/int/basic.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 97, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/norm_cast.lean&#x27;, &#x27;line&#x27;: 335, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/rat/basic.lean&#x27;, &#x27;line&#x27;: 488, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/norm_cast.lean&#x27;, &#x27;line&#x27;: 335, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='rat → nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (q : rat), @ne.{1} nat (q.denom) (@has_zero.zero.{0} nat nat.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='orange'><a title='Normalize the goal and the given expression,
then close the goal with exact.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='Normalize the goal and the given expression,
then close the goal with exact.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='teal'><a title='exact_mod_cast'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='exact_mod_cast'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='lime'><a title='p : nat,
p_prime : nat.prime p,
q r : rat,
hq : @ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero),
hr : @ne.{1} rat r (@has_zero.zero.{0} rat rat.has_zero),
hqr : @ne.{1} rat (@has_add.add.{0} rat rat.has_add q r) (@has_zero.zero.{0} rat rat.has_zero),
h : @has_le.le.{0} int int.has_le (padic_val_rat p q) (padic_val_rat p r),
hqn : @ne.{1} int (q.num) (@has_zero.zero.{0} int int.has_zero),
hqd :
  @ne.{1} int (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
    (@has_zero.zero.{0} int int.has_zero),
hrn : @ne.{1} int (r.num) (@has_zero.zero.{0} int int.has_zero)
⊢ @ne.{1} int (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom))
    (@has_zero.zero.{0} int int.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>221  have hqdv : q.num /. q.denom ≠ 0, from rat.mk_ne_zero_of_ne_zero hqn hqd,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='q'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='rat.num'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='rat.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='q'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='rat.denom'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ne'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='rat.mk_ne_zero_of_ne_zero'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hqn'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hqd'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/rat/basic.lean&#x27;, &#x27;line&#x27;: 46, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/rat/basic.lean&#x27;, &#x27;line&#x27;: 96, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/rat/basic.lean&#x27;, &#x27;line&#x27;: 46, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 97, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/rat/basic.lean&#x27;, &#x27;line&#x27;: 505, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='rat → int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='int → int → rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='rat → nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='∀ {n d : int}, @ne.{1} int n (@has_zero.zero.{0} int int.has_zero) → @ne.{1} int d (@has_zero.zero.{0} int int.has_zero) → @ne.{1} rat (rat.mk n d) (@has_zero.zero.{0} rat rat.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@ne.{1} int (q.num) (@has_zero.zero.{0} int int.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@ne.{1} int (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)) (@has_zero.zero.{0} int int.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='Form the quotient `n / d` where `n d : ℤ`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>222  have hrdv : r.num /. r.denom ≠ 0, from rat.mk_ne_zero_of_ne_zero hrn hrd,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='r'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='rat.num'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='rat.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='r'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='rat.denom'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ne'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='rat.mk_ne_zero_of_ne_zero'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hrn'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hrd'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/rat/basic.lean&#x27;, &#x27;line&#x27;: 46, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/rat/basic.lean&#x27;, &#x27;line&#x27;: 96, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/rat/basic.lean&#x27;, &#x27;line&#x27;: 46, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 97, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/rat/basic.lean&#x27;, &#x27;line&#x27;: 505, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='rat → int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='int → int → rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='rat → nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='∀ {n d : int}, @ne.{1} int n (@has_zero.zero.{0} int int.has_zero) → @ne.{1} int d (@has_zero.zero.{0} int int.has_zero) → @ne.{1} rat (rat.mk n d) (@has_zero.zero.{0} rat rat.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@ne.{1} int (r.num) (@has_zero.zero.{0} int int.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@ne.{1} int (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)) (@has_zero.zero.{0} int int.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='Form the quotient `n / d` where `n d : ℤ`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>223  have hqreq : q + r = (((q.num * r.denom + q.denom * r.num : ℤ)) /. (↑q.denom * ↑r.denom : ℤ)),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='q'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='r'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='q'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='rat.num'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mul.mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='r'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='rat.denom'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='q'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='rat.denom'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mul.mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='r'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='rat.num'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='rat.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='coe'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='q'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='rat.denom'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mul.mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='coe'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='r'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='rat.denom'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/rat/basic.lean&#x27;, &#x27;line&#x27;: 46, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 312, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/rat/basic.lean&#x27;, &#x27;line&#x27;: 46, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/rat/basic.lean&#x27;, &#x27;line&#x27;: 46, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 312, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/rat/basic.lean&#x27;, &#x27;line&#x27;: 46, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/int/basic.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/rat/basic.lean&#x27;, &#x27;line&#x27;: 96, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/coe.lean&#x27;, &#x27;line&#x27;: 67, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/rat/basic.lean&#x27;, &#x27;line&#x27;: 46, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 312, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/coe.lean&#x27;, &#x27;line&#x27;: 67, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/rat/basic.lean&#x27;, &#x27;line&#x27;: 46, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/int/basic.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_add.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='rat → int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_mul.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='rat → nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_add.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='rat → nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_mul.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='rat → int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='int → int → rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {a b : Type} [_inst_1 : has_lift_t.{1 1} a b], a → b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='rat → nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_mul.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {a b : Type} [_inst_1 : has_lift_t.{1 1} a b], a → b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='rat → nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                </code><font color='orange'><a title='Form the quotient `n / d` where `n d : ℤ`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>224    from rat.add_num_denom _ _,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='rat.add_num_denom'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/rat/basic.lean&#x27;, &#x27;line&#x27;: 567, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='∀ (q r : rat), @eq.{1} rat (@has_add.add.{0} rat rat.has_add q r) (rat.mk (@has_add.add.{0} int int.has_add (@has_mul.mul.{0} int int.has_mul (q.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom))) (@has_mul.mul.{0} int int.has_mul (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)) (r.num))) (@has_mul.mul.{0} int int.has_mul (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>225  have hqrd : q.num * ↑(r.denom) + ↑(q.denom) * r.num ≠ 0,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='q'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='rat.num'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mul.mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='coe'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='r'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='rat.denom'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='coe'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='q'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='rat.denom'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_mul.mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='r'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='rat.num'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ne'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/rat/basic.lean&#x27;, &#x27;line&#x27;: 46, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 312, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/coe.lean&#x27;, &#x27;line&#x27;: 67, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/rat/basic.lean&#x27;, &#x27;line&#x27;: 46, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/coe.lean&#x27;, &#x27;line&#x27;: 67, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/rat/basic.lean&#x27;, &#x27;line&#x27;: 46, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 312, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/rat/basic.lean&#x27;, &#x27;line&#x27;: 46, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 97, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='rat → int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_mul.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {a b : Type} [_inst_1 : has_lift_t.{1 1} a b], a → b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='rat → nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type} [c : has_add.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {a b : Type} [_inst_1 : has_lift_t.{1 1} a b], a → b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='rat → nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type} [c : has_mul.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='rat → int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>226    from rat.mk_num_ne_zero_of_ne_zero hqr hqreq,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='rat.mk_num_ne_zero_of_ne_zero'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hqr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hqreq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/rat/basic.lean&#x27;, &#x27;line&#x27;: 497, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='∀ {q : rat} {n d : int}, @ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero) → @eq.{1} rat q (rat.mk n d) → @ne.{1} int n (@has_zero.zero.{0} int int.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@ne.{1} rat (@has_add.add.{0} rat rat.has_add q r) (@has_zero.zero.{0} rat rat.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@eq.{1} rat (@has_add.add.{0} rat rat.has_add q r) (rat.mk (@has_add.add.{0} int int.has_add (@has_mul.mul.{0} int int.has_mul (q.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom))) (@has_mul.mul.{0} int int.has_mul (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)) (r.num))) (@has_mul.mul.{0} int int.has_mul (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>227  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
p_prime : nat.prime p,
q r : rat,
hq : @ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero),
hr : @ne.{1} rat r (@has_zero.zero.{0} rat rat.has_zero),
hqr : @ne.{1} rat (@has_add.add.{0} rat rat.has_add q r) (@has_zero.zero.{0} rat rat.has_zero),
h : @has_le.le.{0} int int.has_le (padic_val_rat p q) (padic_val_rat p r),
hqn : @ne.{1} int (q.num) (@has_zero.zero.{0} int int.has_zero),
hqd :
  @ne.{1} int (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
    (@has_zero.zero.{0} int int.has_zero),
hrn : @ne.{1} int (r.num) (@has_zero.zero.{0} int int.has_zero),
hrd :
  @ne.{1} int (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom))
    (@has_zero.zero.{0} int int.has_zero),
hqdv :
  @ne.{1} rat
    (rat.mk (q.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))
    (@has_zero.zero.{0} rat rat.has_zero),
hrdv :
  @ne.{1} rat
    (rat.mk (r.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
    (@has_zero.zero.{0} rat rat.has_zero),
hqreq :
  @eq.{1} rat (@has_add.add.{0} rat rat.has_add q r)
    (rat.mk
       (@has_add.add.{0} int int.has_add
          (@has_mul.mul.{0} int int.has_mul (q.num)
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
          (@has_mul.mul.{0} int int.has_mul
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
             (r.num)))
       (@has_mul.mul.{0} int int.has_mul
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))),
hqrd :
  @ne.{1} int
    (@has_add.add.{0} int int.has_add
       (@has_mul.mul.{0} int int.has_mul (q.num)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
       (@has_mul.mul.{0} int int.has_mul
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
          (r.num)))
    (@has_zero.zero.{0} int int.has_zero)
⊢ @has_le.le.{0} int int.has_le (padic_val_rat p q) (padic_val_rat p (@has_add.add.{0} rat rat.has_add q r))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>228    conv_lhs { rw ←(@rat.num_denom q) },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='blue'><a title='rat.num_denom'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='q'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/converter/interactive.lean&#x27;, &#x27;line&#x27;: 123, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/rat/basic.lean&#x27;, &#x27;line&#x27;: 216, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/converter/interactive.lean&#x27;, &#x27;line&#x27;: 123, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit name (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.ident)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) (lean.parser.pexpr std.prec.max))) → conv.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {a : rat}, @eq.{1} rat (rat.mk (a.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (a.denom))) a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit name (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.ident)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) (lean.parser.pexpr std.prec.max))) → conv.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='conv_lhs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='conv_lhs'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(at id)?&#x27;, &#x27;(in expr)?&#x27;, &#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;(at id)?&#x27;, &#x27;(in expr)?&#x27;, &#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
p_prime : nat.prime p,
q r : rat,
hq : @ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero),
hr : @ne.{1} rat r (@has_zero.zero.{0} rat rat.has_zero),
hqr : @ne.{1} rat (@has_add.add.{0} rat rat.has_add q r) (@has_zero.zero.{0} rat rat.has_zero),
h : @has_le.le.{0} int int.has_le (padic_val_rat p q) (padic_val_rat p r),
hqn : @ne.{1} int (q.num) (@has_zero.zero.{0} int int.has_zero),
hqd :
  @ne.{1} int (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
    (@has_zero.zero.{0} int int.has_zero),
hrn : @ne.{1} int (r.num) (@has_zero.zero.{0} int int.has_zero),
hrd :
  @ne.{1} int (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom))
    (@has_zero.zero.{0} int int.has_zero),
hqdv :
  @ne.{1} rat
    (rat.mk (q.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))
    (@has_zero.zero.{0} rat rat.has_zero),
hrdv :
  @ne.{1} rat
    (rat.mk (r.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
    (@has_zero.zero.{0} rat rat.has_zero),
hqreq :
  @eq.{1} rat (@has_add.add.{0} rat rat.has_add q r)
    (rat.mk
       (@has_add.add.{0} int int.has_add
          (@has_mul.mul.{0} int int.has_mul (q.num)
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
          (@has_mul.mul.{0} int int.has_mul
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
             (r.num)))
       (@has_mul.mul.{0} int int.has_mul
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))),
hqrd :
  @ne.{1} int
    (@has_add.add.{0} int int.has_add
       (@has_mul.mul.{0} int int.has_mul (q.num)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
       (@has_mul.mul.{0} int int.has_mul
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
          (r.num)))
    (@has_zero.zero.{0} int int.has_zero)
⊢ @has_le.le.{0} int int.has_le (padic_val_rat p q) (padic_val_rat p (@has_add.add.{0} rat rat.has_add q r))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
p_prime : nat.prime p,
q r : rat,
hq : @ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero),
hr : @ne.{1} rat r (@has_zero.zero.{0} rat rat.has_zero),
hqr : @ne.{1} rat (@has_add.add.{0} rat rat.has_add q r) (@has_zero.zero.{0} rat rat.has_zero),
h : @has_le.le.{0} int int.has_le (padic_val_rat p q) (padic_val_rat p r),
hqn : @ne.{1} int (q.num) (@has_zero.zero.{0} int int.has_zero),
hqd :
  @ne.{1} int (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
    (@has_zero.zero.{0} int int.has_zero),
hrn : @ne.{1} int (r.num) (@has_zero.zero.{0} int int.has_zero),
hrd :
  @ne.{1} int (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom))
    (@has_zero.zero.{0} int int.has_zero),
hqdv :
  @ne.{1} rat
    (rat.mk (q.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))
    (@has_zero.zero.{0} rat rat.has_zero),
hrdv :
  @ne.{1} rat
    (rat.mk (r.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
    (@has_zero.zero.{0} rat rat.has_zero),
hqreq :
  @eq.{1} rat (@has_add.add.{0} rat rat.has_add q r)
    (rat.mk
       (@has_add.add.{0} int int.has_add
          (@has_mul.mul.{0} int int.has_mul (q.num)
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
          (@has_mul.mul.{0} int int.has_mul
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
             (r.num)))
       (@has_mul.mul.{0} int int.has_mul
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))),
hqrd :
  @ne.{1} int
    (@has_add.add.{0} int int.has_add
       (@has_mul.mul.{0} int int.has_mul (q.num)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
       (@has_mul.mul.{0} int int.has_mul
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
          (r.num)))
    (@has_zero.zero.{0} int int.has_zero)
| padic_val_rat p q'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
p_prime : nat.prime p,
q r : rat,
hq : @ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero),
hr : @ne.{1} rat r (@has_zero.zero.{0} rat rat.has_zero),
hqr : @ne.{1} rat (@has_add.add.{0} rat rat.has_add q r) (@has_zero.zero.{0} rat rat.has_zero),
h : @has_le.le.{0} int int.has_le (padic_val_rat p q) (padic_val_rat p r),
hqn : @ne.{1} int (q.num) (@has_zero.zero.{0} int int.has_zero),
hqd :
  @ne.{1} int (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
    (@has_zero.zero.{0} int int.has_zero),
hrn : @ne.{1} int (r.num) (@has_zero.zero.{0} int int.has_zero),
hrd :
  @ne.{1} int (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom))
    (@has_zero.zero.{0} int int.has_zero),
hqdv :
  @ne.{1} rat
    (rat.mk (q.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))
    (@has_zero.zero.{0} rat rat.has_zero),
hrdv :
  @ne.{1} rat
    (rat.mk (r.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
    (@has_zero.zero.{0} rat rat.has_zero),
hqreq :
  @eq.{1} rat (@has_add.add.{0} rat rat.has_add q r)
    (rat.mk
       (@has_add.add.{0} int int.has_add
          (@has_mul.mul.{0} int int.has_mul (q.num)
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
          (@has_mul.mul.{0} int int.has_mul
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
             (r.num)))
       (@has_mul.mul.{0} int int.has_mul
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))),
hqrd :
  @ne.{1} int
    (@has_add.add.{0} int int.has_add
       (@has_mul.mul.{0} int int.has_mul (q.num)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
       (@has_mul.mul.{0} int int.has_mul
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
          (r.num)))
    (@has_zero.zero.{0} int int.has_zero)
| padic_val_rat p
    (rat.mk (q.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
p_prime : nat.prime p,
q r : rat,
hq : @ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero),
hr : @ne.{1} rat r (@has_zero.zero.{0} rat rat.has_zero),
hqr : @ne.{1} rat (@has_add.add.{0} rat rat.has_add q r) (@has_zero.zero.{0} rat rat.has_zero),
h : @has_le.le.{0} int int.has_le (padic_val_rat p q) (padic_val_rat p r),
hqn : @ne.{1} int (q.num) (@has_zero.zero.{0} int int.has_zero),
hqd :
  @ne.{1} int (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
    (@has_zero.zero.{0} int int.has_zero),
hrn : @ne.{1} int (r.num) (@has_zero.zero.{0} int int.has_zero),
hrd :
  @ne.{1} int (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom))
    (@has_zero.zero.{0} int int.has_zero),
hqdv :
  @ne.{1} rat
    (rat.mk (q.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))
    (@has_zero.zero.{0} rat rat.has_zero),
hrdv :
  @ne.{1} rat
    (rat.mk (r.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
    (@has_zero.zero.{0} rat rat.has_zero),
hqreq :
  @eq.{1} rat (@has_add.add.{0} rat rat.has_add q r)
    (rat.mk
       (@has_add.add.{0} int int.has_add
          (@has_mul.mul.{0} int int.has_mul (q.num)
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
          (@has_mul.mul.{0} int int.has_mul
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
             (r.num)))
       (@has_mul.mul.{0} int int.has_mul
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))),
hqrd :
  @ne.{1} int
    (@has_add.add.{0} int int.has_add
       (@has_mul.mul.{0} int int.has_mul (q.num)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
       (@has_mul.mul.{0} int int.has_mul
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
          (r.num)))
    (@has_zero.zero.{0} int int.has_zero)
⊢ @has_le.le.{0} int int.has_le
    (padic_val_rat p
       (rat.mk (q.num)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))))
    (padic_val_rat p (@has_add.add.{0} rat rat.has_add q r))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>229    rw [hqreq, padic_val_rat_le_padic_val_rat_iff p hqn hqrd hqd (mul_ne_zero hqd hrd),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='hqreq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='padic_val_rat.padic_val_rat_le_padic_val_rat_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hqn'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hqrd'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='mul_ne_zero'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hqd'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hrd'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 188, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/ring.lean&#x27;, &#x27;line&#x27;: 287, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{1} rat (@has_add.add.{0} rat rat.has_add q r) (rat.mk (@has_add.add.{0} int int.has_add (@has_mul.mul.{0} int int.has_mul (q.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom))) (@has_mul.mul.{0} int int.has_mul (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)) (r.num))) (@has_mul.mul.{0} int int.has_mul (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (p : nat) [p_prime : nat.prime p] {n₁ n₂ d₁ d₂ : int}, @ne.{1} int n₁ (@has_zero.zero.{0} int int.has_zero) → @ne.{1} int n₂ (@has_zero.zero.{0} int int.has_zero) → @ne.{1} int d₁ (@has_zero.zero.{0} int int.has_zero) → @ne.{1} int d₂ (@has_zero.zero.{0} int int.has_zero) → iff (@has_le.le.{0} int int.has_le (padic_val_rat p (rat.mk n₁ d₁)) (padic_val_rat p (rat.mk n₂ d₂))) (∀ (n : nat), @has_dvd.dvd.{0} int (@comm_semiring_has_dvd.{0} int int.comm_semiring) (@has_pow.pow.{0 0} int nat (@monoid.has_pow.{0} int int.monoid) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p) n) (@has_mul.mul.{0} int int.has_mul n₁ d₂) → @has_dvd.dvd.{0} int (@comm_semiring_has_dvd.{0} int int.comm_semiring) (@has_pow.pow.{0 0} int nat (@monoid.has_pow.{0} int int.monoid) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p) n) (@has_mul.mul.{0} int int.has_mul n₂ d₁))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@ne.{1} int (q.num) (@has_zero.zero.{0} int int.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@ne.{1} int (@has_add.add.{0} int int.has_add (@has_mul.mul.{0} int int.has_mul (q.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom))) (@has_mul.mul.{0} int int.has_mul (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)) (r.num))) (@has_zero.zero.{0} int int.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type} [_inst_1 : integral_domain.{0} α] {a b : α}, @ne.{1} α a (@has_zero.zero.{0} α (@no_zero_divisors.to_has_zero.{0} α (@integral_domain.to_no_zero_divisors.{0} α _inst_1))) → @ne.{1} α b (@has_zero.zero.{0} α (@no_zero_divisors.to_has_zero.{0} α (@integral_domain.to_no_zero_divisors.{0} α _inst_1))) → @ne.{1} α (@has_mul.mul.{0} α (@no_zero_divisors.to_has_mul.{0} α (@integral_domain.to_no_zero_divisors.{0} α _inst_1)) a b) (@has_zero.zero.{0} α (@no_zero_divisors.to_has_zero.{0} α (@integral_domain.to_no_zero_divisors.{0} α _inst_1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@ne.{1} int (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)) (@has_zero.zero.{0} int int.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@ne.{1} int (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)) (@has_zero.zero.{0} int int.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='A condition for `padic_val_rat p (n₁ / d₁) ≤ padic_val_rat p (n₂ / d₂),
in terms of divisibility by `p^n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
p_prime : nat.prime p,
q r : rat,
hq : @ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero),
hr : @ne.{1} rat r (@has_zero.zero.{0} rat rat.has_zero),
hqr : @ne.{1} rat (@has_add.add.{0} rat rat.has_add q r) (@has_zero.zero.{0} rat rat.has_zero),
h : @has_le.le.{0} int int.has_le (padic_val_rat p q) (padic_val_rat p r),
hqn : @ne.{1} int (q.num) (@has_zero.zero.{0} int int.has_zero),
hqd :
  @ne.{1} int (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
    (@has_zero.zero.{0} int int.has_zero),
hrn : @ne.{1} int (r.num) (@has_zero.zero.{0} int int.has_zero),
hrd :
  @ne.{1} int (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom))
    (@has_zero.zero.{0} int int.has_zero),
hqdv :
  @ne.{1} rat
    (rat.mk (q.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))
    (@has_zero.zero.{0} rat rat.has_zero),
hrdv :
  @ne.{1} rat
    (rat.mk (r.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
    (@has_zero.zero.{0} rat rat.has_zero),
hqreq :
  @eq.{1} rat (@has_add.add.{0} rat rat.has_add q r)
    (rat.mk
       (@has_add.add.{0} int int.has_add
          (@has_mul.mul.{0} int int.has_mul (q.num)
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
          (@has_mul.mul.{0} int int.has_mul
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
             (r.num)))
       (@has_mul.mul.{0} int int.has_mul
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))),
hqrd :
  @ne.{1} int
    (@has_add.add.{0} int int.has_add
       (@has_mul.mul.{0} int int.has_mul (q.num)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
       (@has_mul.mul.{0} int int.has_mul
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
          (r.num)))
    (@has_zero.zero.{0} int int.has_zero)
⊢ @has_le.le.{0} int int.has_le
    (padic_val_rat p
       (rat.mk (q.num)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))))
    (padic_val_rat p (@has_add.add.{0} rat rat.has_add q r))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
p_prime : nat.prime p,
q r : rat,
hq : @ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero),
hr : @ne.{1} rat r (@has_zero.zero.{0} rat rat.has_zero),
hqr : @ne.{1} rat (@has_add.add.{0} rat rat.has_add q r) (@has_zero.zero.{0} rat rat.has_zero),
h : @has_le.le.{0} int int.has_le (padic_val_rat p q) (padic_val_rat p r),
hqn : @ne.{1} int (q.num) (@has_zero.zero.{0} int int.has_zero),
hqd :
  @ne.{1} int (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
    (@has_zero.zero.{0} int int.has_zero),
hrn : @ne.{1} int (r.num) (@has_zero.zero.{0} int int.has_zero),
hrd :
  @ne.{1} int (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom))
    (@has_zero.zero.{0} int int.has_zero),
hqdv :
  @ne.{1} rat
    (rat.mk (q.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))
    (@has_zero.zero.{0} rat rat.has_zero),
hrdv :
  @ne.{1} rat
    (rat.mk (r.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
    (@has_zero.zero.{0} rat rat.has_zero),
hqreq :
  @eq.{1} rat (@has_add.add.{0} rat rat.has_add q r)
    (rat.mk
       (@has_add.add.{0} int int.has_add
          (@has_mul.mul.{0} int int.has_mul (q.num)
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
          (@has_mul.mul.{0} int int.has_mul
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
             (r.num)))
       (@has_mul.mul.{0} int int.has_mul
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))),
hqrd :
  @ne.{1} int
    (@has_add.add.{0} int int.has_add
       (@has_mul.mul.{0} int int.has_mul (q.num)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
       (@has_mul.mul.{0} int int.has_mul
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
          (r.num)))
    (@has_zero.zero.{0} int int.has_zero)
⊢ @has_le.le.{0} int int.has_le
    (padic_val_rat p
       (rat.mk (q.num)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))))
    (padic_val_rat p
       (rat.mk
          (@has_add.add.{0} int int.has_add
             (@has_mul.mul.{0} int int.has_mul (q.num)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
             (@has_mul.mul.{0} int int.has_mul
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
                (r.num)))
          (@has_mul.mul.{0} int int.has_mul
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
p_prime : nat.prime p,
q r : rat,
hq : @ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero),
hr : @ne.{1} rat r (@has_zero.zero.{0} rat rat.has_zero),
hqr : @ne.{1} rat (@has_add.add.{0} rat rat.has_add q r) (@has_zero.zero.{0} rat rat.has_zero),
h : @has_le.le.{0} int int.has_le (padic_val_rat p q) (padic_val_rat p r),
hqn : @ne.{1} int (q.num) (@has_zero.zero.{0} int int.has_zero),
hqd :
  @ne.{1} int (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
    (@has_zero.zero.{0} int int.has_zero),
hrn : @ne.{1} int (r.num) (@has_zero.zero.{0} int int.has_zero),
hrd :
  @ne.{1} int (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom))
    (@has_zero.zero.{0} int int.has_zero),
hqdv :
  @ne.{1} rat
    (rat.mk (q.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))
    (@has_zero.zero.{0} rat rat.has_zero),
hrdv :
  @ne.{1} rat
    (rat.mk (r.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
    (@has_zero.zero.{0} rat rat.has_zero),
hqreq :
  @eq.{1} rat (@has_add.add.{0} rat rat.has_add q r)
    (rat.mk
       (@has_add.add.{0} int int.has_add
          (@has_mul.mul.{0} int int.has_mul (q.num)
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
          (@has_mul.mul.{0} int int.has_mul
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
             (r.num)))
       (@has_mul.mul.{0} int int.has_mul
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))),
hqrd :
  @ne.{1} int
    (@has_add.add.{0} int int.has_add
       (@has_mul.mul.{0} int int.has_mul (q.num)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
       (@has_mul.mul.{0} int int.has_mul
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
          (r.num)))
    (@has_zero.zero.{0} int int.has_zero)
⊢ ∀ (n : nat),
    @has_dvd.dvd.{0} int (@comm_semiring_has_dvd.{0} int int.comm_semiring)
      (@has_pow.pow.{0 0} int nat (@monoid.has_pow.{0} int int.monoid)
         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
         n)
      (@has_mul.mul.{0} int int.has_mul (q.num)
         (@has_mul.mul.{0} int
            (@no_zero_divisors.to_has_mul.{0} int
               (@integral_domain.to_no_zero_divisors.{0} int
                  (@normalization_domain.to_integral_domain.{0} int int.normalization_domain)))
            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))) →
    @has_dvd.dvd.{0} int (@comm_semiring_has_dvd.{0} int int.comm_semiring)
      (@has_pow.pow.{0 0} int nat (@monoid.has_pow.{0} int int.monoid)
         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
         n)
      (@has_mul.mul.{0} int int.has_mul
         (@has_add.add.{0} int int.has_add
            (@has_mul.mul.{0} int int.has_mul (q.num)
               (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
            (@has_mul.mul.{0} int int.has_mul
               (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
               (r.num)))
         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>230      ← multiplicity_le_multiplicity_iff, mul_left_comm,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='multiplicity.multiplicity_le_multiplicity_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='mul_left_comm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/ring_theory/multiplicity.lean&#x27;, &#x27;line&#x27;: 141, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 52, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : comm_semiring.{0} α] [_inst_2 : @decidable_rel.{1} α (@has_dvd.dvd.{0} α (@comm_semiring_has_dvd.{0} α _inst_1))] {a b c d : α}, iff (@has_le.le.{0} enat enat.has_le (@multiplicity.{0} α _inst_1 (λ (a b : α), _inst_2 a b) a b) (@multiplicity.{0} α _inst_1 (λ (a b : α), _inst_2 a b) c d)) (∀ (n : nat), @has_dvd.dvd.{0} α (@comm_semiring_has_dvd.{0} α _inst_1) (@has_pow.pow.{0 0} α nat (@monoid.has_pow.{0} α (@semiring.to_monoid.{0} α (@comm_semiring.to_semiring.{0} α _inst_1))) a n) b → @has_dvd.dvd.{0} α (@comm_semiring_has_dvd.{0} α _inst_1) (@has_pow.pow.{0 0} α nat (@monoid.has_pow.{0} α (@semiring.to_monoid.{0} α (@comm_semiring.to_semiring.{0} α _inst_1))) c n) d)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : comm_semigroup.{0} α] (a b c : α), @eq.{1} α (@has_mul.mul.{0} α (@semigroup.to_has_mul.{0} α (@comm_semigroup.to_semigroup.{0} α _inst_1)) a (@has_mul.mul.{0} α (@semigroup.to_has_mul.{0} α (@comm_semigroup.to_semigroup.{0} α _inst_1)) b c)) (@has_mul.mul.{0} α (@semigroup.to_has_mul.{0} α (@comm_semigroup.to_semigroup.{0} α _inst_1)) b (@has_mul.mul.{0} α (@semigroup.to_has_mul.{0} α (@comm_semigroup.to_semigroup.{0} α _inst_1)) a c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
p_prime : nat.prime p,
q r : rat,
hq : @ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero),
hr : @ne.{1} rat r (@has_zero.zero.{0} rat rat.has_zero),
hqr : @ne.{1} rat (@has_add.add.{0} rat rat.has_add q r) (@has_zero.zero.{0} rat rat.has_zero),
h : @has_le.le.{0} int int.has_le (padic_val_rat p q) (padic_val_rat p r),
hqn : @ne.{1} int (q.num) (@has_zero.zero.{0} int int.has_zero),
hqd :
  @ne.{1} int (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
    (@has_zero.zero.{0} int int.has_zero),
hrn : @ne.{1} int (r.num) (@has_zero.zero.{0} int int.has_zero),
hrd :
  @ne.{1} int (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom))
    (@has_zero.zero.{0} int int.has_zero),
hqdv :
  @ne.{1} rat
    (rat.mk (q.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))
    (@has_zero.zero.{0} rat rat.has_zero),
hrdv :
  @ne.{1} rat
    (rat.mk (r.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
    (@has_zero.zero.{0} rat rat.has_zero),
hqreq :
  @eq.{1} rat (@has_add.add.{0} rat rat.has_add q r)
    (rat.mk
       (@has_add.add.{0} int int.has_add
          (@has_mul.mul.{0} int int.has_mul (q.num)
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
          (@has_mul.mul.{0} int int.has_mul
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
             (r.num)))
       (@has_mul.mul.{0} int int.has_mul
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))),
hqrd :
  @ne.{1} int
    (@has_add.add.{0} int int.has_add
       (@has_mul.mul.{0} int int.has_mul (q.num)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
       (@has_mul.mul.{0} int int.has_mul
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
          (r.num)))
    (@has_zero.zero.{0} int int.has_zero)
⊢ ∀ (n : nat),
    @has_dvd.dvd.{0} int (@comm_semiring_has_dvd.{0} int int.comm_semiring)
      (@has_pow.pow.{0 0} int nat (@monoid.has_pow.{0} int int.monoid)
         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
         n)
      (@has_mul.mul.{0} int int.has_mul (q.num)
         (@has_mul.mul.{0} int
            (@no_zero_divisors.to_has_mul.{0} int
               (@integral_domain.to_no_zero_divisors.{0} int
                  (@normalization_domain.to_integral_domain.{0} int int.normalization_domain)))
            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
            (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))) →
    @has_dvd.dvd.{0} int (@comm_semiring_has_dvd.{0} int int.comm_semiring)
      (@has_pow.pow.{0 0} int nat (@monoid.has_pow.{0} int int.monoid)
         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
         n)
      (@has_mul.mul.{0} int int.has_mul
         (@has_add.add.{0} int int.has_add
            (@has_mul.mul.{0} int int.has_mul (q.num)
               (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
            (@has_mul.mul.{0} int int.has_mul
               (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
               (r.num)))
         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
p_prime : nat.prime p,
q r : rat,
hq : @ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero),
hr : @ne.{1} rat r (@has_zero.zero.{0} rat rat.has_zero),
hqr : @ne.{1} rat (@has_add.add.{0} rat rat.has_add q r) (@has_zero.zero.{0} rat rat.has_zero),
h : @has_le.le.{0} int int.has_le (padic_val_rat p q) (padic_val_rat p r),
hqn : @ne.{1} int (q.num) (@has_zero.zero.{0} int int.has_zero),
hqd :
  @ne.{1} int (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
    (@has_zero.zero.{0} int int.has_zero),
hrn : @ne.{1} int (r.num) (@has_zero.zero.{0} int int.has_zero),
hrd :
  @ne.{1} int (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom))
    (@has_zero.zero.{0} int int.has_zero),
hqdv :
  @ne.{1} rat
    (rat.mk (q.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))
    (@has_zero.zero.{0} rat rat.has_zero),
hrdv :
  @ne.{1} rat
    (rat.mk (r.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
    (@has_zero.zero.{0} rat rat.has_zero),
hqreq :
  @eq.{1} rat (@has_add.add.{0} rat rat.has_add q r)
    (rat.mk
       (@has_add.add.{0} int int.has_add
          (@has_mul.mul.{0} int int.has_mul (q.num)
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
          (@has_mul.mul.{0} int int.has_mul
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
             (r.num)))
       (@has_mul.mul.{0} int int.has_mul
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))),
hqrd :
  @ne.{1} int
    (@has_add.add.{0} int int.has_add
       (@has_mul.mul.{0} int int.has_mul (q.num)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
       (@has_mul.mul.{0} int int.has_mul
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
          (r.num)))
    (@has_zero.zero.{0} int int.has_zero)
⊢ @has_le.le.{0} enat enat.has_le
    (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
       (@has_mul.mul.{0} int int.has_mul (q.num)
          (@has_mul.mul.{0} int
             (@no_zero_divisors.to_has_mul.{0} int
                (@integral_domain.to_no_zero_divisors.{0} int
                   (@normalization_domain.to_integral_domain.{0} int int.normalization_domain)))
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))))
    (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
       (@has_mul.mul.{0} int int.has_mul
          (@has_add.add.{0} int int.has_add
             (@has_mul.mul.{0} int int.has_mul (q.num)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
             (@has_mul.mul.{0} int int.has_mul
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
                (r.num)))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
p_prime : nat.prime p,
q r : rat,
hq : @ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero),
hr : @ne.{1} rat r (@has_zero.zero.{0} rat rat.has_zero),
hqr : @ne.{1} rat (@has_add.add.{0} rat rat.has_add q r) (@has_zero.zero.{0} rat rat.has_zero),
h : @has_le.le.{0} int int.has_le (padic_val_rat p q) (padic_val_rat p r),
hqn : @ne.{1} int (q.num) (@has_zero.zero.{0} int int.has_zero),
hqd :
  @ne.{1} int (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
    (@has_zero.zero.{0} int int.has_zero),
hrn : @ne.{1} int (r.num) (@has_zero.zero.{0} int int.has_zero),
hrd :
  @ne.{1} int (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom))
    (@has_zero.zero.{0} int int.has_zero),
hqdv :
  @ne.{1} rat
    (rat.mk (q.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))
    (@has_zero.zero.{0} rat rat.has_zero),
hrdv :
  @ne.{1} rat
    (rat.mk (r.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
    (@has_zero.zero.{0} rat rat.has_zero),
hqreq :
  @eq.{1} rat (@has_add.add.{0} rat rat.has_add q r)
    (rat.mk
       (@has_add.add.{0} int int.has_add
          (@has_mul.mul.{0} int int.has_mul (q.num)
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
          (@has_mul.mul.{0} int int.has_mul
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
             (r.num)))
       (@has_mul.mul.{0} int int.has_mul
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))),
hqrd :
  @ne.{1} int
    (@has_add.add.{0} int int.has_add
       (@has_mul.mul.{0} int int.has_mul (q.num)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
       (@has_mul.mul.{0} int int.has_mul
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
          (r.num)))
    (@has_zero.zero.{0} int int.has_zero)
⊢ @has_le.le.{0} enat enat.has_le
    (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
       (@has_mul.mul.{0} int (@semigroup.to_has_mul.{0} int (@comm_semigroup.to_semigroup.{0} int int.comm_semigroup))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
          (@has_mul.mul.{0} int
             (@semigroup.to_has_mul.{0} int (@comm_semigroup.to_semigroup.{0} int int.comm_semigroup))
             (q.num)
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))))
    (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
       (@has_mul.mul.{0} int int.has_mul
          (@has_add.add.{0} int int.has_add
             (@has_mul.mul.{0} int int.has_mul (q.num)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
             (@has_mul.mul.{0} int int.has_mul
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
                (r.num)))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>231      multiplicity.mul (nat.prime_iff_prime_int.1 p_prime), add_mul],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='multiplicity.mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='nat.prime_iff_prime_int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='p_prime'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='add_mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/ring_theory/multiplicity.lean&#x27;, &#x27;line&#x27;: 327, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/gcd_domain.lean&#x27;, &#x27;line&#x27;: 579, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/ring.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : integral_domain.{0} α] [_inst_2 : @decidable_rel.{1} α (@has_dvd.dvd.{0} α (@comm_semiring_has_dvd.{0} α (@nonzero_comm_semiring.to_comm_semiring.{0} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} α (@integral_domain.to_nonzero_comm_ring.{0} α _inst_1)))))] {p a b : α}, @prime.{0} α (@nonzero_comm_semiring.to_comm_semiring.{0} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} α (@integral_domain.to_nonzero_comm_ring.{0} α _inst_1))) p → @eq.{1} enat (@multiplicity.{0} α (@nonzero_comm_semiring.to_comm_semiring.{0} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} α (@integral_domain.to_nonzero_comm_ring.{0} α _inst_1))) (λ (a b : α), _inst_2 a b) p (@has_mul.mul.{0} α (@no_zero_divisors.to_has_mul.{0} α (@domain.to_no_zero_divisors.{0} α (@integral_domain.to_domain.{0} α _inst_1))) a b)) (@has_add.add.{0} enat enat.has_add (@multiplicity.{0} α (@nonzero_comm_semiring.to_comm_semiring.{0} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} α (@integral_domain.to_nonzero_comm_ring.{0} α _inst_1))) (λ (a b : α), _inst_2 a b) p a) (@multiplicity.{0} α (@nonzero_comm_semiring.to_comm_semiring.{0} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} α (@integral_domain.to_nonzero_comm_ring.{0} α _inst_1))) (λ (a b : α), _inst_2 a b) p b))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {p : nat}, iff (nat.prime p) (@prime.{0} int int.comm_semiring (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat.prime p'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : distrib.{0} α] (a b c : α), @eq.{1} α (@has_mul.mul.{0} α (@distrib.to_has_mul.{0} α _inst_1) (@has_add.add.{0} α (@distrib.to_has_add.{0} α _inst_1) a b) c) (@has_add.add.{0} α (@distrib.to_has_add.{0} α _inst_1) (@has_mul.mul.{0} α (@distrib.to_has_mul.{0} α _inst_1) a c) (@has_mul.mul.{0} α (@distrib.to_has_mul.{0} α _inst_1) b c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
p_prime : nat.prime p,
q r : rat,
hq : @ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero),
hr : @ne.{1} rat r (@has_zero.zero.{0} rat rat.has_zero),
hqr : @ne.{1} rat (@has_add.add.{0} rat rat.has_add q r) (@has_zero.zero.{0} rat rat.has_zero),
h : @has_le.le.{0} int int.has_le (padic_val_rat p q) (padic_val_rat p r),
hqn : @ne.{1} int (q.num) (@has_zero.zero.{0} int int.has_zero),
hqd :
  @ne.{1} int (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
    (@has_zero.zero.{0} int int.has_zero),
hrn : @ne.{1} int (r.num) (@has_zero.zero.{0} int int.has_zero),
hrd :
  @ne.{1} int (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom))
    (@has_zero.zero.{0} int int.has_zero),
hqdv :
  @ne.{1} rat
    (rat.mk (q.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))
    (@has_zero.zero.{0} rat rat.has_zero),
hrdv :
  @ne.{1} rat
    (rat.mk (r.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
    (@has_zero.zero.{0} rat rat.has_zero),
hqreq :
  @eq.{1} rat (@has_add.add.{0} rat rat.has_add q r)
    (rat.mk
       (@has_add.add.{0} int int.has_add
          (@has_mul.mul.{0} int int.has_mul (q.num)
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
          (@has_mul.mul.{0} int int.has_mul
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
             (r.num)))
       (@has_mul.mul.{0} int int.has_mul
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))),
hqrd :
  @ne.{1} int
    (@has_add.add.{0} int int.has_add
       (@has_mul.mul.{0} int int.has_mul (q.num)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
       (@has_mul.mul.{0} int int.has_mul
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
          (r.num)))
    (@has_zero.zero.{0} int int.has_zero)
⊢ @has_le.le.{0} enat enat.has_le
    (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
       (@has_mul.mul.{0} int (@semigroup.to_has_mul.{0} int (@comm_semigroup.to_semigroup.{0} int int.comm_semigroup))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
          (@has_mul.mul.{0} int
             (@semigroup.to_has_mul.{0} int (@comm_semigroup.to_semigroup.{0} int int.comm_semigroup))
             (q.num)
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))))
    (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
       (@has_mul.mul.{0} int int.has_mul
          (@has_add.add.{0} int int.has_add
             (@has_mul.mul.{0} int int.has_mul (q.num)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
             (@has_mul.mul.{0} int int.has_mul
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
                (r.num)))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
p_prime : nat.prime p,
q r : rat,
hq : @ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero),
hr : @ne.{1} rat r (@has_zero.zero.{0} rat rat.has_zero),
hqr : @ne.{1} rat (@has_add.add.{0} rat rat.has_add q r) (@has_zero.zero.{0} rat rat.has_zero),
h : @has_le.le.{0} int int.has_le (padic_val_rat p q) (padic_val_rat p r),
hqn : @ne.{1} int (q.num) (@has_zero.zero.{0} int int.has_zero),
hqd :
  @ne.{1} int (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
    (@has_zero.zero.{0} int int.has_zero),
hrn : @ne.{1} int (r.num) (@has_zero.zero.{0} int int.has_zero),
hrd :
  @ne.{1} int (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom))
    (@has_zero.zero.{0} int int.has_zero),
hqdv :
  @ne.{1} rat
    (rat.mk (q.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))
    (@has_zero.zero.{0} rat rat.has_zero),
hrdv :
  @ne.{1} rat
    (rat.mk (r.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
    (@has_zero.zero.{0} rat rat.has_zero),
hqreq :
  @eq.{1} rat (@has_add.add.{0} rat rat.has_add q r)
    (rat.mk
       (@has_add.add.{0} int int.has_add
          (@has_mul.mul.{0} int int.has_mul (q.num)
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
          (@has_mul.mul.{0} int int.has_mul
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
             (r.num)))
       (@has_mul.mul.{0} int int.has_mul
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))),
hqrd :
  @ne.{1} int
    (@has_add.add.{0} int int.has_add
       (@has_mul.mul.{0} int int.has_mul (q.num)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
       (@has_mul.mul.{0} int int.has_mul
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
          (r.num)))
    (@has_zero.zero.{0} int int.has_zero)
⊢ @has_le.le.{0} enat enat.has_le
    (@has_add.add.{0} enat enat.has_add
       (@multiplicity.{0} int
          (@nonzero_comm_semiring.to_comm_semiring.{0} int
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} int
                (@integral_domain.to_nonzero_comm_ring.{0} int
                   (@normalization_domain.to_integral_domain.{0} int int.normalization_domain))))
          (λ (a b : int), (λ (a b : int), int.decidable_dvd a b) a b)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))
       (@multiplicity.{0} int
          (@nonzero_comm_semiring.to_comm_semiring.{0} int
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} int
                (@integral_domain.to_nonzero_comm_ring.{0} int
                   (@normalization_domain.to_integral_domain.{0} int int.normalization_domain))))
          (λ (a b : int), (λ (a b : int), int.decidable_dvd a b) a b)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
          (@has_mul.mul.{0} int
             (@semigroup.to_has_mul.{0} int (@comm_semigroup.to_semigroup.{0} int int.comm_semigroup))
             (q.num)
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))))
    (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
       (@has_mul.mul.{0} int int.has_mul
          (@has_add.add.{0} int int.has_add
             (@has_mul.mul.{0} int int.has_mul (q.num)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
             (@has_mul.mul.{0} int int.has_mul
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
                (r.num)))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
p_prime : nat.prime p,
q r : rat,
hq : @ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero),
hr : @ne.{1} rat r (@has_zero.zero.{0} rat rat.has_zero),
hqr : @ne.{1} rat (@has_add.add.{0} rat rat.has_add q r) (@has_zero.zero.{0} rat rat.has_zero),
h : @has_le.le.{0} int int.has_le (padic_val_rat p q) (padic_val_rat p r),
hqn : @ne.{1} int (q.num) (@has_zero.zero.{0} int int.has_zero),
hqd :
  @ne.{1} int (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
    (@has_zero.zero.{0} int int.has_zero),
hrn : @ne.{1} int (r.num) (@has_zero.zero.{0} int int.has_zero),
hrd :
  @ne.{1} int (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom))
    (@has_zero.zero.{0} int int.has_zero),
hqdv :
  @ne.{1} rat
    (rat.mk (q.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))
    (@has_zero.zero.{0} rat rat.has_zero),
hrdv :
  @ne.{1} rat
    (rat.mk (r.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
    (@has_zero.zero.{0} rat rat.has_zero),
hqreq :
  @eq.{1} rat (@has_add.add.{0} rat rat.has_add q r)
    (rat.mk
       (@has_add.add.{0} int int.has_add
          (@has_mul.mul.{0} int int.has_mul (q.num)
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
          (@has_mul.mul.{0} int int.has_mul
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
             (r.num)))
       (@has_mul.mul.{0} int int.has_mul
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))),
hqrd :
  @ne.{1} int
    (@has_add.add.{0} int int.has_add
       (@has_mul.mul.{0} int int.has_mul (q.num)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
       (@has_mul.mul.{0} int int.has_mul
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
          (r.num)))
    (@has_zero.zero.{0} int int.has_zero)
⊢ @has_le.le.{0} enat enat.has_le
    (@has_add.add.{0} enat enat.has_add
       (@multiplicity.{0} int
          (@nonzero_comm_semiring.to_comm_semiring.{0} int
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} int
                (@integral_domain.to_nonzero_comm_ring.{0} int
                   (@normalization_domain.to_integral_domain.{0} int int.normalization_domain))))
          (λ (a b : int), (λ (a b : int), int.decidable_dvd a b) a b)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))
       (@multiplicity.{0} int
          (@nonzero_comm_semiring.to_comm_semiring.{0} int
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} int
                (@integral_domain.to_nonzero_comm_ring.{0} int
                   (@normalization_domain.to_integral_domain.{0} int int.normalization_domain))))
          (λ (a b : int), (λ (a b : int), int.decidable_dvd a b) a b)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
          (@has_mul.mul.{0} int
             (@semigroup.to_has_mul.{0} int (@comm_semigroup.to_semigroup.{0} int int.comm_semigroup))
             (q.num)
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))))
    (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
       (@has_add.add.{0} int (@distrib.to_has_add.{0} int int.distrib)
          (@has_mul.mul.{0} int (@distrib.to_has_mul.{0} int int.distrib)
             (@has_mul.mul.{0} int int.has_mul (q.num)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))
          (@has_mul.mul.{0} int (@distrib.to_has_mul.{0} int int.distrib)
             (@has_mul.mul.{0} int int.has_mul
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
                (r.num))
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>232    rw [←(@rat.num_denom q), ←(@rat.num_denom r), padic_val_rat_le_padic_val_rat_iff p hqn hrn hqd hrd,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='rat.num_denom'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='q'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='rat.num_denom'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='r'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='padic_val_rat.padic_val_rat_le_padic_val_rat_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hqn'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hrn'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hqd'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hrd'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/rat/basic.lean&#x27;, &#x27;line&#x27;: 216, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/rat/basic.lean&#x27;, &#x27;line&#x27;: 216, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 188, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {a : rat}, @eq.{1} rat (rat.mk (a.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (a.denom))) a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {a : rat}, @eq.{1} rat (rat.mk (a.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (a.denom))) a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (p : nat) [p_prime : nat.prime p] {n₁ n₂ d₁ d₂ : int}, @ne.{1} int n₁ (@has_zero.zero.{0} int int.has_zero) → @ne.{1} int n₂ (@has_zero.zero.{0} int int.has_zero) → @ne.{1} int d₁ (@has_zero.zero.{0} int int.has_zero) → @ne.{1} int d₂ (@has_zero.zero.{0} int int.has_zero) → iff (@has_le.le.{0} int int.has_le (padic_val_rat p (rat.mk n₁ d₁)) (padic_val_rat p (rat.mk n₂ d₂))) (∀ (n : nat), @has_dvd.dvd.{0} int (@comm_semiring_has_dvd.{0} int int.comm_semiring) (@has_pow.pow.{0 0} int nat (@monoid.has_pow.{0} int int.monoid) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p) n) (@has_mul.mul.{0} int int.has_mul n₁ d₂) → @has_dvd.dvd.{0} int (@comm_semiring_has_dvd.{0} int int.comm_semiring) (@has_pow.pow.{0 0} int nat (@monoid.has_pow.{0} int int.monoid) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p) n) (@has_mul.mul.{0} int int.has_mul n₂ d₁))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@ne.{1} int (q.num) (@has_zero.zero.{0} int int.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@ne.{1} int (r.num) (@has_zero.zero.{0} int int.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@ne.{1} int (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)) (@has_zero.zero.{0} int int.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@ne.{1} int (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)) (@has_zero.zero.{0} int int.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='A condition for `padic_val_rat p (n₁ / d₁) ≤ padic_val_rat p (n₂ / d₂),
in terms of divisibility by `p^n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
p_prime : nat.prime p,
q r : rat,
hq : @ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero),
hr : @ne.{1} rat r (@has_zero.zero.{0} rat rat.has_zero),
hqr : @ne.{1} rat (@has_add.add.{0} rat rat.has_add q r) (@has_zero.zero.{0} rat rat.has_zero),
h : @has_le.le.{0} int int.has_le (padic_val_rat p q) (padic_val_rat p r),
hqn : @ne.{1} int (q.num) (@has_zero.zero.{0} int int.has_zero),
hqd :
  @ne.{1} int (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
    (@has_zero.zero.{0} int int.has_zero),
hrn : @ne.{1} int (r.num) (@has_zero.zero.{0} int int.has_zero),
hrd :
  @ne.{1} int (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom))
    (@has_zero.zero.{0} int int.has_zero),
hqdv :
  @ne.{1} rat
    (rat.mk (q.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))
    (@has_zero.zero.{0} rat rat.has_zero),
hrdv :
  @ne.{1} rat
    (rat.mk (r.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
    (@has_zero.zero.{0} rat rat.has_zero),
hqreq :
  @eq.{1} rat (@has_add.add.{0} rat rat.has_add q r)
    (rat.mk
       (@has_add.add.{0} int int.has_add
          (@has_mul.mul.{0} int int.has_mul (q.num)
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
          (@has_mul.mul.{0} int int.has_mul
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
             (r.num)))
       (@has_mul.mul.{0} int int.has_mul
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))),
hqrd :
  @ne.{1} int
    (@has_add.add.{0} int int.has_add
       (@has_mul.mul.{0} int int.has_mul (q.num)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
       (@has_mul.mul.{0} int int.has_mul
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
          (r.num)))
    (@has_zero.zero.{0} int int.has_zero)
⊢ @has_le.le.{0} enat enat.has_le
    (@has_add.add.{0} enat enat.has_add
       (@multiplicity.{0} int
          (@nonzero_comm_semiring.to_comm_semiring.{0} int
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} int
                (@integral_domain.to_nonzero_comm_ring.{0} int
                   (@normalization_domain.to_integral_domain.{0} int int.normalization_domain))))
          (λ (a b : int), (λ (a b : int), int.decidable_dvd a b) a b)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))
       (@multiplicity.{0} int
          (@nonzero_comm_semiring.to_comm_semiring.{0} int
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} int
                (@integral_domain.to_nonzero_comm_ring.{0} int
                   (@normalization_domain.to_integral_domain.{0} int int.normalization_domain))))
          (λ (a b : int), (λ (a b : int), int.decidable_dvd a b) a b)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
          (@has_mul.mul.{0} int
             (@semigroup.to_has_mul.{0} int (@comm_semigroup.to_semigroup.{0} int int.comm_semigroup))
             (q.num)
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))))
    (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
       (@has_add.add.{0} int (@distrib.to_has_add.{0} int int.distrib)
          (@has_mul.mul.{0} int (@distrib.to_has_mul.{0} int int.distrib)
             (@has_mul.mul.{0} int int.has_mul (q.num)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))
          (@has_mul.mul.{0} int (@distrib.to_has_mul.{0} int int.distrib)
             (@has_mul.mul.{0} int int.has_mul
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
                (r.num))
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
p_prime : nat.prime p,
q r : rat,
hq : @ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero),
hr : @ne.{1} rat r (@has_zero.zero.{0} rat rat.has_zero),
hqr : @ne.{1} rat (@has_add.add.{0} rat rat.has_add q r) (@has_zero.zero.{0} rat rat.has_zero),
hqn : @ne.{1} int (q.num) (@has_zero.zero.{0} int int.has_zero),
hqd :
  @ne.{1} int (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
    (@has_zero.zero.{0} int int.has_zero),
hrn : @ne.{1} int (r.num) (@has_zero.zero.{0} int int.has_zero),
hrd :
  @ne.{1} int (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom))
    (@has_zero.zero.{0} int int.has_zero),
hqdv :
  @ne.{1} rat
    (rat.mk (q.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))
    (@has_zero.zero.{0} rat rat.has_zero),
hrdv :
  @ne.{1} rat
    (rat.mk (r.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
    (@has_zero.zero.{0} rat rat.has_zero),
hqreq :
  @eq.{1} rat (@has_add.add.{0} rat rat.has_add q r)
    (rat.mk
       (@has_add.add.{0} int int.has_add
          (@has_mul.mul.{0} int int.has_mul (q.num)
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
          (@has_mul.mul.{0} int int.has_mul
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
             (r.num)))
       (@has_mul.mul.{0} int int.has_mul
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))),
hqrd :
  @ne.{1} int
    (@has_add.add.{0} int int.has_add
       (@has_mul.mul.{0} int int.has_mul (q.num)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
       (@has_mul.mul.{0} int int.has_mul
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
          (r.num)))
    (@has_zero.zero.{0} int int.has_zero),
h :
  @has_le.le.{0} int int.has_le
    (padic_val_rat p
       (rat.mk (q.num)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))))
    (padic_val_rat p r)
⊢ @has_le.le.{0} enat enat.has_le
    (@has_add.add.{0} enat enat.has_add
       (@multiplicity.{0} int
          (@nonzero_comm_semiring.to_comm_semiring.{0} int
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} int
                (@integral_domain.to_nonzero_comm_ring.{0} int
                   (@normalization_domain.to_integral_domain.{0} int int.normalization_domain))))
          (λ (a b : int), (λ (a b : int), int.decidable_dvd a b) a b)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))
       (@multiplicity.{0} int
          (@nonzero_comm_semiring.to_comm_semiring.{0} int
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} int
                (@integral_domain.to_nonzero_comm_ring.{0} int
                   (@normalization_domain.to_integral_domain.{0} int int.normalization_domain))))
          (λ (a b : int), (λ (a b : int), int.decidable_dvd a b) a b)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
          (@has_mul.mul.{0} int
             (@semigroup.to_has_mul.{0} int (@comm_semigroup.to_semigroup.{0} int int.comm_semigroup))
             (q.num)
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))))
    (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
       (@has_add.add.{0} int (@distrib.to_has_add.{0} int int.distrib)
          (@has_mul.mul.{0} int (@distrib.to_has_mul.{0} int int.distrib)
             (@has_mul.mul.{0} int int.has_mul (q.num)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))
          (@has_mul.mul.{0} int (@distrib.to_has_mul.{0} int int.distrib)
             (@has_mul.mul.{0} int int.has_mul
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
                (r.num))
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
p_prime : nat.prime p,
q r : rat,
hq : @ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero),
hr : @ne.{1} rat r (@has_zero.zero.{0} rat rat.has_zero),
hqr : @ne.{1} rat (@has_add.add.{0} rat rat.has_add q r) (@has_zero.zero.{0} rat rat.has_zero),
hqn : @ne.{1} int (q.num) (@has_zero.zero.{0} int int.has_zero),
hqd :
  @ne.{1} int (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
    (@has_zero.zero.{0} int int.has_zero),
hrn : @ne.{1} int (r.num) (@has_zero.zero.{0} int int.has_zero),
hrd :
  @ne.{1} int (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom))
    (@has_zero.zero.{0} int int.has_zero),
hqdv :
  @ne.{1} rat
    (rat.mk (q.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))
    (@has_zero.zero.{0} rat rat.has_zero),
hrdv :
  @ne.{1} rat
    (rat.mk (r.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
    (@has_zero.zero.{0} rat rat.has_zero),
hqreq :
  @eq.{1} rat (@has_add.add.{0} rat rat.has_add q r)
    (rat.mk
       (@has_add.add.{0} int int.has_add
          (@has_mul.mul.{0} int int.has_mul (q.num)
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
          (@has_mul.mul.{0} int int.has_mul
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
             (r.num)))
       (@has_mul.mul.{0} int int.has_mul
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))),
hqrd :
  @ne.{1} int
    (@has_add.add.{0} int int.has_add
       (@has_mul.mul.{0} int int.has_mul (q.num)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
       (@has_mul.mul.{0} int int.has_mul
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
          (r.num)))
    (@has_zero.zero.{0} int int.has_zero),
h :
  @has_le.le.{0} int int.has_le
    (padic_val_rat p
       (rat.mk (q.num)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))))
    (padic_val_rat p
       (rat.mk (r.num)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom))))
⊢ @has_le.le.{0} enat enat.has_le
    (@has_add.add.{0} enat enat.has_add
       (@multiplicity.{0} int
          (@nonzero_comm_semiring.to_comm_semiring.{0} int
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} int
                (@integral_domain.to_nonzero_comm_ring.{0} int
                   (@normalization_domain.to_integral_domain.{0} int int.normalization_domain))))
          (λ (a b : int), (λ (a b : int), int.decidable_dvd a b) a b)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))
       (@multiplicity.{0} int
          (@nonzero_comm_semiring.to_comm_semiring.{0} int
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} int
                (@integral_domain.to_nonzero_comm_ring.{0} int
                   (@normalization_domain.to_integral_domain.{0} int int.normalization_domain))))
          (λ (a b : int), (λ (a b : int), int.decidable_dvd a b) a b)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
          (@has_mul.mul.{0} int
             (@semigroup.to_has_mul.{0} int (@comm_semigroup.to_semigroup.{0} int int.comm_semigroup))
             (q.num)
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))))
    (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
       (@has_add.add.{0} int (@distrib.to_has_add.{0} int int.distrib)
          (@has_mul.mul.{0} int (@distrib.to_has_mul.{0} int int.distrib)
             (@has_mul.mul.{0} int int.has_mul (q.num)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))
          (@has_mul.mul.{0} int (@distrib.to_has_mul.{0} int int.distrib)
             (@has_mul.mul.{0} int int.has_mul
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
                (r.num))
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
p_prime : nat.prime p,
q r : rat,
hq : @ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero),
hr : @ne.{1} rat r (@has_zero.zero.{0} rat rat.has_zero),
hqr : @ne.{1} rat (@has_add.add.{0} rat rat.has_add q r) (@has_zero.zero.{0} rat rat.has_zero),
hqn : @ne.{1} int (q.num) (@has_zero.zero.{0} int int.has_zero),
hqd :
  @ne.{1} int (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
    (@has_zero.zero.{0} int int.has_zero),
hrn : @ne.{1} int (r.num) (@has_zero.zero.{0} int int.has_zero),
hrd :
  @ne.{1} int (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom))
    (@has_zero.zero.{0} int int.has_zero),
hqdv :
  @ne.{1} rat
    (rat.mk (q.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))
    (@has_zero.zero.{0} rat rat.has_zero),
hrdv :
  @ne.{1} rat
    (rat.mk (r.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
    (@has_zero.zero.{0} rat rat.has_zero),
hqreq :
  @eq.{1} rat (@has_add.add.{0} rat rat.has_add q r)
    (rat.mk
       (@has_add.add.{0} int int.has_add
          (@has_mul.mul.{0} int int.has_mul (q.num)
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
          (@has_mul.mul.{0} int int.has_mul
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
             (r.num)))
       (@has_mul.mul.{0} int int.has_mul
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))),
hqrd :
  @ne.{1} int
    (@has_add.add.{0} int int.has_add
       (@has_mul.mul.{0} int int.has_mul (q.num)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
       (@has_mul.mul.{0} int int.has_mul
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
          (r.num)))
    (@has_zero.zero.{0} int int.has_zero),
h :
  ∀ (n : nat),
    @has_dvd.dvd.{0} int (@comm_semiring_has_dvd.{0} int int.comm_semiring)
      (@has_pow.pow.{0 0} int nat (@monoid.has_pow.{0} int int.monoid)
         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
         n)
      (@has_mul.mul.{0} int int.has_mul (q.num)
         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom))) →
    @has_dvd.dvd.{0} int (@comm_semiring_has_dvd.{0} int int.comm_semiring)
      (@has_pow.pow.{0 0} int nat (@monoid.has_pow.{0} int int.monoid)
         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
         n)
      (@has_mul.mul.{0} int int.has_mul (r.num)
         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))
⊢ @has_le.le.{0} enat enat.has_le
    (@has_add.add.{0} enat enat.has_add
       (@multiplicity.{0} int
          (@nonzero_comm_semiring.to_comm_semiring.{0} int
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} int
                (@integral_domain.to_nonzero_comm_ring.{0} int
                   (@normalization_domain.to_integral_domain.{0} int int.normalization_domain))))
          (λ (a b : int), (λ (a b : int), int.decidable_dvd a b) a b)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))
       (@multiplicity.{0} int
          (@nonzero_comm_semiring.to_comm_semiring.{0} int
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} int
                (@integral_domain.to_nonzero_comm_ring.{0} int
                   (@normalization_domain.to_integral_domain.{0} int int.normalization_domain))))
          (λ (a b : int), (λ (a b : int), int.decidable_dvd a b) a b)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
          (@has_mul.mul.{0} int
             (@semigroup.to_has_mul.{0} int (@comm_semigroup.to_semigroup.{0} int int.comm_semigroup))
             (q.num)
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))))
    (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
       (@has_add.add.{0} int (@distrib.to_has_add.{0} int int.distrib)
          (@has_mul.mul.{0} int (@distrib.to_has_mul.{0} int int.distrib)
             (@has_mul.mul.{0} int int.has_mul (q.num)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))
          (@has_mul.mul.{0} int (@distrib.to_has_mul.{0} int int.distrib)
             (@has_mul.mul.{0} int int.has_mul
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
                (r.num))
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>233      ← multiplicity_le_multiplicity_iff] at h,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='multiplicity.multiplicity_le_multiplicity_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/ring_theory/multiplicity.lean&#x27;, &#x27;line&#x27;: 141, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : comm_semiring.{0} α] [_inst_2 : @decidable_rel.{1} α (@has_dvd.dvd.{0} α (@comm_semiring_has_dvd.{0} α _inst_1))] {a b c d : α}, iff (@has_le.le.{0} enat enat.has_le (@multiplicity.{0} α _inst_1 (λ (a b : α), _inst_2 a b) a b) (@multiplicity.{0} α _inst_1 (λ (a b : α), _inst_2 a b) c d)) (∀ (n : nat), @has_dvd.dvd.{0} α (@comm_semiring_has_dvd.{0} α _inst_1) (@has_pow.pow.{0 0} α nat (@monoid.has_pow.{0} α (@semiring.to_monoid.{0} α (@comm_semiring.to_semiring.{0} α _inst_1))) a n) b → @has_dvd.dvd.{0} α (@comm_semiring_has_dvd.{0} α _inst_1) (@has_pow.pow.{0 0} α nat (@monoid.has_pow.{0} α (@semiring.to_monoid.{0} α (@comm_semiring.to_semiring.{0} α _inst_1))) c n) d)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
p_prime : nat.prime p,
q r : rat,
hq : @ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero),
hr : @ne.{1} rat r (@has_zero.zero.{0} rat rat.has_zero),
hqr : @ne.{1} rat (@has_add.add.{0} rat rat.has_add q r) (@has_zero.zero.{0} rat rat.has_zero),
hqn : @ne.{1} int (q.num) (@has_zero.zero.{0} int int.has_zero),
hqd :
  @ne.{1} int (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
    (@has_zero.zero.{0} int int.has_zero),
hrn : @ne.{1} int (r.num) (@has_zero.zero.{0} int int.has_zero),
hrd :
  @ne.{1} int (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom))
    (@has_zero.zero.{0} int int.has_zero),
hqdv :
  @ne.{1} rat
    (rat.mk (q.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))
    (@has_zero.zero.{0} rat rat.has_zero),
hrdv :
  @ne.{1} rat
    (rat.mk (r.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
    (@has_zero.zero.{0} rat rat.has_zero),
hqreq :
  @eq.{1} rat (@has_add.add.{0} rat rat.has_add q r)
    (rat.mk
       (@has_add.add.{0} int int.has_add
          (@has_mul.mul.{0} int int.has_mul (q.num)
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
          (@has_mul.mul.{0} int int.has_mul
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
             (r.num)))
       (@has_mul.mul.{0} int int.has_mul
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))),
hqrd :
  @ne.{1} int
    (@has_add.add.{0} int int.has_add
       (@has_mul.mul.{0} int int.has_mul (q.num)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
       (@has_mul.mul.{0} int int.has_mul
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
          (r.num)))
    (@has_zero.zero.{0} int int.has_zero),
h :
  ∀ (n : nat),
    @has_dvd.dvd.{0} int (@comm_semiring_has_dvd.{0} int int.comm_semiring)
      (@has_pow.pow.{0 0} int nat (@monoid.has_pow.{0} int int.monoid)
         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
         n)
      (@has_mul.mul.{0} int int.has_mul (q.num)
         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom))) →
    @has_dvd.dvd.{0} int (@comm_semiring_has_dvd.{0} int int.comm_semiring)
      (@has_pow.pow.{0 0} int nat (@monoid.has_pow.{0} int int.monoid)
         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
         n)
      (@has_mul.mul.{0} int int.has_mul (r.num)
         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))
⊢ @has_le.le.{0} enat enat.has_le
    (@has_add.add.{0} enat enat.has_add
       (@multiplicity.{0} int
          (@nonzero_comm_semiring.to_comm_semiring.{0} int
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} int
                (@integral_domain.to_nonzero_comm_ring.{0} int
                   (@normalization_domain.to_integral_domain.{0} int int.normalization_domain))))
          (λ (a b : int), (λ (a b : int), int.decidable_dvd a b) a b)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))
       (@multiplicity.{0} int
          (@nonzero_comm_semiring.to_comm_semiring.{0} int
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} int
                (@integral_domain.to_nonzero_comm_ring.{0} int
                   (@normalization_domain.to_integral_domain.{0} int int.normalization_domain))))
          (λ (a b : int), (λ (a b : int), int.decidable_dvd a b) a b)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
          (@has_mul.mul.{0} int
             (@semigroup.to_has_mul.{0} int (@comm_semigroup.to_semigroup.{0} int int.comm_semigroup))
             (q.num)
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))))
    (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
       (@has_add.add.{0} int (@distrib.to_has_add.{0} int int.distrib)
          (@has_mul.mul.{0} int (@distrib.to_has_mul.{0} int int.distrib)
             (@has_mul.mul.{0} int int.has_mul (q.num)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))
          (@has_mul.mul.{0} int (@distrib.to_has_mul.{0} int int.distrib)
             (@has_mul.mul.{0} int int.has_mul
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
                (r.num))
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
p_prime : nat.prime p,
q r : rat,
hq : @ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero),
hr : @ne.{1} rat r (@has_zero.zero.{0} rat rat.has_zero),
hqr : @ne.{1} rat (@has_add.add.{0} rat rat.has_add q r) (@has_zero.zero.{0} rat rat.has_zero),
hqn : @ne.{1} int (q.num) (@has_zero.zero.{0} int int.has_zero),
hqd :
  @ne.{1} int (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
    (@has_zero.zero.{0} int int.has_zero),
hrn : @ne.{1} int (r.num) (@has_zero.zero.{0} int int.has_zero),
hrd :
  @ne.{1} int (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom))
    (@has_zero.zero.{0} int int.has_zero),
hqdv :
  @ne.{1} rat
    (rat.mk (q.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))
    (@has_zero.zero.{0} rat rat.has_zero),
hrdv :
  @ne.{1} rat
    (rat.mk (r.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
    (@has_zero.zero.{0} rat rat.has_zero),
hqreq :
  @eq.{1} rat (@has_add.add.{0} rat rat.has_add q r)
    (rat.mk
       (@has_add.add.{0} int int.has_add
          (@has_mul.mul.{0} int int.has_mul (q.num)
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
          (@has_mul.mul.{0} int int.has_mul
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
             (r.num)))
       (@has_mul.mul.{0} int int.has_mul
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))),
hqrd :
  @ne.{1} int
    (@has_add.add.{0} int int.has_add
       (@has_mul.mul.{0} int int.has_mul (q.num)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
       (@has_mul.mul.{0} int int.has_mul
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
          (r.num)))
    (@has_zero.zero.{0} int int.has_zero),
h :
  @has_le.le.{0} enat enat.has_le
    (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
       (@has_mul.mul.{0} int int.has_mul (q.num)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom))))
    (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
       (@has_mul.mul.{0} int int.has_mul (r.num)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))))
⊢ @has_le.le.{0} enat enat.has_le
    (@has_add.add.{0} enat enat.has_add
       (@multiplicity.{0} int
          (@nonzero_comm_semiring.to_comm_semiring.{0} int
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} int
                (@integral_domain.to_nonzero_comm_ring.{0} int
                   (@normalization_domain.to_integral_domain.{0} int int.normalization_domain))))
          (λ (a b : int), (λ (a b : int), int.decidable_dvd a b) a b)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))
       (@multiplicity.{0} int
          (@nonzero_comm_semiring.to_comm_semiring.{0} int
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} int
                (@integral_domain.to_nonzero_comm_ring.{0} int
                   (@normalization_domain.to_integral_domain.{0} int int.normalization_domain))))
          (λ (a b : int), (λ (a b : int), int.decidable_dvd a b) a b)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
          (@has_mul.mul.{0} int
             (@semigroup.to_has_mul.{0} int (@comm_semigroup.to_semigroup.{0} int int.comm_semigroup))
             (q.num)
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))))
    (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
       (@has_add.add.{0} int (@distrib.to_has_add.{0} int int.distrib)
          (@has_mul.mul.{0} int (@distrib.to_has_mul.{0} int int.distrib)
             (@has_mul.mul.{0} int int.has_mul (q.num)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))
          (@has_mul.mul.{0} int (@distrib.to_has_mul.{0} int int.distrib)
             (@has_mul.mul.{0} int int.has_mul
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
                (r.num))
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
p_prime : nat.prime p,
q r : rat,
hq : @ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero),
hr : @ne.{1} rat r (@has_zero.zero.{0} rat rat.has_zero),
hqr : @ne.{1} rat (@has_add.add.{0} rat rat.has_add q r) (@has_zero.zero.{0} rat rat.has_zero),
h : @has_le.le.{0} int int.has_le (padic_val_rat p q) (padic_val_rat p r),
hqn : @ne.{1} int (q.num) (@has_zero.zero.{0} int int.has_zero),
hqd :
  @ne.{1} int (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
    (@has_zero.zero.{0} int int.has_zero),
hrn : @ne.{1} int (r.num) (@has_zero.zero.{0} int int.has_zero),
hrd :
  @ne.{1} int (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom))
    (@has_zero.zero.{0} int int.has_zero),
hqdv :
  @ne.{1} rat
    (rat.mk (q.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))
    (@has_zero.zero.{0} rat rat.has_zero),
hrdv :
  @ne.{1} rat
    (rat.mk (r.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
    (@has_zero.zero.{0} rat rat.has_zero),
hqreq :
  @eq.{1} rat (@has_add.add.{0} rat rat.has_add q r)
    (rat.mk
       (@has_add.add.{0} int int.has_add
          (@has_mul.mul.{0} int int.has_mul (q.num)
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
          (@has_mul.mul.{0} int int.has_mul
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
             (r.num)))
       (@has_mul.mul.{0} int int.has_mul
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))),
hqrd :
  @ne.{1} int
    (@has_add.add.{0} int int.has_add
       (@has_mul.mul.{0} int int.has_mul (q.num)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
       (@has_mul.mul.{0} int int.has_mul
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
          (r.num)))
    (@has_zero.zero.{0} int int.has_zero)
⊢ @has_le.le.{0} enat enat.has_le
    (@has_add.add.{0} enat enat.has_add
       (@multiplicity.{0} int
          (@nonzero_comm_semiring.to_comm_semiring.{0} int
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} int
                (@integral_domain.to_nonzero_comm_ring.{0} int
                   (@normalization_domain.to_integral_domain.{0} int int.normalization_domain))))
          (λ (a b : int), (λ (a b : int), int.decidable_dvd a b) a b)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))
       (@multiplicity.{0} int
          (@nonzero_comm_semiring.to_comm_semiring.{0} int
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} int
                (@integral_domain.to_nonzero_comm_ring.{0} int
                   (@normalization_domain.to_integral_domain.{0} int int.normalization_domain))))
          (λ (a b : int), (λ (a b : int), int.decidable_dvd a b) a b)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
          (@has_mul.mul.{0} int
             (@semigroup.to_has_mul.{0} int (@comm_semigroup.to_semigroup.{0} int int.comm_semigroup))
             (q.num)
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))))
    (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
       (@has_add.add.{0} int (@distrib.to_has_add.{0} int int.distrib)
          (@has_mul.mul.{0} int (@distrib.to_has_mul.{0} int int.distrib)
             (@has_mul.mul.{0} int int.has_mul (q.num)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))
          (@has_mul.mul.{0} int (@distrib.to_has_mul.{0} int int.distrib)
             (@has_mul.mul.{0} int int.has_mul
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
                (r.num))
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
p_prime : nat.prime p,
q r : rat,
hq : @ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero),
hr : @ne.{1} rat r (@has_zero.zero.{0} rat rat.has_zero),
hqr : @ne.{1} rat (@has_add.add.{0} rat rat.has_add q r) (@has_zero.zero.{0} rat rat.has_zero),
hqn : @ne.{1} int (q.num) (@has_zero.zero.{0} int int.has_zero),
hqd :
  @ne.{1} int (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
    (@has_zero.zero.{0} int int.has_zero),
hrn : @ne.{1} int (r.num) (@has_zero.zero.{0} int int.has_zero),
hrd :
  @ne.{1} int (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom))
    (@has_zero.zero.{0} int int.has_zero),
hqdv :
  @ne.{1} rat
    (rat.mk (q.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))
    (@has_zero.zero.{0} rat rat.has_zero),
hrdv :
  @ne.{1} rat
    (rat.mk (r.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
    (@has_zero.zero.{0} rat rat.has_zero),
hqreq :
  @eq.{1} rat (@has_add.add.{0} rat rat.has_add q r)
    (rat.mk
       (@has_add.add.{0} int int.has_add
          (@has_mul.mul.{0} int int.has_mul (q.num)
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
          (@has_mul.mul.{0} int int.has_mul
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
             (r.num)))
       (@has_mul.mul.{0} int int.has_mul
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))),
hqrd :
  @ne.{1} int
    (@has_add.add.{0} int int.has_add
       (@has_mul.mul.{0} int int.has_mul (q.num)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
       (@has_mul.mul.{0} int int.has_mul
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
          (r.num)))
    (@has_zero.zero.{0} int int.has_zero),
h :
  @has_le.le.{0} enat enat.has_le
    (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
       (@has_mul.mul.{0} int int.has_mul (q.num)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom))))
    (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
       (@has_mul.mul.{0} int int.has_mul (r.num)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))))
⊢ @has_le.le.{0} enat enat.has_le
    (@has_add.add.{0} enat enat.has_add
       (@multiplicity.{0} int
          (@nonzero_comm_semiring.to_comm_semiring.{0} int
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} int
                (@integral_domain.to_nonzero_comm_ring.{0} int
                   (@normalization_domain.to_integral_domain.{0} int int.normalization_domain))))
          (λ (a b : int), (λ (a b : int), int.decidable_dvd a b) a b)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))
       (@multiplicity.{0} int
          (@nonzero_comm_semiring.to_comm_semiring.{0} int
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} int
                (@integral_domain.to_nonzero_comm_ring.{0} int
                   (@normalization_domain.to_integral_domain.{0} int int.normalization_domain))))
          (λ (a b : int), (λ (a b : int), int.decidable_dvd a b) a b)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
          (@has_mul.mul.{0} int
             (@semigroup.to_has_mul.{0} int (@comm_semigroup.to_semigroup.{0} int int.comm_semigroup))
             (q.num)
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))))
    (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
       (@has_add.add.{0} int (@distrib.to_has_add.{0} int int.distrib)
          (@has_mul.mul.{0} int (@distrib.to_has_mul.{0} int int.distrib)
             (@has_mul.mul.{0} int int.has_mul (q.num)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))
          (@has_mul.mul.{0} int (@distrib.to_has_mul.{0} int int.distrib)
             (@has_mul.mul.{0} int int.has_mul
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
                (r.num))
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>234    calc _ ≤ min (multiplicity ↑p (q.num * ↑(r.denom) * ↑(q.denom)))</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='tactic.interactive.exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='min'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='blue'><a title='rat.num'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='rat.denom'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_mul.mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/functions.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 11}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/rat/basic.lean&#x27;, &#x27;line&#x27;: 46, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/rat/basic.lean&#x27;, &#x27;line&#x27;: 46, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 312, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {α : Type} [_inst_1 : decidable_linear_order.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='green'><a title='rat → int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='rat → nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type} [c : has_mul.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
p_prime : nat.prime p,
q r : rat,
hq : @ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero),
hr : @ne.{1} rat r (@has_zero.zero.{0} rat rat.has_zero),
hqr : @ne.{1} rat (@has_add.add.{0} rat rat.has_add q r) (@has_zero.zero.{0} rat rat.has_zero),
hqn : @ne.{1} int (q.num) (@has_zero.zero.{0} int int.has_zero),
hqd :
  @ne.{1} int (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
    (@has_zero.zero.{0} int int.has_zero),
hrn : @ne.{1} int (r.num) (@has_zero.zero.{0} int int.has_zero),
hrd :
  @ne.{1} int (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom))
    (@has_zero.zero.{0} int int.has_zero),
hqdv :
  @ne.{1} rat
    (rat.mk (q.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))
    (@has_zero.zero.{0} rat rat.has_zero),
hrdv :
  @ne.{1} rat
    (rat.mk (r.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
    (@has_zero.zero.{0} rat rat.has_zero),
hqreq :
  @eq.{1} rat (@has_add.add.{0} rat rat.has_add q r)
    (rat.mk
       (@has_add.add.{0} int int.has_add
          (@has_mul.mul.{0} int int.has_mul (q.num)
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
          (@has_mul.mul.{0} int int.has_mul
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
             (r.num)))
       (@has_mul.mul.{0} int int.has_mul
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))),
hqrd :
  @ne.{1} int
    (@has_add.add.{0} int int.has_add
       (@has_mul.mul.{0} int int.has_mul (q.num)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
       (@has_mul.mul.{0} int int.has_mul
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
          (r.num)))
    (@has_zero.zero.{0} int int.has_zero),
h :
  @has_le.le.{0} enat enat.has_le
    (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
       (@has_mul.mul.{0} int int.has_mul (q.num)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom))))
    (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
       (@has_mul.mul.{0} int int.has_mul (r.num)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))))
⊢ @has_le.le.{0} enat enat.has_le
    (@has_add.add.{0} enat enat.has_add
       (@multiplicity.{0} int
          (@nonzero_comm_semiring.to_comm_semiring.{0} int
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} int
                (@integral_domain.to_nonzero_comm_ring.{0} int
                   (@normalization_domain.to_integral_domain.{0} int int.normalization_domain))))
          (λ (a b : int), (λ (a b : int), int.decidable_dvd a b) a b)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))
       (@multiplicity.{0} int
          (@nonzero_comm_semiring.to_comm_semiring.{0} int
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} int
                (@integral_domain.to_nonzero_comm_ring.{0} int
                   (@normalization_domain.to_integral_domain.{0} int int.normalization_domain))))
          (λ (a b : int), (λ (a b : int), int.decidable_dvd a b) a b)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
          (@has_mul.mul.{0} int
             (@semigroup.to_has_mul.{0} int (@comm_semigroup.to_semigroup.{0} int int.comm_semigroup))
             (q.num)
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))))
    (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
       (@has_add.add.{0} int (@distrib.to_has_add.{0} int int.distrib)
          (@has_mul.mul.{0} int (@distrib.to_has_mul.{0} int int.distrib)
             (@has_mul.mul.{0} int int.has_mul (q.num)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))
          (@has_mul.mul.{0} int (@distrib.to_has_mul.{0} int int.distrib)
             (@has_mul.mul.{0} int int.has_mul
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
                (r.num))
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>235      (multiplicity ↑p (↑(q.denom) * r.num * ↑(q.denom))) : (le_min</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='multiplicity'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='r'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='q'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='le_min'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/ring_theory/multiplicity.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/rat/basic.lean&#x27;, &#x27;line&#x27;: 46, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/rat/basic.lean&#x27;, &#x27;line&#x27;: 46, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/functions.lean&#x27;, &#x27;line&#x27;: 35, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {α : Type} [_inst_1 : comm_semiring.{0} α] [_inst_2 : @decidable_rel.{1} α (@has_dvd.dvd.{0} α (@comm_semiring_has_dvd.{0} α _inst_1))], α → α → enat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='∀ {α : Type} [_inst_1 : decidable_linear_order.{0} α] {a b c : α}, @has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@linear_order.to_partial_order.{0} α (@decidable_linear_order.to_linear_order.{0} α _inst_1)))) c a → @has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@linear_order.to_partial_order.{0} α (@decidable_linear_order.to_linear_order.{0} α _inst_1)))) c b → @has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@linear_order.to_partial_order.{0} α (@decidable_linear_order.to_linear_order.{0} α _inst_1)))) c (@min.{0} α _inst_1 a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='`multiplicity a b` returns the largest natural number `n` such that
 `a ^ n ∣ b`, as an `enat` or natural with infinity. If `∀ n, a ^ n ∣ b`,
 then it returns `⊤`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
p_prime : nat.prime p,
q r : rat,
hq : @ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero),
hr : @ne.{1} rat r (@has_zero.zero.{0} rat rat.has_zero),
hqr : @ne.{1} rat (@has_add.add.{0} rat rat.has_add q r) (@has_zero.zero.{0} rat rat.has_zero),
hqn : @ne.{1} int (q.num) (@has_zero.zero.{0} int int.has_zero),
hqd :
  @ne.{1} int (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
    (@has_zero.zero.{0} int int.has_zero),
hrn : @ne.{1} int (r.num) (@has_zero.zero.{0} int int.has_zero),
hrd :
  @ne.{1} int (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom))
    (@has_zero.zero.{0} int int.has_zero),
hqdv :
  @ne.{1} rat
    (rat.mk (q.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))
    (@has_zero.zero.{0} rat rat.has_zero),
hrdv :
  @ne.{1} rat
    (rat.mk (r.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
    (@has_zero.zero.{0} rat rat.has_zero),
hqreq :
  @eq.{1} rat (@has_add.add.{0} rat rat.has_add q r)
    (rat.mk
       (@has_add.add.{0} int int.has_add
          (@has_mul.mul.{0} int int.has_mul (q.num)
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
          (@has_mul.mul.{0} int int.has_mul
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
             (r.num)))
       (@has_mul.mul.{0} int int.has_mul
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))),
hqrd :
  @ne.{1} int
    (@has_add.add.{0} int int.has_add
       (@has_mul.mul.{0} int int.has_mul (q.num)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
       (@has_mul.mul.{0} int int.has_mul
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
          (r.num)))
    (@has_zero.zero.{0} int int.has_zero),
h :
  @has_le.le.{0} enat enat.has_le
    (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
       (@has_mul.mul.{0} int int.has_mul (q.num)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom))))
    (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
       (@has_mul.mul.{0} int int.has_mul (r.num)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))))
⊢ @has_le.le.{0} enat enat.has_le
    (@has_add.add.{0} enat enat.has_add
       (@multiplicity.{0} int
          (@nonzero_comm_semiring.to_comm_semiring.{0} int
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} int
                (@integral_domain.to_nonzero_comm_ring.{0} int
                   (@normalization_domain.to_integral_domain.{0} int int.normalization_domain))))
          (λ (a b : int), (λ (a b : int), int.decidable_dvd a b) a b)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))
       (@multiplicity.{0} int
          (@nonzero_comm_semiring.to_comm_semiring.{0} int
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} int
                (@integral_domain.to_nonzero_comm_ring.{0} int
                   (@normalization_domain.to_integral_domain.{0} int int.normalization_domain))))
          (λ (a b : int), (λ (a b : int), int.decidable_dvd a b) a b)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
          (@has_mul.mul.{0} int
             (@semigroup.to_has_mul.{0} int (@comm_semigroup.to_semigroup.{0} int int.comm_semigroup))
             (q.num)
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))))
    (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
       (@has_add.add.{0} int (@distrib.to_has_add.{0} int int.distrib)
          (@has_mul.mul.{0} int (@distrib.to_has_mul.{0} int int.distrib)
             (@has_mul.mul.{0} int int.has_mul (q.num)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))
          (@has_mul.mul.{0} int (@distrib.to_has_mul.{0} int int.distrib)
             (@has_mul.mul.{0} int int.has_mul
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
                (r.num))
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>236      (by rw [@multiplicity.mul _ _ _ _ (_ * _) _ (nat.prime_iff_prime_int.1 p_prime), add_comm])</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='multiplicity.mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='blue'><a title='nat.prime_iff_prime_int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='p_prime'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='add_comm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/ring_theory/multiplicity.lean&#x27;, &#x27;line&#x27;: 327, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/gcd_domain.lean&#x27;, &#x27;line&#x27;: 579, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 226, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type} [_inst_1 : integral_domain.{0} α] [_inst_2 : @decidable_rel.{1} α (@has_dvd.dvd.{0} α (@comm_semiring_has_dvd.{0} α (@nonzero_comm_semiring.to_comm_semiring.{0} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} α (@integral_domain.to_nonzero_comm_ring.{0} α _inst_1)))))] {p a b : α}, @prime.{0} α (@nonzero_comm_semiring.to_comm_semiring.{0} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} α (@integral_domain.to_nonzero_comm_ring.{0} α _inst_1))) p → @eq.{1} enat (@multiplicity.{0} α (@nonzero_comm_semiring.to_comm_semiring.{0} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} α (@integral_domain.to_nonzero_comm_ring.{0} α _inst_1))) (λ (a b : α), _inst_2 a b) p (@has_mul.mul.{0} α (@no_zero_divisors.to_has_mul.{0} α (@domain.to_no_zero_divisors.{0} α (@integral_domain.to_domain.{0} α _inst_1))) a b)) (@has_add.add.{0} enat enat.has_add (@multiplicity.{0} α (@nonzero_comm_semiring.to_comm_semiring.{0} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} α (@integral_domain.to_nonzero_comm_ring.{0} α _inst_1))) (λ (a b : α), _inst_2 a b) p a) (@multiplicity.{0} α (@nonzero_comm_semiring.to_comm_semiring.{0} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} α (@integral_domain.to_nonzero_comm_ring.{0} α _inst_1))) (λ (a b : α), _inst_2 a b) p b))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {p : nat}, iff (nat.prime p) (@prime.{0} int int.comm_semiring (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat.prime p'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : add_comm_semigroup.{0} α] (a b : α), @eq.{1} α (@has_add.add.{0} α (@add_semigroup.to_has_add.{0} α (@add_comm_semigroup.to_add_semigroup.{0} α _inst_1)) a b) (@has_add.add.{0} α (@add_semigroup.to_has_add.{0} α (@add_comm_semigroup.to_add_semigroup.{0} α _inst_1)) b a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
p_prime : nat.prime p,
q r : rat,
hq : @ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero),
hr : @ne.{1} rat r (@has_zero.zero.{0} rat rat.has_zero),
hqr : @ne.{1} rat (@has_add.add.{0} rat rat.has_add q r) (@has_zero.zero.{0} rat rat.has_zero),
hqn : @ne.{1} int (q.num) (@has_zero.zero.{0} int int.has_zero),
hqd :
  @ne.{1} int (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
    (@has_zero.zero.{0} int int.has_zero),
hrn : @ne.{1} int (r.num) (@has_zero.zero.{0} int int.has_zero),
hrd :
  @ne.{1} int (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom))
    (@has_zero.zero.{0} int int.has_zero),
hqdv :
  @ne.{1} rat
    (rat.mk (q.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))
    (@has_zero.zero.{0} rat rat.has_zero),
hrdv :
  @ne.{1} rat
    (rat.mk (r.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
    (@has_zero.zero.{0} rat rat.has_zero),
hqreq :
  @eq.{1} rat (@has_add.add.{0} rat rat.has_add q r)
    (rat.mk
       (@has_add.add.{0} int int.has_add
          (@has_mul.mul.{0} int int.has_mul (q.num)
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
          (@has_mul.mul.{0} int int.has_mul
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
             (r.num)))
       (@has_mul.mul.{0} int int.has_mul
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))),
hqrd :
  @ne.{1} int
    (@has_add.add.{0} int int.has_add
       (@has_mul.mul.{0} int int.has_mul (q.num)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
       (@has_mul.mul.{0} int int.has_mul
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
          (r.num)))
    (@has_zero.zero.{0} int int.has_zero),
h :
  @has_le.le.{0} enat enat.has_le
    (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
       (@has_mul.mul.{0} int int.has_mul (q.num)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom))))
    (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
       (@has_mul.mul.{0} int int.has_mul (r.num)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))))
⊢ @has_le.le.{0} enat enat.has_le
    (@has_add.add.{0} enat enat.has_add
       (@multiplicity.{0} int
          (@nonzero_comm_semiring.to_comm_semiring.{0} int
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} int
                (@integral_domain.to_nonzero_comm_ring.{0} int
                   (@normalization_domain.to_integral_domain.{0} int int.normalization_domain))))
          (λ (a b : int), (λ (a b : int), int.decidable_dvd a b) a b)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))
       (@multiplicity.{0} int
          (@nonzero_comm_semiring.to_comm_semiring.{0} int
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} int
                (@integral_domain.to_nonzero_comm_ring.{0} int
                   (@normalization_domain.to_integral_domain.{0} int int.normalization_domain))))
          (λ (a b : int), (λ (a b : int), int.decidable_dvd a b) a b)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
          (@has_mul.mul.{0} int
             (@semigroup.to_has_mul.{0} int (@comm_semigroup.to_semigroup.{0} int int.comm_semigroup))
             (q.num)
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))))
    (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
       (@has_add.add.{0} int (@distrib.to_has_add.{0} int int.distrib)
          (@has_mul.mul.{0} int (@distrib.to_has_mul.{0} int int.distrib)
             (@has_mul.mul.{0} int int.has_mul (q.num)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))
          (@has_mul.mul.{0} int (@distrib.to_has_mul.{0} int int.distrib)
             (@has_mul.mul.{0} int int.has_mul
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
                (r.num))
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
p_prime : nat.prime p,
q r : rat,
hq : @ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero),
hr : @ne.{1} rat r (@has_zero.zero.{0} rat rat.has_zero),
hqr : @ne.{1} rat (@has_add.add.{0} rat rat.has_add q r) (@has_zero.zero.{0} rat rat.has_zero),
hqn : @ne.{1} int (q.num) (@has_zero.zero.{0} int int.has_zero),
hqd :
  @ne.{1} int (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
    (@has_zero.zero.{0} int int.has_zero),
hrn : @ne.{1} int (r.num) (@has_zero.zero.{0} int int.has_zero),
hrd :
  @ne.{1} int (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom))
    (@has_zero.zero.{0} int int.has_zero),
hqdv :
  @ne.{1} rat
    (rat.mk (q.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))
    (@has_zero.zero.{0} rat rat.has_zero),
hrdv :
  @ne.{1} rat
    (rat.mk (r.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
    (@has_zero.zero.{0} rat rat.has_zero),
hqreq :
  @eq.{1} rat (@has_add.add.{0} rat rat.has_add q r)
    (rat.mk
       (@has_add.add.{0} int int.has_add
          (@has_mul.mul.{0} int int.has_mul (q.num)
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
          (@has_mul.mul.{0} int int.has_mul
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
             (r.num)))
       (@has_mul.mul.{0} int int.has_mul
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))),
hqrd :
  @ne.{1} int
    (@has_add.add.{0} int int.has_add
       (@has_mul.mul.{0} int int.has_mul (q.num)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
       (@has_mul.mul.{0} int int.has_mul
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
          (r.num)))
    (@has_zero.zero.{0} int int.has_zero),
h :
  @has_le.le.{0} enat enat.has_le
    (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
       (@has_mul.mul.{0} int int.has_mul (q.num)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom))))
    (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
       (@has_mul.mul.{0} int int.has_mul (r.num)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))))
⊢ @has_le.le.{0} enat
    (@preorder.to_has_le.{0} enat
       (@partial_order.to_preorder.{0} enat
          (@linear_order.to_partial_order.{0} enat
             (@decidable_linear_order.to_linear_order.{0} enat enat.decidable_linear_order))))
    ?m_1
    (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
       (@has_mul.mul.{0} int int.has_mul
          (@has_mul.mul.{0} int int.has_mul (q.num)
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
p_prime : nat.prime p,
q r : rat,
hq : @ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero),
hr : @ne.{1} rat r (@has_zero.zero.{0} rat rat.has_zero),
hqr : @ne.{1} rat (@has_add.add.{0} rat rat.has_add q r) (@has_zero.zero.{0} rat rat.has_zero),
hqn : @ne.{1} int (q.num) (@has_zero.zero.{0} int int.has_zero),
hqd :
  @ne.{1} int (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
    (@has_zero.zero.{0} int int.has_zero),
hrn : @ne.{1} int (r.num) (@has_zero.zero.{0} int int.has_zero),
hrd :
  @ne.{1} int (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom))
    (@has_zero.zero.{0} int int.has_zero),
hqdv :
  @ne.{1} rat
    (rat.mk (q.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))
    (@has_zero.zero.{0} rat rat.has_zero),
hrdv :
  @ne.{1} rat
    (rat.mk (r.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
    (@has_zero.zero.{0} rat rat.has_zero),
hqreq :
  @eq.{1} rat (@has_add.add.{0} rat rat.has_add q r)
    (rat.mk
       (@has_add.add.{0} int int.has_add
          (@has_mul.mul.{0} int int.has_mul (q.num)
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
          (@has_mul.mul.{0} int int.has_mul
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
             (r.num)))
       (@has_mul.mul.{0} int int.has_mul
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))),
hqrd :
  @ne.{1} int
    (@has_add.add.{0} int int.has_add
       (@has_mul.mul.{0} int int.has_mul (q.num)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
       (@has_mul.mul.{0} int int.has_mul
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
          (r.num)))
    (@has_zero.zero.{0} int int.has_zero),
h :
  @has_le.le.{0} enat enat.has_le
    (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
       (@has_mul.mul.{0} int int.has_mul (q.num)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom))))
    (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
       (@has_mul.mul.{0} int int.has_mul (r.num)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))))
⊢ @has_le.le.{0} enat
    (@preorder.to_has_le.{0} enat
       (@partial_order.to_preorder.{0} enat
          (@linear_order.to_partial_order.{0} enat
             (@decidable_linear_order.to_linear_order.{0} enat enat.decidable_linear_order))))
    ?m_1
    (@has_add.add.{0} enat enat.has_add
       (@multiplicity.{0} int
          (@nonzero_comm_semiring.to_comm_semiring.{0} int
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} int
                (@integral_domain.to_nonzero_comm_ring.{0} int
                   (@normalization_domain.to_integral_domain.{0} int int.normalization_domain))))
          (λ (a b : int), (λ (a b : int), int.decidable_dvd a b) a b)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
          (@has_mul.mul.{0} int int.has_mul (q.num)
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom))))
       (@multiplicity.{0} int
          (@nonzero_comm_semiring.to_comm_semiring.{0} int
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} int
                (@integral_domain.to_nonzero_comm_ring.{0} int
                   (@normalization_domain.to_integral_domain.{0} int int.normalization_domain))))
          (λ (a b : int), (λ (a b : int), int.decidable_dvd a b) a b)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
p_prime : nat.prime p,
q r : rat,
hq : @ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero),
hr : @ne.{1} rat r (@has_zero.zero.{0} rat rat.has_zero),
hqr : @ne.{1} rat (@has_add.add.{0} rat rat.has_add q r) (@has_zero.zero.{0} rat rat.has_zero),
hqn : @ne.{1} int (q.num) (@has_zero.zero.{0} int int.has_zero),
hqd :
  @ne.{1} int (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
    (@has_zero.zero.{0} int int.has_zero),
hrn : @ne.{1} int (r.num) (@has_zero.zero.{0} int int.has_zero),
hrd :
  @ne.{1} int (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom))
    (@has_zero.zero.{0} int int.has_zero),
hqdv :
  @ne.{1} rat
    (rat.mk (q.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))
    (@has_zero.zero.{0} rat rat.has_zero),
hrdv :
  @ne.{1} rat
    (rat.mk (r.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
    (@has_zero.zero.{0} rat rat.has_zero),
hqreq :
  @eq.{1} rat (@has_add.add.{0} rat rat.has_add q r)
    (rat.mk
       (@has_add.add.{0} int int.has_add
          (@has_mul.mul.{0} int int.has_mul (q.num)
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
          (@has_mul.mul.{0} int int.has_mul
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
             (r.num)))
       (@has_mul.mul.{0} int int.has_mul
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))),
hqrd :
  @ne.{1} int
    (@has_add.add.{0} int int.has_add
       (@has_mul.mul.{0} int int.has_mul (q.num)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
       (@has_mul.mul.{0} int int.has_mul
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
          (r.num)))
    (@has_zero.zero.{0} int int.has_zero),
h :
  @has_le.le.{0} enat enat.has_le
    (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
       (@has_mul.mul.{0} int int.has_mul (q.num)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom))))
    (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
       (@has_mul.mul.{0} int int.has_mul (r.num)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))))
⊢ @has_le.le.{0} enat enat.has_le
    (@has_add.add.{0} enat enat.has_add
       (@multiplicity.{0} int
          (@nonzero_comm_semiring.to_comm_semiring.{0} int
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} int
                (@integral_domain.to_nonzero_comm_ring.{0} int
                   (@normalization_domain.to_integral_domain.{0} int int.normalization_domain))))
          (λ (a b : int), (λ (a b : int), int.decidable_dvd a b) a b)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))
       (@multiplicity.{0} int
          (@nonzero_comm_semiring.to_comm_semiring.{0} int
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} int
                (@integral_domain.to_nonzero_comm_ring.{0} int
                   (@normalization_domain.to_integral_domain.{0} int int.normalization_domain))))
          (λ (a b : int), (λ (a b : int), int.decidable_dvd a b) a b)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
          (@has_mul.mul.{0} int
             (@semigroup.to_has_mul.{0} int (@comm_semigroup.to_semigroup.{0} int int.comm_semigroup))
             (q.num)
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))))
    (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
       (@has_add.add.{0} int (@distrib.to_has_add.{0} int int.distrib)
          (@has_mul.mul.{0} int (@distrib.to_has_mul.{0} int int.distrib)
             (@has_mul.mul.{0} int int.has_mul (q.num)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))
          (@has_mul.mul.{0} int (@distrib.to_has_mul.{0} int int.distrib)
             (@has_mul.mul.{0} int int.has_mul
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
                (r.num))
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>237      (by rw [mul_assoc, @multiplicity.mul _ _ _ _ (q.denom : ℤ)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='mul_assoc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='multiplicity.mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='q'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/ring_theory/multiplicity.lean&#x27;, &#x27;line&#x27;: 327, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/rat/basic.lean&#x27;, &#x27;line&#x27;: 46, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : semigroup.{0} α] (a b c : α), @eq.{1} α (@has_mul.mul.{0} α (@semigroup.to_has_mul.{0} α _inst_1) (@has_mul.mul.{0} α (@semigroup.to_has_mul.{0} α _inst_1) a b) c) (@has_mul.mul.{0} α (@semigroup.to_has_mul.{0} α _inst_1) a (@has_mul.mul.{0} α (@semigroup.to_has_mul.{0} α _inst_1) b c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type} [_inst_1 : integral_domain.{0} α] [_inst_2 : @decidable_rel.{1} α (@has_dvd.dvd.{0} α (@comm_semiring_has_dvd.{0} α (@nonzero_comm_semiring.to_comm_semiring.{0} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} α (@integral_domain.to_nonzero_comm_ring.{0} α _inst_1)))))] {p a b : α}, @prime.{0} α (@nonzero_comm_semiring.to_comm_semiring.{0} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} α (@integral_domain.to_nonzero_comm_ring.{0} α _inst_1))) p → @eq.{1} enat (@multiplicity.{0} α (@nonzero_comm_semiring.to_comm_semiring.{0} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} α (@integral_domain.to_nonzero_comm_ring.{0} α _inst_1))) (λ (a b : α), _inst_2 a b) p (@has_mul.mul.{0} α (@no_zero_divisors.to_has_mul.{0} α (@domain.to_no_zero_divisors.{0} α (@integral_domain.to_domain.{0} α _inst_1))) a b)) (@has_add.add.{0} enat enat.has_add (@multiplicity.{0} α (@nonzero_comm_semiring.to_comm_semiring.{0} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} α (@integral_domain.to_nonzero_comm_ring.{0} α _inst_1))) (λ (a b : α), _inst_2 a b) p a) (@multiplicity.{0} α (@nonzero_comm_semiring.to_comm_semiring.{0} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} α (@integral_domain.to_nonzero_comm_ring.{0} α _inst_1))) (λ (a b : α), _inst_2 a b) p b))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
p_prime : nat.prime p,
q r : rat,
hq : @ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero),
hr : @ne.{1} rat r (@has_zero.zero.{0} rat rat.has_zero),
hqr : @ne.{1} rat (@has_add.add.{0} rat rat.has_add q r) (@has_zero.zero.{0} rat rat.has_zero),
hqn : @ne.{1} int (q.num) (@has_zero.zero.{0} int int.has_zero),
hqd :
  @ne.{1} int (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
    (@has_zero.zero.{0} int int.has_zero),
hrn : @ne.{1} int (r.num) (@has_zero.zero.{0} int int.has_zero),
hrd :
  @ne.{1} int (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom))
    (@has_zero.zero.{0} int int.has_zero),
hqdv :
  @ne.{1} rat
    (rat.mk (q.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))
    (@has_zero.zero.{0} rat rat.has_zero),
hrdv :
  @ne.{1} rat
    (rat.mk (r.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
    (@has_zero.zero.{0} rat rat.has_zero),
hqreq :
  @eq.{1} rat (@has_add.add.{0} rat rat.has_add q r)
    (rat.mk
       (@has_add.add.{0} int int.has_add
          (@has_mul.mul.{0} int int.has_mul (q.num)
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
          (@has_mul.mul.{0} int int.has_mul
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
             (r.num)))
       (@has_mul.mul.{0} int int.has_mul
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))),
hqrd :
  @ne.{1} int
    (@has_add.add.{0} int int.has_add
       (@has_mul.mul.{0} int int.has_mul (q.num)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
       (@has_mul.mul.{0} int int.has_mul
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
          (r.num)))
    (@has_zero.zero.{0} int int.has_zero),
h :
  @has_le.le.{0} enat enat.has_le
    (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
       (@has_mul.mul.{0} int int.has_mul (q.num)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom))))
    (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
       (@has_mul.mul.{0} int int.has_mul (r.num)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))))
⊢ @has_le.le.{0} enat enat.has_le
    (@has_add.add.{0} enat enat.has_add
       (@multiplicity.{0} int
          (@nonzero_comm_semiring.to_comm_semiring.{0} int
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} int
                (@integral_domain.to_nonzero_comm_ring.{0} int
                   (@normalization_domain.to_integral_domain.{0} int int.normalization_domain))))
          (λ (a b : int), (λ (a b : int), int.decidable_dvd a b) a b)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))
       (@multiplicity.{0} int
          (@nonzero_comm_semiring.to_comm_semiring.{0} int
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} int
                (@integral_domain.to_nonzero_comm_ring.{0} int
                   (@normalization_domain.to_integral_domain.{0} int int.normalization_domain))))
          (λ (a b : int), (λ (a b : int), int.decidable_dvd a b) a b)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
          (@has_mul.mul.{0} int
             (@semigroup.to_has_mul.{0} int (@comm_semigroup.to_semigroup.{0} int int.comm_semigroup))
             (q.num)
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))))
    (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
       (@has_add.add.{0} int (@distrib.to_has_add.{0} int int.distrib)
          (@has_mul.mul.{0} int (@distrib.to_has_mul.{0} int int.distrib)
             (@has_mul.mul.{0} int int.has_mul (q.num)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))
          (@has_mul.mul.{0} int (@distrib.to_has_mul.{0} int int.distrib)
             (@has_mul.mul.{0} int int.has_mul
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
                (r.num))
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
p_prime : nat.prime p,
q r : rat,
hq : @ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero),
hr : @ne.{1} rat r (@has_zero.zero.{0} rat rat.has_zero),
hqr : @ne.{1} rat (@has_add.add.{0} rat rat.has_add q r) (@has_zero.zero.{0} rat rat.has_zero),
hqn : @ne.{1} int (q.num) (@has_zero.zero.{0} int int.has_zero),
hqd :
  @ne.{1} int (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
    (@has_zero.zero.{0} int int.has_zero),
hrn : @ne.{1} int (r.num) (@has_zero.zero.{0} int int.has_zero),
hrd :
  @ne.{1} int (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom))
    (@has_zero.zero.{0} int int.has_zero),
hqdv :
  @ne.{1} rat
    (rat.mk (q.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))
    (@has_zero.zero.{0} rat rat.has_zero),
hrdv :
  @ne.{1} rat
    (rat.mk (r.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
    (@has_zero.zero.{0} rat rat.has_zero),
hqreq :
  @eq.{1} rat (@has_add.add.{0} rat rat.has_add q r)
    (rat.mk
       (@has_add.add.{0} int int.has_add
          (@has_mul.mul.{0} int int.has_mul (q.num)
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
          (@has_mul.mul.{0} int int.has_mul
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
             (r.num)))
       (@has_mul.mul.{0} int int.has_mul
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))),
hqrd :
  @ne.{1} int
    (@has_add.add.{0} int int.has_add
       (@has_mul.mul.{0} int int.has_mul (q.num)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
       (@has_mul.mul.{0} int int.has_mul
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
          (r.num)))
    (@has_zero.zero.{0} int int.has_zero),
h :
  @has_le.le.{0} enat enat.has_le
    (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
       (@has_mul.mul.{0} int int.has_mul (q.num)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom))))
    (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
       (@has_mul.mul.{0} int int.has_mul (r.num)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))))
⊢ @has_le.le.{0} enat
    (@preorder.to_has_le.{0} enat
       (@partial_order.to_preorder.{0} enat
          (@linear_order.to_partial_order.{0} enat
             (@decidable_linear_order.to_linear_order.{0} enat enat.decidable_linear_order))))
    (@has_add.add.{0} enat
       (@add_semigroup.to_has_add.{0} enat
          (@add_comm_semigroup.to_add_semigroup.{0} enat
             (@add_comm_monoid.to_add_comm_semigroup.{0} enat enat.add_comm_monoid)))
       (@multiplicity.{0} int
          (@nonzero_comm_semiring.to_comm_semiring.{0} int
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} int
                (@integral_domain.to_nonzero_comm_ring.{0} int
                   (@normalization_domain.to_integral_domain.{0} int int.normalization_domain))))
          (λ (a b : int), (λ (a b : int), int.decidable_dvd a b) a b)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))
       (@multiplicity.{0} int
          (@nonzero_comm_semiring.to_comm_semiring.{0} int
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} int
                (@integral_domain.to_nonzero_comm_ring.{0} int
                   (@normalization_domain.to_integral_domain.{0} int int.normalization_domain))))
          (λ (a b : int), (λ (a b : int), int.decidable_dvd a b) a b)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
          (@has_mul.mul.{0} int int.has_mul (q.num)
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))))
    (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
       (@has_mul.mul.{0} int int.has_mul
          (@has_mul.mul.{0} int int.has_mul
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
             (r.num))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
p_prime : nat.prime p,
q r : rat,
hq : @ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero),
hr : @ne.{1} rat r (@has_zero.zero.{0} rat rat.has_zero),
hqr : @ne.{1} rat (@has_add.add.{0} rat rat.has_add q r) (@has_zero.zero.{0} rat rat.has_zero),
hqn : @ne.{1} int (q.num) (@has_zero.zero.{0} int int.has_zero),
hqd :
  @ne.{1} int (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
    (@has_zero.zero.{0} int int.has_zero),
hrn : @ne.{1} int (r.num) (@has_zero.zero.{0} int int.has_zero),
hrd :
  @ne.{1} int (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom))
    (@has_zero.zero.{0} int int.has_zero),
hqdv :
  @ne.{1} rat
    (rat.mk (q.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))
    (@has_zero.zero.{0} rat rat.has_zero),
hrdv :
  @ne.{1} rat
    (rat.mk (r.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
    (@has_zero.zero.{0} rat rat.has_zero),
hqreq :
  @eq.{1} rat (@has_add.add.{0} rat rat.has_add q r)
    (rat.mk
       (@has_add.add.{0} int int.has_add
          (@has_mul.mul.{0} int int.has_mul (q.num)
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
          (@has_mul.mul.{0} int int.has_mul
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
             (r.num)))
       (@has_mul.mul.{0} int int.has_mul
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))),
hqrd :
  @ne.{1} int
    (@has_add.add.{0} int int.has_add
       (@has_mul.mul.{0} int int.has_mul (q.num)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
       (@has_mul.mul.{0} int int.has_mul
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
          (r.num)))
    (@has_zero.zero.{0} int int.has_zero),
h :
  @has_le.le.{0} enat enat.has_le
    (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
       (@has_mul.mul.{0} int int.has_mul (q.num)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom))))
    (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
       (@has_mul.mul.{0} int int.has_mul (r.num)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))))
⊢ @has_le.le.{0} enat
    (@preorder.to_has_le.{0} enat
       (@partial_order.to_preorder.{0} enat
          (@linear_order.to_partial_order.{0} enat
             (@decidable_linear_order.to_linear_order.{0} enat enat.decidable_linear_order))))
    (@has_add.add.{0} enat
       (@add_semigroup.to_has_add.{0} enat
          (@add_comm_semigroup.to_add_semigroup.{0} enat
             (@add_comm_monoid.to_add_comm_semigroup.{0} enat enat.add_comm_monoid)))
       (@multiplicity.{0} int
          (@nonzero_comm_semiring.to_comm_semiring.{0} int
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} int
                (@integral_domain.to_nonzero_comm_ring.{0} int
                   (@normalization_domain.to_integral_domain.{0} int int.normalization_domain))))
          (λ (a b : int), (λ (a b : int), int.decidable_dvd a b) a b)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))
       (@multiplicity.{0} int
          (@nonzero_comm_semiring.to_comm_semiring.{0} int
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} int
                (@integral_domain.to_nonzero_comm_ring.{0} int
                   (@normalization_domain.to_integral_domain.{0} int int.normalization_domain))))
          (λ (a b : int), (λ (a b : int), int.decidable_dvd a b) a b)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
          (@has_mul.mul.{0} int int.has_mul (q.num)
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))))
    (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
       (@has_mul.mul.{0} int (@semigroup.to_has_mul.{0} int int.semigroup)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
          (@has_mul.mul.{0} int (@semigroup.to_has_mul.{0} int int.semigroup) (r.num)
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>238          (_ * _) (nat.prime_iff_prime_int.1 p_prime)];</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='nat.prime_iff_prime_int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='p_prime'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/gcd_domain.lean&#x27;, &#x27;line&#x27;: 579, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {p : nat}, iff (nat.prime p) (@prime.{0} int int.comm_semiring (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat.prime p'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
p_prime : nat.prime p,
q r : rat,
hq : @ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero),
hr : @ne.{1} rat r (@has_zero.zero.{0} rat rat.has_zero),
hqr : @ne.{1} rat (@has_add.add.{0} rat rat.has_add q r) (@has_zero.zero.{0} rat rat.has_zero),
hqn : @ne.{1} int (q.num) (@has_zero.zero.{0} int int.has_zero),
hqd :
  @ne.{1} int (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
    (@has_zero.zero.{0} int int.has_zero),
hrn : @ne.{1} int (r.num) (@has_zero.zero.{0} int int.has_zero),
hrd :
  @ne.{1} int (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom))
    (@has_zero.zero.{0} int int.has_zero),
hqdv :
  @ne.{1} rat
    (rat.mk (q.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))
    (@has_zero.zero.{0} rat rat.has_zero),
hrdv :
  @ne.{1} rat
    (rat.mk (r.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
    (@has_zero.zero.{0} rat rat.has_zero),
hqreq :
  @eq.{1} rat (@has_add.add.{0} rat rat.has_add q r)
    (rat.mk
       (@has_add.add.{0} int int.has_add
          (@has_mul.mul.{0} int int.has_mul (q.num)
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
          (@has_mul.mul.{0} int int.has_mul
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
             (r.num)))
       (@has_mul.mul.{0} int int.has_mul
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))),
hqrd :
  @ne.{1} int
    (@has_add.add.{0} int int.has_add
       (@has_mul.mul.{0} int int.has_mul (q.num)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
       (@has_mul.mul.{0} int int.has_mul
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
          (r.num)))
    (@has_zero.zero.{0} int int.has_zero),
h :
  @has_le.le.{0} enat enat.has_le
    (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
       (@has_mul.mul.{0} int int.has_mul (q.num)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom))))
    (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
       (@has_mul.mul.{0} int int.has_mul (r.num)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))))
⊢ @has_le.le.{0} enat
    (@preorder.to_has_le.{0} enat
       (@partial_order.to_preorder.{0} enat
          (@linear_order.to_partial_order.{0} enat
             (@decidable_linear_order.to_linear_order.{0} enat enat.decidable_linear_order))))
    (@has_add.add.{0} enat
       (@add_semigroup.to_has_add.{0} enat
          (@add_comm_semigroup.to_add_semigroup.{0} enat
             (@add_comm_monoid.to_add_comm_semigroup.{0} enat enat.add_comm_monoid)))
       (@multiplicity.{0} int
          (@nonzero_comm_semiring.to_comm_semiring.{0} int
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} int
                (@integral_domain.to_nonzero_comm_ring.{0} int
                   (@normalization_domain.to_integral_domain.{0} int int.normalization_domain))))
          (λ (a b : int), (λ (a b : int), int.decidable_dvd a b) a b)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))
       (@multiplicity.{0} int
          (@nonzero_comm_semiring.to_comm_semiring.{0} int
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} int
                (@integral_domain.to_nonzero_comm_ring.{0} int
                   (@normalization_domain.to_integral_domain.{0} int int.normalization_domain))))
          (λ (a b : int), (λ (a b : int), int.decidable_dvd a b) a b)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
          (@has_mul.mul.{0} int int.has_mul (q.num)
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))))
    (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
       (@has_mul.mul.{0} int (@semigroup.to_has_mul.{0} int int.semigroup)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
          (@has_mul.mul.{0} int (@semigroup.to_has_mul.{0} int int.semigroup) (r.num)
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
p_prime : nat.prime p,
q r : rat,
hq : @ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero),
hr : @ne.{1} rat r (@has_zero.zero.{0} rat rat.has_zero),
hqr : @ne.{1} rat (@has_add.add.{0} rat rat.has_add q r) (@has_zero.zero.{0} rat rat.has_zero),
hqn : @ne.{1} int (q.num) (@has_zero.zero.{0} int int.has_zero),
hqd :
  @ne.{1} int (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
    (@has_zero.zero.{0} int int.has_zero),
hrn : @ne.{1} int (r.num) (@has_zero.zero.{0} int int.has_zero),
hrd :
  @ne.{1} int (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom))
    (@has_zero.zero.{0} int int.has_zero),
hqdv :
  @ne.{1} rat
    (rat.mk (q.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))
    (@has_zero.zero.{0} rat rat.has_zero),
hrdv :
  @ne.{1} rat
    (rat.mk (r.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
    (@has_zero.zero.{0} rat rat.has_zero),
hqreq :
  @eq.{1} rat (@has_add.add.{0} rat rat.has_add q r)
    (rat.mk
       (@has_add.add.{0} int int.has_add
          (@has_mul.mul.{0} int int.has_mul (q.num)
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
          (@has_mul.mul.{0} int int.has_mul
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
             (r.num)))
       (@has_mul.mul.{0} int int.has_mul
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))),
hqrd :
  @ne.{1} int
    (@has_add.add.{0} int int.has_add
       (@has_mul.mul.{0} int int.has_mul (q.num)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
       (@has_mul.mul.{0} int int.has_mul
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
          (r.num)))
    (@has_zero.zero.{0} int int.has_zero),
h :
  @has_le.le.{0} enat enat.has_le
    (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
       (@has_mul.mul.{0} int int.has_mul (q.num)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom))))
    (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
       (@has_mul.mul.{0} int int.has_mul (r.num)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))))
⊢ @has_le.le.{0} enat
    (@preorder.to_has_le.{0} enat
       (@partial_order.to_preorder.{0} enat
          (@linear_order.to_partial_order.{0} enat
             (@decidable_linear_order.to_linear_order.{0} enat enat.decidable_linear_order))))
    (@has_add.add.{0} enat
       (@add_semigroup.to_has_add.{0} enat
          (@add_comm_semigroup.to_add_semigroup.{0} enat
             (@add_comm_monoid.to_add_comm_semigroup.{0} enat enat.add_comm_monoid)))
       (@multiplicity.{0} int
          (@nonzero_comm_semiring.to_comm_semiring.{0} int
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} int
                (@integral_domain.to_nonzero_comm_ring.{0} int
                   (@normalization_domain.to_integral_domain.{0} int int.normalization_domain))))
          (λ (a b : int), (λ (a b : int), int.decidable_dvd a b) a b)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))
       (@multiplicity.{0} int
          (@nonzero_comm_semiring.to_comm_semiring.{0} int
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} int
                (@integral_domain.to_nonzero_comm_ring.{0} int
                   (@normalization_domain.to_integral_domain.{0} int int.normalization_domain))))
          (λ (a b : int), (λ (a b : int), int.decidable_dvd a b) a b)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
          (@has_mul.mul.{0} int int.has_mul (q.num)
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))))
    (@has_add.add.{0} enat enat.has_add
       (@multiplicity.{0} int
          (@nonzero_comm_semiring.to_comm_semiring.{0} int
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} int
                (@integral_domain.to_nonzero_comm_ring.{0} int
                   (@normalization_domain.to_integral_domain.{0} int int.normalization_domain))))
          (λ (a b : int), (λ (a b : int), int.decidable_dvd a b) a b)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))
       (@multiplicity.{0} int
          (@nonzero_comm_semiring.to_comm_semiring.{0} int
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} int
                (@integral_domain.to_nonzero_comm_ring.{0} int
                   (@normalization_domain.to_integral_domain.{0} int int.normalization_domain))))
          (λ (a b : int), (λ (a b : int), int.decidable_dvd a b) a b)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
          (@has_mul.mul.{0} int int.has_mul (r.num)
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
p_prime : nat.prime p,
q r : rat,
hq : @ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero),
hr : @ne.{1} rat r (@has_zero.zero.{0} rat rat.has_zero),
hqr : @ne.{1} rat (@has_add.add.{0} rat rat.has_add q r) (@has_zero.zero.{0} rat rat.has_zero),
hqn : @ne.{1} int (q.num) (@has_zero.zero.{0} int int.has_zero),
hqd :
  @ne.{1} int (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
    (@has_zero.zero.{0} int int.has_zero),
hrn : @ne.{1} int (r.num) (@has_zero.zero.{0} int int.has_zero),
hrd :
  @ne.{1} int (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom))
    (@has_zero.zero.{0} int int.has_zero),
hqdv :
  @ne.{1} rat
    (rat.mk (q.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))
    (@has_zero.zero.{0} rat rat.has_zero),
hrdv :
  @ne.{1} rat
    (rat.mk (r.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
    (@has_zero.zero.{0} rat rat.has_zero),
hqreq :
  @eq.{1} rat (@has_add.add.{0} rat rat.has_add q r)
    (rat.mk
       (@has_add.add.{0} int int.has_add
          (@has_mul.mul.{0} int int.has_mul (q.num)
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
          (@has_mul.mul.{0} int int.has_mul
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
             (r.num)))
       (@has_mul.mul.{0} int int.has_mul
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))),
hqrd :
  @ne.{1} int
    (@has_add.add.{0} int int.has_add
       (@has_mul.mul.{0} int int.has_mul (q.num)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
       (@has_mul.mul.{0} int int.has_mul
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
          (r.num)))
    (@has_zero.zero.{0} int int.has_zero),
h :
  @has_le.le.{0} enat enat.has_le
    (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
       (@has_mul.mul.{0} int int.has_mul (q.num)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom))))
    (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
       (@has_mul.mul.{0} int int.has_mul (r.num)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))))
⊢ @has_le.le.{0} enat
    (@preorder.to_has_le.{0} enat
       (@partial_order.to_preorder.{0} enat
          (@linear_order.to_partial_order.{0} enat
             (@decidable_linear_order.to_linear_order.{0} enat enat.decidable_linear_order))))
    (@has_add.add.{0} enat
       (@add_semigroup.to_has_add.{0} enat
          (@add_comm_semigroup.to_add_semigroup.{0} enat
             (@add_comm_monoid.to_add_comm_semigroup.{0} enat enat.add_comm_monoid)))
       (@multiplicity.{0} int
          (@nonzero_comm_semiring.to_comm_semiring.{0} int
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} int
                (@integral_domain.to_nonzero_comm_ring.{0} int
                   (@normalization_domain.to_integral_domain.{0} int int.normalization_domain))))
          (λ (a b : int), (λ (a b : int), int.decidable_dvd a b) a b)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))
       (@multiplicity.{0} int
          (@nonzero_comm_semiring.to_comm_semiring.{0} int
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} int
                (@integral_domain.to_nonzero_comm_ring.{0} int
                   (@normalization_domain.to_integral_domain.{0} int int.normalization_domain))))
          (λ (a b : int), (λ (a b : int), int.decidable_dvd a b) a b)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
          (@has_mul.mul.{0} int int.has_mul (q.num)
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))))
    (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
       (@has_mul.mul.{0} int int.has_mul
          (@has_mul.mul.{0} int int.has_mul
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
             (r.num))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>239        exact add_le_add_left&#x27; h))</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='add_le_add_left&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/ordered_group.lean&#x27;, &#x27;line&#x27;: 37, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : ordered_comm_monoid.{0} α] {a b c : α}, @has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@ordered_comm_monoid.to_partial_order.{0} α _inst_1))) a b → @has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@ordered_comm_monoid.to_partial_order.{0} α _inst_1))) (@has_add.add.{0} α (@add_semigroup.to_has_add.{0} α (@add_monoid.to_add_semigroup.{0} α (@add_comm_monoid.to_add_monoid.{0} α (@ordered_comm_monoid.to_add_comm_monoid.{0} α _inst_1)))) c a) (@has_add.add.{0} α (@add_semigroup.to_has_add.{0} α (@add_monoid.to_add_semigroup.{0} α (@add_comm_monoid.to_add_monoid.{0} α (@ordered_comm_monoid.to_add_comm_monoid.{0} α _inst_1)))) c b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_le.le.{0} enat enat.has_le (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p) (@has_mul.mul.{0} int int.has_mul (q.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))) (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p) (@has_mul.mul.{0} int int.has_mul (r.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
p_prime : nat.prime p,
q r : rat,
hq : @ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero),
hr : @ne.{1} rat r (@has_zero.zero.{0} rat rat.has_zero),
hqr : @ne.{1} rat (@has_add.add.{0} rat rat.has_add q r) (@has_zero.zero.{0} rat rat.has_zero),
hqn : @ne.{1} int (q.num) (@has_zero.zero.{0} int int.has_zero),
hqd :
  @ne.{1} int (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
    (@has_zero.zero.{0} int int.has_zero),
hrn : @ne.{1} int (r.num) (@has_zero.zero.{0} int int.has_zero),
hrd :
  @ne.{1} int (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom))
    (@has_zero.zero.{0} int int.has_zero),
hqdv :
  @ne.{1} rat
    (rat.mk (q.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))
    (@has_zero.zero.{0} rat rat.has_zero),
hrdv :
  @ne.{1} rat
    (rat.mk (r.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
    (@has_zero.zero.{0} rat rat.has_zero),
hqreq :
  @eq.{1} rat (@has_add.add.{0} rat rat.has_add q r)
    (rat.mk
       (@has_add.add.{0} int int.has_add
          (@has_mul.mul.{0} int int.has_mul (q.num)
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
          (@has_mul.mul.{0} int int.has_mul
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
             (r.num)))
       (@has_mul.mul.{0} int int.has_mul
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))),
hqrd :
  @ne.{1} int
    (@has_add.add.{0} int int.has_add
       (@has_mul.mul.{0} int int.has_mul (q.num)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
       (@has_mul.mul.{0} int int.has_mul
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
          (r.num)))
    (@has_zero.zero.{0} int int.has_zero),
h :
  @has_le.le.{0} enat enat.has_le
    (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
       (@has_mul.mul.{0} int int.has_mul (q.num)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom))))
    (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
       (@has_mul.mul.{0} int int.has_mul (r.num)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))))
⊢ @has_le.le.{0} enat
    (@preorder.to_has_le.{0} enat
       (@partial_order.to_preorder.{0} enat
          (@linear_order.to_partial_order.{0} enat
             (@decidable_linear_order.to_linear_order.{0} enat enat.decidable_linear_order))))
    (@has_add.add.{0} enat
       (@add_semigroup.to_has_add.{0} enat
          (@add_comm_semigroup.to_add_semigroup.{0} enat
             (@add_comm_monoid.to_add_comm_semigroup.{0} enat enat.add_comm_monoid)))
       (@multiplicity.{0} int
          (@nonzero_comm_semiring.to_comm_semiring.{0} int
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} int
                (@integral_domain.to_nonzero_comm_ring.{0} int
                   (@normalization_domain.to_integral_domain.{0} int int.normalization_domain))))
          (λ (a b : int), (λ (a b : int), int.decidable_dvd a b) a b)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))
       (@multiplicity.{0} int
          (@nonzero_comm_semiring.to_comm_semiring.{0} int
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} int
                (@integral_domain.to_nonzero_comm_ring.{0} int
                   (@normalization_domain.to_integral_domain.{0} int int.normalization_domain))))
          (λ (a b : int), (λ (a b : int), int.decidable_dvd a b) a b)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
          (@has_mul.mul.{0} int int.has_mul (q.num)
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))))
    (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
       (@has_mul.mul.{0} int int.has_mul
          (@has_mul.mul.{0} int int.has_mul
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
             (r.num))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
p_prime : nat.prime p,
q r : rat,
hq : @ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero),
hr : @ne.{1} rat r (@has_zero.zero.{0} rat rat.has_zero),
hqr : @ne.{1} rat (@has_add.add.{0} rat rat.has_add q r) (@has_zero.zero.{0} rat rat.has_zero),
hqn : @ne.{1} int (q.num) (@has_zero.zero.{0} int int.has_zero),
hqd :
  @ne.{1} int (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
    (@has_zero.zero.{0} int int.has_zero),
hrn : @ne.{1} int (r.num) (@has_zero.zero.{0} int int.has_zero),
hrd :
  @ne.{1} int (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom))
    (@has_zero.zero.{0} int int.has_zero),
hqdv :
  @ne.{1} rat
    (rat.mk (q.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))
    (@has_zero.zero.{0} rat rat.has_zero),
hrdv :
  @ne.{1} rat
    (rat.mk (r.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
    (@has_zero.zero.{0} rat rat.has_zero),
hqreq :
  @eq.{1} rat (@has_add.add.{0} rat rat.has_add q r)
    (rat.mk
       (@has_add.add.{0} int int.has_add
          (@has_mul.mul.{0} int int.has_mul (q.num)
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
          (@has_mul.mul.{0} int int.has_mul
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
             (r.num)))
       (@has_mul.mul.{0} int int.has_mul
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))),
hqrd :
  @ne.{1} int
    (@has_add.add.{0} int int.has_add
       (@has_mul.mul.{0} int int.has_mul (q.num)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
       (@has_mul.mul.{0} int int.has_mul
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
          (r.num)))
    (@has_zero.zero.{0} int int.has_zero),
h :
  @has_le.le.{0} enat enat.has_le
    (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
       (@has_mul.mul.{0} int int.has_mul (q.num)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom))))
    (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
       (@has_mul.mul.{0} int int.has_mul (r.num)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))))
⊢ @has_le.le.{0} enat enat.has_le
    (@has_add.add.{0} enat enat.has_add
       (@multiplicity.{0} int
          (@nonzero_comm_semiring.to_comm_semiring.{0} int
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} int
                (@integral_domain.to_nonzero_comm_ring.{0} int
                   (@normalization_domain.to_integral_domain.{0} int int.normalization_domain))))
          (λ (a b : int), (λ (a b : int), int.decidable_dvd a b) a b)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))
       (@multiplicity.{0} int
          (@nonzero_comm_semiring.to_comm_semiring.{0} int
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} int
                (@integral_domain.to_nonzero_comm_ring.{0} int
                   (@normalization_domain.to_integral_domain.{0} int int.normalization_domain))))
          (λ (a b : int), (λ (a b : int), int.decidable_dvd a b) a b)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
          (@has_mul.mul.{0} int
             (@semigroup.to_has_mul.{0} int (@comm_semigroup.to_semigroup.{0} int int.comm_semigroup))
             (q.num)
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))))
    (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
       (@has_add.add.{0} int (@distrib.to_has_add.{0} int int.distrib)
          (@has_mul.mul.{0} int (@distrib.to_has_mul.{0} int int.distrib)
             (@has_mul.mul.{0} int int.has_mul (q.num)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))
          (@has_mul.mul.{0} int (@distrib.to_has_mul.{0} int int.distrib)
             (@has_mul.mul.{0} int int.has_mul
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
                (r.num))
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>240      ... ≤ _ : min_le_multiplicity_add</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='multiplicity.min_le_multiplicity_add'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/ring_theory/multiplicity.lean&#x27;, &#x27;line&#x27;: 151, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='∀ {α : Type} [_inst_1 : comm_semiring.{0} α] [_inst_2 : @decidable_rel.{1} α (@has_dvd.dvd.{0} α (@comm_semiring_has_dvd.{0} α _inst_1))] {p a b : α}, @has_le.le.{0} enat enat.has_le (@min.{0} enat enat.decidable_linear_order (@multiplicity.{0} α _inst_1 (λ (a b : α), _inst_2 a b) p a) (@multiplicity.{0} α _inst_1 (λ (a b : α), _inst_2 a b) p b)) (@multiplicity.{0} α _inst_1 (λ (a b : α), _inst_2 a b) p (@has_add.add.{0} α (@distrib.to_has_add.{0} α (@semiring.to_distrib.{0} α (@comm_semiring.to_semiring.{0} α _inst_1))) a b))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
p_prime : nat.prime p,
q r : rat,
hq : @ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero),
hr : @ne.{1} rat r (@has_zero.zero.{0} rat rat.has_zero),
hqr : @ne.{1} rat (@has_add.add.{0} rat rat.has_add q r) (@has_zero.zero.{0} rat rat.has_zero),
hqn : @ne.{1} int (q.num) (@has_zero.zero.{0} int int.has_zero),
hqd :
  @ne.{1} int (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
    (@has_zero.zero.{0} int int.has_zero),
hrn : @ne.{1} int (r.num) (@has_zero.zero.{0} int int.has_zero),
hrd :
  @ne.{1} int (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom))
    (@has_zero.zero.{0} int int.has_zero),
hqdv :
  @ne.{1} rat
    (rat.mk (q.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))
    (@has_zero.zero.{0} rat rat.has_zero),
hrdv :
  @ne.{1} rat
    (rat.mk (r.num) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
    (@has_zero.zero.{0} rat rat.has_zero),
hqreq :
  @eq.{1} rat (@has_add.add.{0} rat rat.has_add q r)
    (rat.mk
       (@has_add.add.{0} int int.has_add
          (@has_mul.mul.{0} int int.has_mul (q.num)
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
          (@has_mul.mul.{0} int int.has_mul
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
             (r.num)))
       (@has_mul.mul.{0} int int.has_mul
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))),
hqrd :
  @ne.{1} int
    (@has_add.add.{0} int int.has_add
       (@has_mul.mul.{0} int int.has_mul (q.num)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
       (@has_mul.mul.{0} int int.has_mul
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
          (r.num)))
    (@has_zero.zero.{0} int int.has_zero),
h :
  @has_le.le.{0} enat enat.has_le
    (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
       (@has_mul.mul.{0} int int.has_mul (q.num)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom))))
    (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
       (@has_mul.mul.{0} int int.has_mul (r.num)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))))
⊢ @has_le.le.{0} enat enat.has_le
    (@has_add.add.{0} enat enat.has_add
       (@multiplicity.{0} int
          (@nonzero_comm_semiring.to_comm_semiring.{0} int
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} int
                (@integral_domain.to_nonzero_comm_ring.{0} int
                   (@normalization_domain.to_integral_domain.{0} int int.normalization_domain))))
          (λ (a b : int), (λ (a b : int), int.decidable_dvd a b) a b)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))
       (@multiplicity.{0} int
          (@nonzero_comm_semiring.to_comm_semiring.{0} int
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{0} int
                (@integral_domain.to_nonzero_comm_ring.{0} int
                   (@normalization_domain.to_integral_domain.{0} int int.normalization_domain))))
          (λ (a b : int), (λ (a b : int), int.decidable_dvd a b) a b)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
          (@has_mul.mul.{0} int
             (@semigroup.to_has_mul.{0} int (@comm_semigroup.to_semigroup.{0} int int.comm_semigroup))
             (q.num)
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))))
    (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
       (@has_add.add.{0} int (@distrib.to_has_add.{0} int int.distrib)
          (@has_mul.mul.{0} int (@distrib.to_has_mul.{0} int int.distrib)
             (@has_mul.mul.{0} int int.has_mul (q.num)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (r.denom)))
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))
          (@has_mul.mul.{0} int (@distrib.to_has_mul.{0} int int.distrib)
             (@has_mul.mul.{0} int int.has_mul
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom))
                (r.num))
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (q.denom)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>241  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>242  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>243  /--</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>244  The minimum of the valuations of `q` and `r` is less than or equal to the valuation of `q + r`.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>245  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>246  theorem min_le_padic_val_rat_add {q r : ℚ}</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='blue'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/rat/basic.lean&#x27;, &#x27;line&#x27;: 46, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='orange'><a title='`rat`, or `ℚ`, is the type of rational numbers. It is defined
 as the set of pairs ⟨n, d⟩ of integers such that `d` is positive and `n` and
 `d` are coprime. This representation is preferred to the quotient
 because without periodic reduction, the numerator and denominator can grow
 exponentially (for example, adding 1/2 to itself repeatedly).'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>247    (hq : q ≠ 0) (hr : r ≠ 0) (hqr : q + r ≠ 0) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='q'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ne'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='r'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ne'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='q'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='r'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ne'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 97, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 97, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 97, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_add.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>248    min (padic_val_rat p q) (padic_val_rat p r) ≤ padic_val_rat p (q + r) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='min'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='padic_val_rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='q'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='padic_val_rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='r'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_le.le'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='padic_val_rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='q'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='r'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/functions.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 11}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 62, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;line&#x27;: 62, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 319, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 62, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} [_inst_1 : decidable_linear_order.{u} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='nat → rat → int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='nat → rat → int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type} [c : has_le.{0} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat → rat → int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_add.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='For `p ≠ 1`, the p-adic valuation of an integer `z ≠ 0` is the largest natural number `n` such that
p^n divides z.

`padic_val_rat` defines the valuation of a rational `q` to be the valuation of `q.num` minus the
valuation of `q.denom`.
If `q = 0` or `p = 1`, then `padic_val_rat p q` defaults to 0.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='For `p ≠ 1`, the p-adic valuation of an integer `z ≠ 0` is the largest natural number `n` such that
p^n divides z.

`padic_val_rat` defines the valuation of a rational `q` to be the valuation of `q.num` minus the
valuation of `q.denom`.
If `q = 0` or `p = 1`, then `padic_val_rat p q` defaults to 0.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='For `p ≠ 1`, the p-adic valuation of an integer `z ≠ 0` is the largest natural number `n` such that
p^n divides z.

`padic_val_rat` defines the valuation of a rational `q` to be the valuation of `q.num` minus the
valuation of `q.denom`.
If `q = 0` or `p = 1`, then `padic_val_rat p q` defaults to 0.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>249  (le_total (padic_val_rat p q) (padic_val_rat p r)).elim</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='le_total'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='padic_val_rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='q'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='padic_val_rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='r'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='or.elim'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 57, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 62, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;line&#x27;: 62, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 202, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type} [_inst_1 : linear_order.{0} α] (a b : α), or (@has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@linear_order.to_partial_order.{0} α _inst_1))) a b) (@has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@linear_order.to_partial_order.{0} α _inst_1))) b a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='nat → rat → int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='nat → rat → int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {a b c : Prop}, or a b → (a → c) → (b → c) → c'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='For `p ≠ 1`, the p-adic valuation of an integer `z ≠ 0` is the largest natural number `n` such that
p^n divides z.

`padic_val_rat` defines the valuation of a rational `q` to be the valuation of `q.num` minus the
valuation of `q.denom`.
If `q = 0` or `p = 1`, then `padic_val_rat p q` defaults to 0.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='For `p ≠ 1`, the p-adic valuation of an integer `z ≠ 0` is the largest natural number `n` such that
p^n divides z.

`padic_val_rat` defines the valuation of a rational `q` to be the valuation of `q.num` minus the
valuation of `q.denom`.
If `q = 0` or `p = 1`, then `padic_val_rat p q` defaults to 0.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>250    (λ h, by rw [min_eq_left h]; exact le_padic_val_rat_add_of_le _ hq hr hqr h)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='min_eq_left'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='padic_val_rat.le_padic_val_rat_add_of_le'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='hq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hqr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/functions.lean&#x27;, &#x27;line&#x27;: 70, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 213, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@has_le.le.{0} int (@preorder.to_has_le.{0} int (@partial_order.to_preorder.{0} int (@linear_order.to_partial_order.{0} int (@linear_ordered_ring.to_linear_order.{0} int (@linear_ordered_comm_ring.to_linear_ordered_ring.{0} int (@decidable_linear_ordered_comm_ring.to_linear_ordered_comm_ring.{0} int int.decidable_linear_ordered_comm_ring)))))) (padic_val_rat p q) (padic_val_rat p r)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : decidable_linear_order.{0} α] {a b : α}, @has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@linear_order.to_partial_order.{0} α (@decidable_linear_order.to_linear_order.{0} α _inst_1)))) a b → @eq.{1} α (@min.{0} α _inst_1 a b) a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_le.le.{0} int (@preorder.to_has_le.{0} int (@partial_order.to_preorder.{0} int (@linear_order.to_partial_order.{0} int (@linear_ordered_ring.to_linear_order.{0} int (@linear_ordered_comm_ring.to_linear_ordered_ring.{0} int (@decidable_linear_ordered_comm_ring.to_linear_ordered_comm_ring.{0} int int.decidable_linear_ordered_comm_ring)))))) (padic_val_rat p q) (padic_val_rat p r)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (p : nat) [p_prime : nat.prime p] {q r : rat}, @ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero) → @ne.{1} rat r (@has_zero.zero.{0} rat rat.has_zero) → @ne.{1} rat (@has_add.add.{0} rat rat.has_add q r) (@has_zero.zero.{0} rat rat.has_zero) → @has_le.le.{0} int int.has_le (padic_val_rat p q) (padic_val_rat p r) → @has_le.le.{0} int int.has_le (padic_val_rat p q) (padic_val_rat p (@has_add.add.{0} rat rat.has_add q r))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@ne.{1} rat r (@has_zero.zero.{0} rat rat.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@ne.{1} rat (@has_add.add.{0} rat rat.has_add q r) (@has_zero.zero.{0} rat rat.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_le.le.{0} int (@preorder.to_has_le.{0} int (@partial_order.to_preorder.{0} int (@linear_order.to_partial_order.{0} int (@linear_ordered_ring.to_linear_order.{0} int (@linear_ordered_comm_ring.to_linear_ordered_ring.{0} int (@decidable_linear_ordered_comm_ring.to_linear_ordered_comm_ring.{0} int int.decidable_linear_ordered_comm_ring)))))) (padic_val_rat p q) (padic_val_rat p r)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Sufficient conditions to show that the p-adic valuation of `q` is less than or equal to the
p-adic vlauation of `q + r`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='lime'><a title='p : nat,
p_prime : nat.prime p,
q r : rat,
hq : @ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero),
hr : @ne.{1} rat r (@has_zero.zero.{0} rat rat.has_zero),
hqr : @ne.{1} rat (@has_add.add.{0} rat rat.has_add q r) (@has_zero.zero.{0} rat rat.has_zero),
h :
  @has_le.le.{0} int
    (@preorder.to_has_le.{0} int
       (@partial_order.to_preorder.{0} int
          (@linear_order.to_partial_order.{0} int
             (@linear_ordered_ring.to_linear_order.{0} int
                (@linear_ordered_comm_ring.to_linear_ordered_ring.{0} int
                   (@decidable_linear_ordered_comm_ring.to_linear_ordered_comm_ring.{0} int
                      int.decidable_linear_ordered_comm_ring))))))
    (padic_val_rat p q)
    (padic_val_rat p r)
⊢ @has_le.le.{0} int int.has_le
    (@min.{0} int
       (@decidable_linear_ordered_semiring.to_decidable_linear_order.{0} int
          (@decidable_linear_ordered_comm_ring.to_decidable_linear_ordered_semiring.{0} int
             int.decidable_linear_ordered_comm_ring))
       (padic_val_rat p q)
       (padic_val_rat p r))
    (padic_val_rat p (@has_add.add.{0} rat rat.has_add q r))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
p_prime : nat.prime p,
q r : rat,
hq : @ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero),
hr : @ne.{1} rat r (@has_zero.zero.{0} rat rat.has_zero),
hqr : @ne.{1} rat (@has_add.add.{0} rat rat.has_add q r) (@has_zero.zero.{0} rat rat.has_zero),
h :
  @has_le.le.{0} int
    (@preorder.to_has_le.{0} int
       (@partial_order.to_preorder.{0} int
          (@linear_order.to_partial_order.{0} int
             (@linear_ordered_ring.to_linear_order.{0} int
                (@linear_ordered_comm_ring.to_linear_ordered_ring.{0} int
                   (@decidable_linear_ordered_comm_ring.to_linear_ordered_comm_ring.{0} int
                      int.decidable_linear_ordered_comm_ring))))))
    (padic_val_rat p q)
    (padic_val_rat p r)
⊢ @has_le.le.{0} int int.has_le (padic_val_rat p q) (padic_val_rat p (@has_add.add.{0} rat rat.has_add q r))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
p_prime : nat.prime p,
q r : rat,
hq : @ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero),
hr : @ne.{1} rat r (@has_zero.zero.{0} rat rat.has_zero),
hqr : @ne.{1} rat (@has_add.add.{0} rat rat.has_add q r) (@has_zero.zero.{0} rat rat.has_zero),
h :
  @has_le.le.{0} int
    (@preorder.to_has_le.{0} int
       (@partial_order.to_preorder.{0} int
          (@linear_order.to_partial_order.{0} int
             (@linear_ordered_ring.to_linear_order.{0} int
                (@linear_ordered_comm_ring.to_linear_ordered_ring.{0} int
                   (@decidable_linear_ordered_comm_ring.to_linear_ordered_comm_ring.{0} int
                      int.decidable_linear_ordered_comm_ring))))))
    (padic_val_rat p q)
    (padic_val_rat p r)
⊢ @has_le.le.{0} int int.has_le
    (@min.{0} int
       (@decidable_linear_ordered_semiring.to_decidable_linear_order.{0} int
          (@decidable_linear_ordered_comm_ring.to_decidable_linear_ordered_semiring.{0} int
             int.decidable_linear_ordered_comm_ring))
       (padic_val_rat p q)
       (padic_val_rat p r))
    (padic_val_rat p (@has_add.add.{0} rat rat.has_add q r))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>251    (λ h, by rw [min_eq_right h, add_comm]; exact le_padic_val_rat_add_of_le _ hr hq</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='min_eq_right'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='add_comm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='padic_val_rat.le_padic_val_rat_add_of_le'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='hr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/functions.lean&#x27;, &#x27;line&#x27;: 74, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 226, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 213, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@has_le.le.{0} int (@preorder.to_has_le.{0} int (@partial_order.to_preorder.{0} int (@linear_order.to_partial_order.{0} int (@linear_ordered_ring.to_linear_order.{0} int (@linear_ordered_comm_ring.to_linear_ordered_ring.{0} int (@decidable_linear_ordered_comm_ring.to_linear_ordered_comm_ring.{0} int int.decidable_linear_ordered_comm_ring)))))) (padic_val_rat p r) (padic_val_rat p q)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : decidable_linear_order.{0} α] {a b : α}, @has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@linear_order.to_partial_order.{0} α (@decidable_linear_order.to_linear_order.{0} α _inst_1)))) b a → @eq.{1} α (@min.{0} α _inst_1 a b) b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_le.le.{0} int (@preorder.to_has_le.{0} int (@partial_order.to_preorder.{0} int (@linear_order.to_partial_order.{0} int (@linear_ordered_ring.to_linear_order.{0} int (@linear_ordered_comm_ring.to_linear_ordered_ring.{0} int (@decidable_linear_ordered_comm_ring.to_linear_ordered_comm_ring.{0} int int.decidable_linear_ordered_comm_ring)))))) (padic_val_rat p r) (padic_val_rat p q)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : add_comm_semigroup.{0} α] (a b : α), @eq.{1} α (@has_add.add.{0} α (@add_semigroup.to_has_add.{0} α (@add_comm_semigroup.to_add_semigroup.{0} α _inst_1)) a b) (@has_add.add.{0} α (@add_semigroup.to_has_add.{0} α (@add_comm_semigroup.to_add_semigroup.{0} α _inst_1)) b a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (p : nat) [p_prime : nat.prime p] {q r : rat}, @ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero) → @ne.{1} rat r (@has_zero.zero.{0} rat rat.has_zero) → @ne.{1} rat (@has_add.add.{0} rat rat.has_add q r) (@has_zero.zero.{0} rat rat.has_zero) → @has_le.le.{0} int int.has_le (padic_val_rat p q) (padic_val_rat p r) → @has_le.le.{0} int int.has_le (padic_val_rat p q) (padic_val_rat p (@has_add.add.{0} rat rat.has_add q r))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@ne.{1} rat r (@has_zero.zero.{0} rat rat.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Sufficient conditions to show that the p-adic valuation of `q` is less than or equal to the
p-adic vlauation of `q + r`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='lime'><a title='p : nat,
p_prime : nat.prime p,
q r : rat,
hq : @ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero),
hr : @ne.{1} rat r (@has_zero.zero.{0} rat rat.has_zero),
hqr : @ne.{1} rat (@has_add.add.{0} rat rat.has_add q r) (@has_zero.zero.{0} rat rat.has_zero),
h :
  @has_le.le.{0} int
    (@preorder.to_has_le.{0} int
       (@partial_order.to_preorder.{0} int
          (@linear_order.to_partial_order.{0} int
             (@linear_ordered_ring.to_linear_order.{0} int
                (@linear_ordered_comm_ring.to_linear_ordered_ring.{0} int
                   (@decidable_linear_ordered_comm_ring.to_linear_ordered_comm_ring.{0} int
                      int.decidable_linear_ordered_comm_ring))))))
    (padic_val_rat p r)
    (padic_val_rat p q)
⊢ @has_le.le.{0} int int.has_le
    (@min.{0} int
       (@decidable_linear_ordered_semiring.to_decidable_linear_order.{0} int
          (@decidable_linear_ordered_comm_ring.to_decidable_linear_ordered_semiring.{0} int
             int.decidable_linear_ordered_comm_ring))
       (padic_val_rat p q)
       (padic_val_rat p r))
    (padic_val_rat p (@has_add.add.{0} rat rat.has_add q r))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
p_prime : nat.prime p,
q r : rat,
hq : @ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero),
hr : @ne.{1} rat r (@has_zero.zero.{0} rat rat.has_zero),
hqr : @ne.{1} rat (@has_add.add.{0} rat rat.has_add q r) (@has_zero.zero.{0} rat rat.has_zero),
h :
  @has_le.le.{0} int
    (@preorder.to_has_le.{0} int
       (@partial_order.to_preorder.{0} int
          (@linear_order.to_partial_order.{0} int
             (@linear_ordered_ring.to_linear_order.{0} int
                (@linear_ordered_comm_ring.to_linear_ordered_ring.{0} int
                   (@decidable_linear_ordered_comm_ring.to_linear_ordered_comm_ring.{0} int
                      int.decidable_linear_ordered_comm_ring))))))
    (padic_val_rat p r)
    (padic_val_rat p q)
⊢ @has_le.le.{0} int int.has_le (padic_val_rat p r) (padic_val_rat p (@has_add.add.{0} rat rat.has_add q r))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
p_prime : nat.prime p,
q r : rat,
hq : @ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero),
hr : @ne.{1} rat r (@has_zero.zero.{0} rat rat.has_zero),
hqr : @ne.{1} rat (@has_add.add.{0} rat rat.has_add q r) (@has_zero.zero.{0} rat rat.has_zero),
h :
  @has_le.le.{0} int
    (@preorder.to_has_le.{0} int
       (@partial_order.to_preorder.{0} int
          (@linear_order.to_partial_order.{0} int
             (@linear_ordered_ring.to_linear_order.{0} int
                (@linear_ordered_comm_ring.to_linear_ordered_ring.{0} int
                   (@decidable_linear_ordered_comm_ring.to_linear_ordered_comm_ring.{0} int
                      int.decidable_linear_ordered_comm_ring))))))
    (padic_val_rat p r)
    (padic_val_rat p q)
⊢ @has_le.le.{0} int int.has_le (padic_val_rat p r)
    (padic_val_rat p
       (@has_add.add.{0} rat
          (@add_semigroup.to_has_add.{0} rat (@add_comm_semigroup.to_add_semigroup.{0} rat rat.add_comm_semigroup))
          r
          q))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
p_prime : nat.prime p,
q r : rat,
hq : @ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero),
hr : @ne.{1} rat r (@has_zero.zero.{0} rat rat.has_zero),
hqr : @ne.{1} rat (@has_add.add.{0} rat rat.has_add q r) (@has_zero.zero.{0} rat rat.has_zero),
h :
  @has_le.le.{0} int
    (@preorder.to_has_le.{0} int
       (@partial_order.to_preorder.{0} int
          (@linear_order.to_partial_order.{0} int
             (@linear_ordered_ring.to_linear_order.{0} int
                (@linear_ordered_comm_ring.to_linear_ordered_ring.{0} int
                   (@decidable_linear_ordered_comm_ring.to_linear_ordered_comm_ring.{0} int
                      int.decidable_linear_ordered_comm_ring))))))
    (padic_val_rat p r)
    (padic_val_rat p q)
⊢ @has_le.le.{0} int int.has_le
    (@min.{0} int
       (@decidable_linear_ordered_semiring.to_decidable_linear_order.{0} int
          (@decidable_linear_ordered_comm_ring.to_decidable_linear_ordered_semiring.{0} int
             int.decidable_linear_ordered_comm_ring))
       (padic_val_rat p q)
       (padic_val_rat p r))
    (padic_val_rat p (@has_add.add.{0} rat rat.has_add q r))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>252      (by rwa add_comm) h)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='add_comm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 391, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 226, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : add_comm_semigroup.{0} α] (a b : α), @eq.{1} α (@has_add.add.{0} α (@add_semigroup.to_has_add.{0} α (@add_comm_semigroup.to_add_semigroup.{0} α _inst_1)) a b) (@has_add.add.{0} α (@add_semigroup.to_has_add.{0} α (@add_comm_semigroup.to_add_semigroup.{0} α _inst_1)) b a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_le.le.{0} int (@preorder.to_has_le.{0} int (@partial_order.to_preorder.{0} int (@linear_order.to_partial_order.{0} int (@linear_ordered_ring.to_linear_order.{0} int (@linear_ordered_comm_ring.to_linear_ordered_ring.{0} int (@decidable_linear_ordered_comm_ring.to_linear_ordered_comm_ring.{0} int int.decidable_linear_ordered_comm_ring)))))) (padic_val_rat p r) (padic_val_rat p q)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`rewrite` followed by `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rwa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
p_prime : nat.prime p,
q r : rat,
hq : @ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero),
hr : @ne.{1} rat r (@has_zero.zero.{0} rat rat.has_zero),
hqr : @ne.{1} rat (@has_add.add.{0} rat rat.has_add q r) (@has_zero.zero.{0} rat rat.has_zero),
h :
  @has_le.le.{0} int
    (@preorder.to_has_le.{0} int
       (@partial_order.to_preorder.{0} int
          (@linear_order.to_partial_order.{0} int
             (@linear_ordered_ring.to_linear_order.{0} int
                (@linear_ordered_comm_ring.to_linear_ordered_ring.{0} int
                   (@decidable_linear_ordered_comm_ring.to_linear_ordered_comm_ring.{0} int
                      int.decidable_linear_ordered_comm_ring))))))
    (padic_val_rat p r)
    (padic_val_rat p q)
⊢ @has_le.le.{0} int int.has_le
    (@min.{0} int
       (@decidable_linear_ordered_semiring.to_decidable_linear_order.{0} int
          (@decidable_linear_ordered_comm_ring.to_decidable_linear_ordered_semiring.{0} int
             int.decidable_linear_ordered_comm_ring))
       (padic_val_rat p q)
       (padic_val_rat p r))
    (padic_val_rat p (@has_add.add.{0} rat rat.has_add q r))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
p_prime : nat.prime p,
q r : rat,
hq : @ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero),
hr : @ne.{1} rat r (@has_zero.zero.{0} rat rat.has_zero),
hqr : @ne.{1} rat (@has_add.add.{0} rat rat.has_add q r) (@has_zero.zero.{0} rat rat.has_zero),
h :
  @has_le.le.{0} int
    (@preorder.to_has_le.{0} int
       (@partial_order.to_preorder.{0} int
          (@linear_order.to_partial_order.{0} int
             (@linear_ordered_ring.to_linear_order.{0} int
                (@linear_ordered_comm_ring.to_linear_ordered_ring.{0} int
                   (@decidable_linear_ordered_comm_ring.to_linear_ordered_comm_ring.{0} int
                      int.decidable_linear_ordered_comm_ring))))))
    (padic_val_rat p r)
    (padic_val_rat p q)
⊢ @ne.{1} rat (@has_add.add.{0} rat rat.has_add r q) (@has_zero.zero.{0} rat rat.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
p_prime : nat.prime p,
q r : rat,
hq : @ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero),
hr : @ne.{1} rat r (@has_zero.zero.{0} rat rat.has_zero),
hqr : @ne.{1} rat (@has_add.add.{0} rat rat.has_add q r) (@has_zero.zero.{0} rat rat.has_zero),
h :
  @has_le.le.{0} int
    (@preorder.to_has_le.{0} int
       (@partial_order.to_preorder.{0} int
          (@linear_order.to_partial_order.{0} int
             (@linear_ordered_ring.to_linear_order.{0} int
                (@linear_ordered_comm_ring.to_linear_ordered_ring.{0} int
                   (@decidable_linear_ordered_comm_ring.to_linear_ordered_comm_ring.{0} int
                      int.decidable_linear_ordered_comm_ring))))))
    (padic_val_rat p r)
    (padic_val_rat p q)
⊢ @has_le.le.{0} int int.has_le
    (@min.{0} int
       (@decidable_linear_ordered_semiring.to_decidable_linear_order.{0} int
          (@decidable_linear_ordered_comm_ring.to_decidable_linear_ordered_semiring.{0} int
             int.decidable_linear_ordered_comm_ring))
       (padic_val_rat p q)
       (padic_val_rat p r))
    (padic_val_rat p (@has_add.add.{0} rat rat.has_add q r))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>253  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>254  end padic_val_rat</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>255  end padic_val_rat</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>256  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>257  /--</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>258  If `q ≠ 0`, the p-adic norm of a rational `q` is `p ^ (-(padic_val_rat p q))`.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>259  If `q = 0`, the p-adic norm of `q` is 0.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>260  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>261  def padic_norm (p : ℕ) (q : ℚ) : ℚ :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='blue'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 293, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/rat/basic.lean&#x27;, &#x27;line&#x27;: 46, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/rat/basic.lean&#x27;, &#x27;line&#x27;: 46, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='orange'><a title='`rat`, or `ℚ`, is the type of rational numbers. It is defined
 as the set of pairs ⟨n, d⟩ of integers such that `d` is positive and `n` and
 `d` are coprime. This representation is preferred to the quotient
 because without periodic reduction, the numerator and denominator can grow
 exponentially (for example, adding 1/2 to itself repeatedly).'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`rat`, or `ℚ`, is the type of rational numbers. It is defined
 as the set of pairs ⟨n, d⟩ of integers such that `d` is positive and `n` and
 `d` are coprime. This representation is preferred to the quotient
 because without periodic reduction, the numerator and denominator can grow
 exponentially (for example, adding 1/2 to itself repeatedly).'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>262  if q = 0 then 0 else (↑p : ℚ) ^ (-(padic_val_rat p q))</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='q'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='coe'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_pow.pow'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_neg.neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='padic_val_rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='q'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/coe.lean&#x27;, &#x27;line&#x27;: 67, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/rat/basic.lean&#x27;, &#x27;line&#x27;: 46, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 340, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 314, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 62, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='green'><a title='Π {a b : Type} [_inst_1 : has_lift_t.{1 1} a b], a → b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α β : Type} [c : has_pow.{0 0} α β], α → β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type} [c : has_neg.{0} α], α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat → rat → int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='orange'><a title='`rat`, or `ℚ`, is the type of rational numbers. It is defined
 as the set of pairs ⟨n, d⟩ of integers such that `d` is positive and `n` and
 `d` are coprime. This representation is preferred to the quotient
 because without periodic reduction, the numerator and denominator can grow
 exponentially (for example, adding 1/2 to itself repeatedly).'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='For `p ≠ 1`, the p-adic valuation of an integer `z ≠ 0` is the largest natural number `n` such that
p^n divides z.

`padic_val_rat` defines the valuation of a rational `q` to be the valuation of `q.num` minus the
valuation of `q.denom`.
If `q = 0` or `p = 1`, then `padic_val_rat p q` defaults to 0.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>263  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>264  namespace padic_norm</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>265  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>266  section padic_norm</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>267  open padic_val_rat</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>268  variables (p : ℕ)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 293, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>269  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>270  /--</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>271  Unfolds the definition of the p-adic norm of `q` when `q ≠ 0`.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>272  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>273  @[simp] protected lemma eq_fpow_of_nonzero {q : ℚ} (hq : q ≠ 0) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                </code><font color='blue'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='q'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ne'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/rat/basic.lean&#x27;, &#x27;line&#x27;: 46, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 97, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                          </code><font color='orange'><a title='`rat`, or `ℚ`, is the type of rational numbers. It is defined
 as the set of pairs ⟨n, d⟩ of integers such that `d` is positive and `n` and
 `d` are coprime. This representation is preferred to the quotient
 because without periodic reduction, the numerator and denominator can grow
 exponentially (for example, adding 1/2 to itself repeatedly).'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>274    padic_norm p q = p ^ (-(padic_val_rat p q)) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='padic_norm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='q'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_pow.pow'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_neg.neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='padic_val_rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='q'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 261, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 340, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 314, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 62, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='nat → rat → rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α β : Type} [c : has_pow.{0 0} α β], α → β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type} [c : has_neg.{0} α], α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat → rat → int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='If `q ≠ 0`, the p-adic norm of a rational `q` is `p ^ (-(padic_val_rat p q))`.
If `q = 0`, the p-adic norm of `q` is 0.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='For `p ≠ 1`, the p-adic valuation of an integer `z ≠ 0` is the largest natural number `n` such that
p^n divides z.

`padic_val_rat` defines the valuation of a rational `q` to be the valuation of `q.num` minus the
valuation of `q.denom`.
If `q = 0` or `p = 1`, then `padic_val_rat p q` defaults to 0.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>275  by simp [hq, padic_norm]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='hq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='padic_norm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 261, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat → rat → rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='If `q ≠ 0`, the p-adic norm of a rational `q` is `p ^ (-(padic_val_rat p q))`.
If `q = 0`, the p-adic norm of `q` is 0.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='p : nat,
q : rat,
hq : @ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)
⊢ @eq.{1} rat (padic_norm p q)
    (@has_pow.pow.{0 0} rat int (@int.has_pow.{0} rat rat.division_ring)
       (@coe.{1 1} nat rat
          (@coe_to_lift.{1 1} nat rat
             (@coe_base.{1 1} nat rat (@nat.cast_coe.{0} rat rat.has_zero rat.has_one rat.has_add)))
          p)
       (@has_neg.neg.{0} int int.has_neg (padic_val_rat p q)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>276  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
q : rat,
hq : @ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)
⊢ @eq.{1} rat (padic_norm p q)
    (@has_pow.pow.{0 0} rat int (@int.has_pow.{0} rat rat.division_ring)
       (@coe.{1 1} nat rat
          (@coe_to_lift.{1 1} nat rat
             (@coe_base.{1 1} nat rat (@nat.cast_coe.{0} rat rat.has_zero rat.has_one rat.has_add)))
          p)
       (@has_neg.neg.{0} int int.has_neg (padic_val_rat p q)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>277  /--</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>278  The p-adic norm is nonnegative.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>279  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>280  protected lemma nonneg (q : ℚ) : 0 ≤ padic_norm p q :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='blue'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='has_le.le'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='padic_norm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='q'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/rat/basic.lean&#x27;, &#x27;line&#x27;: 46, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 319, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 261, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Π {α : Type} [c : has_le.{0} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat → rat → rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='orange'><a title='`rat`, or `ℚ`, is the type of rational numbers. It is defined
 as the set of pairs ⟨n, d⟩ of integers such that `d` is positive and `n` and
 `d` are coprime. This representation is preferred to the quotient
 because without periodic reduction, the numerator and denominator can grow
 exponentially (for example, adding 1/2 to itself repeatedly).'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='If `q ≠ 0`, the p-adic norm of a rational `q` is `p ^ (-(padic_val_rat p q))`.
If `q = 0`, the p-adic norm of `q` is 0.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>281  if hq : q = 0 then by simp [hq]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='dite'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='q'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='hq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 609, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (c : Prop) [h : decidable c] {α : Prop}, (c → α) → (not c → α) → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='lime'><a title='p : nat,
q : rat,
hq : @eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)
⊢ @has_le.le.{0} rat rat.has_le (@has_zero.zero.{0} rat rat.has_zero) (padic_norm p q)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>282  else</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>283    begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='p : nat,
q : rat,
hq : not (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero))
⊢ @has_le.le.{0} rat rat.has_le (@has_zero.zero.{0} rat rat.has_zero) (padic_norm p q)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>284      unfold padic_norm; split_ifs,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1411, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/split_ifs.lean&#x27;, &#x27;line&#x27;: 84, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.unfold_config {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.ff, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.ff, beta := bool.tt, eta := bool.ff, proj := bool.ff, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.ff, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Given defined constants `e₁ ... eₙ`, `unfold e₁ ... eₙ` iteratively unfolds all occurrences in the target of the main goal, using equational lemmas associated with the definitions.

As with `simp`, the `at` modifier can be used to specify locations for the unfolding.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title=' Splits all if-then-else-expressions into multiple goals.

Given a goal of the form `g (if p then x else y)`, `split_ifs` will produce
two goals: `p ⊢ g x` and `¬p ⊢ g y`.

If there are multiple ite-expressions, then `split_ifs` will split them all,
starting with a top-most one whose condition does not contain another
ite-expression.

`split_ifs at *` splits all ite-expressions in all hypotheses as well as the goal.

`split_ifs with h₁ h₂ h₃` overrides the default names for the hypotheses.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='unfold'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='split_ifs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id*&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.unfold_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
q : rat,
hq : not (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero))
⊢ @has_le.le.{0} rat rat.has_le (@has_zero.zero.{0} rat rat.has_zero) (padic_norm p q)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
q : rat,
hq : not (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero))
⊢ @has_le.le.{0} rat rat.has_le (@has_zero.zero.{0} rat rat.has_zero)
    (@has_pow.pow.{0 0} rat int (@int.has_pow.{0} rat rat.division_ring)
       (@coe.{1 1} nat rat
          (@coe_to_lift.{1 1} nat rat
             (@coe_base.{1 1} nat rat (@nat.cast_coe.{0} rat rat.has_zero rat.has_one rat.has_add)))
          p)
       (@has_neg.neg.{0} int int.has_neg (padic_val_rat p q)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>285      apply fpow_nonneg_of_nonneg,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='fpow_nonneg_of_nonneg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/field_power.lean&#x27;, &#x27;line&#x27;: 122, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {K : Type} [_inst_1 : discrete_linear_ordered_field.{0} K] {a : K}, @has_le.le.{0} K (@preorder.to_has_le.{0} K (@partial_order.to_preorder.{0} K (@ordered_comm_monoid.to_partial_order.{0} K (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} K (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} K (@ordered_ring.to_ordered_semiring.{0} K (@linear_ordered_ring.to_ordered_ring.{0} K (@linear_ordered_field.to_linear_ordered_ring.{0} K (@discrete_linear_ordered_field.to_linear_ordered_field.{0} K _inst_1))))))))) (@has_zero.zero.{0} K (@no_zero_divisors.to_has_zero.{0} K (@domain.to_no_zero_divisors.{0} K (@division_ring.to_domain.{0} K (@field.to_division_ring.{0} K (@linear_ordered_field.to_field.{0} K (@discrete_linear_ordered_field.to_linear_ordered_field.{0} K _inst_1))))))) a → ∀ (z : int), @has_le.le.{0} K (@preorder.to_has_le.{0} K (@partial_order.to_preorder.{0} K (@ordered_comm_monoid.to_partial_order.{0} K (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} K (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} K (@ordered_ring.to_ordered_semiring.{0} K (@linear_ordered_ring.to_ordered_ring.{0} K (@linear_ordered_field.to_linear_ordered_ring.{0} K (@discrete_linear_ordered_field.to_linear_ordered_field.{0} K _inst_1))))))))) (@has_zero.zero.{0} K (@no_zero_divisors.to_has_zero.{0} K (@domain.to_no_zero_divisors.{0} K (@division_ring.to_domain.{0} K (@field.to_division_ring.{0} K (@linear_ordered_field.to_field.{0} K (@discrete_linear_ordered_field.to_linear_ordered_field.{0} K _inst_1))))))) (@has_pow.pow.{0 0} K int (@int.has_pow.{0} K (@field.to_division_ring.{0} K (@linear_ordered_field.to_field.{0} K (@discrete_linear_ordered_field.to_linear_ordered_field.{0} K _inst_1)))) a z)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
q : rat,
hq : not (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero))
⊢ @has_le.le.{0} rat rat.has_le (@has_zero.zero.{0} rat rat.has_zero)
    (@has_pow.pow.{0 0} rat int (@int.has_pow.{0} rat rat.division_ring)
       (@coe.{1 1} nat rat
          (@coe_to_lift.{1 1} nat rat
             (@coe_base.{1 1} nat rat (@nat.cast_coe.{0} rat rat.has_zero rat.has_one rat.has_add)))
          p)
       (@has_neg.neg.{0} int int.has_neg (padic_val_rat p q)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
q : rat,
hq : not (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero))
⊢ @has_le.le.{0} rat
    (@preorder.to_has_le.{0} rat
       (@partial_order.to_preorder.{0} rat
          (@ordered_comm_monoid.to_partial_order.{0} rat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} rat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} rat
                   (@ordered_ring.to_ordered_semiring.{0} rat
                      (@linear_ordered_ring.to_ordered_ring.{0} rat
                         (@linear_ordered_field.to_linear_ordered_ring.{0} rat
                            (@discrete_linear_ordered_field.to_linear_ordered_field.{0} rat
                               rat.discrete_linear_ordered_field)))))))))
    (@has_zero.zero.{0} rat
       (@no_zero_divisors.to_has_zero.{0} rat
          (@domain.to_no_zero_divisors.{0} rat
             (@division_ring.to_domain.{0} rat
                (@field.to_division_ring.{0} rat
                   (@linear_ordered_field.to_field.{0} rat
                      (@discrete_linear_ordered_field.to_linear_ordered_field.{0} rat
                         rat.discrete_linear_ordered_field)))))))
    (@coe.{1 1} nat rat
       (@coe_to_lift.{1 1} nat rat
          (@coe_base.{1 1} nat rat (@nat.cast_coe.{0} rat rat.has_zero rat.has_one rat.has_add)))
       p)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>286      exact_mod_cast nat.zero_le _</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='blue'><a title='nat.zero_le'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/norm_cast.lean&#x27;, &#x27;line&#x27;: 335, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/nat/basic.lean&#x27;, &#x27;line&#x27;: 75, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/norm_cast.lean&#x27;, &#x27;line&#x27;: 335, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (n : nat), @has_le.le.{0} nat nat.has_le (@has_zero.zero.{0} nat nat.has_zero) n'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Normalize the goal and the given expression,
then close the goal with exact.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='Normalize the goal and the given expression,
then close the goal with exact.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact_mod_cast'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='exact_mod_cast'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
q : rat,
hq : not (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero))
⊢ @has_le.le.{0} rat
    (@preorder.to_has_le.{0} rat
       (@partial_order.to_preorder.{0} rat
          (@ordered_comm_monoid.to_partial_order.{0} rat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} rat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} rat
                   (@ordered_ring.to_ordered_semiring.{0} rat
                      (@linear_ordered_ring.to_ordered_ring.{0} rat
                         (@linear_ordered_field.to_linear_ordered_ring.{0} rat
                            (@discrete_linear_ordered_field.to_linear_ordered_field.{0} rat
                               rat.discrete_linear_ordered_field)))))))))
    (@has_zero.zero.{0} rat
       (@no_zero_divisors.to_has_zero.{0} rat
          (@domain.to_no_zero_divisors.{0} rat
             (@division_ring.to_domain.{0} rat
                (@field.to_division_ring.{0} rat
                   (@linear_ordered_field.to_field.{0} rat
                      (@discrete_linear_ordered_field.to_linear_ordered_field.{0} rat
                         rat.discrete_linear_ordered_field)))))))
    (@coe.{1 1} nat rat
       (@coe_to_lift.{1 1} nat rat
          (@coe_base.{1 1} nat rat (@nat.cast_coe.{0} rat rat.has_zero rat.has_one rat.has_add)))
       p)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>287    end</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/norm_cast.lean&#x27;, &#x27;line&#x27;: 335, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='not (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Normalize the goal and the given expression,
then close the goal with exact.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact_mod_cast'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
q : rat,
hq : not (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero))
⊢ @has_le.le.{0} rat
    (@preorder.to_has_le.{0} rat
       (@partial_order.to_preorder.{0} rat
          (@ordered_comm_monoid.to_partial_order.{0} rat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} rat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} rat
                   (@ordered_ring.to_ordered_semiring.{0} rat
                      (@linear_ordered_ring.to_ordered_ring.{0} rat
                         (@linear_ordered_field.to_linear_ordered_ring.{0} rat
                            (@discrete_linear_ordered_field.to_linear_ordered_field.{0} rat
                               rat.discrete_linear_ordered_field)))))))))
    (@has_zero.zero.{0} rat
       (@no_zero_divisors.to_has_zero.{0} rat
          (@domain.to_no_zero_divisors.{0} rat
             (@division_ring.to_domain.{0} rat
                (@field.to_division_ring.{0} rat
                   (@linear_ordered_field.to_field.{0} rat
                      (@discrete_linear_ordered_field.to_linear_ordered_field.{0} rat
                         rat.discrete_linear_ordered_field)))))))
    (@coe.{1 1} nat rat
       (@coe_to_lift.{1 1} nat rat
          (@coe_base.{1 1} nat rat (@nat.cast_coe.{0} rat rat.has_zero rat.has_one rat.has_add)))
       p)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>288  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>289  /--</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>290  The p-adic norm of 0 is 0.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>291  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>292  @[simp] protected lemma zero : padic_norm p 0 = 0 := by simp [padic_norm]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='blue'><a title='padic_norm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='padic_norm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='red'><a title='{&#x27;line&#x27;: 261, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 261, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='green'><a title='nat → rat → rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat → rat → rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='orange'><a title='If `q ≠ 0`, the p-adic norm of a rational `q` is `p ^ (-(padic_val_rat p q))`.
If `q = 0`, the p-adic norm of `q` is 0.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='If `q ≠ 0`, the p-adic norm of a rational `q` is `p ^ (-(padic_val_rat p q))`.
If `q = 0`, the p-adic norm of `q` is 0.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                        </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                        </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                       </code><font color='lime'><a title='p : nat
⊢ @eq.{1} rat (padic_norm p (@has_zero.zero.{0} rat rat.has_zero)) (@has_zero.zero.{0} rat rat.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>293  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat
⊢ @eq.{1} rat (padic_norm p (@has_zero.zero.{0} rat rat.has_zero)) (@has_zero.zero.{0} rat rat.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>294  /--</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>295  The p-adic norm of 1 is 1.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>296  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>297  @[simp] protected lemma one : padic_norm p 1 = 1 := by simp [padic_norm]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='blue'><a title='padic_norm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='padic_norm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='red'><a title='{&#x27;line&#x27;: 261, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 261, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='green'><a title='nat → rat → rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat → rat → rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='orange'><a title='If `q ≠ 0`, the p-adic norm of a rational `q` is `p ^ (-(padic_val_rat p q))`.
If `q = 0`, the p-adic norm of `q` is 0.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='If `q ≠ 0`, the p-adic norm of a rational `q` is `p ^ (-(padic_val_rat p q))`.
If `q = 0`, the p-adic norm of `q` is 0.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                       </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                       </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                      </code><font color='lime'><a title='p : nat
⊢ @eq.{1} rat (padic_norm p (@has_one.one.{0} rat rat.has_one)) (@has_one.one.{0} rat rat.has_one)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>298  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat
⊢ @eq.{1} rat (padic_norm p (@has_one.one.{0} rat rat.has_one)) (@has_one.one.{0} rat rat.has_one)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>299  /--</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>300  The image of `padic_norm p` is {0} ∪ {p^(-n) | n ∈ ℤ}.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>301  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>302  protected theorem image {q : ℚ} (hq : q ≠ 0) : ∃ n : ℤ, padic_norm p q = p ^ (-n) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='blue'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='q'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ne'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='padic_norm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='q'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_pow.pow'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_neg.neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/rat/basic.lean&#x27;, &#x27;line&#x27;: 46, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 97, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/int/basic.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 261, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 340, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 314, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Π {α : Type}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat → rat → rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α β : Type} [c : has_pow.{0 0} α β], α → β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type} [c : has_neg.{0} α], α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='orange'><a title='`rat`, or `ℚ`, is the type of rational numbers. It is defined
 as the set of pairs ⟨n, d⟩ of integers such that `d` is positive and `n` and
 `d` are coprime. This representation is preferred to the quotient
 because without periodic reduction, the numerator and denominator can grow
 exponentially (for example, adding 1/2 to itself repeatedly).'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='orange'><a title='If `q ≠ 0`, the p-adic norm of a rational `q` is `p ^ (-(padic_val_rat p q))`.
If `q = 0`, the p-adic norm of `q` is 0.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>303  ⟨ (padic_val_rat p q), by simp [padic_norm, hq] ⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='padic_val_rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='q'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='padic_norm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 62, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 261, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='nat → rat → int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat → rat → rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='For `p ≠ 1`, the p-adic valuation of an integer `z ≠ 0` is the largest natural number `n` such that
p^n divides z.

`padic_val_rat` defines the valuation of a rational `q` to be the valuation of `q.num` minus the
valuation of `q.denom`.
If `q = 0` or `p = 1`, then `padic_val_rat p q` defaults to 0.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='If `q ≠ 0`, the p-adic norm of a rational `q` is `p ^ (-(padic_val_rat p q))`.
If `q = 0`, the p-adic norm of `q` is 0.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='lime'><a title='p : nat,
q : rat,
hq : @ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)
⊢ @eq.{1} rat (padic_norm p q)
    (@has_pow.pow.{0 0} rat int (@int.has_pow.{0} rat rat.division_ring)
       (@coe.{1 1} nat rat
          (@coe_to_lift.{1 1} nat rat
             (@coe_base.{1 1} nat rat (@nat.cast_coe.{0} rat rat.has_zero rat.has_one rat.has_add)))
          p)
       (@has_neg.neg.{0} int int.has_neg (padic_val_rat p q)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>304  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>305  variable [hp : p.prime]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='nat.prime'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/nat/prime.lean&#x27;, &#x27;line&#x27;: 36, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='green'><a title='nat → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='`prime p` means that `p` is a prime number, that is, a natural number
 at least 2 whose only divisors are `p` and `1`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>306  include hp</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>307  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>308  /--</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>309  If `q ≠ 0`, then `padic_norm p q ≠ 0`.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>310  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>311  protected lemma nonzero {q : ℚ} (hq : q ≠ 0) : padic_norm p q ≠ 0 :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='blue'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='q'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ne'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='padic_norm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='q'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ne'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/rat/basic.lean&#x27;, &#x27;line&#x27;: 46, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 97, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 261, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 97, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='nat → rat → rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='orange'><a title='`rat`, or `ℚ`, is the type of rational numbers. It is defined
 as the set of pairs ⟨n, d⟩ of integers such that `d` is positive and `n` and
 `d` are coprime. This representation is preferred to the quotient
 because without periodic reduction, the numerator and denominator can grow
 exponentially (for example, adding 1/2 to itself repeatedly).'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='If `q ≠ 0`, the p-adic norm of a rational `q` is `p ^ (-(padic_val_rat p q))`.
If `q = 0`, the p-adic norm of `q` is 0.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>312  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
q : rat,
hq : @ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)
⊢ @ne.{1} rat (padic_norm p q) (@has_zero.zero.{0} rat rat.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>313    rw padic_norm.eq_fpow_of_nonzero p hq,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='padic_norm.eq_fpow_of_nonzero'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 273, &#x27;column&#x27;: 24}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (p : nat) {q : rat}, @ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero) → @eq.{1} rat (padic_norm p q) (@has_pow.pow.{0 0} rat int (@int.has_pow.{0} rat rat.division_ring) (@coe.{1 1} nat rat (@coe_to_lift.{1 1} nat rat (@coe_base.{1 1} nat rat (@nat.cast_coe.{0} rat rat.has_zero rat.has_one rat.has_add))) p) (@has_neg.neg.{0} int int.has_neg (padic_val_rat p q)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Unfolds the definition of the p-adic norm of `q` when `q ≠ 0`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
q : rat,
hq : @ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)
⊢ @ne.{1} rat (padic_norm p q) (@has_zero.zero.{0} rat rat.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
q : rat,
hq : @ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)
⊢ @ne.{1} rat
    (@has_pow.pow.{0 0} rat int (@int.has_pow.{0} rat rat.division_ring)
       (@coe.{1 1} nat rat
          (@coe_to_lift.{1 1} nat rat
             (@coe_base.{1 1} nat rat (@nat.cast_coe.{0} rat rat.has_zero rat.has_one rat.has_add)))
          p)
       (@has_neg.neg.{0} int int.has_neg (padic_val_rat p q)))
    (@has_zero.zero.{0} rat rat.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>314    apply fpow_ne_zero_of_ne_zero,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='fpow_ne_zero_of_ne_zero'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/field_power.lean&#x27;, &#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {K : Type} [_inst_1 : division_ring.{0} K] {a : K}, @ne.{1} K a (@has_zero.zero.{0} K (@no_zero_divisors.to_has_zero.{0} K (@domain.to_no_zero_divisors.{0} K (@division_ring.to_domain.{0} K _inst_1)))) → ∀ (z : int), @ne.{1} K (@has_pow.pow.{0 0} K int (@int.has_pow.{0} K _inst_1) a z) (@has_zero.zero.{0} K (@no_zero_divisors.to_has_zero.{0} K (@domain.to_no_zero_divisors.{0} K (@division_ring.to_domain.{0} K _inst_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
q : rat,
hq : @ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)
⊢ @ne.{1} rat
    (@has_pow.pow.{0 0} rat int (@int.has_pow.{0} rat rat.division_ring)
       (@coe.{1 1} nat rat
          (@coe_to_lift.{1 1} nat rat
             (@coe_base.{1 1} nat rat (@nat.cast_coe.{0} rat rat.has_zero rat.has_one rat.has_add)))
          p)
       (@has_neg.neg.{0} int int.has_neg (padic_val_rat p q)))
    (@has_zero.zero.{0} rat rat.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
q : rat,
hq : @ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)
⊢ @ne.{1} rat
    (@coe.{1 1} nat rat
       (@coe_to_lift.{1 1} nat rat
          (@coe_base.{1 1} nat rat (@nat.cast_coe.{0} rat rat.has_zero rat.has_one rat.has_add)))
       p)
    (@has_zero.zero.{0} rat
       (@no_zero_divisors.to_has_zero.{0} rat
          (@domain.to_no_zero_divisors.{0} rat (@division_ring.to_domain.{0} rat rat.division_ring))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>315    exact_mod_cast ne_of_gt hp.pos</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='ne_of_gt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/norm_cast.lean&#x27;, &#x27;line&#x27;: 335, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 90, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/norm_cast.lean&#x27;, &#x27;line&#x27;: 335, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/nat/prime.lean&#x27;, &#x27;line&#x27;: 93, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/norm_cast.lean&#x27;, &#x27;line&#x27;: 335, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : preorder.{0} α] {a b : α}, @gt.{0} α (@preorder.to_has_lt.{0} α _inst_1) a b → @ne.{1} α a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat.prime p'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Normalize the goal and the given expression,
then close the goal with exact.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='Normalize the goal and the given expression,
then close the goal with exact.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='Normalize the goal and the given expression,
then close the goal with exact.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact_mod_cast'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='exact_mod_cast'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='exact_mod_cast'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
q : rat,
hq : @ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)
⊢ @ne.{1} rat
    (@coe.{1 1} nat rat
       (@coe_to_lift.{1 1} nat rat
          (@coe_base.{1 1} nat rat (@nat.cast_coe.{0} rat rat.has_zero rat.has_one rat.has_add)))
       p)
    (@has_zero.zero.{0} rat
       (@no_zero_divisors.to_has_zero.{0} rat
          (@domain.to_no_zero_divisors.{0} rat (@division_ring.to_domain.{0} rat rat.division_ring))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>316  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>317  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>318  /--</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>319  `padic_norm p` is symmetric.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>320  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>321  @[simp] protected lemma neg (q : ℚ) : padic_norm p (-q) = padic_norm p q :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='blue'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='padic_norm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_neg.neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='q'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='padic_norm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='q'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/rat/basic.lean&#x27;, &#x27;line&#x27;: 46, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 261, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 314, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 261, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='nat → rat → rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type} [c : has_neg.{0} α], α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat → rat → rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='orange'><a title='`rat`, or `ℚ`, is the type of rational numbers. It is defined
 as the set of pairs ⟨n, d⟩ of integers such that `d` is positive and `n` and
 `d` are coprime. This representation is preferred to the quotient
 because without periodic reduction, the numerator and denominator can grow
 exponentially (for example, adding 1/2 to itself repeatedly).'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='If `q ≠ 0`, the p-adic norm of a rational `q` is `p ^ (-(padic_val_rat p q))`.
If `q = 0`, the p-adic norm of `q` is 0.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='If `q ≠ 0`, the p-adic norm of a rational `q` is `p ^ (-(padic_val_rat p q))`.
If `q = 0`, the p-adic norm of `q` is 0.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>322  if hq : q = 0 then by simp [hq]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='dite'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='q'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='hq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 609, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (c : Prop) [h : decidable c] {α : Prop}, (c → α) → (not c → α) → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='lime'><a title='p : nat,
hp : nat.prime p,
q : rat,
hq : @eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)
⊢ @eq.{1} rat (padic_norm p (@has_neg.neg.{0} rat rat.has_neg q)) (padic_norm p q)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>323  else by simp [padic_norm, hq, hp.one_lt]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='padic_norm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 261, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat → rat → rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='not (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_lt.lt.{0} nat nat.has_lt (@has_one.one.{0} nat nat.has_one) p'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='If `q ≠ 0`, the p-adic norm of a rational `q` is `p ^ (-(padic_val_rat p q))`.
If `q = 0`, the p-adic norm of `q` is 0.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='lime'><a title='p : nat,
hp : nat.prime p,
q : rat,
hq : not (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero))
⊢ @eq.{1} rat (padic_norm p (@has_neg.neg.{0} rat rat.has_neg q)) (padic_norm p q)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>324  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
q : rat,
hq : not (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero))
⊢ @eq.{1} rat (padic_norm p (@has_neg.neg.{0} rat rat.has_neg q)) (padic_norm p q)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>325  /--</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>326  If the p-adic norm of `q` is 0, then `q` is 0.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>327  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>328  lemma zero_of_padic_norm_eq_zero {q : ℚ} (h : padic_norm p q = 0) : q = 0 :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='blue'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='padic_norm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='q'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='q'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/rat/basic.lean&#x27;, &#x27;line&#x27;: 46, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;line&#x27;: 261, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='nat → rat → rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='orange'><a title='`rat`, or `ℚ`, is the type of rational numbers. It is defined
 as the set of pairs ⟨n, d⟩ of integers such that `d` is positive and `n` and
 `d` are coprime. This representation is preferred to the quotient
 because without periodic reduction, the numerator and denominator can grow
 exponentially (for example, adding 1/2 to itself repeatedly).'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='If `q ≠ 0`, the p-adic norm of a rational `q` is `p ^ (-(padic_val_rat p q))`.
If `q = 0`, the p-adic norm of `q` is 0.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>329  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
q : rat,
h : @eq.{1} rat (padic_norm p q) (@has_zero.zero.{0} rat rat.has_zero)
⊢ @eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>330    apply by_contradiction, intro hq,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='by_contradiction'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/logic/basic.lean&#x27;, &#x27;line&#x27;: 167, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 122, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {p : Prop} [_inst_1 : decidable p], (not p → false) → p'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='If the current goal is a Pi/forall `∀ x : t, u` (resp. `let x := t in u`) then `intro` puts `x : t` (resp. `x := t`) in the local context. The new subgoal target is `u`.

If the goal is an arrow `t → u`, then it puts `h : t` in the local context and the new goal target is `u`.

If the goal is neither a Pi/forall nor begins with a let binder, the tactic `intro` applies the tactic `whnf` until an introduction can be applied or the goal is not head reducible. In the latter case, the tactic fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='intro'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;id?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
q : rat,
h : @eq.{1} rat (padic_norm p q) (@has_zero.zero.{0} rat rat.has_zero)
⊢ @eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
q : rat,
h : @eq.{1} rat (padic_norm p q) (@has_zero.zero.{0} rat rat.has_zero)
⊢ not (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)) → false'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
q : rat,
h : @eq.{1} rat (padic_norm p q) (@has_zero.zero.{0} rat rat.has_zero),
hq : not (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero))
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>331    unfold padic_norm at h, rw if_neg hq at h,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='blue'><a title='if_neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1411, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 845, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.unfold_config {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.ff, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.ff, beta := bool.tt, eta := bool.ff, proj := bool.ff, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.ff, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {c : Prop} [h : decidable c], not c → ∀ {α : Type} {t e : α}, @eq.{1} α (@ite.{1} c h α t e) e'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='not (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Given defined constants `e₁ ... eₙ`, `unfold e₁ ... eₙ` iteratively unfolds all occurrences in the target of the main goal, using equational lemmas associated with the definitions.

As with `simp`, the `at` modifier can be used to specify locations for the unfolding.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='unfold'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id*&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.unfold_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
q : rat,
h : @eq.{1} rat (padic_norm p q) (@has_zero.zero.{0} rat rat.has_zero),
hq : not (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero))
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
q : rat,
hq : not (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)),
h :
  @eq.{1} rat
    (@ite.{1} (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero))
       (rat.decidable_eq q (@has_zero.zero.{0} rat rat.has_zero))
       rat
       (@has_zero.zero.{0} rat rat.has_zero)
       (@has_pow.pow.{0 0} rat int (@int.has_pow.{0} rat rat.division_ring)
          (@coe.{1 1} nat rat
             (@coe_to_lift.{1 1} nat rat
                (@coe_base.{1 1} nat rat (@nat.cast_coe.{0} rat rat.has_zero rat.has_one rat.has_add)))
             p)
          (@has_neg.neg.{0} int int.has_neg (padic_val_rat p q))))
    (@has_zero.zero.{0} rat rat.has_zero)
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
q : rat,
hq : not (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)),
h :
  @eq.{1} rat
    (@has_pow.pow.{0 0} rat int (@int.has_pow.{0} rat rat.division_ring)
       (@coe.{1 1} nat rat
          (@coe_to_lift.{1 1} nat rat
             (@coe_base.{1 1} nat rat (@nat.cast_coe.{0} rat rat.has_zero rat.has_one rat.has_add)))
          p)
       (@has_neg.neg.{0} int int.has_neg (padic_val_rat p q)))
    (@has_zero.zero.{0} rat rat.has_zero)
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>332    apply absurd h,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='absurd'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 28, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, a → not a → b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{1} rat (@has_pow.pow.{0 0} rat int (@int.has_pow.{0} rat rat.division_ring) (@coe.{1 1} nat rat (@coe_to_lift.{1 1} nat rat (@coe_base.{1 1} nat rat (@nat.cast_coe.{0} rat rat.has_zero rat.has_one rat.has_add))) p) (@has_neg.neg.{0} int int.has_neg (padic_val_rat p q))) (@has_zero.zero.{0} rat rat.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
q : rat,
hq : not (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)),
h :
  @eq.{1} rat
    (@has_pow.pow.{0 0} rat int (@int.has_pow.{0} rat rat.division_ring)
       (@coe.{1 1} nat rat
          (@coe_to_lift.{1 1} nat rat
             (@coe_base.{1 1} nat rat (@nat.cast_coe.{0} rat rat.has_zero rat.has_one rat.has_add)))
          p)
       (@has_neg.neg.{0} int int.has_neg (padic_val_rat p q)))
    (@has_zero.zero.{0} rat rat.has_zero)
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
q : rat,
hq : not (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)),
h :
  @eq.{1} rat
    (@has_pow.pow.{0 0} rat int (@int.has_pow.{0} rat rat.division_ring)
       (@coe.{1 1} nat rat
          (@coe_to_lift.{1 1} nat rat
             (@coe_base.{1 1} nat rat (@nat.cast_coe.{0} rat rat.has_zero rat.has_one rat.has_add)))
          p)
       (@has_neg.neg.{0} int int.has_neg (padic_val_rat p q)))
    (@has_zero.zero.{0} rat rat.has_zero)
⊢ not
    (@eq.{1} rat
       (@has_pow.pow.{0 0} rat int (@int.has_pow.{0} rat rat.division_ring)
          (@coe.{1 1} nat rat
             (@coe_to_lift.{1 1} nat rat
                (@coe_base.{1 1} nat rat (@nat.cast_coe.{0} rat rat.has_zero rat.has_one rat.has_add)))
             p)
          (@has_neg.neg.{0} int int.has_neg (padic_val_rat p q)))
       (@has_zero.zero.{0} rat rat.has_zero))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>333    apply fpow_ne_zero_of_ne_zero,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='fpow_ne_zero_of_ne_zero'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/field_power.lean&#x27;, &#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {K : Type} [_inst_1 : division_ring.{0} K] {a : K}, @ne.{1} K a (@has_zero.zero.{0} K (@no_zero_divisors.to_has_zero.{0} K (@domain.to_no_zero_divisors.{0} K (@division_ring.to_domain.{0} K _inst_1)))) → ∀ (z : int), @ne.{1} K (@has_pow.pow.{0 0} K int (@int.has_pow.{0} K _inst_1) a z) (@has_zero.zero.{0} K (@no_zero_divisors.to_has_zero.{0} K (@domain.to_no_zero_divisors.{0} K (@division_ring.to_domain.{0} K _inst_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
q : rat,
hq : not (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)),
h :
  @eq.{1} rat
    (@has_pow.pow.{0 0} rat int (@int.has_pow.{0} rat rat.division_ring)
       (@coe.{1 1} nat rat
          (@coe_to_lift.{1 1} nat rat
             (@coe_base.{1 1} nat rat (@nat.cast_coe.{0} rat rat.has_zero rat.has_one rat.has_add)))
          p)
       (@has_neg.neg.{0} int int.has_neg (padic_val_rat p q)))
    (@has_zero.zero.{0} rat rat.has_zero)
⊢ not
    (@eq.{1} rat
       (@has_pow.pow.{0 0} rat int (@int.has_pow.{0} rat rat.division_ring)
          (@coe.{1 1} nat rat
             (@coe_to_lift.{1 1} nat rat
                (@coe_base.{1 1} nat rat (@nat.cast_coe.{0} rat rat.has_zero rat.has_one rat.has_add)))
             p)
          (@has_neg.neg.{0} int int.has_neg (padic_val_rat p q)))
       (@has_zero.zero.{0} rat rat.has_zero))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
q : rat,
hq : not (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)),
h :
  @eq.{1} rat
    (@has_pow.pow.{0 0} rat int (@int.has_pow.{0} rat rat.division_ring)
       (@coe.{1 1} nat rat
          (@coe_to_lift.{1 1} nat rat
             (@coe_base.{1 1} nat rat (@nat.cast_coe.{0} rat rat.has_zero rat.has_one rat.has_add)))
          p)
       (@has_neg.neg.{0} int int.has_neg (padic_val_rat p q)))
    (@has_zero.zero.{0} rat rat.has_zero)
⊢ @ne.{1} rat
    (@coe.{1 1} nat rat
       (@coe_to_lift.{1 1} nat rat
          (@coe_base.{1 1} nat rat (@nat.cast_coe.{0} rat rat.has_zero rat.has_one rat.has_add)))
       p)
    (@has_zero.zero.{0} rat
       (@no_zero_divisors.to_has_zero.{0} rat
          (@domain.to_no_zero_divisors.{0} rat (@division_ring.to_domain.{0} rat rat.division_ring))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>334    exact_mod_cast hp.ne_zero</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='hp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/norm_cast.lean&#x27;, &#x27;line&#x27;: 335, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/nat/prime.lean&#x27;, &#x27;line&#x27;: 88, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/norm_cast.lean&#x27;, &#x27;line&#x27;: 335, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat.prime p'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Normalize the goal and the given expression,
then close the goal with exact.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='Normalize the goal and the given expression,
then close the goal with exact.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact_mod_cast'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='exact_mod_cast'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
q : rat,
hq : not (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)),
h :
  @eq.{1} rat
    (@has_pow.pow.{0 0} rat int (@int.has_pow.{0} rat rat.division_ring)
       (@coe.{1 1} nat rat
          (@coe_to_lift.{1 1} nat rat
             (@coe_base.{1 1} nat rat (@nat.cast_coe.{0} rat rat.has_zero rat.has_one rat.has_add)))
          p)
       (@has_neg.neg.{0} int int.has_neg (padic_val_rat p q)))
    (@has_zero.zero.{0} rat rat.has_zero)
⊢ @ne.{1} rat
    (@coe.{1 1} nat rat
       (@coe_to_lift.{1 1} nat rat
          (@coe_base.{1 1} nat rat (@nat.cast_coe.{0} rat rat.has_zero rat.has_one rat.has_add)))
       p)
    (@has_zero.zero.{0} rat
       (@no_zero_divisors.to_has_zero.{0} rat
          (@domain.to_no_zero_divisors.{0} rat (@division_ring.to_domain.{0} rat rat.division_ring))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>335  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>336  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>337  /--</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>338  The p-adic norm is multiplicative.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>339  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>340  @[simp] protected theorem mul (q r : ℚ) : padic_norm p (q*r) = padic_norm p q * padic_norm p r :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='blue'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='padic_norm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='q'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_mul.mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='r'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='padic_norm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='q'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mul.mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='padic_norm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='r'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/rat/basic.lean&#x27;, &#x27;line&#x27;: 46, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 261, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 312, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 261, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 312, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 261, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='nat → rat → rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type} [c : has_mul.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat → rat → rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_mul.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat → rat → rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='orange'><a title='`rat`, or `ℚ`, is the type of rational numbers. It is defined
 as the set of pairs ⟨n, d⟩ of integers such that `d` is positive and `n` and
 `d` are coprime. This representation is preferred to the quotient
 because without periodic reduction, the numerator and denominator can grow
 exponentially (for example, adding 1/2 to itself repeatedly).'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='If `q ≠ 0`, the p-adic norm of a rational `q` is `p ^ (-(padic_val_rat p q))`.
If `q = 0`, the p-adic norm of `q` is 0.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='If `q ≠ 0`, the p-adic norm of a rational `q` is `p ^ (-(padic_val_rat p q))`.
If `q = 0`, the p-adic norm of `q` is 0.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='If `q ≠ 0`, the p-adic norm of a rational `q` is `p ^ (-(padic_val_rat p q))`.
If `q = 0`, the p-adic norm of `q` is 0.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>341  if hq : q = 0 then</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='dite'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='q'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 609, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (c : Prop) [h : decidable c] {α : Prop}, (c → α) → (not c → α) → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>342    by simp [hq]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='hq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='lime'><a title='p : nat,
hp : nat.prime p,
q r : rat,
hq : @eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)
⊢ @eq.{1} rat (padic_norm p (@has_mul.mul.{0} rat rat.has_mul q r))
    (@has_mul.mul.{0} rat rat.has_mul (padic_norm p q) (padic_norm p r))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>343  else if hr : r = 0 then</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='hq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='r'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 609, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='not (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>344    by simp [hr]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='hr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{1} rat r (@has_zero.zero.{0} rat rat.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='lime'><a title='p : nat,
hp : nat.prime p,
q r : rat,
hq : not (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)),
hr : @eq.{1} rat r (@has_zero.zero.{0} rat rat.has_zero)
⊢ @eq.{1} rat (padic_norm p (@has_mul.mul.{0} rat rat.has_mul q r))
    (@has_mul.mul.{0} rat rat.has_mul (padic_norm p q) (padic_norm p r))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>345  else</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>346    have q*r ≠ 0, from mul_ne_zero hq hr,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='q'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_mul.mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='r'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ne'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='mul_ne_zero'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 312, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 97, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/ring.lean&#x27;, &#x27;line&#x27;: 287, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='not (@eq.{1} rat r (@has_zero.zero.{0} rat rat.has_zero))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type} [c : has_mul.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='∀ {α : Type} [_inst_1 : integral_domain.{0} α] {a b : α}, @ne.{1} α a (@has_zero.zero.{0} α (@no_zero_divisors.to_has_zero.{0} α (@integral_domain.to_no_zero_divisors.{0} α _inst_1))) → @ne.{1} α b (@has_zero.zero.{0} α (@no_zero_divisors.to_has_zero.{0} α (@integral_domain.to_no_zero_divisors.{0} α _inst_1))) → @ne.{1} α (@has_mul.mul.{0} α (@no_zero_divisors.to_has_mul.{0} α (@integral_domain.to_no_zero_divisors.{0} α _inst_1)) a b) (@has_zero.zero.{0} α (@no_zero_divisors.to_has_zero.{0} α (@integral_domain.to_no_zero_divisors.{0} α _inst_1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='not (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='not (@eq.{1} rat r (@has_zero.zero.{0} rat rat.has_zero))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>347    have (↑p : ℚ) ≠ 0, by simp [hp.ne_zero],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='coe'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ne'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/coe.lean&#x27;, &#x27;line&#x27;: 67, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/rat/basic.lean&#x27;, &#x27;line&#x27;: 46, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 97, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {a b : Type} [_inst_1 : has_lift_t.{1 1} a b], a → b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@ne.{1} nat p (@has_zero.zero.{0} nat nat.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='`rat`, or `ℚ`, is the type of rational numbers. It is defined
 as the set of pairs ⟨n, d⟩ of integers such that `d` is positive and `n` and
 `d` are coprime. This representation is preferred to the quotient
 because without periodic reduction, the numerator and denominator can grow
 exponentially (for example, adding 1/2 to itself repeatedly).'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='lime'><a title='p : nat,
hp : nat.prime p,
q r : rat,
hq : not (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)),
hr : not (@eq.{1} rat r (@has_zero.zero.{0} rat rat.has_zero)),
this : @ne.{1} rat (@has_mul.mul.{0} rat rat.has_mul q r) (@has_zero.zero.{0} rat rat.has_zero)
⊢ @ne.{1} rat
    (@coe.{1 1} nat rat
       (@coe_to_lift.{1 1} nat rat
          (@coe_base.{1 1} nat rat (@nat.cast_coe.{0} rat rat.has_zero rat.has_one rat.has_add)))
       p)
    (@has_zero.zero.{0} rat rat.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>348    by simp [padic_norm, *, padic_val_rat.mul, fpow_add this]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='padic_norm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='padic_val_rat.mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='fpow_add'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 261, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 147, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/field_power.lean&#x27;, &#x27;line&#x27;: 51, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat → rat → rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (p : nat) [p_prime : nat.prime p] {q r : rat}, @ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero) → @ne.{1} rat r (@has_zero.zero.{0} rat rat.has_zero) → @eq.{1} int (padic_val_rat p (@has_mul.mul.{0} rat rat.has_mul q r)) (@has_add.add.{0} int int.has_add (padic_val_rat p q) (padic_val_rat p r))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {K : Type} [_inst_1 : division_ring.{0} K] {a : K}, @ne.{1} K a (@has_zero.zero.{0} K (@no_zero_divisors.to_has_zero.{0} K (@domain.to_no_zero_divisors.{0} K (@division_ring.to_domain.{0} K _inst_1)))) → ∀ (z1 z2 : int), @eq.{1} K (@has_pow.pow.{0 0} K int (@int.has_pow.{0} K _inst_1) a (@has_add.add.{0} int int.has_add z1 z2)) (@has_mul.mul.{0} K (@no_zero_divisors.to_has_mul.{0} K (@domain.to_no_zero_divisors.{0} K (@division_ring.to_domain.{0} K _inst_1))) (@has_pow.pow.{0 0} K int (@int.has_pow.{0} K _inst_1) a z1) (@has_pow.pow.{0 0} K int (@int.has_pow.{0} K _inst_1) a z2))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@ne.{1} rat (@coe.{1 1} nat rat (@coe_to_lift.{1 1} nat rat (@coe_base.{1 1} nat rat (@nat.cast_coe.{0} rat rat.has_zero rat.has_one rat.has_add))) p) (@has_zero.zero.{0} rat rat.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='If `q ≠ 0`, the p-adic norm of a rational `q` is `p ^ (-(padic_val_rat p q))`.
If `q = 0`, the p-adic norm of `q` is 0.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='A rewrite lemma for `padic_val_rat p (q * r)` with conditions `q ≠ 0`, `r ≠ 0`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='lime'><a title='p : nat,
hp : nat.prime p,
q r : rat,
hq : not (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)),
hr : not (@eq.{1} rat r (@has_zero.zero.{0} rat rat.has_zero)),
this : @ne.{1} rat (@has_mul.mul.{0} rat rat.has_mul q r) (@has_zero.zero.{0} rat rat.has_zero),
this :
  @ne.{1} rat
    (@coe.{1 1} nat rat
       (@coe_to_lift.{1 1} nat rat
          (@coe_base.{1 1} nat rat (@nat.cast_coe.{0} rat rat.has_zero rat.has_one rat.has_add)))
       p)
    (@has_zero.zero.{0} rat rat.has_zero)
⊢ @eq.{1} rat (padic_norm p (@has_mul.mul.{0} rat rat.has_mul q r))
    (@has_mul.mul.{0} rat rat.has_mul (padic_norm p q) (padic_norm p r))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>349  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
q r : rat,
hq : not (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)),
hr : not (@eq.{1} rat r (@has_zero.zero.{0} rat rat.has_zero)),
this : @ne.{1} rat (@has_mul.mul.{0} rat rat.has_mul q r) (@has_zero.zero.{0} rat rat.has_zero),
this :
  @ne.{1} rat
    (@coe.{1 1} nat rat
       (@coe_to_lift.{1 1} nat rat
          (@coe_base.{1 1} nat rat (@nat.cast_coe.{0} rat rat.has_zero rat.has_one rat.has_add)))
       p)
    (@has_zero.zero.{0} rat rat.has_zero)
⊢ @eq.{1} rat (padic_norm p (@has_mul.mul.{0} rat rat.has_mul q r))
    (@has_mul.mul.{0} rat rat.has_mul (padic_norm p q) (padic_norm p r))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>350  /--</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>351  The p-adic norm respects division.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>352  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>353  @[simp] protected theorem div (q r : ℚ) : padic_norm p (q / r) = padic_norm p q / padic_norm p r :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='blue'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='padic_norm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='q'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_div.div'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='r'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='padic_norm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='q'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_div.div'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='padic_norm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='r'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/rat/basic.lean&#x27;, &#x27;line&#x27;: 46, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 261, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 316, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 261, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 316, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 261, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='nat → rat → rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_div.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat → rat → rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_div.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat → rat → rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='orange'><a title='`rat`, or `ℚ`, is the type of rational numbers. It is defined
 as the set of pairs ⟨n, d⟩ of integers such that `d` is positive and `n` and
 `d` are coprime. This representation is preferred to the quotient
 because without periodic reduction, the numerator and denominator can grow
 exponentially (for example, adding 1/2 to itself repeatedly).'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='If `q ≠ 0`, the p-adic norm of a rational `q` is `p ^ (-(padic_val_rat p q))`.
If `q = 0`, the p-adic norm of `q` is 0.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='If `q ≠ 0`, the p-adic norm of a rational `q` is `p ^ (-(padic_val_rat p q))`.
If `q = 0`, the p-adic norm of `q` is 0.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='If `q ≠ 0`, the p-adic norm of a rational `q` is `p ^ (-(padic_val_rat p q))`.
If `q = 0`, the p-adic norm of `q` is 0.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>354  if hr : r = 0 then by simp [hr] else</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='dite'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='r'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='hr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 609, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (c : Prop) [h : decidable c] {α : Prop}, (c → α) → (not c → α) → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{1} rat r (@has_zero.zero.{0} rat rat.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='lime'><a title='p : nat,
hp : nat.prime p,
q r : rat,
hr : @eq.{1} rat r (@has_zero.zero.{0} rat rat.has_zero)
⊢ @eq.{1} rat (padic_norm p (@has_div.div.{0} rat (@division_ring_has_div&#x27;.{0} rat rat.division_ring) q r))
    (@has_div.div.{0} rat (@division_ring_has_div&#x27;.{0} rat rat.division_ring) (padic_norm p q) (padic_norm p r))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>355  eq_div_of_mul_eq _ _ (padic_norm.nonzero _ hr) (by rw [←padic_norm.mul, div_mul_cancel _ hr])</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='hr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='padic_norm.nonzero'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='hr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='padic_norm.mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='div_mul_cancel'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='hr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/field.lean&#x27;, &#x27;line&#x27;: 213, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 311, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 340, &#x27;column&#x27;: 26}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/field.lean&#x27;, &#x27;line&#x27;: 178, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='not (@eq.{1} rat r (@has_zero.zero.{0} rat rat.has_zero))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='∀ (p : nat) [hp : nat.prime p] {q : rat}, @ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero) → @ne.{1} rat (padic_norm p q) (@has_zero.zero.{0} rat rat.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='not (@eq.{1} rat r (@has_zero.zero.{0} rat rat.has_zero))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (p : nat) [hp : nat.prime p] (q r : rat), @eq.{1} rat (padic_norm p (@has_mul.mul.{0} rat rat.has_mul q r)) (@has_mul.mul.{0} rat rat.has_mul (padic_norm p q) (padic_norm p r))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : division_ring.{0} α] (a : α) {b : α}, @ne.{1} α b (@has_zero.zero.{0} α (@zero_ne_one_class.to_has_zero.{0} α (@division_ring.to_zero_ne_one_class.{0} α _inst_1))) → @eq.{1} α (@has_mul.mul.{0} α (@mul_zero_class.to_has_mul.{0} α (@semiring.to_mul_zero_class.{0} α (@ring.to_semiring.{0} α (@division_ring.to_ring.{0} α _inst_1)))) (@has_div.div.{0} α (@division_ring_has_div.{0} α _inst_1 _inst_1) a b) b) a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='not (@eq.{1} rat r (@has_zero.zero.{0} rat rat.has_zero))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='orange'><a title='If `q ≠ 0`, then `padic_norm p q ≠ 0`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The p-adic norm is multiplicative.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                  </code><font color='lime'><a title='p : nat,
hp : nat.prime p,
q r : rat,
hr : not (@eq.{1} rat r (@has_zero.zero.{0} rat rat.has_zero))
⊢ @eq.{1} rat
    (@has_mul.mul.{0} rat
       (@mul_zero_class.to_has_mul.{0} rat
          (@semiring.to_mul_zero_class.{0} rat
             (@ring.to_semiring.{0} rat (@division_ring.to_ring.{0} rat rat.division_ring))))
       (padic_norm p (@has_div.div.{0} rat (@division_ring_has_div&#x27;.{0} rat rat.division_ring) q r))
       (padic_norm p r))
    (padic_norm p q)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
q r : rat,
hr : not (@eq.{1} rat r (@has_zero.zero.{0} rat rat.has_zero))
⊢ @eq.{1} rat
    (padic_norm p
       (@has_mul.mul.{0} rat rat.has_mul (@has_div.div.{0} rat (@division_ring_has_div&#x27;.{0} rat rat.division_ring) q r)
          r))
    (padic_norm p q)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>356  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>357  /--</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>358  The p-adic norm of an integer is at most 1.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>359  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>360  protected theorem of_int (z : ℤ) : padic_norm p ↑z ≤ 1 :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='blue'><a title='int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='padic_norm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='coe'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_le.le'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/int/basic.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 261, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/coe.lean&#x27;, &#x27;line&#x27;: 67, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 319, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='nat → rat → rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {a b : Type} [_inst_1 : has_lift_t.{1 1} a b], a → b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_le.{0} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='orange'><a title='If `q ≠ 0`, the p-adic norm of a rational `q` is `p ^ (-(padic_val_rat p q))`.
If `q = 0`, the p-adic norm of `q` is 0.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>361  if hz : z = 0 then by simp [hz] else</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='dite'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='hz'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 609, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (c : Prop) [h : decidable c] {α : Prop}, (c → α) → (not c → α) → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{1} int z (@has_zero.zero.{0} int int.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='lime'><a title='p : nat,
hp : nat.prime p,
z : int,
hz : @eq.{1} int z (@has_zero.zero.{0} int int.has_zero)
⊢ @has_le.le.{0} rat rat.has_le
    (padic_norm p
       (@coe.{1 1} int rat
          (@coe_to_lift.{1 1} int rat
             (@coe_base.{1 1} int rat (@int.cast_coe.{0} rat rat.has_neg rat.has_zero rat.has_one rat.has_add)))
          z))
    (@has_one.one.{0} rat rat.has_one)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>362  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
z : int,
hz : not (@eq.{1} int z (@has_zero.zero.{0} int int.has_zero))
⊢ @has_le.le.{0} rat rat.has_le
    (padic_norm p
       (@coe.{1 1} int rat
          (@coe_to_lift.{1 1} int rat
             (@coe_base.{1 1} int rat (@int.cast_coe.{0} rat rat.has_neg rat.has_zero rat.has_one rat.has_add)))
          z))
    (@has_one.one.{0} rat rat.has_one)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>363    unfold padic_norm,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1411, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.unfold_config {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.ff, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.ff, beta := bool.tt, eta := bool.ff, proj := bool.ff, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.ff, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Given defined constants `e₁ ... eₙ`, `unfold e₁ ... eₙ` iteratively unfolds all occurrences in the target of the main goal, using equational lemmas associated with the definitions.

As with `simp`, the `at` modifier can be used to specify locations for the unfolding.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='unfold'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id*&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.unfold_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
z : int,
hz : not (@eq.{1} int z (@has_zero.zero.{0} int int.has_zero))
⊢ @has_le.le.{0} rat rat.has_le
    (padic_norm p
       (@coe.{1 1} int rat
          (@coe_to_lift.{1 1} int rat
             (@coe_base.{1 1} int rat (@int.cast_coe.{0} rat rat.has_neg rat.has_zero rat.has_one rat.has_add)))
          z))
    (@has_one.one.{0} rat rat.has_one)'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
z : int,
hz : not (@eq.{1} int z (@has_zero.zero.{0} int int.has_zero))
⊢ @has_le.le.{0} rat rat.has_le
    (@ite.{1}
       (@eq.{1} rat
          (@coe.{1 1} int rat
             (@coe_to_lift.{1 1} int rat
                (@coe_base.{1 1} int rat (@int.cast_coe.{0} rat rat.has_neg rat.has_zero rat.has_one rat.has_add)))
             z)
          (@has_zero.zero.{0} rat rat.has_zero))
       (rat.decidable_eq
          (@coe.{1 1} int rat
             (@coe_to_lift.{1 1} int rat
                (@coe_base.{1 1} int rat (@int.cast_coe.{0} rat rat.has_neg rat.has_zero rat.has_one rat.has_add)))
             z)
          (@has_zero.zero.{0} rat rat.has_zero))
       rat
       (@has_zero.zero.{0} rat rat.has_zero)
       (@has_pow.pow.{0 0} rat int (@int.has_pow.{0} rat rat.division_ring)
          (@coe.{1 1} nat rat
             (@coe_to_lift.{1 1} nat rat
                (@coe_base.{1 1} nat rat (@nat.cast_coe.{0} rat rat.has_zero rat.has_one rat.has_add)))
             p)
          (@has_neg.neg.{0} int int.has_neg
             (padic_val_rat p
                (@coe.{1 1} int rat
                   (@coe_to_lift.{1 1} int rat
                      (@coe_base.{1 1} int rat
                         (@int.cast_coe.{0} rat rat.has_neg rat.has_zero rat.has_one rat.has_add)))
                   z)))))
    (@has_one.one.{0} rat rat.has_one)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>364    rw [if_neg _],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='if_neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 845, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {c : Prop} [h : decidable c], not c → ∀ {α : Type} {t e : α}, @eq.{1} α (@ite.{1} c h α t e) e'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
z : int,
hz : not (@eq.{1} int z (@has_zero.zero.{0} int int.has_zero))
⊢ @has_le.le.{0} rat rat.has_le
    (@ite.{1}
       (@eq.{1} rat
          (@coe.{1 1} int rat
             (@coe_to_lift.{1 1} int rat
                (@coe_base.{1 1} int rat (@int.cast_coe.{0} rat rat.has_neg rat.has_zero rat.has_one rat.has_add)))
             z)
          (@has_zero.zero.{0} rat rat.has_zero))
       (rat.decidable_eq
          (@coe.{1 1} int rat
             (@coe_to_lift.{1 1} int rat
                (@coe_base.{1 1} int rat (@int.cast_coe.{0} rat rat.has_neg rat.has_zero rat.has_one rat.has_add)))
             z)
          (@has_zero.zero.{0} rat rat.has_zero))
       rat
       (@has_zero.zero.{0} rat rat.has_zero)
       (@has_pow.pow.{0 0} rat int (@int.has_pow.{0} rat rat.division_ring)
          (@coe.{1 1} nat rat
             (@coe_to_lift.{1 1} nat rat
                (@coe_base.{1 1} nat rat (@nat.cast_coe.{0} rat rat.has_zero rat.has_one rat.has_add)))
             p)
          (@has_neg.neg.{0} int int.has_neg
             (padic_val_rat p
                (@coe.{1 1} int rat
                   (@coe_to_lift.{1 1} int rat
                      (@coe_base.{1 1} int rat
                         (@int.cast_coe.{0} rat rat.has_neg rat.has_zero rat.has_one rat.has_add)))
                   z)))))
    (@has_one.one.{0} rat rat.has_one)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
p : nat,
hp : nat.prime p,
z : int,
hz : not (@eq.{1} int z (@has_zero.zero.{0} int int.has_zero))
⊢ @has_le.le.{0} rat rat.has_le
    (@has_pow.pow.{0 0} rat int (@int.has_pow.{0} rat rat.division_ring)
       (@coe.{1 1} nat rat
          (@coe_to_lift.{1 1} nat rat
             (@coe_base.{1 1} nat rat (@nat.cast_coe.{0} rat rat.has_zero rat.has_one rat.has_add)))
          p)
       (@has_neg.neg.{0} int int.has_neg
          (padic_val_rat p
             (@coe.{1 1} int rat
                (@coe_to_lift.{1 1} int rat
                   (@coe_base.{1 1} int rat (@int.cast_coe.{0} rat rat.has_neg rat.has_zero rat.has_one rat.has_add)))
                z))))
    (@has_one.one.{0} rat rat.has_one)

p : nat,
hp : nat.prime p,
z : int,
hz : not (@eq.{1} int z (@has_zero.zero.{0} int int.has_zero))
⊢ not
    (@eq.{1} rat
       (@coe.{1 1} int rat
          (@coe_to_lift.{1 1} int rat
             (@coe_base.{1 1} int rat (@int.cast_coe.{0} rat rat.has_neg rat.has_zero rat.has_one rat.has_add)))
          z)
       (@has_zero.zero.{0} rat rat.has_zero))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>365    { refine fpow_le_one_of_nonpos _ _,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='fpow_le_one_of_nonpos'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/field_power.lean&#x27;, &#x27;line&#x27;: 162, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {K : Type} [_inst_1 : discrete_linear_ordered_field.{0} K] {p : K}, @has_le.le.{0} K (@preorder.to_has_le.{0} K (@partial_order.to_preorder.{0} K (@ordered_comm_monoid.to_partial_order.{0} K (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} K (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} K (@ordered_ring.to_ordered_semiring.{0} K (@linear_ordered_ring.to_ordered_ring.{0} K (@linear_ordered_field.to_linear_ordered_ring.{0} K (@discrete_linear_ordered_field.to_linear_ordered_field.{0} K _inst_1))))))))) (@has_one.one.{0} K (@zero_ne_one_class.to_has_one.{0} K (@domain.to_zero_ne_one_class.{0} K (@division_ring.to_domain.{0} K (@field.to_division_ring.{0} K (@linear_ordered_field.to_field.{0} K (@discrete_linear_ordered_field.to_linear_ordered_field.{0} K _inst_1))))))) p → ∀ {z : int}, @has_le.le.{0} int int.has_le z (@has_zero.zero.{0} int int.has_zero) → @has_le.le.{0} K (@preorder.to_has_le.{0} K (@partial_order.to_preorder.{0} K (@ordered_comm_monoid.to_partial_order.{0} K (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} K (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} K (@ordered_ring.to_ordered_semiring.{0} K (@linear_ordered_ring.to_ordered_ring.{0} K (@linear_ordered_field.to_linear_ordered_ring.{0} K (@discrete_linear_ordered_field.to_linear_ordered_field.{0} K _inst_1))))))))) (@has_pow.pow.{0 0} K int (@int.has_pow.{0} K (@field.to_division_ring.{0} K (@linear_ordered_field.to_field.{0} K (@discrete_linear_ordered_field.to_linear_ordered_field.{0} K _inst_1)))) p z) (@has_one.one.{0} K (@zero_ne_one_class.to_has_one.{0} K (@domain.to_zero_ne_one_class.{0} K (@division_ring.to_domain.{0} K (@field.to_division_ring.{0} K (@linear_ordered_field.to_field.{0} K (@discrete_linear_ordered_field.to_linear_ordered_field.{0} K _inst_1)))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
p : nat,
hp : nat.prime p,
z : int,
hz : not (@eq.{1} int z (@has_zero.zero.{0} int int.has_zero))
⊢ @has_le.le.{0} rat rat.has_le
    (@has_pow.pow.{0 0} rat int (@int.has_pow.{0} rat rat.division_ring)
       (@coe.{1 1} nat rat
          (@coe_to_lift.{1 1} nat rat
             (@coe_base.{1 1} nat rat (@nat.cast_coe.{0} rat rat.has_zero rat.has_one rat.has_add)))
          p)
       (@has_neg.neg.{0} int int.has_neg
          (padic_val_rat p
             (@coe.{1 1} int rat
                (@coe_to_lift.{1 1} int rat
                   (@coe_base.{1 1} int rat (@int.cast_coe.{0} rat rat.has_neg rat.has_zero rat.has_one rat.has_add)))
                z))))
    (@has_one.one.{0} rat rat.has_one)

p : nat,
hp : nat.prime p,
z : int,
hz : not (@eq.{1} int z (@has_zero.zero.{0} int int.has_zero))
⊢ not
    (@eq.{1} rat
       (@coe.{1 1} int rat
          (@coe_to_lift.{1 1} int rat
             (@coe_base.{1 1} int rat (@int.cast_coe.{0} rat rat.has_neg rat.has_zero rat.has_one rat.has_add)))
          z)
       (@has_zero.zero.{0} rat rat.has_zero))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
z : int,
hz : not (@eq.{1} int z (@has_zero.zero.{0} int int.has_zero))
⊢ @has_le.le.{0} rat rat.has_le
    (@has_pow.pow.{0 0} rat int (@int.has_pow.{0} rat rat.division_ring)
       (@coe.{1 1} nat rat
          (@coe_to_lift.{1 1} nat rat
             (@coe_base.{1 1} nat rat (@nat.cast_coe.{0} rat rat.has_zero rat.has_one rat.has_add)))
          p)
       (@has_neg.neg.{0} int int.has_neg
          (padic_val_rat p
             (@coe.{1 1} int rat
                (@coe_to_lift.{1 1} int rat
                   (@coe_base.{1 1} int rat (@int.cast_coe.{0} rat rat.has_neg rat.has_zero rat.has_one rat.has_add)))
                z))))
    (@has_one.one.{0} rat rat.has_one)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
p : nat,
hp : nat.prime p,
z : int,
hz : not (@eq.{1} int z (@has_zero.zero.{0} int int.has_zero))
⊢ @has_le.le.{0} rat
    (@preorder.to_has_le.{0} rat
       (@partial_order.to_preorder.{0} rat
          (@ordered_comm_monoid.to_partial_order.{0} rat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} rat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} rat
                   (@ordered_ring.to_ordered_semiring.{0} rat
                      (@linear_ordered_ring.to_ordered_ring.{0} rat
                         (@linear_ordered_field.to_linear_ordered_ring.{0} rat
                            (@discrete_linear_ordered_field.to_linear_ordered_field.{0} rat
                               rat.discrete_linear_ordered_field)))))))))
    (@has_one.one.{0} rat
       (@zero_ne_one_class.to_has_one.{0} rat
          (@domain.to_zero_ne_one_class.{0} rat
             (@division_ring.to_domain.{0} rat
                (@field.to_division_ring.{0} rat
                   (@linear_ordered_field.to_field.{0} rat
                      (@discrete_linear_ordered_field.to_linear_ordered_field.{0} rat
                         rat.discrete_linear_ordered_field)))))))
    (@coe.{1 1} nat rat
       (@coe_to_lift.{1 1} nat rat
          (@coe_base.{1 1} nat rat (@nat.cast_coe.{0} rat rat.has_zero rat.has_one rat.has_add)))
       p)

p : nat,
hp : nat.prime p,
z : int,
hz : not (@eq.{1} int z (@has_zero.zero.{0} int int.has_zero))
⊢ @has_le.le.{0} int int.has_le
    (@has_neg.neg.{0} int int.has_neg
       (padic_val_rat p
          (@coe.{1 1} int rat
             (@coe_to_lift.{1 1} int rat
                (@coe_base.{1 1} int rat (@int.cast_coe.{0} rat rat.has_neg rat.has_zero rat.has_one rat.has_add)))
             z)))
    (@has_zero.zero.{0} int int.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>366      { exact_mod_cast le_of_lt hp.one_lt, },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='blue'><a title='le_of_lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/norm_cast.lean&#x27;, &#x27;line&#x27;: 335, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 99, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/norm_cast.lean&#x27;, &#x27;line&#x27;: 335, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/nat/prime.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : preorder.{0} α] {a b : α}, @has_lt.lt.{0} α (@preorder.to_has_lt.{0} α _inst_1) a b → @has_le.le.{0} α (@preorder.to_has_le.{0} α _inst_1) a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat.prime p'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='Normalize the goal and the given expression,
then close the goal with exact.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='Normalize the goal and the given expression,
then close the goal with exact.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='exact_mod_cast'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='exact_mod_cast'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
p : nat,
hp : nat.prime p,
z : int,
hz : not (@eq.{1} int z (@has_zero.zero.{0} int int.has_zero))
⊢ @has_le.le.{0} rat
    (@preorder.to_has_le.{0} rat
       (@partial_order.to_preorder.{0} rat
          (@ordered_comm_monoid.to_partial_order.{0} rat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} rat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} rat
                   (@ordered_ring.to_ordered_semiring.{0} rat
                      (@linear_ordered_ring.to_ordered_ring.{0} rat
                         (@linear_ordered_field.to_linear_ordered_ring.{0} rat
                            (@discrete_linear_ordered_field.to_linear_ordered_field.{0} rat
                               rat.discrete_linear_ordered_field)))))))))
    (@has_one.one.{0} rat
       (@zero_ne_one_class.to_has_one.{0} rat
          (@domain.to_zero_ne_one_class.{0} rat
             (@division_ring.to_domain.{0} rat
                (@field.to_division_ring.{0} rat
                   (@linear_ordered_field.to_field.{0} rat
                      (@discrete_linear_ordered_field.to_linear_ordered_field.{0} rat
                         rat.discrete_linear_ordered_field)))))))
    (@coe.{1 1} nat rat
       (@coe_to_lift.{1 1} nat rat
          (@coe_base.{1 1} nat rat (@nat.cast_coe.{0} rat rat.has_zero rat.has_one rat.has_add)))
       p)

p : nat,
hp : nat.prime p,
z : int,
hz : not (@eq.{1} int z (@has_zero.zero.{0} int int.has_zero))
⊢ @has_le.le.{0} int int.has_le
    (@has_neg.neg.{0} int int.has_neg
       (padic_val_rat p
          (@coe.{1 1} int rat
             (@coe_to_lift.{1 1} int rat
                (@coe_base.{1 1} int rat (@int.cast_coe.{0} rat rat.has_neg rat.has_zero rat.has_one rat.has_add)))
             z)))
    (@has_zero.zero.{0} int int.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
z : int,
hz : not (@eq.{1} int z (@has_zero.zero.{0} int int.has_zero))
⊢ @has_le.le.{0} rat
    (@preorder.to_has_le.{0} rat
       (@partial_order.to_preorder.{0} rat
          (@ordered_comm_monoid.to_partial_order.{0} rat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} rat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} rat
                   (@ordered_ring.to_ordered_semiring.{0} rat
                      (@linear_ordered_ring.to_ordered_ring.{0} rat
                         (@linear_ordered_field.to_linear_ordered_ring.{0} rat
                            (@discrete_linear_ordered_field.to_linear_ordered_field.{0} rat
                               rat.discrete_linear_ordered_field)))))))))
    (@has_one.one.{0} rat
       (@zero_ne_one_class.to_has_one.{0} rat
          (@domain.to_zero_ne_one_class.{0} rat
             (@division_ring.to_domain.{0} rat
                (@field.to_division_ring.{0} rat
                   (@linear_ordered_field.to_field.{0} rat
                      (@discrete_linear_ordered_field.to_linear_ordered_field.{0} rat
                         rat.discrete_linear_ordered_field)))))))
    (@coe.{1 1} nat rat
       (@coe_to_lift.{1 1} nat rat
          (@coe_base.{1 1} nat rat (@nat.cast_coe.{0} rat rat.has_zero rat.has_one rat.has_add)))
       p)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
z : int,
hz : not (@eq.{1} int z (@has_zero.zero.{0} int int.has_zero))
⊢ @has_le.le.{0} int int.has_le
    (@has_neg.neg.{0} int int.has_neg
       (padic_val_rat p
          (@coe.{1 1} int rat
             (@coe_to_lift.{1 1} int rat
                (@coe_base.{1 1} int rat (@int.cast_coe.{0} rat rat.has_neg rat.has_zero rat.has_one rat.has_add)))
             z)))
    (@has_zero.zero.{0} int int.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>367      { rw [padic_val_rat_of_int _ hp.ne_one hz, neg_nonpos],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='padic_val_rat.padic_val_rat_of_int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='hp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hz'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='neg_nonpos'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 111, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/nat/prime.lean&#x27;, &#x27;line&#x27;: 42, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/ordered_group.lean&#x27;, &#x27;line&#x27;: 520, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {p : nat} (z : int) (hp : @ne.{1} nat p (@has_one.one.{0} nat nat.has_one)) (hz : @ne.{1} int z (@has_zero.zero.{0} int int.has_zero)), @eq.{1} int (padic_val_rat p (@coe.{1 1} int rat (@coe_to_lift.{1 1} int rat (@coe_base.{1 1} int rat (@int.cast_coe.{0} rat rat.has_neg rat.has_zero rat.has_one rat.has_add))) z)) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (@roption.get.{0} nat (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p) z) (@iff.mpr (@multiplicity.finite.{0} int int.comm_semiring (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p) z) (and (@ne.{1} nat (int.nat_abs (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)) (@has_one.one.{0} nat nat.has_one)) (@ne.{1} int z (@has_zero.zero.{0} int int.has_zero))) (@multiplicity.finite_int_iff (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p) z) (@and.intro (@ne.{1} nat (int.nat_abs (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)) (@has_one.one.{0} nat nat.has_one)) (@ne.{1} int z (@has_zero.zero.{0} int int.has_zero)) hp hz))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat.prime p'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='not (@eq.{1} int z (@has_zero.zero.{0} int int.has_zero))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : ordered_comm_group.{0} α] {a : α}, iff (@has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@ordered_comm_monoid.to_partial_order.{0} α (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} α (@ordered_comm_group.to_ordered_cancel_comm_monoid.{0} α _inst_1))))) (@has_neg.neg.{0} α (@add_group.to_has_neg.{0} α (@add_comm_group.to_add_group.{0} α (@ordered_comm_group.to_add_comm_group.{0} α _inst_1))) a) (@has_zero.zero.{0} α (@add_monoid.to_has_zero.{0} α (@add_group.to_add_monoid.{0} α (@add_comm_group.to_add_group.{0} α (@ordered_comm_group.to_add_comm_group.{0} α _inst_1)))))) (@has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@ordered_comm_monoid.to_partial_order.{0} α (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} α (@ordered_comm_group.to_ordered_cancel_comm_monoid.{0} α _inst_1))))) (@has_zero.zero.{0} α (@add_monoid.to_has_zero.{0} α (@add_group.to_add_monoid.{0} α (@add_comm_group.to_add_group.{0} α (@ordered_comm_group.to_add_comm_group.{0} α _inst_1))))) a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The p-adic value of an integer `z ≠ 0` is the multiplicity of `p` in `z`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
z : int,
hz : not (@eq.{1} int z (@has_zero.zero.{0} int int.has_zero))
⊢ @has_le.le.{0} int int.has_le
    (@has_neg.neg.{0} int int.has_neg
       (padic_val_rat p
          (@coe.{1 1} int rat
             (@coe_to_lift.{1 1} int rat
                (@coe_base.{1 1} int rat (@int.cast_coe.{0} rat rat.has_neg rat.has_zero rat.has_one rat.has_add)))
             z)))
    (@has_zero.zero.{0} int int.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
z : int,
hz : not (@eq.{1} int z (@has_zero.zero.{0} int int.has_zero))
⊢ @has_le.le.{0} int int.has_le
    (@has_neg.neg.{0} int int.has_neg
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
          (@roption.get.{0} nat
             (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                z)
             (@iff.mpr
                (@multiplicity.finite.{0} int int.comm_semiring
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   z)
                (and
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int z (@has_zero.zero.{0} int int.has_zero)))
                (@multiplicity.finite_int_iff
                   (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                   z)
                (@and.intro
                   (@ne.{1} nat
                      (int.nat_abs
                         (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                      (@has_one.one.{0} nat nat.has_one))
                   (@ne.{1} int z (@has_zero.zero.{0} int int.has_zero))
                   (@nat.prime.ne_one p hp)
                   hz)))))
    (@has_zero.zero.{0} int int.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
z : int,
hz : not (@eq.{1} int z (@has_zero.zero.{0} int int.has_zero))
⊢ @has_le.le.{0} int
    (@preorder.to_has_le.{0} int
       (@partial_order.to_preorder.{0} int
          (@ordered_comm_monoid.to_partial_order.{0} int
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} int
                (@ordered_comm_group.to_ordered_cancel_comm_monoid.{0} int
                   (@ordered_ring.to_ordered_comm_group.{0} int
                      (@linear_ordered_ring.to_ordered_ring.{0} int
                         (@linear_ordered_comm_ring.to_linear_ordered_ring.{0} int
                            (@decidable_linear_ordered_comm_ring.to_linear_ordered_comm_ring.{0} int
                               int.decidable_linear_ordered_comm_ring)))))))))
    (@has_zero.zero.{0} int
       (@add_monoid.to_has_zero.{0} int
          (@add_group.to_add_monoid.{0} int
             (@add_comm_group.to_add_group.{0} int
                (@ordered_comm_group.to_add_comm_group.{0} int
                   (@ordered_ring.to_ordered_comm_group.{0} int
                      (@linear_ordered_ring.to_ordered_ring.{0} int
                         (@linear_ordered_comm_ring.to_linear_ordered_ring.{0} int
                            (@decidable_linear_ordered_comm_ring.to_linear_ordered_comm_ring.{0} int
                               int.decidable_linear_ordered_comm_ring)))))))))
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
       (@roption.get.{0} nat
          (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
             z)
          (@iff.mpr
             (@multiplicity.finite.{0} int int.comm_semiring
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                z)
             (and
                (@ne.{1} nat
                   (int.nat_abs
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                   (@has_one.one.{0} nat nat.has_one))
                (@ne.{1} int z (@has_zero.zero.{0} int int.has_zero)))
             (@multiplicity.finite_int_iff
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                z)
             (@and.intro
                (@ne.{1} nat
                   (int.nat_abs
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                   (@has_one.one.{0} nat nat.has_one))
                (@ne.{1} int z (@has_zero.zero.{0} int int.has_zero))
                (@nat.prime.ne_one p hp)
                hz))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>368        norm_cast, simp }},</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/norm_cast.lean&#x27;, &#x27;line&#x27;: 305, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='Normalize casts at the given locations by moving them &quot;upwards&quot;.
As opposed to simp, norm_cast can be used without necessarily
closing the goal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='norm_cast'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
z : int,
hz : not (@eq.{1} int z (@has_zero.zero.{0} int int.has_zero))
⊢ @has_le.le.{0} int
    (@preorder.to_has_le.{0} int
       (@partial_order.to_preorder.{0} int
          (@ordered_comm_monoid.to_partial_order.{0} int
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} int
                (@ordered_comm_group.to_ordered_cancel_comm_monoid.{0} int
                   (@ordered_ring.to_ordered_comm_group.{0} int
                      (@linear_ordered_ring.to_ordered_ring.{0} int
                         (@linear_ordered_comm_ring.to_linear_ordered_ring.{0} int
                            (@decidable_linear_ordered_comm_ring.to_linear_ordered_comm_ring.{0} int
                               int.decidable_linear_ordered_comm_ring)))))))))
    (@has_zero.zero.{0} int
       (@add_monoid.to_has_zero.{0} int
          (@add_group.to_add_monoid.{0} int
             (@add_comm_group.to_add_group.{0} int
                (@ordered_comm_group.to_add_comm_group.{0} int
                   (@ordered_ring.to_ordered_comm_group.{0} int
                      (@linear_ordered_ring.to_ordered_ring.{0} int
                         (@linear_ordered_comm_ring.to_linear_ordered_ring.{0} int
                            (@decidable_linear_ordered_comm_ring.to_linear_ordered_comm_ring.{0} int
                               int.decidable_linear_ordered_comm_ring)))))))))
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
       (@roption.get.{0} nat
          (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
             z)
          (@iff.mpr
             (@multiplicity.finite.{0} int int.comm_semiring
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                z)
             (and
                (@ne.{1} nat
                   (int.nat_abs
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                   (@has_one.one.{0} nat nat.has_one))
                (@ne.{1} int z (@has_zero.zero.{0} int int.has_zero)))
             (@multiplicity.finite_int_iff
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                z)
             (@and.intro
                (@ne.{1} nat
                   (int.nat_abs
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                   (@has_one.one.{0} nat nat.has_one))
                (@ne.{1} int z (@has_zero.zero.{0} int int.has_zero))
                (@nat.prime.ne_one p hp)
                hz))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
z : int,
hz : not (@eq.{1} int z (@has_zero.zero.{0} int int.has_zero))
⊢ @has_le.le.{0} nat nat.has_le (@has_zero.zero.{0} nat nat.has_zero)
    (@roption.get.{0} nat
       (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
          z)
       (@iff.mpr
          (@multiplicity.finite.{0} int int.comm_semiring
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
             z)
          (and
             (@ne.{1} nat
                (int.nat_abs (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                (@has_one.one.{0} nat nat.has_one))
             (@ne.{1} int z (@has_zero.zero.{0} int int.has_zero)))
          (@multiplicity.finite_int_iff
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
             z)
          (@and.intro
             (@ne.{1} nat
                (int.nat_abs (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                (@has_one.one.{0} nat nat.has_one))
             (@ne.{1} int z (@has_zero.zero.{0} int int.has_zero))
             (@nat.prime.ne_one p hp)
             hz)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
z : int,
hz : not (@eq.{1} int z (@has_zero.zero.{0} int int.has_zero))
⊢ not
    (@eq.{1} rat
       (@coe.{1 1} int rat
          (@coe_to_lift.{1 1} int rat
             (@coe_base.{1 1} int rat (@int.cast_coe.{0} rat rat.has_neg rat.has_zero rat.has_one rat.has_add)))
          z)
       (@has_zero.zero.{0} rat rat.has_zero))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>369    exact_mod_cast hz</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='hz'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/norm_cast.lean&#x27;, &#x27;line&#x27;: 335, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/norm_cast.lean&#x27;, &#x27;line&#x27;: 335, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='not (@eq.{1} int z (@has_zero.zero.{0} int int.has_zero))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Normalize the goal and the given expression,
then close the goal with exact.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Normalize the goal and the given expression,
then close the goal with exact.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact_mod_cast'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact_mod_cast'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
z : int,
hz : not (@eq.{1} int z (@has_zero.zero.{0} int int.has_zero))
⊢ not
    (@eq.{1} rat
       (@coe.{1 1} int rat
          (@coe_to_lift.{1 1} int rat
             (@coe_base.{1 1} int rat (@int.cast_coe.{0} rat rat.has_neg rat.has_zero rat.has_one rat.has_add)))
          z)
       (@has_zero.zero.{0} rat rat.has_zero))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>370  end</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='hz'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='not (@eq.{1} int z (@has_zero.zero.{0} int int.has_zero))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>371  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>372  private lemma nonarchimedean_aux {q r : ℚ} (h : padic_val_rat p q ≤ padic_val_rat p r) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='blue'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='padic_val_rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='q'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_le.le'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='padic_val_rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='r'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/rat/basic.lean&#x27;, &#x27;line&#x27;: 46, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;line&#x27;: 62, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 319, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 62, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='nat → rat → int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_le.{0} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat → rat → int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='orange'><a title='`rat`, or `ℚ`, is the type of rational numbers. It is defined
 as the set of pairs ⟨n, d⟩ of integers such that `d` is positive and `n` and
 `d` are coprime. This representation is preferred to the quotient
 because without periodic reduction, the numerator and denominator can grow
 exponentially (for example, adding 1/2 to itself repeatedly).'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='For `p ≠ 1`, the p-adic valuation of an integer `z ≠ 0` is the largest natural number `n` such that
p^n divides z.

`padic_val_rat` defines the valuation of a rational `q` to be the valuation of `q.num` minus the
valuation of `q.denom`.
If `q = 0` or `p = 1`, then `padic_val_rat p q` defaults to 0.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='For `p ≠ 1`, the p-adic valuation of an integer `z ≠ 0` is the largest natural number `n` such that
p^n divides z.

`padic_val_rat` defines the valuation of a rational `q` to be the valuation of `q.num` minus the
valuation of `q.denom`.
If `q = 0` or `p = 1`, then `padic_val_rat p q` defaults to 0.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>373    padic_norm p (q + r) ≤ max (padic_norm p q) (padic_norm p r) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='padic_norm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='q'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='r'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_le.le'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='max'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='padic_norm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='q'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='padic_norm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='r'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 261, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 319, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/functions.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 11}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 261, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;line&#x27;: 261, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='nat → rat → rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_add.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type} [c : has_le.{0} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [_inst_1 : decidable_linear_order.{u} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='nat → rat → rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='nat → rat → rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='If `q ≠ 0`, the p-adic norm of a rational `q` is `p ^ (-(padic_val_rat p q))`.
If `q = 0`, the p-adic norm of `q` is 0.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='If `q ≠ 0`, the p-adic norm of a rational `q` is `p ^ (-(padic_val_rat p q))`.
If `q = 0`, the p-adic norm of `q` is 0.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='If `q ≠ 0`, the p-adic norm of a rational `q` is `p ^ (-(padic_val_rat p q))`.
If `q = 0`, the p-adic norm of `q` is 0.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>374  have hnqp : padic_norm p q ≥ 0, from padic_norm.nonneg _ _,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='padic_norm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='q'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ge'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='padic_norm.nonneg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;line&#x27;: 261, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 371, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;line&#x27;: 280, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='nat → rat → rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [_inst_1 : has_le.{0} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='∀ (p : nat) (q : rat), @has_le.le.{0} rat rat.has_le (@has_zero.zero.{0} rat rat.has_zero) (padic_norm p q)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='If `q ≠ 0`, the p-adic norm of a rational `q` is `p ^ (-(padic_val_rat p q))`.
If `q = 0`, the p-adic norm of `q` is 0.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='The p-adic norm is nonnegative.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>375  have hnrp : padic_norm p r ≥ 0, from padic_norm.nonneg _ _,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='padic_norm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='r'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ge'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='padic_norm.nonneg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;line&#x27;: 261, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 371, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;line&#x27;: 280, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='nat → rat → rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [_inst_1 : has_le.{0} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='∀ (p : nat) (q : rat), @has_le.le.{0} rat rat.has_le (@has_zero.zero.{0} rat rat.has_zero) (padic_norm p q)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='If `q ≠ 0`, the p-adic norm of a rational `q` is `p ^ (-(padic_val_rat p q))`.
If `q = 0`, the p-adic norm of `q` is 0.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='The p-adic norm is nonnegative.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>376  if hq : q = 0 then</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='dite'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='q'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 609, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (c : Prop) [h : decidable c] {α : Prop}, (c → α) → (not c → α) → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>377    by simp [hq, max_eq_right hnrp, le_max_right]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='hq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='max_eq_right'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hnrp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='le_max_right'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/functions.lean&#x27;, &#x27;line&#x27;: 102, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/functions.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : decidable_linear_order.{0} α] {a b : α}, @has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@linear_order.to_partial_order.{0} α (@decidable_linear_order.to_linear_order.{0} α _inst_1)))) a b → @eq.{1} α (@max.{0} α _inst_1 a b) b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@ge.{0} rat rat.has_le (padic_norm p r) (@has_zero.zero.{0} rat rat.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} [_inst_1 : decidable_linear_order.{?l_1} α] (a b : α), @has_le.le.{?l_1} α (@preorder.to_has_le.{?l_1} α (@partial_order.to_preorder.{?l_1} α (@linear_order.to_partial_order.{?l_1} α (@decidable_linear_order.to_linear_order.{?l_1} α _inst_1)))) b (@max.{?l_1} α _inst_1 a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='lime'><a title='p : nat,
hp : nat.prime p,
q r : rat,
h : @has_le.le.{0} int int.has_le (padic_val_rat p q) (padic_val_rat p r),
hnqp : @ge.{0} rat rat.has_le (padic_norm p q) (@has_zero.zero.{0} rat rat.has_zero),
hnrp : @ge.{0} rat rat.has_le (padic_norm p r) (@has_zero.zero.{0} rat rat.has_zero),
hq : @eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)
⊢ @has_le.le.{0} rat rat.has_le (padic_norm p (@has_add.add.{0} rat rat.has_add q r))
    (@max.{0} rat rat.decidable_linear_order (padic_norm p q) (padic_norm p r))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>378  else if hr : r = 0 then</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='hq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='r'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 609, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='not (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>379    by simp [hr, max_eq_left hnqp, le_max_left]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='hr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='max_eq_left'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hnqp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='le_max_left'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/functions.lean&#x27;, &#x27;line&#x27;: 99, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/functions.lean&#x27;, &#x27;line&#x27;: 38, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{1} rat r (@has_zero.zero.{0} rat rat.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : decidable_linear_order.{0} α] {a b : α}, @has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@linear_order.to_partial_order.{0} α (@decidable_linear_order.to_linear_order.{0} α _inst_1)))) b a → @eq.{1} α (@max.{0} α _inst_1 a b) a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@ge.{0} rat rat.has_le (padic_norm p q) (@has_zero.zero.{0} rat rat.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} [_inst_1 : decidable_linear_order.{?l_1} α] (a b : α), @has_le.le.{?l_1} α (@preorder.to_has_le.{?l_1} α (@partial_order.to_preorder.{?l_1} α (@linear_order.to_partial_order.{?l_1} α (@decidable_linear_order.to_linear_order.{?l_1} α _inst_1)))) a (@max.{?l_1} α _inst_1 a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='lime'><a title='p : nat,
hp : nat.prime p,
q r : rat,
h : @has_le.le.{0} int int.has_le (padic_val_rat p q) (padic_val_rat p r),
hnqp : @ge.{0} rat rat.has_le (padic_norm p q) (@has_zero.zero.{0} rat rat.has_zero),
hnrp : @ge.{0} rat rat.has_le (padic_norm p r) (@has_zero.zero.{0} rat rat.has_zero),
hq : not (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)),
hr : @eq.{1} rat r (@has_zero.zero.{0} rat rat.has_zero)
⊢ @has_le.le.{0} rat rat.has_le (padic_norm p (@has_add.add.{0} rat rat.has_add q r))
    (@max.{0} rat rat.decidable_linear_order (padic_norm p q) (padic_norm p r))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>380  else if hqr : q + r = 0 then</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='hr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='q'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='r'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 609, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='not (@eq.{1} rat r (@has_zero.zero.{0} rat rat.has_zero))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_add.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>381    le_trans (by simpa [hqr] using hnqp) (le_max_left _ _)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='le_trans'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='hqr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='hnqp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='le_max_left'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 33, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/functions.lean&#x27;, &#x27;line&#x27;: 38, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type} [_inst_1 : preorder.{0} α] {a b c : α}, @has_le.le.{0} α (@preorder.to_has_le.{0} α _inst_1) a b → @has_le.le.{0} α (@preorder.to_has_le.{0} α _inst_1) b c → @has_le.le.{0} α (@preorder.to_has_le.{0} α _inst_1) a c'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{1} rat (@has_add.add.{0} rat rat.has_add q r) (@has_zero.zero.{0} rat rat.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@ge.{0} rat rat.has_le (padic_norm p q) (@has_zero.zero.{0} rat rat.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {α : Type} [_inst_1 : decidable_linear_order.{0} α] (a b : α), @has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@linear_order.to_partial_order.{0} α (@decidable_linear_order.to_linear_order.{0} α _inst_1)))) a (@max.{0} α _inst_1 a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='lime'><a title='p : nat,
hp : nat.prime p,
q r : rat,
h : @has_le.le.{0} int int.has_le (padic_val_rat p q) (padic_val_rat p r),
hnqp : @ge.{0} rat rat.has_le (padic_norm p q) (@has_zero.zero.{0} rat rat.has_zero),
hnrp : @ge.{0} rat rat.has_le (padic_norm p r) (@has_zero.zero.{0} rat rat.has_zero),
hq : not (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)),
hr : not (@eq.{1} rat r (@has_zero.zero.{0} rat rat.has_zero)),
hqr : @eq.{1} rat (@has_add.add.{0} rat rat.has_add q r) (@has_zero.zero.{0} rat rat.has_zero)
⊢ @has_le.le.{0} rat (@preorder.to_has_le.{0} rat rat.preorder) (padic_norm p (@has_add.add.{0} rat rat.has_add q r))
    (padic_norm p q)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>382  else</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>383    begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='p : nat,
hp : nat.prime p,
q r : rat,
h : @has_le.le.{0} int int.has_le (padic_val_rat p q) (padic_val_rat p r),
hnqp : @ge.{0} rat rat.has_le (padic_norm p q) (@has_zero.zero.{0} rat rat.has_zero),
hnrp : @ge.{0} rat rat.has_le (padic_norm p r) (@has_zero.zero.{0} rat rat.has_zero),
hq : not (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)),
hr : not (@eq.{1} rat r (@has_zero.zero.{0} rat rat.has_zero)),
hqr : not (@eq.{1} rat (@has_add.add.{0} rat rat.has_add q r) (@has_zero.zero.{0} rat rat.has_zero))
⊢ @has_le.le.{0} rat rat.has_le (padic_norm p (@has_add.add.{0} rat rat.has_add q r))
    (@max.{0} rat rat.decidable_linear_order (padic_norm p q) (padic_norm p r))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>384      unfold padic_norm, split_ifs,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1411, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/split_ifs.lean&#x27;, &#x27;line&#x27;: 84, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.unfold_config {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.ff, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.ff, beta := bool.tt, eta := bool.ff, proj := bool.ff, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.ff, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Given defined constants `e₁ ... eₙ`, `unfold e₁ ... eₙ` iteratively unfolds all occurrences in the target of the main goal, using equational lemmas associated with the definitions.

As with `simp`, the `at` modifier can be used to specify locations for the unfolding.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title=' Splits all if-then-else-expressions into multiple goals.

Given a goal of the form `g (if p then x else y)`, `split_ifs` will produce
two goals: `p ⊢ g x` and `¬p ⊢ g y`.

If there are multiple ite-expressions, then `split_ifs` will split them all,
starting with a top-most one whose condition does not contain another
ite-expression.

`split_ifs at *` splits all ite-expressions in all hypotheses as well as the goal.

`split_ifs with h₁ h₂ h₃` overrides the default names for the hypotheses.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='unfold'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='split_ifs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id*&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.unfold_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
q r : rat,
h : @has_le.le.{0} int int.has_le (padic_val_rat p q) (padic_val_rat p r),
hnqp : @ge.{0} rat rat.has_le (padic_norm p q) (@has_zero.zero.{0} rat rat.has_zero),
hnrp : @ge.{0} rat rat.has_le (padic_norm p r) (@has_zero.zero.{0} rat rat.has_zero),
hq : not (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)),
hr : not (@eq.{1} rat r (@has_zero.zero.{0} rat rat.has_zero)),
hqr : not (@eq.{1} rat (@has_add.add.{0} rat rat.has_add q r) (@has_zero.zero.{0} rat rat.has_zero))
⊢ @has_le.le.{0} rat rat.has_le (padic_norm p (@has_add.add.{0} rat rat.has_add q r))
    (@max.{0} rat rat.decidable_linear_order (padic_norm p q) (padic_norm p r))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
q r : rat,
h : @has_le.le.{0} int int.has_le (padic_val_rat p q) (padic_val_rat p r),
hnqp : @ge.{0} rat rat.has_le (padic_norm p q) (@has_zero.zero.{0} rat rat.has_zero),
hnrp : @ge.{0} rat rat.has_le (padic_norm p r) (@has_zero.zero.{0} rat rat.has_zero),
hq : not (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)),
hr : not (@eq.{1} rat r (@has_zero.zero.{0} rat rat.has_zero)),
hqr : not (@eq.{1} rat (@has_add.add.{0} rat rat.has_add q r) (@has_zero.zero.{0} rat rat.has_zero))
⊢ @has_le.le.{0} rat rat.has_le
    (@ite.{1} (@eq.{1} rat (@has_add.add.{0} rat rat.has_add q r) (@has_zero.zero.{0} rat rat.has_zero))
       (rat.decidable_eq (@has_add.add.{0} rat rat.has_add q r) (@has_zero.zero.{0} rat rat.has_zero))
       rat
       (@has_zero.zero.{0} rat rat.has_zero)
       (@has_pow.pow.{0 0} rat int (@int.has_pow.{0} rat rat.division_ring)
          (@coe.{1 1} nat rat
             (@coe_to_lift.{1 1} nat rat
                (@coe_base.{1 1} nat rat (@nat.cast_coe.{0} rat rat.has_zero rat.has_one rat.has_add)))
             p)
          (@has_neg.neg.{0} int int.has_neg (padic_val_rat p (@has_add.add.{0} rat rat.has_add q r)))))
    (@max.{0} rat rat.decidable_linear_order
       (@ite.{1} (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero))
          (rat.decidable_eq q (@has_zero.zero.{0} rat rat.has_zero))
          rat
          (@has_zero.zero.{0} rat rat.has_zero)
          (@has_pow.pow.{0 0} rat int (@int.has_pow.{0} rat rat.division_ring)
             (@coe.{1 1} nat rat
                (@coe_to_lift.{1 1} nat rat
                   (@coe_base.{1 1} nat rat (@nat.cast_coe.{0} rat rat.has_zero rat.has_one rat.has_add)))
                p)
             (@has_neg.neg.{0} int int.has_neg (padic_val_rat p q))))
       (@ite.{1} (@eq.{1} rat r (@has_zero.zero.{0} rat rat.has_zero))
          (rat.decidable_eq r (@has_zero.zero.{0} rat rat.has_zero))
          rat
          (@has_zero.zero.{0} rat rat.has_zero)
          (@has_pow.pow.{0 0} rat int (@int.has_pow.{0} rat rat.division_ring)
             (@coe.{1 1} nat rat
                (@coe_to_lift.{1 1} nat rat
                   (@coe_base.{1 1} nat rat (@nat.cast_coe.{0} rat rat.has_zero rat.has_one rat.has_add)))
                p)
             (@has_neg.neg.{0} int int.has_neg (padic_val_rat p r)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
q r : rat,
h : @has_le.le.{0} int int.has_le (padic_val_rat p q) (padic_val_rat p r),
hnqp : @ge.{0} rat rat.has_le (padic_norm p q) (@has_zero.zero.{0} rat rat.has_zero),
hnrp : @ge.{0} rat rat.has_le (padic_norm p r) (@has_zero.zero.{0} rat rat.has_zero),
hq : not (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)),
hr : not (@eq.{1} rat r (@has_zero.zero.{0} rat rat.has_zero)),
hqr : not (@eq.{1} rat (@has_add.add.{0} rat rat.has_add q r) (@has_zero.zero.{0} rat rat.has_zero))
⊢ @has_le.le.{0} rat rat.has_le
    (@has_pow.pow.{0 0} rat int (@int.has_pow.{0} rat rat.division_ring)
       (@coe.{1 1} nat rat
          (@coe_to_lift.{1 1} nat rat
             (@coe_base.{1 1} nat rat (@nat.cast_coe.{0} rat rat.has_zero rat.has_one rat.has_add)))
          p)
       (@has_neg.neg.{0} int int.has_neg (padic_val_rat p (@has_add.add.{0} rat rat.has_add q r))))
    (@max.{0} rat rat.decidable_linear_order
       (@has_pow.pow.{0 0} rat int (@int.has_pow.{0} rat rat.division_ring)
          (@coe.{1 1} nat rat
             (@coe_to_lift.{1 1} nat rat
                (@coe_base.{1 1} nat rat (@nat.cast_coe.{0} rat rat.has_zero rat.has_one rat.has_add)))
             p)
          (@has_neg.neg.{0} int int.has_neg (padic_val_rat p q)))
       (@has_pow.pow.{0 0} rat int (@int.has_pow.{0} rat rat.division_ring)
          (@coe.{1 1} nat rat
             (@coe_to_lift.{1 1} nat rat
                (@coe_base.{1 1} nat rat (@nat.cast_coe.{0} rat rat.has_zero rat.has_one rat.has_add)))
             p)
          (@has_neg.neg.{0} int int.has_neg (padic_val_rat p r))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>385      apply le_max_iff.2,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='le_max_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/order_functions.lean&#x27;, &#x27;line&#x27;: 100, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : decidable_linear_order.{0} α] {a b c : α}, iff (@has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@lattice.semilattice_inf.to_partial_order.{0} α (@lattice.lattice.to_semilattice_inf.{0} α (@lattice.lattice_of_decidable_linear_order.{0} α _inst_1))))) a (@max.{0} α _inst_1 b c)) (or (@has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@lattice.semilattice_inf.to_partial_order.{0} α (@lattice.lattice.to_semilattice_inf.{0} α (@lattice.lattice_of_decidable_linear_order.{0} α _inst_1))))) a b) (@has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@lattice.semilattice_inf.to_partial_order.{0} α (@lattice.lattice.to_semilattice_inf.{0} α (@lattice.lattice_of_decidable_linear_order.{0} α _inst_1))))) a c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
q r : rat,
h : @has_le.le.{0} int int.has_le (padic_val_rat p q) (padic_val_rat p r),
hnqp : @ge.{0} rat rat.has_le (padic_norm p q) (@has_zero.zero.{0} rat rat.has_zero),
hnrp : @ge.{0} rat rat.has_le (padic_norm p r) (@has_zero.zero.{0} rat rat.has_zero),
hq : not (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)),
hr : not (@eq.{1} rat r (@has_zero.zero.{0} rat rat.has_zero)),
hqr : not (@eq.{1} rat (@has_add.add.{0} rat rat.has_add q r) (@has_zero.zero.{0} rat rat.has_zero))
⊢ @has_le.le.{0} rat rat.has_le
    (@has_pow.pow.{0 0} rat int (@int.has_pow.{0} rat rat.division_ring)
       (@coe.{1 1} nat rat
          (@coe_to_lift.{1 1} nat rat
             (@coe_base.{1 1} nat rat (@nat.cast_coe.{0} rat rat.has_zero rat.has_one rat.has_add)))
          p)
       (@has_neg.neg.{0} int int.has_neg (padic_val_rat p (@has_add.add.{0} rat rat.has_add q r))))
    (@max.{0} rat rat.decidable_linear_order
       (@has_pow.pow.{0 0} rat int (@int.has_pow.{0} rat rat.division_ring)
          (@coe.{1 1} nat rat
             (@coe_to_lift.{1 1} nat rat
                (@coe_base.{1 1} nat rat (@nat.cast_coe.{0} rat rat.has_zero rat.has_one rat.has_add)))
             p)
          (@has_neg.neg.{0} int int.has_neg (padic_val_rat p q)))
       (@has_pow.pow.{0 0} rat int (@int.has_pow.{0} rat rat.division_ring)
          (@coe.{1 1} nat rat
             (@coe_to_lift.{1 1} nat rat
                (@coe_base.{1 1} nat rat (@nat.cast_coe.{0} rat rat.has_zero rat.has_one rat.has_add)))
             p)
          (@has_neg.neg.{0} int int.has_neg (padic_val_rat p r))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
q r : rat,
h : @has_le.le.{0} int int.has_le (padic_val_rat p q) (padic_val_rat p r),
hnqp : @ge.{0} rat rat.has_le (padic_norm p q) (@has_zero.zero.{0} rat rat.has_zero),
hnrp : @ge.{0} rat rat.has_le (padic_norm p r) (@has_zero.zero.{0} rat rat.has_zero),
hq : not (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)),
hr : not (@eq.{1} rat r (@has_zero.zero.{0} rat rat.has_zero)),
hqr : not (@eq.{1} rat (@has_add.add.{0} rat rat.has_add q r) (@has_zero.zero.{0} rat rat.has_zero))
⊢ or
    (@has_le.le.{0} rat
       (@preorder.to_has_le.{0} rat
          (@partial_order.to_preorder.{0} rat
             (@lattice.semilattice_inf.to_partial_order.{0} rat
                (@lattice.lattice.to_semilattice_inf.{0} rat
                   (@lattice.lattice_of_decidable_linear_order.{0} rat rat.decidable_linear_order)))))
       (@has_pow.pow.{0 0} rat int (@int.has_pow.{0} rat rat.division_ring)
          (@coe.{1 1} nat rat
             (@coe_to_lift.{1 1} nat rat
                (@coe_base.{1 1} nat rat (@nat.cast_coe.{0} rat rat.has_zero rat.has_one rat.has_add)))
             p)
          (@has_neg.neg.{0} int int.has_neg (padic_val_rat p (@has_add.add.{0} rat rat.has_add q r))))
       (@has_pow.pow.{0 0} rat int (@int.has_pow.{0} rat rat.division_ring)
          (@coe.{1 1} nat rat
             (@coe_to_lift.{1 1} nat rat
                (@coe_base.{1 1} nat rat (@nat.cast_coe.{0} rat rat.has_zero rat.has_one rat.has_add)))
             p)
          (@has_neg.neg.{0} int int.has_neg (padic_val_rat p q))))
    (@has_le.le.{0} rat
       (@preorder.to_has_le.{0} rat
          (@partial_order.to_preorder.{0} rat
             (@lattice.semilattice_inf.to_partial_order.{0} rat
                (@lattice.lattice.to_semilattice_inf.{0} rat
                   (@lattice.lattice_of_decidable_linear_order.{0} rat rat.decidable_linear_order)))))
       (@has_pow.pow.{0 0} rat int (@int.has_pow.{0} rat rat.division_ring)
          (@coe.{1 1} nat rat
             (@coe_to_lift.{1 1} nat rat
                (@coe_base.{1 1} nat rat (@nat.cast_coe.{0} rat rat.has_zero rat.has_one rat.has_add)))
             p)
          (@has_neg.neg.{0} int int.has_neg (padic_val_rat p (@has_add.add.{0} rat rat.has_add q r))))
       (@has_pow.pow.{0 0} rat int (@int.has_pow.{0} rat rat.division_ring)
          (@coe.{1 1} nat rat
             (@coe_to_lift.{1 1} nat rat
                (@coe_base.{1 1} nat rat (@nat.cast_coe.{0} rat rat.has_zero rat.has_one rat.has_add)))
             p)
          (@has_neg.neg.{0} int int.has_neg (padic_val_rat p r))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>386      left,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1000, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Applies the first constructor when the type of the target is an inductive data type with two constructors.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='left'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
q r : rat,
h : @has_le.le.{0} int int.has_le (padic_val_rat p q) (padic_val_rat p r),
hnqp : @ge.{0} rat rat.has_le (padic_norm p q) (@has_zero.zero.{0} rat rat.has_zero),
hnrp : @ge.{0} rat rat.has_le (padic_norm p r) (@has_zero.zero.{0} rat rat.has_zero),
hq : not (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)),
hr : not (@eq.{1} rat r (@has_zero.zero.{0} rat rat.has_zero)),
hqr : not (@eq.{1} rat (@has_add.add.{0} rat rat.has_add q r) (@has_zero.zero.{0} rat rat.has_zero))
⊢ or
    (@has_le.le.{0} rat
       (@preorder.to_has_le.{0} rat
          (@partial_order.to_preorder.{0} rat
             (@lattice.semilattice_inf.to_partial_order.{0} rat
                (@lattice.lattice.to_semilattice_inf.{0} rat
                   (@lattice.lattice_of_decidable_linear_order.{0} rat rat.decidable_linear_order)))))
       (@has_pow.pow.{0 0} rat int (@int.has_pow.{0} rat rat.division_ring)
          (@coe.{1 1} nat rat
             (@coe_to_lift.{1 1} nat rat
                (@coe_base.{1 1} nat rat (@nat.cast_coe.{0} rat rat.has_zero rat.has_one rat.has_add)))
             p)
          (@has_neg.neg.{0} int int.has_neg (padic_val_rat p (@has_add.add.{0} rat rat.has_add q r))))
       (@has_pow.pow.{0 0} rat int (@int.has_pow.{0} rat rat.division_ring)
          (@coe.{1 1} nat rat
             (@coe_to_lift.{1 1} nat rat
                (@coe_base.{1 1} nat rat (@nat.cast_coe.{0} rat rat.has_zero rat.has_one rat.has_add)))
             p)
          (@has_neg.neg.{0} int int.has_neg (padic_val_rat p q))))
    (@has_le.le.{0} rat
       (@preorder.to_has_le.{0} rat
          (@partial_order.to_preorder.{0} rat
             (@lattice.semilattice_inf.to_partial_order.{0} rat
                (@lattice.lattice.to_semilattice_inf.{0} rat
                   (@lattice.lattice_of_decidable_linear_order.{0} rat rat.decidable_linear_order)))))
       (@has_pow.pow.{0 0} rat int (@int.has_pow.{0} rat rat.division_ring)
          (@coe.{1 1} nat rat
             (@coe_to_lift.{1 1} nat rat
                (@coe_base.{1 1} nat rat (@nat.cast_coe.{0} rat rat.has_zero rat.has_one rat.has_add)))
             p)
          (@has_neg.neg.{0} int int.has_neg (padic_val_rat p (@has_add.add.{0} rat rat.has_add q r))))
       (@has_pow.pow.{0 0} rat int (@int.has_pow.{0} rat rat.division_ring)
          (@coe.{1 1} nat rat
             (@coe_to_lift.{1 1} nat rat
                (@coe_base.{1 1} nat rat (@nat.cast_coe.{0} rat rat.has_zero rat.has_one rat.has_add)))
             p)
          (@has_neg.neg.{0} int int.has_neg (padic_val_rat p r))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
q r : rat,
h : @has_le.le.{0} int int.has_le (padic_val_rat p q) (padic_val_rat p r),
hnqp : @ge.{0} rat rat.has_le (padic_norm p q) (@has_zero.zero.{0} rat rat.has_zero),
hnrp : @ge.{0} rat rat.has_le (padic_norm p r) (@has_zero.zero.{0} rat rat.has_zero),
hq : not (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)),
hr : not (@eq.{1} rat r (@has_zero.zero.{0} rat rat.has_zero)),
hqr : not (@eq.{1} rat (@has_add.add.{0} rat rat.has_add q r) (@has_zero.zero.{0} rat rat.has_zero))
⊢ @has_le.le.{0} rat
    (@preorder.to_has_le.{0} rat
       (@partial_order.to_preorder.{0} rat
          (@lattice.semilattice_inf.to_partial_order.{0} rat
             (@lattice.lattice.to_semilattice_inf.{0} rat
                (@lattice.lattice_of_decidable_linear_order.{0} rat rat.decidable_linear_order)))))
    (@has_pow.pow.{0 0} rat int (@int.has_pow.{0} rat rat.division_ring)
       (@coe.{1 1} nat rat
          (@coe_to_lift.{1 1} nat rat
             (@coe_base.{1 1} nat rat (@nat.cast_coe.{0} rat rat.has_zero rat.has_one rat.has_add)))
          p)
       (@has_neg.neg.{0} int int.has_neg (padic_val_rat p (@has_add.add.{0} rat rat.has_add q r))))
    (@has_pow.pow.{0 0} rat int (@int.has_pow.{0} rat rat.division_ring)
       (@coe.{1 1} nat rat
          (@coe_to_lift.{1 1} nat rat
             (@coe_base.{1 1} nat rat (@nat.cast_coe.{0} rat rat.has_zero rat.has_one rat.has_add)))
          p)
       (@has_neg.neg.{0} int int.has_neg (padic_val_rat p q)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>387      apply fpow_le_of_le,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='fpow_le_of_le'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/field_power.lean&#x27;, &#x27;line&#x27;: 130, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {K : Type} [_inst_1 : discrete_linear_ordered_field.{0} K] {x : K}, @has_le.le.{0} K (@preorder.to_has_le.{0} K (@partial_order.to_preorder.{0} K (@ordered_comm_monoid.to_partial_order.{0} K (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} K (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} K (@ordered_ring.to_ordered_semiring.{0} K (@linear_ordered_ring.to_ordered_ring.{0} K (@linear_ordered_field.to_linear_ordered_ring.{0} K (@discrete_linear_ordered_field.to_linear_ordered_field.{0} K _inst_1))))))))) (@has_one.one.{0} K (@zero_ne_one_class.to_has_one.{0} K (@domain.to_zero_ne_one_class.{0} K (@division_ring.to_domain.{0} K (@field.to_division_ring.{0} K (@linear_ordered_field.to_field.{0} K (@discrete_linear_ordered_field.to_linear_ordered_field.{0} K _inst_1))))))) x → ∀ {a b : int}, @has_le.le.{0} int int.has_le a b → @has_le.le.{0} K (@preorder.to_has_le.{0} K (@partial_order.to_preorder.{0} K (@ordered_comm_monoid.to_partial_order.{0} K (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} K (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} K (@ordered_ring.to_ordered_semiring.{0} K (@linear_ordered_ring.to_ordered_ring.{0} K (@linear_ordered_field.to_linear_ordered_ring.{0} K (@discrete_linear_ordered_field.to_linear_ordered_field.{0} K _inst_1))))))))) (@has_pow.pow.{0 0} K int (@int.has_pow.{0} K (@field.to_division_ring.{0} K (@linear_ordered_field.to_field.{0} K (@discrete_linear_ordered_field.to_linear_ordered_field.{0} K _inst_1)))) x a) (@has_pow.pow.{0 0} K int (@int.has_pow.{0} K (@field.to_division_ring.{0} K (@linear_ordered_field.to_field.{0} K (@discrete_linear_ordered_field.to_linear_ordered_field.{0} K _inst_1)))) x b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
q r : rat,
h : @has_le.le.{0} int int.has_le (padic_val_rat p q) (padic_val_rat p r),
hnqp : @ge.{0} rat rat.has_le (padic_norm p q) (@has_zero.zero.{0} rat rat.has_zero),
hnrp : @ge.{0} rat rat.has_le (padic_norm p r) (@has_zero.zero.{0} rat rat.has_zero),
hq : not (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)),
hr : not (@eq.{1} rat r (@has_zero.zero.{0} rat rat.has_zero)),
hqr : not (@eq.{1} rat (@has_add.add.{0} rat rat.has_add q r) (@has_zero.zero.{0} rat rat.has_zero))
⊢ @has_le.le.{0} rat
    (@preorder.to_has_le.{0} rat
       (@partial_order.to_preorder.{0} rat
          (@lattice.semilattice_inf.to_partial_order.{0} rat
             (@lattice.lattice.to_semilattice_inf.{0} rat
                (@lattice.lattice_of_decidable_linear_order.{0} rat rat.decidable_linear_order)))))
    (@has_pow.pow.{0 0} rat int (@int.has_pow.{0} rat rat.division_ring)
       (@coe.{1 1} nat rat
          (@coe_to_lift.{1 1} nat rat
             (@coe_base.{1 1} nat rat (@nat.cast_coe.{0} rat rat.has_zero rat.has_one rat.has_add)))
          p)
       (@has_neg.neg.{0} int int.has_neg (padic_val_rat p (@has_add.add.{0} rat rat.has_add q r))))
    (@has_pow.pow.{0 0} rat int (@int.has_pow.{0} rat rat.division_ring)
       (@coe.{1 1} nat rat
          (@coe_to_lift.{1 1} nat rat
             (@coe_base.{1 1} nat rat (@nat.cast_coe.{0} rat rat.has_zero rat.has_one rat.has_add)))
          p)
       (@has_neg.neg.{0} int int.has_neg (padic_val_rat p q)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
p : nat,
hp : nat.prime p,
q r : rat,
h : @has_le.le.{0} int int.has_le (padic_val_rat p q) (padic_val_rat p r),
hnqp : @ge.{0} rat rat.has_le (padic_norm p q) (@has_zero.zero.{0} rat rat.has_zero),
hnrp : @ge.{0} rat rat.has_le (padic_norm p r) (@has_zero.zero.{0} rat rat.has_zero),
hq : not (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)),
hr : not (@eq.{1} rat r (@has_zero.zero.{0} rat rat.has_zero)),
hqr : not (@eq.{1} rat (@has_add.add.{0} rat rat.has_add q r) (@has_zero.zero.{0} rat rat.has_zero))
⊢ @has_le.le.{0} rat
    (@preorder.to_has_le.{0} rat
       (@partial_order.to_preorder.{0} rat
          (@ordered_comm_monoid.to_partial_order.{0} rat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} rat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} rat
                   (@ordered_ring.to_ordered_semiring.{0} rat
                      (@linear_ordered_ring.to_ordered_ring.{0} rat
                         (@linear_ordered_field.to_linear_ordered_ring.{0} rat
                            (@discrete_linear_ordered_field.to_linear_ordered_field.{0} rat
                               rat.discrete_linear_ordered_field)))))))))
    (@has_one.one.{0} rat
       (@zero_ne_one_class.to_has_one.{0} rat
          (@domain.to_zero_ne_one_class.{0} rat
             (@division_ring.to_domain.{0} rat
                (@field.to_division_ring.{0} rat
                   (@linear_ordered_field.to_field.{0} rat
                      (@discrete_linear_ordered_field.to_linear_ordered_field.{0} rat
                         rat.discrete_linear_ordered_field)))))))
    (@coe.{1 1} nat rat
       (@coe_to_lift.{1 1} nat rat
          (@coe_base.{1 1} nat rat (@nat.cast_coe.{0} rat rat.has_zero rat.has_one rat.has_add)))
       p)

p : nat,
hp : nat.prime p,
q r : rat,
h : @has_le.le.{0} int int.has_le (padic_val_rat p q) (padic_val_rat p r),
hnqp : @ge.{0} rat rat.has_le (padic_norm p q) (@has_zero.zero.{0} rat rat.has_zero),
hnrp : @ge.{0} rat rat.has_le (padic_norm p r) (@has_zero.zero.{0} rat rat.has_zero),
hq : not (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)),
hr : not (@eq.{1} rat r (@has_zero.zero.{0} rat rat.has_zero)),
hqr : not (@eq.{1} rat (@has_add.add.{0} rat rat.has_add q r) (@has_zero.zero.{0} rat rat.has_zero))
⊢ @has_le.le.{0} int int.has_le
    (@has_neg.neg.{0} int int.has_neg (padic_val_rat p (@has_add.add.{0} rat rat.has_add q r)))
    (@has_neg.neg.{0} int int.has_neg (padic_val_rat p q))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>388      { exact_mod_cast le_of_lt hp.one_lt },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='blue'><a title='le_of_lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/norm_cast.lean&#x27;, &#x27;line&#x27;: 335, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 99, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/norm_cast.lean&#x27;, &#x27;line&#x27;: 335, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/nat/prime.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/norm_cast.lean&#x27;, &#x27;line&#x27;: 335, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : preorder.{0} α] {a b : α}, @has_lt.lt.{0} α (@preorder.to_has_lt.{0} α _inst_1) a b → @has_le.le.{0} α (@preorder.to_has_le.{0} α _inst_1) a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat.prime p'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='Normalize the goal and the given expression,
then close the goal with exact.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='Normalize the goal and the given expression,
then close the goal with exact.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='Normalize the goal and the given expression,
then close the goal with exact.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='exact_mod_cast'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='exact_mod_cast'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='exact_mod_cast'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
p : nat,
hp : nat.prime p,
q r : rat,
h : @has_le.le.{0} int int.has_le (padic_val_rat p q) (padic_val_rat p r),
hnqp : @ge.{0} rat rat.has_le (padic_norm p q) (@has_zero.zero.{0} rat rat.has_zero),
hnrp : @ge.{0} rat rat.has_le (padic_norm p r) (@has_zero.zero.{0} rat rat.has_zero),
hq : not (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)),
hr : not (@eq.{1} rat r (@has_zero.zero.{0} rat rat.has_zero)),
hqr : not (@eq.{1} rat (@has_add.add.{0} rat rat.has_add q r) (@has_zero.zero.{0} rat rat.has_zero))
⊢ @has_le.le.{0} rat
    (@preorder.to_has_le.{0} rat
       (@partial_order.to_preorder.{0} rat
          (@ordered_comm_monoid.to_partial_order.{0} rat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} rat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} rat
                   (@ordered_ring.to_ordered_semiring.{0} rat
                      (@linear_ordered_ring.to_ordered_ring.{0} rat
                         (@linear_ordered_field.to_linear_ordered_ring.{0} rat
                            (@discrete_linear_ordered_field.to_linear_ordered_field.{0} rat
                               rat.discrete_linear_ordered_field)))))))))
    (@has_one.one.{0} rat
       (@zero_ne_one_class.to_has_one.{0} rat
          (@domain.to_zero_ne_one_class.{0} rat
             (@division_ring.to_domain.{0} rat
                (@field.to_division_ring.{0} rat
                   (@linear_ordered_field.to_field.{0} rat
                      (@discrete_linear_ordered_field.to_linear_ordered_field.{0} rat
                         rat.discrete_linear_ordered_field)))))))
    (@coe.{1 1} nat rat
       (@coe_to_lift.{1 1} nat rat
          (@coe_base.{1 1} nat rat (@nat.cast_coe.{0} rat rat.has_zero rat.has_one rat.has_add)))
       p)

p : nat,
hp : nat.prime p,
q r : rat,
h : @has_le.le.{0} int int.has_le (padic_val_rat p q) (padic_val_rat p r),
hnqp : @ge.{0} rat rat.has_le (padic_norm p q) (@has_zero.zero.{0} rat rat.has_zero),
hnrp : @ge.{0} rat rat.has_le (padic_norm p r) (@has_zero.zero.{0} rat rat.has_zero),
hq : not (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)),
hr : not (@eq.{1} rat r (@has_zero.zero.{0} rat rat.has_zero)),
hqr : not (@eq.{1} rat (@has_add.add.{0} rat rat.has_add q r) (@has_zero.zero.{0} rat rat.has_zero))
⊢ @has_le.le.{0} int int.has_le
    (@has_neg.neg.{0} int int.has_neg (padic_val_rat p (@has_add.add.{0} rat rat.has_add q r)))
    (@has_neg.neg.{0} int int.has_neg (padic_val_rat p q))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
q r : rat,
h : @has_le.le.{0} int int.has_le (padic_val_rat p q) (padic_val_rat p r),
hnqp : @ge.{0} rat rat.has_le (padic_norm p q) (@has_zero.zero.{0} rat rat.has_zero),
hnrp : @ge.{0} rat rat.has_le (padic_norm p r) (@has_zero.zero.{0} rat rat.has_zero),
hq : not (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)),
hr : not (@eq.{1} rat r (@has_zero.zero.{0} rat rat.has_zero)),
hqr : not (@eq.{1} rat (@has_add.add.{0} rat rat.has_add q r) (@has_zero.zero.{0} rat rat.has_zero))
⊢ @has_le.le.{0} rat
    (@preorder.to_has_le.{0} rat
       (@partial_order.to_preorder.{0} rat
          (@ordered_comm_monoid.to_partial_order.{0} rat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} rat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} rat
                   (@ordered_ring.to_ordered_semiring.{0} rat
                      (@linear_ordered_ring.to_ordered_ring.{0} rat
                         (@linear_ordered_field.to_linear_ordered_ring.{0} rat
                            (@discrete_linear_ordered_field.to_linear_ordered_field.{0} rat
                               rat.discrete_linear_ordered_field)))))))))
    (@has_one.one.{0} rat
       (@zero_ne_one_class.to_has_one.{0} rat
          (@domain.to_zero_ne_one_class.{0} rat
             (@division_ring.to_domain.{0} rat
                (@field.to_division_ring.{0} rat
                   (@linear_ordered_field.to_field.{0} rat
                      (@discrete_linear_ordered_field.to_linear_ordered_field.{0} rat
                         rat.discrete_linear_ordered_field)))))))
    (@coe.{1 1} nat rat
       (@coe_to_lift.{1 1} nat rat
          (@coe_base.{1 1} nat rat (@nat.cast_coe.{0} rat rat.has_zero rat.has_one rat.has_add)))
       p)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
q r : rat,
h : @has_le.le.{0} int int.has_le (padic_val_rat p q) (padic_val_rat p r),
hnqp : @ge.{0} rat rat.has_le (padic_norm p q) (@has_zero.zero.{0} rat rat.has_zero),
hnrp : @ge.{0} rat rat.has_le (padic_norm p r) (@has_zero.zero.{0} rat rat.has_zero),
hq : not (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)),
hr : not (@eq.{1} rat r (@has_zero.zero.{0} rat rat.has_zero)),
hqr : not (@eq.{1} rat (@has_add.add.{0} rat rat.has_add q r) (@has_zero.zero.{0} rat rat.has_zero))
⊢ @has_le.le.{0} int int.has_le
    (@has_neg.neg.{0} int int.has_neg (padic_val_rat p (@has_add.add.{0} rat rat.has_add q r)))
    (@has_neg.neg.{0} int int.has_neg (padic_val_rat p q))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>389      { apply neg_le_neg,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='neg_le_neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/ordered_group.lean&#x27;, &#x27;line&#x27;: 212, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : ordered_comm_group.{0} α] {a b : α}, @has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@ordered_comm_group.to_partial_order.{0} α _inst_1))) a b → @has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@ordered_comm_group.to_partial_order.{0} α _inst_1))) (@has_neg.neg.{0} α (@add_group.to_has_neg.{0} α (@add_comm_group.to_add_group.{0} α (@ordered_comm_group.to_add_comm_group.{0} α _inst_1))) b) (@has_neg.neg.{0} α (@add_group.to_has_neg.{0} α (@add_comm_group.to_add_group.{0} α (@ordered_comm_group.to_add_comm_group.{0} α _inst_1))) a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
q r : rat,
h : @has_le.le.{0} int int.has_le (padic_val_rat p q) (padic_val_rat p r),
hnqp : @ge.{0} rat rat.has_le (padic_norm p q) (@has_zero.zero.{0} rat rat.has_zero),
hnrp : @ge.{0} rat rat.has_le (padic_norm p r) (@has_zero.zero.{0} rat rat.has_zero),
hq : not (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)),
hr : not (@eq.{1} rat r (@has_zero.zero.{0} rat rat.has_zero)),
hqr : not (@eq.{1} rat (@has_add.add.{0} rat rat.has_add q r) (@has_zero.zero.{0} rat rat.has_zero))
⊢ @has_le.le.{0} int int.has_le
    (@has_neg.neg.{0} int int.has_neg (padic_val_rat p (@has_add.add.{0} rat rat.has_add q r)))
    (@has_neg.neg.{0} int int.has_neg (padic_val_rat p q))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
q r : rat,
h : @has_le.le.{0} int int.has_le (padic_val_rat p q) (padic_val_rat p r),
hnqp : @ge.{0} rat rat.has_le (padic_norm p q) (@has_zero.zero.{0} rat rat.has_zero),
hnrp : @ge.{0} rat rat.has_le (padic_norm p r) (@has_zero.zero.{0} rat rat.has_zero),
hq : not (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)),
hr : not (@eq.{1} rat r (@has_zero.zero.{0} rat rat.has_zero)),
hqr : not (@eq.{1} rat (@has_add.add.{0} rat rat.has_add q r) (@has_zero.zero.{0} rat rat.has_zero))
⊢ @has_le.le.{0} int
    (@preorder.to_has_le.{0} int
       (@partial_order.to_preorder.{0} int
          (@ordered_comm_group.to_partial_order.{0} int
             (@ordered_ring.to_ordered_comm_group.{0} int
                (@linear_ordered_ring.to_ordered_ring.{0} int
                   (@linear_ordered_comm_ring.to_linear_ordered_ring.{0} int
                      (@decidable_linear_ordered_comm_ring.to_linear_ordered_comm_ring.{0} int
                         int.decidable_linear_ordered_comm_ring)))))))
    (padic_val_rat p q)
    (padic_val_rat p (@has_add.add.{0} rat rat.has_add q r))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>390        have : padic_val_rat p q =</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
q r : rat,
h : @has_le.le.{0} int int.has_le (padic_val_rat p q) (padic_val_rat p r),
hnqp : @ge.{0} rat rat.has_le (padic_norm p q) (@has_zero.zero.{0} rat rat.has_zero),
hnrp : @ge.{0} rat rat.has_le (padic_norm p r) (@has_zero.zero.{0} rat rat.has_zero),
hq : not (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)),
hr : not (@eq.{1} rat r (@has_zero.zero.{0} rat rat.has_zero)),
hqr : not (@eq.{1} rat (@has_add.add.{0} rat rat.has_add q r) (@has_zero.zero.{0} rat rat.has_zero))
⊢ @has_le.le.{0} int
    (@preorder.to_has_le.{0} int
       (@partial_order.to_preorder.{0} int
          (@ordered_comm_group.to_partial_order.{0} int
             (@ordered_ring.to_ordered_comm_group.{0} int
                (@linear_ordered_ring.to_ordered_ring.{0} int
                   (@linear_ordered_comm_ring.to_linear_ordered_ring.{0} int
                      (@decidable_linear_ordered_comm_ring.to_linear_ordered_comm_ring.{0} int
                         int.decidable_linear_ordered_comm_ring)))))))
    (padic_val_rat p q)
    (padic_val_rat p (@has_add.add.{0} rat rat.has_add q r))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>391                min (padic_val_rat p q) (padic_val_rat p r),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='min'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='blue'><a title='q'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='padic_val_rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='r'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/functions.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 11}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 62, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type} [_inst_1 : decidable_linear_order.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat → rat → int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='For `p ≠ 1`, the p-adic valuation of an integer `z ≠ 0` is the largest natural number `n` such that
p^n divides z.

`padic_val_rat` defines the valuation of a rational `q` to be the valuation of `q.num` minus the
valuation of `q.denom`.
If `q = 0` or `p = 1`, then `padic_val_rat p q` defaults to 0.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
q r : rat,
h : @has_le.le.{0} int int.has_le (padic_val_rat p q) (padic_val_rat p r),
hnqp : @ge.{0} rat rat.has_le (padic_norm p q) (@has_zero.zero.{0} rat rat.has_zero),
hnrp : @ge.{0} rat rat.has_le (padic_norm p r) (@has_zero.zero.{0} rat rat.has_zero),
hq : not (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)),
hr : not (@eq.{1} rat r (@has_zero.zero.{0} rat rat.has_zero)),
hqr : not (@eq.{1} rat (@has_add.add.{0} rat rat.has_add q r) (@has_zero.zero.{0} rat rat.has_zero))
⊢ @has_le.le.{0} int
    (@preorder.to_has_le.{0} int
       (@partial_order.to_preorder.{0} int
          (@ordered_comm_group.to_partial_order.{0} int
             (@ordered_ring.to_ordered_comm_group.{0} int
                (@linear_ordered_ring.to_ordered_ring.{0} int
                   (@linear_ordered_comm_ring.to_linear_ordered_ring.{0} int
                      (@decidable_linear_ordered_comm_ring.to_linear_ordered_comm_ring.{0} int
                         int.decidable_linear_ordered_comm_ring)))))))
    (padic_val_rat p q)
    (padic_val_rat p (@has_add.add.{0} rat rat.has_add q r))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
p : nat,
hp : nat.prime p,
q r : rat,
h : @has_le.le.{0} int int.has_le (padic_val_rat p q) (padic_val_rat p r),
hnqp : @ge.{0} rat rat.has_le (padic_norm p q) (@has_zero.zero.{0} rat rat.has_zero),
hnrp : @ge.{0} rat rat.has_le (padic_norm p r) (@has_zero.zero.{0} rat rat.has_zero),
hq : not (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)),
hr : not (@eq.{1} rat r (@has_zero.zero.{0} rat rat.has_zero)),
hqr : not (@eq.{1} rat (@has_add.add.{0} rat rat.has_add q r) (@has_zero.zero.{0} rat rat.has_zero))
⊢ @eq.{1} int (padic_val_rat p q)
    (@min.{0} int
       (@decidable_linear_ordered_semiring.to_decidable_linear_order.{0} int
          (@decidable_linear_ordered_comm_ring.to_decidable_linear_ordered_semiring.{0} int
             int.decidable_linear_ordered_comm_ring))
       (padic_val_rat p q)
       (padic_val_rat p r))

p : nat,
hp : nat.prime p,
q r : rat,
h : @has_le.le.{0} int int.has_le (padic_val_rat p q) (padic_val_rat p r),
hnqp : @ge.{0} rat rat.has_le (padic_norm p q) (@has_zero.zero.{0} rat rat.has_zero),
hnrp : @ge.{0} rat rat.has_le (padic_norm p r) (@has_zero.zero.{0} rat rat.has_zero),
hq : not (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)),
hr : not (@eq.{1} rat r (@has_zero.zero.{0} rat rat.has_zero)),
hqr : not (@eq.{1} rat (@has_add.add.{0} rat rat.has_add q r) (@has_zero.zero.{0} rat rat.has_zero)),
this :
  @eq.{1} int (padic_val_rat p q)
    (@min.{0} int
       (@decidable_linear_ordered_semiring.to_decidable_linear_order.{0} int
          (@decidable_linear_ordered_comm_ring.to_decidable_linear_ordered_semiring.{0} int
             int.decidable_linear_ordered_comm_ring))
       (padic_val_rat p q)
       (padic_val_rat p r))
⊢ @has_le.le.{0} int
    (@preorder.to_has_le.{0} int
       (@partial_order.to_preorder.{0} int
          (@ordered_comm_group.to_partial_order.{0} int
             (@ordered_ring.to_ordered_comm_group.{0} int
                (@linear_ordered_ring.to_ordered_ring.{0} int
                   (@linear_ordered_comm_ring.to_linear_ordered_ring.{0} int
                      (@decidable_linear_ordered_comm_ring.to_linear_ordered_comm_ring.{0} int
                         int.decidable_linear_ordered_comm_ring)))))))
    (padic_val_rat p q)
    (padic_val_rat p (@has_add.add.{0} rat rat.has_add q r))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>392          from (min_eq_left h).symm,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='min_eq_left'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/functions.lean&#x27;, &#x27;line&#x27;: 70, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type} [_inst_1 : decidable_linear_order.{0} α] {a b : α}, @has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@linear_order.to_partial_order.{0} α (@decidable_linear_order.to_linear_order.{0} α _inst_1)))) a b → @eq.{1} α (@min.{0} α _inst_1 a b) a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_le.le.{0} int int.has_le (padic_val_rat p q) (padic_val_rat p r)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
p : nat,
hp : nat.prime p,
q r : rat,
h : @has_le.le.{0} int int.has_le (padic_val_rat p q) (padic_val_rat p r),
hnqp : @ge.{0} rat rat.has_le (padic_norm p q) (@has_zero.zero.{0} rat rat.has_zero),
hnrp : @ge.{0} rat rat.has_le (padic_norm p r) (@has_zero.zero.{0} rat rat.has_zero),
hq : not (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)),
hr : not (@eq.{1} rat r (@has_zero.zero.{0} rat rat.has_zero)),
hqr : not (@eq.{1} rat (@has_add.add.{0} rat rat.has_add q r) (@has_zero.zero.{0} rat rat.has_zero))
⊢ @eq.{1} int (padic_val_rat p q)
    (@min.{0} int
       (@decidable_linear_ordered_semiring.to_decidable_linear_order.{0} int
          (@decidable_linear_ordered_comm_ring.to_decidable_linear_ordered_semiring.{0} int
             int.decidable_linear_ordered_comm_ring))
       (padic_val_rat p q)
       (padic_val_rat p r))

p : nat,
hp : nat.prime p,
q r : rat,
h : @has_le.le.{0} int int.has_le (padic_val_rat p q) (padic_val_rat p r),
hnqp : @ge.{0} rat rat.has_le (padic_norm p q) (@has_zero.zero.{0} rat rat.has_zero),
hnrp : @ge.{0} rat rat.has_le (padic_norm p r) (@has_zero.zero.{0} rat rat.has_zero),
hq : not (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)),
hr : not (@eq.{1} rat r (@has_zero.zero.{0} rat rat.has_zero)),
hqr : not (@eq.{1} rat (@has_add.add.{0} rat rat.has_add q r) (@has_zero.zero.{0} rat rat.has_zero)),
this :
  @eq.{1} int (padic_val_rat p q)
    (@min.{0} int
       (@decidable_linear_ordered_semiring.to_decidable_linear_order.{0} int
          (@decidable_linear_ordered_comm_ring.to_decidable_linear_ordered_semiring.{0} int
             int.decidable_linear_ordered_comm_ring))
       (padic_val_rat p q)
       (padic_val_rat p r))
⊢ @has_le.le.{0} int
    (@preorder.to_has_le.{0} int
       (@partial_order.to_preorder.{0} int
          (@ordered_comm_group.to_partial_order.{0} int
             (@ordered_ring.to_ordered_comm_group.{0} int
                (@linear_ordered_ring.to_ordered_ring.{0} int
                   (@linear_ordered_comm_ring.to_linear_ordered_ring.{0} int
                      (@decidable_linear_ordered_comm_ring.to_linear_ordered_comm_ring.{0} int
                         int.decidable_linear_ordered_comm_ring)))))))
    (padic_val_rat p q)
    (padic_val_rat p (@has_add.add.{0} rat rat.has_add q r))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
q r : rat,
h : @has_le.le.{0} int int.has_le (padic_val_rat p q) (padic_val_rat p r),
hnqp : @ge.{0} rat rat.has_le (padic_norm p q) (@has_zero.zero.{0} rat rat.has_zero),
hnrp : @ge.{0} rat rat.has_le (padic_norm p r) (@has_zero.zero.{0} rat rat.has_zero),
hq : not (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)),
hr : not (@eq.{1} rat r (@has_zero.zero.{0} rat rat.has_zero)),
hqr : not (@eq.{1} rat (@has_add.add.{0} rat rat.has_add q r) (@has_zero.zero.{0} rat rat.has_zero)),
this :
  @eq.{1} int (padic_val_rat p q)
    (@min.{0} int
       (@decidable_linear_ordered_semiring.to_decidable_linear_order.{0} int
          (@decidable_linear_ordered_comm_ring.to_decidable_linear_ordered_semiring.{0} int
             int.decidable_linear_ordered_comm_ring))
       (padic_val_rat p q)
       (padic_val_rat p r))
⊢ @has_le.le.{0} int
    (@preorder.to_has_le.{0} int
       (@partial_order.to_preorder.{0} int
          (@ordered_comm_group.to_partial_order.{0} int
             (@ordered_ring.to_ordered_comm_group.{0} int
                (@linear_ordered_ring.to_ordered_ring.{0} int
                   (@linear_ordered_comm_ring.to_linear_ordered_ring.{0} int
                      (@decidable_linear_ordered_comm_ring.to_linear_ordered_comm_ring.{0} int
                         int.decidable_linear_ordered_comm_ring)))))))
    (padic_val_rat p q)
    (padic_val_rat p (@has_add.add.{0} rat rat.has_add q r))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>393        rw this,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{1} int (padic_val_rat p q) (@min.{0} int (@decidable_linear_ordered_semiring.to_decidable_linear_order.{0} int (@decidable_linear_ordered_comm_ring.to_decidable_linear_ordered_semiring.{0} int int.decidable_linear_ordered_comm_ring)) (padic_val_rat p q) (padic_val_rat p r))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
q r : rat,
h : @has_le.le.{0} int int.has_le (padic_val_rat p q) (padic_val_rat p r),
hnqp : @ge.{0} rat rat.has_le (padic_norm p q) (@has_zero.zero.{0} rat rat.has_zero),
hnrp : @ge.{0} rat rat.has_le (padic_norm p r) (@has_zero.zero.{0} rat rat.has_zero),
hq : not (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)),
hr : not (@eq.{1} rat r (@has_zero.zero.{0} rat rat.has_zero)),
hqr : not (@eq.{1} rat (@has_add.add.{0} rat rat.has_add q r) (@has_zero.zero.{0} rat rat.has_zero)),
this :
  @eq.{1} int (padic_val_rat p q)
    (@min.{0} int
       (@decidable_linear_ordered_semiring.to_decidable_linear_order.{0} int
          (@decidable_linear_ordered_comm_ring.to_decidable_linear_ordered_semiring.{0} int
             int.decidable_linear_ordered_comm_ring))
       (padic_val_rat p q)
       (padic_val_rat p r))
⊢ @has_le.le.{0} int
    (@preorder.to_has_le.{0} int
       (@partial_order.to_preorder.{0} int
          (@ordered_comm_group.to_partial_order.{0} int
             (@ordered_ring.to_ordered_comm_group.{0} int
                (@linear_ordered_ring.to_ordered_ring.{0} int
                   (@linear_ordered_comm_ring.to_linear_ordered_ring.{0} int
                      (@decidable_linear_ordered_comm_ring.to_linear_ordered_comm_ring.{0} int
                         int.decidable_linear_ordered_comm_ring)))))))
    (padic_val_rat p q)
    (padic_val_rat p (@has_add.add.{0} rat rat.has_add q r))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
q r : rat,
h : @has_le.le.{0} int int.has_le (padic_val_rat p q) (padic_val_rat p r),
hnqp : @ge.{0} rat rat.has_le (padic_norm p q) (@has_zero.zero.{0} rat rat.has_zero),
hnrp : @ge.{0} rat rat.has_le (padic_norm p r) (@has_zero.zero.{0} rat rat.has_zero),
hq : not (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)),
hr : not (@eq.{1} rat r (@has_zero.zero.{0} rat rat.has_zero)),
hqr : not (@eq.{1} rat (@has_add.add.{0} rat rat.has_add q r) (@has_zero.zero.{0} rat rat.has_zero)),
this :
  @eq.{1} int (padic_val_rat p q)
    (@min.{0} int
       (@decidable_linear_ordered_semiring.to_decidable_linear_order.{0} int
          (@decidable_linear_ordered_comm_ring.to_decidable_linear_ordered_semiring.{0} int
             int.decidable_linear_ordered_comm_ring))
       (padic_val_rat p q)
       (padic_val_rat p r))
⊢ @has_le.le.{0} int
    (@preorder.to_has_le.{0} int
       (@partial_order.to_preorder.{0} int
          (@ordered_comm_group.to_partial_order.{0} int
             (@ordered_ring.to_ordered_comm_group.{0} int
                (@linear_ordered_ring.to_ordered_ring.{0} int
                   (@linear_ordered_comm_ring.to_linear_ordered_ring.{0} int
                      (@decidable_linear_ordered_comm_ring.to_linear_ordered_comm_ring.{0} int
                         int.decidable_linear_ordered_comm_ring)))))))
    (@min.{0} int
       (@decidable_linear_ordered_semiring.to_decidable_linear_order.{0} int
          (@decidable_linear_ordered_comm_ring.to_decidable_linear_ordered_semiring.{0} int
             int.decidable_linear_ordered_comm_ring))
       (padic_val_rat p q)
       (padic_val_rat p r))
    (padic_val_rat p (@has_add.add.{0} rat rat.has_add q r))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>394        apply min_le_padic_val_rat_add; assumption }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='padic_val_rat.min_le_padic_val_rat_add'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 246, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 227, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (p : nat) [p_prime : nat.prime p] {q r : rat}, @ne.{1} rat q (@has_zero.zero.{0} rat rat.has_zero) → @ne.{1} rat r (@has_zero.zero.{0} rat rat.has_zero) → @ne.{1} rat (@has_add.add.{0} rat rat.has_add q r) (@has_zero.zero.{0} rat rat.has_zero) → @has_le.le.{0} int int.has_le (@min.{0} int (@decidable_linear_ordered_semiring.to_decidable_linear_order.{0} int (@decidable_linear_ordered_comm_ring.to_decidable_linear_ordered_semiring.{0} int int.decidable_linear_ordered_comm_ring)) (padic_val_rat p q) (padic_val_rat p r)) (padic_val_rat p (@has_add.add.{0} rat rat.has_add q r))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The minimum of the valuations of `q` and `r` is less than or equal to the valuation of `q + r`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic looks in the local context for a hypothesis whose type is equal to the goal target. If it finds one, it uses it to prove the goal, and otherwise it fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='teal'><a title='assumption'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
q r : rat,
h : @has_le.le.{0} int int.has_le (padic_val_rat p q) (padic_val_rat p r),
hnqp : @ge.{0} rat rat.has_le (padic_norm p q) (@has_zero.zero.{0} rat rat.has_zero),
hnrp : @ge.{0} rat rat.has_le (padic_norm p r) (@has_zero.zero.{0} rat rat.has_zero),
hq : not (@eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)),
hr : not (@eq.{1} rat r (@has_zero.zero.{0} rat rat.has_zero)),
hqr : not (@eq.{1} rat (@has_add.add.{0} rat rat.has_add q r) (@has_zero.zero.{0} rat rat.has_zero)),
this :
  @eq.{1} int (padic_val_rat p q)
    (@min.{0} int
       (@decidable_linear_ordered_semiring.to_decidable_linear_order.{0} int
          (@decidable_linear_ordered_comm_ring.to_decidable_linear_ordered_semiring.{0} int
             int.decidable_linear_ordered_comm_ring))
       (padic_val_rat p q)
       (padic_val_rat p r))
⊢ @has_le.le.{0} int
    (@preorder.to_has_le.{0} int
       (@partial_order.to_preorder.{0} int
          (@ordered_comm_group.to_partial_order.{0} int
             (@ordered_ring.to_ordered_comm_group.{0} int
                (@linear_ordered_ring.to_ordered_ring.{0} int
                   (@linear_ordered_comm_ring.to_linear_ordered_ring.{0} int
                      (@decidable_linear_ordered_comm_ring.to_linear_ordered_comm_ring.{0} int
                         int.decidable_linear_ordered_comm_ring)))))))
    (@min.{0} int
       (@decidable_linear_ordered_semiring.to_decidable_linear_order.{0} int
          (@decidable_linear_ordered_comm_ring.to_decidable_linear_ordered_semiring.{0} int
             int.decidable_linear_ordered_comm_ring))
       (padic_val_rat p q)
       (padic_val_rat p r))
    (padic_val_rat p (@has_add.add.{0} rat rat.has_add q r))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>395    end</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hqr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='not (@eq.{1} rat (@has_add.add.{0} rat rat.has_add q r) (@has_zero.zero.{0} rat rat.has_zero))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>396  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>397  /--</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>398  The p-adic norm is nonarchimedean: the norm of `p + q` is at most the max of the norm of `p` and</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>399  the norm of `q`.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>400  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>401  protected theorem nonarchimedean {q r : ℚ} :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='blue'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/rat/basic.lean&#x27;, &#x27;line&#x27;: 46, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='orange'><a title='`rat`, or `ℚ`, is the type of rational numbers. It is defined
 as the set of pairs ⟨n, d⟩ of integers such that `d` is positive and `n` and
 `d` are coprime. This representation is preferred to the quotient
 because without periodic reduction, the numerator and denominator can grow
 exponentially (for example, adding 1/2 to itself repeatedly).'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>402    padic_norm p (q + r) ≤ max (padic_norm p q) (padic_norm p r) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='padic_norm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='q'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='r'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_le.le'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='max'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='padic_norm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='q'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='padic_norm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='r'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 261, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 319, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/functions.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 11}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 261, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;line&#x27;: 261, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='nat → rat → rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_add.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type} [c : has_le.{0} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [_inst_1 : decidable_linear_order.{u} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='nat → rat → rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='nat → rat → rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='If `q ≠ 0`, the p-adic norm of a rational `q` is `p ^ (-(padic_val_rat p q))`.
If `q = 0`, the p-adic norm of `q` is 0.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='If `q ≠ 0`, the p-adic norm of a rational `q` is `p ^ (-(padic_val_rat p q))`.
If `q = 0`, the p-adic norm of `q` is 0.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='If `q ≠ 0`, the p-adic norm of a rational `q` is `p ^ (-(padic_val_rat p q))`.
If `q = 0`, the p-adic norm of `q` is 0.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>403  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
q r : rat
⊢ @has_le.le.{0} rat rat.has_le (padic_norm p (@has_add.add.{0} rat rat.has_add q r))
    (@max.{0} rat rat.decidable_linear_order (padic_norm p q) (padic_norm p r))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>404      wlog hle := le_total (padic_val_rat p q) (padic_val_rat p r) using [q r],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='le_total'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='blue'><a title='q'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='padic_val_rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='r'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/wlog.lean&#x27;, &#x27;line&#x27;: 153, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 57, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/wlog.lean&#x27;, &#x27;line&#x27;: 153, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/wlog.lean&#x27;, &#x27;line&#x27;: 153, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/wlog.lean&#x27;, &#x27;line&#x27;: 153, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/wlog.lean&#x27;, &#x27;line&#x27;: 153, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 62, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/wlog.lean&#x27;, &#x27;line&#x27;: 153, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/wlog.lean&#x27;, &#x27;line&#x27;: 153, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/wlog.lean&#x27;, &#x27;line&#x27;: 153, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} (list.{0} (list.{0} name))) (λ (a : option.{0} (list.{0} (list.{0} name))), @option.has_reflect (list.{0} (list.{0} name)) (λ (a : list.{0} (list.{0} name)), @list.reflect (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) `(list.{0} name) a) `(list.{0} (list.{0} name)) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative (list.{0} (list.{0} name)) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit (list.{0} (list.{0} name)) (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) (@has_orelse.orelse.{0 0} lean.parser.{0} (@alternative.to_has_orelse.{0 0} lean.parser.{0} lean.parser.alternative) (list.{0} (list.{0} name)) (@interactive.types.list_of (list.{0} name) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident)) (@functor.map.{0 0} lean.parser.{0} (@applicative.to_functor.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) (list.{0} name) (list.{0} (list.{0} name)) (λ (x : list.{0} name), @list.cons.{0} (list.{0} name) x (@list.nil.{0} (list.{0} name))) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident))))) → opt_param.{1} (tactic.{0} unit) (@has_orelse.orelse.{0 0} tactic.{0} (@alternative.to_has_orelse.{0 0} tactic.{0} tactic.alternative.{0}) unit (tactic.solve_by_elim {backtrack_all_goals := bool.ff, discharger := tactic.done, assumptions := tactic.mk_assumption_set (@decidable.to_bool false decidable.false) (@list.nil.{0} tactic.simp_arg_type) (@list.nil.{0} name), max_rep := @bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)}) (@has_orelse.orelse.{0 0} tactic.{0} (@alternative.to_has_orelse.{0 0} tactic.{0} tactic.alternative.{0}) unit (tactic.tautology bool.tt) (@using_smt unit (@has_bind.and_then.{0 0} unit unit smt_tactic (@monad.to_has_bind.{0 0} smt_tactic smt_tactic.monad) smt_tactic.intros smt_tactic.solve_goals) {cc_cfg := {ignore_instances := bool.tt, ac := bool.tt, ho_fns := @option.none.{0} (list.{0} name), em := bool.tt}, em_cfg := {max_instances := @bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))), max_generation := @bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))}, pre_cfg := {simp_attr := name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) name.anonymous, max_steps := @bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))))))))), zeta := bool.ff}, em_attr := name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) name.anonymous}))) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : linear_order.{0} α] (a b : α), or (@has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@linear_order.to_partial_order.{0} α _inst_1))) a b) (@has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@linear_order.to_partial_order.{0} α _inst_1))) b a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} (list.{0} (list.{0} name))) (λ (a : option.{0} (list.{0} (list.{0} name))), @option.has_reflect (list.{0} (list.{0} name)) (λ (a : list.{0} (list.{0} name)), @list.reflect (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) `(list.{0} name) a) `(list.{0} (list.{0} name)) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative (list.{0} (list.{0} name)) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit (list.{0} (list.{0} name)) (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) (@has_orelse.orelse.{0 0} lean.parser.{0} (@alternative.to_has_orelse.{0 0} lean.parser.{0} lean.parser.alternative) (list.{0} (list.{0} name)) (@interactive.types.list_of (list.{0} name) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident)) (@functor.map.{0 0} lean.parser.{0} (@applicative.to_functor.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) (list.{0} name) (list.{0} (list.{0} name)) (λ (x : list.{0} name), @list.cons.{0} (list.{0} name) x (@list.nil.{0} (list.{0} name))) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident))))) → opt_param.{1} (tactic.{0} unit) (@has_orelse.orelse.{0 0} tactic.{0} (@alternative.to_has_orelse.{0 0} tactic.{0} tactic.alternative.{0}) unit (tactic.solve_by_elim {backtrack_all_goals := bool.ff, discharger := tactic.done, assumptions := tactic.mk_assumption_set (@decidable.to_bool false decidable.false) (@list.nil.{0} tactic.simp_arg_type) (@list.nil.{0} name), max_rep := @bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)}) (@has_orelse.orelse.{0 0} tactic.{0} (@alternative.to_has_orelse.{0 0} tactic.{0} tactic.alternative.{0}) unit (tactic.tautology bool.tt) (@using_smt unit (@has_bind.and_then.{0 0} unit unit smt_tactic (@monad.to_has_bind.{0 0} smt_tactic smt_tactic.monad) smt_tactic.intros smt_tactic.solve_goals) {cc_cfg := {ignore_instances := bool.tt, ac := bool.tt, ho_fns := @option.none.{0} (list.{0} name), em := bool.tt}, em_cfg := {max_instances := @bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))), max_generation := @bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))}, pre_cfg := {simp_attr := name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) name.anonymous, max_steps := @bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))))))))), zeta := bool.ff}, em_attr := name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) name.anonymous}))) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} (list.{0} (list.{0} name))) (λ (a : option.{0} (list.{0} (list.{0} name))), @option.has_reflect (list.{0} (list.{0} name)) (λ (a : list.{0} (list.{0} name)), @list.reflect (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) `(list.{0} name) a) `(list.{0} (list.{0} name)) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative (list.{0} (list.{0} name)) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit (list.{0} (list.{0} name)) (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) (@has_orelse.orelse.{0 0} lean.parser.{0} (@alternative.to_has_orelse.{0 0} lean.parser.{0} lean.parser.alternative) (list.{0} (list.{0} name)) (@interactive.types.list_of (list.{0} name) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident)) (@functor.map.{0 0} lean.parser.{0} (@applicative.to_functor.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) (list.{0} name) (list.{0} (list.{0} name)) (λ (x : list.{0} name), @list.cons.{0} (list.{0} name) x (@list.nil.{0} (list.{0} name))) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident))))) → opt_param.{1} (tactic.{0} unit) (@has_orelse.orelse.{0 0} tactic.{0} (@alternative.to_has_orelse.{0 0} tactic.{0} tactic.alternative.{0}) unit (tactic.solve_by_elim {backtrack_all_goals := bool.ff, discharger := tactic.done, assumptions := tactic.mk_assumption_set (@decidable.to_bool false decidable.false) (@list.nil.{0} tactic.simp_arg_type) (@list.nil.{0} name), max_rep := @bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)}) (@has_orelse.orelse.{0 0} tactic.{0} (@alternative.to_has_orelse.{0 0} tactic.{0} tactic.alternative.{0}) unit (tactic.tautology bool.tt) (@using_smt unit (@has_bind.and_then.{0 0} unit unit smt_tactic (@monad.to_has_bind.{0 0} smt_tactic smt_tactic.monad) smt_tactic.intros smt_tactic.solve_goals) {cc_cfg := {ignore_instances := bool.tt, ac := bool.tt, ho_fns := @option.none.{0} (list.{0} name), em := bool.tt}, em_cfg := {max_instances := @bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))), max_generation := @bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))}, pre_cfg := {simp_attr := name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) name.anonymous, max_steps := @bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))))))))), zeta := bool.ff}, em_attr := name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) name.anonymous}))) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} (list.{0} (list.{0} name))) (λ (a : option.{0} (list.{0} (list.{0} name))), @option.has_reflect (list.{0} (list.{0} name)) (λ (a : list.{0} (list.{0} name)), @list.reflect (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) `(list.{0} name) a) `(list.{0} (list.{0} name)) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative (list.{0} (list.{0} name)) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit (list.{0} (list.{0} name)) (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) (@has_orelse.orelse.{0 0} lean.parser.{0} (@alternative.to_has_orelse.{0 0} lean.parser.{0} lean.parser.alternative) (list.{0} (list.{0} name)) (@interactive.types.list_of (list.{0} name) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident)) (@functor.map.{0 0} lean.parser.{0} (@applicative.to_functor.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) (list.{0} name) (list.{0} (list.{0} name)) (λ (x : list.{0} name), @list.cons.{0} (list.{0} name) x (@list.nil.{0} (list.{0} name))) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident))))) → opt_param.{1} (tactic.{0} unit) (@has_orelse.orelse.{0 0} tactic.{0} (@alternative.to_has_orelse.{0 0} tactic.{0} tactic.alternative.{0}) unit (tactic.solve_by_elim {backtrack_all_goals := bool.ff, discharger := tactic.done, assumptions := tactic.mk_assumption_set (@decidable.to_bool false decidable.false) (@list.nil.{0} tactic.simp_arg_type) (@list.nil.{0} name), max_rep := @bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)}) (@has_orelse.orelse.{0 0} tactic.{0} (@alternative.to_has_orelse.{0 0} tactic.{0} tactic.alternative.{0}) unit (tactic.tautology bool.tt) (@using_smt unit (@has_bind.and_then.{0 0} unit unit smt_tactic (@monad.to_has_bind.{0 0} smt_tactic smt_tactic.monad) smt_tactic.intros smt_tactic.solve_goals) {cc_cfg := {ignore_instances := bool.tt, ac := bool.tt, ho_fns := @option.none.{0} (list.{0} name), em := bool.tt}, em_cfg := {max_instances := @bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))), max_generation := @bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))}, pre_cfg := {simp_attr := name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) name.anonymous, max_steps := @bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))))))))), zeta := bool.ff}, em_attr := name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) name.anonymous}))) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} (list.{0} (list.{0} name))) (λ (a : option.{0} (list.{0} (list.{0} name))), @option.has_reflect (list.{0} (list.{0} name)) (λ (a : list.{0} (list.{0} name)), @list.reflect (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) `(list.{0} name) a) `(list.{0} (list.{0} name)) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative (list.{0} (list.{0} name)) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit (list.{0} (list.{0} name)) (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) (@has_orelse.orelse.{0 0} lean.parser.{0} (@alternative.to_has_orelse.{0 0} lean.parser.{0} lean.parser.alternative) (list.{0} (list.{0} name)) (@interactive.types.list_of (list.{0} name) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident)) (@functor.map.{0 0} lean.parser.{0} (@applicative.to_functor.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) (list.{0} name) (list.{0} (list.{0} name)) (λ (x : list.{0} name), @list.cons.{0} (list.{0} name) x (@list.nil.{0} (list.{0} name))) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident))))) → opt_param.{1} (tactic.{0} unit) (@has_orelse.orelse.{0 0} tactic.{0} (@alternative.to_has_orelse.{0 0} tactic.{0} tactic.alternative.{0}) unit (tactic.solve_by_elim {backtrack_all_goals := bool.ff, discharger := tactic.done, assumptions := tactic.mk_assumption_set (@decidable.to_bool false decidable.false) (@list.nil.{0} tactic.simp_arg_type) (@list.nil.{0} name), max_rep := @bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)}) (@has_orelse.orelse.{0 0} tactic.{0} (@alternative.to_has_orelse.{0 0} tactic.{0} tactic.alternative.{0}) unit (tactic.tautology bool.tt) (@using_smt unit (@has_bind.and_then.{0 0} unit unit smt_tactic (@monad.to_has_bind.{0 0} smt_tactic smt_tactic.monad) smt_tactic.intros smt_tactic.solve_goals) {cc_cfg := {ignore_instances := bool.tt, ac := bool.tt, ho_fns := @option.none.{0} (list.{0} name), em := bool.tt}, em_cfg := {max_instances := @bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))), max_generation := @bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))}, pre_cfg := {simp_attr := name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) name.anonymous, max_steps := @bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))))))))), zeta := bool.ff}, em_attr := name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) name.anonymous}))) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat → rat → int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} (list.{0} (list.{0} name))) (λ (a : option.{0} (list.{0} (list.{0} name))), @option.has_reflect (list.{0} (list.{0} name)) (λ (a : list.{0} (list.{0} name)), @list.reflect (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) `(list.{0} name) a) `(list.{0} (list.{0} name)) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative (list.{0} (list.{0} name)) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit (list.{0} (list.{0} name)) (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) (@has_orelse.orelse.{0 0} lean.parser.{0} (@alternative.to_has_orelse.{0 0} lean.parser.{0} lean.parser.alternative) (list.{0} (list.{0} name)) (@interactive.types.list_of (list.{0} name) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident)) (@functor.map.{0 0} lean.parser.{0} (@applicative.to_functor.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) (list.{0} name) (list.{0} (list.{0} name)) (λ (x : list.{0} name), @list.cons.{0} (list.{0} name) x (@list.nil.{0} (list.{0} name))) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident))))) → opt_param.{1} (tactic.{0} unit) (@has_orelse.orelse.{0 0} tactic.{0} (@alternative.to_has_orelse.{0 0} tactic.{0} tactic.alternative.{0}) unit (tactic.solve_by_elim {backtrack_all_goals := bool.ff, discharger := tactic.done, assumptions := tactic.mk_assumption_set (@decidable.to_bool false decidable.false) (@list.nil.{0} tactic.simp_arg_type) (@list.nil.{0} name), max_rep := @bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)}) (@has_orelse.orelse.{0 0} tactic.{0} (@alternative.to_has_orelse.{0 0} tactic.{0} tactic.alternative.{0}) unit (tactic.tautology bool.tt) (@using_smt unit (@has_bind.and_then.{0 0} unit unit smt_tactic (@monad.to_has_bind.{0 0} smt_tactic smt_tactic.monad) smt_tactic.intros smt_tactic.solve_goals) {cc_cfg := {ignore_instances := bool.tt, ac := bool.tt, ho_fns := @option.none.{0} (list.{0} name), em := bool.tt}, em_cfg := {max_instances := @bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))), max_generation := @bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))}, pre_cfg := {simp_attr := name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) name.anonymous, max_steps := @bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))))))))), zeta := bool.ff}, em_attr := name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) name.anonymous}))) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} (list.{0} (list.{0} name))) (λ (a : option.{0} (list.{0} (list.{0} name))), @option.has_reflect (list.{0} (list.{0} name)) (λ (a : list.{0} (list.{0} name)), @list.reflect (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) `(list.{0} name) a) `(list.{0} (list.{0} name)) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative (list.{0} (list.{0} name)) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit (list.{0} (list.{0} name)) (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) (@has_orelse.orelse.{0 0} lean.parser.{0} (@alternative.to_has_orelse.{0 0} lean.parser.{0} lean.parser.alternative) (list.{0} (list.{0} name)) (@interactive.types.list_of (list.{0} name) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident)) (@functor.map.{0 0} lean.parser.{0} (@applicative.to_functor.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) (list.{0} name) (list.{0} (list.{0} name)) (λ (x : list.{0} name), @list.cons.{0} (list.{0} name) x (@list.nil.{0} (list.{0} name))) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident))))) → opt_param.{1} (tactic.{0} unit) (@has_orelse.orelse.{0 0} tactic.{0} (@alternative.to_has_orelse.{0 0} tactic.{0} tactic.alternative.{0}) unit (tactic.solve_by_elim {backtrack_all_goals := bool.ff, discharger := tactic.done, assumptions := tactic.mk_assumption_set (@decidable.to_bool false decidable.false) (@list.nil.{0} tactic.simp_arg_type) (@list.nil.{0} name), max_rep := @bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)}) (@has_orelse.orelse.{0 0} tactic.{0} (@alternative.to_has_orelse.{0 0} tactic.{0} tactic.alternative.{0}) unit (tactic.tautology bool.tt) (@using_smt unit (@has_bind.and_then.{0 0} unit unit smt_tactic (@monad.to_has_bind.{0 0} smt_tactic smt_tactic.monad) smt_tactic.intros smt_tactic.solve_goals) {cc_cfg := {ignore_instances := bool.tt, ac := bool.tt, ho_fns := @option.none.{0} (list.{0} name), em := bool.tt}, em_cfg := {max_instances := @bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))), max_generation := @bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))}, pre_cfg := {simp_attr := name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) name.anonymous, max_steps := @bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))))))))), zeta := bool.ff}, em_attr := name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) name.anonymous}))) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} (list.{0} (list.{0} name))) (λ (a : option.{0} (list.{0} (list.{0} name))), @option.has_reflect (list.{0} (list.{0} name)) (λ (a : list.{0} (list.{0} name)), @list.reflect (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) `(list.{0} name) a) `(list.{0} (list.{0} name)) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative (list.{0} (list.{0} name)) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit (list.{0} (list.{0} name)) (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) (@has_orelse.orelse.{0 0} lean.parser.{0} (@alternative.to_has_orelse.{0 0} lean.parser.{0} lean.parser.alternative) (list.{0} (list.{0} name)) (@interactive.types.list_of (list.{0} name) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident)) (@functor.map.{0 0} lean.parser.{0} (@applicative.to_functor.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) (list.{0} name) (list.{0} (list.{0} name)) (λ (x : list.{0} name), @list.cons.{0} (list.{0} name) x (@list.nil.{0} (list.{0} name))) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident))))) → opt_param.{1} (tactic.{0} unit) (@has_orelse.orelse.{0 0} tactic.{0} (@alternative.to_has_orelse.{0 0} tactic.{0} tactic.alternative.{0}) unit (tactic.solve_by_elim {backtrack_all_goals := bool.ff, discharger := tactic.done, assumptions := tactic.mk_assumption_set (@decidable.to_bool false decidable.false) (@list.nil.{0} tactic.simp_arg_type) (@list.nil.{0} name), max_rep := @bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)}) (@has_orelse.orelse.{0 0} tactic.{0} (@alternative.to_has_orelse.{0 0} tactic.{0} tactic.alternative.{0}) unit (tactic.tautology bool.tt) (@using_smt unit (@has_bind.and_then.{0 0} unit unit smt_tactic (@monad.to_has_bind.{0 0} smt_tactic smt_tactic.monad) smt_tactic.intros smt_tactic.solve_goals) {cc_cfg := {ignore_instances := bool.tt, ac := bool.tt, ho_fns := @option.none.{0} (list.{0} name), em := bool.tt}, em_cfg := {max_instances := @bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))), max_generation := @bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))}, pre_cfg := {simp_attr := name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) name.anonymous, max_steps := @bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))))))))), zeta := bool.ff}, em_attr := name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) name.anonymous}))) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title=' Without loss of generality: reduces to one goal under variables permutations.

Given a goal of the form `g xs`, a predicate `p` over a set of variables, as well as variable
permutations `xs_i`. Then `wlog` produces goals of the form

The case goal, i.e. the permutation `xs_i` covers all possible cases:
  `⊢ p xs_0 ∨ ⋯ ∨ p xs_n`
The main goal, i.e. the goal reduced to `xs_0`:
  `(h : p xs_0) ⊢ g xs_0`
The invariant goals, i.e. `g` is invariant under `xs_i`:
  `(h : p xs_i) (this : g xs_0) ⊢ gs xs_i`

Either the permutation is provided, or a proof of the disjunction is provided to compute the
permutation. The disjunction need to be in assoc normal form, e.g. `p₀ ∨ (p₁ ∨ p₂)`. In many cases
the invariant goals can be solved by AC rewriting using `cc` etc.

Example:
  On a state `(n m : ℕ) ⊢ p n m` the tactic `wlog h : n ≤ m using [n m, m n]` produces the following
  states:
    `(n m : ℕ) ⊢ n ≤ m ∨ m ≤ n`
    `(n m : ℕ) (h : n ≤ m) ⊢ p n m`
    `(n m : ℕ) (h : m ≤ n) (this : p n m) ⊢ p m n`

`wlog` supports different calling conventions. The name `h` is used to give a name to the introduced
case hypothesis. If the name is avoided, the default will be `case`.

(1) `wlog : p xs0 using [xs0, …, xsn]`
  Results in the case goal `p xs0 ∨ ⋯ ∨ ps xsn`, the main goal `(case : p xs0) ⊢ g xs0` and the
  invariance goals `(case : p xsi) (this : g xs0) ⊢ g xsi`.

(2) `wlog : p xs0 := r using xs0`
  The expression `r` is a proof of the shape `p xs0 ∨ ⋯ ∨ p xsi`, it is also used to compute the
  variable permutations.

(3) `wlog := r using xs0`
  The expression `r` is a proof of the shape `p xs0 ∨ ⋯ ∨ p xsi`, it is also used to compute the
  variable permutations. This is not as stable as (2), for example `p` cannot be a disjunction.

(4) `wlog : R x y using x y` and `wlog : R x y`
  Produces the case `R x y ∨ R y x`. If `R` is ≤, then the disjunction discharged using linearity.
  If `using x y` is avoided then `x` and `y` are the last two variables appearing in the
  expression `R x y`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title=' Without loss of generality: reduces to one goal under variables permutations.

Given a goal of the form `g xs`, a predicate `p` over a set of variables, as well as variable
permutations `xs_i`. Then `wlog` produces goals of the form

The case goal, i.e. the permutation `xs_i` covers all possible cases:
  `⊢ p xs_0 ∨ ⋯ ∨ p xs_n`
The main goal, i.e. the goal reduced to `xs_0`:
  `(h : p xs_0) ⊢ g xs_0`
The invariant goals, i.e. `g` is invariant under `xs_i`:
  `(h : p xs_i) (this : g xs_0) ⊢ gs xs_i`

Either the permutation is provided, or a proof of the disjunction is provided to compute the
permutation. The disjunction need to be in assoc normal form, e.g. `p₀ ∨ (p₁ ∨ p₂)`. In many cases
the invariant goals can be solved by AC rewriting using `cc` etc.

Example:
  On a state `(n m : ℕ) ⊢ p n m` the tactic `wlog h : n ≤ m using [n m, m n]` produces the following
  states:
    `(n m : ℕ) ⊢ n ≤ m ∨ m ≤ n`
    `(n m : ℕ) (h : n ≤ m) ⊢ p n m`
    `(n m : ℕ) (h : m ≤ n) (this : p n m) ⊢ p m n`

`wlog` supports different calling conventions. The name `h` is used to give a name to the introduced
case hypothesis. If the name is avoided, the default will be `case`.

(1) `wlog : p xs0 using [xs0, …, xsn]`
  Results in the case goal `p xs0 ∨ ⋯ ∨ ps xsn`, the main goal `(case : p xs0) ⊢ g xs0` and the
  invariance goals `(case : p xsi) (this : g xs0) ⊢ g xsi`.

(2) `wlog : p xs0 := r using xs0`
  The expression `r` is a proof of the shape `p xs0 ∨ ⋯ ∨ p xsi`, it is also used to compute the
  variable permutations.

(3) `wlog := r using xs0`
  The expression `r` is a proof of the shape `p xs0 ∨ ⋯ ∨ p xsi`, it is also used to compute the
  variable permutations. This is not as stable as (2), for example `p` cannot be a disjunction.

(4) `wlog : R x y using x y` and `wlog : R x y`
  Produces the case `R x y ∨ R y x`. If `R` is ≤, then the disjunction discharged using linearity.
  If `using x y` is avoided then `x` and `y` are the last two variables appearing in the
  expression `R x y`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title=' Without loss of generality: reduces to one goal under variables permutations.

Given a goal of the form `g xs`, a predicate `p` over a set of variables, as well as variable
permutations `xs_i`. Then `wlog` produces goals of the form

The case goal, i.e. the permutation `xs_i` covers all possible cases:
  `⊢ p xs_0 ∨ ⋯ ∨ p xs_n`
The main goal, i.e. the goal reduced to `xs_0`:
  `(h : p xs_0) ⊢ g xs_0`
The invariant goals, i.e. `g` is invariant under `xs_i`:
  `(h : p xs_i) (this : g xs_0) ⊢ gs xs_i`

Either the permutation is provided, or a proof of the disjunction is provided to compute the
permutation. The disjunction need to be in assoc normal form, e.g. `p₀ ∨ (p₁ ∨ p₂)`. In many cases
the invariant goals can be solved by AC rewriting using `cc` etc.

Example:
  On a state `(n m : ℕ) ⊢ p n m` the tactic `wlog h : n ≤ m using [n m, m n]` produces the following
  states:
    `(n m : ℕ) ⊢ n ≤ m ∨ m ≤ n`
    `(n m : ℕ) (h : n ≤ m) ⊢ p n m`
    `(n m : ℕ) (h : m ≤ n) (this : p n m) ⊢ p m n`

`wlog` supports different calling conventions. The name `h` is used to give a name to the introduced
case hypothesis. If the name is avoided, the default will be `case`.

(1) `wlog : p xs0 using [xs0, …, xsn]`
  Results in the case goal `p xs0 ∨ ⋯ ∨ ps xsn`, the main goal `(case : p xs0) ⊢ g xs0` and the
  invariance goals `(case : p xsi) (this : g xs0) ⊢ g xsi`.

(2) `wlog : p xs0 := r using xs0`
  The expression `r` is a proof of the shape `p xs0 ∨ ⋯ ∨ p xsi`, it is also used to compute the
  variable permutations.

(3) `wlog := r using xs0`
  The expression `r` is a proof of the shape `p xs0 ∨ ⋯ ∨ p xsi`, it is also used to compute the
  variable permutations. This is not as stable as (2), for example `p` cannot be a disjunction.

(4) `wlog : R x y using x y` and `wlog : R x y`
  Produces the case `R x y ∨ R y x`. If `R` is ≤, then the disjunction discharged using linearity.
  If `using x y` is avoided then `x` and `y` are the last two variables appearing in the
  expression `R x y`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title=' Without loss of generality: reduces to one goal under variables permutations.

Given a goal of the form `g xs`, a predicate `p` over a set of variables, as well as variable
permutations `xs_i`. Then `wlog` produces goals of the form

The case goal, i.e. the permutation `xs_i` covers all possible cases:
  `⊢ p xs_0 ∨ ⋯ ∨ p xs_n`
The main goal, i.e. the goal reduced to `xs_0`:
  `(h : p xs_0) ⊢ g xs_0`
The invariant goals, i.e. `g` is invariant under `xs_i`:
  `(h : p xs_i) (this : g xs_0) ⊢ gs xs_i`

Either the permutation is provided, or a proof of the disjunction is provided to compute the
permutation. The disjunction need to be in assoc normal form, e.g. `p₀ ∨ (p₁ ∨ p₂)`. In many cases
the invariant goals can be solved by AC rewriting using `cc` etc.

Example:
  On a state `(n m : ℕ) ⊢ p n m` the tactic `wlog h : n ≤ m using [n m, m n]` produces the following
  states:
    `(n m : ℕ) ⊢ n ≤ m ∨ m ≤ n`
    `(n m : ℕ) (h : n ≤ m) ⊢ p n m`
    `(n m : ℕ) (h : m ≤ n) (this : p n m) ⊢ p m n`

`wlog` supports different calling conventions. The name `h` is used to give a name to the introduced
case hypothesis. If the name is avoided, the default will be `case`.

(1) `wlog : p xs0 using [xs0, …, xsn]`
  Results in the case goal `p xs0 ∨ ⋯ ∨ ps xsn`, the main goal `(case : p xs0) ⊢ g xs0` and the
  invariance goals `(case : p xsi) (this : g xs0) ⊢ g xsi`.

(2) `wlog : p xs0 := r using xs0`
  The expression `r` is a proof of the shape `p xs0 ∨ ⋯ ∨ p xsi`, it is also used to compute the
  variable permutations.

(3) `wlog := r using xs0`
  The expression `r` is a proof of the shape `p xs0 ∨ ⋯ ∨ p xsi`, it is also used to compute the
  variable permutations. This is not as stable as (2), for example `p` cannot be a disjunction.

(4) `wlog : R x y using x y` and `wlog : R x y`
  Produces the case `R x y ∨ R y x`. If `R` is ≤, then the disjunction discharged using linearity.
  If `using x y` is avoided then `x` and `y` are the last two variables appearing in the
  expression `R x y`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title=' Without loss of generality: reduces to one goal under variables permutations.

Given a goal of the form `g xs`, a predicate `p` over a set of variables, as well as variable
permutations `xs_i`. Then `wlog` produces goals of the form

The case goal, i.e. the permutation `xs_i` covers all possible cases:
  `⊢ p xs_0 ∨ ⋯ ∨ p xs_n`
The main goal, i.e. the goal reduced to `xs_0`:
  `(h : p xs_0) ⊢ g xs_0`
The invariant goals, i.e. `g` is invariant under `xs_i`:
  `(h : p xs_i) (this : g xs_0) ⊢ gs xs_i`

Either the permutation is provided, or a proof of the disjunction is provided to compute the
permutation. The disjunction need to be in assoc normal form, e.g. `p₀ ∨ (p₁ ∨ p₂)`. In many cases
the invariant goals can be solved by AC rewriting using `cc` etc.

Example:
  On a state `(n m : ℕ) ⊢ p n m` the tactic `wlog h : n ≤ m using [n m, m n]` produces the following
  states:
    `(n m : ℕ) ⊢ n ≤ m ∨ m ≤ n`
    `(n m : ℕ) (h : n ≤ m) ⊢ p n m`
    `(n m : ℕ) (h : m ≤ n) (this : p n m) ⊢ p m n`

`wlog` supports different calling conventions. The name `h` is used to give a name to the introduced
case hypothesis. If the name is avoided, the default will be `case`.

(1) `wlog : p xs0 using [xs0, …, xsn]`
  Results in the case goal `p xs0 ∨ ⋯ ∨ ps xsn`, the main goal `(case : p xs0) ⊢ g xs0` and the
  invariance goals `(case : p xsi) (this : g xs0) ⊢ g xsi`.

(2) `wlog : p xs0 := r using xs0`
  The expression `r` is a proof of the shape `p xs0 ∨ ⋯ ∨ p xsi`, it is also used to compute the
  variable permutations.

(3) `wlog := r using xs0`
  The expression `r` is a proof of the shape `p xs0 ∨ ⋯ ∨ p xsi`, it is also used to compute the
  variable permutations. This is not as stable as (2), for example `p` cannot be a disjunction.

(4) `wlog : R x y using x y` and `wlog : R x y`
  Produces the case `R x y ∨ R y x`. If `R` is ≤, then the disjunction discharged using linearity.
  If `using x y` is avoided then `x` and `y` are the last two variables appearing in the
  expression `R x y`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='For `p ≠ 1`, the p-adic valuation of an integer `z ≠ 0` is the largest natural number `n` such that
p^n divides z.

`padic_val_rat` defines the valuation of a rational `q` to be the valuation of `q.num` minus the
valuation of `q.denom`.
If `q = 0` or `p = 1`, then `padic_val_rat p q` defaults to 0.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title=' Without loss of generality: reduces to one goal under variables permutations.

Given a goal of the form `g xs`, a predicate `p` over a set of variables, as well as variable
permutations `xs_i`. Then `wlog` produces goals of the form

The case goal, i.e. the permutation `xs_i` covers all possible cases:
  `⊢ p xs_0 ∨ ⋯ ∨ p xs_n`
The main goal, i.e. the goal reduced to `xs_0`:
  `(h : p xs_0) ⊢ g xs_0`
The invariant goals, i.e. `g` is invariant under `xs_i`:
  `(h : p xs_i) (this : g xs_0) ⊢ gs xs_i`

Either the permutation is provided, or a proof of the disjunction is provided to compute the
permutation. The disjunction need to be in assoc normal form, e.g. `p₀ ∨ (p₁ ∨ p₂)`. In many cases
the invariant goals can be solved by AC rewriting using `cc` etc.

Example:
  On a state `(n m : ℕ) ⊢ p n m` the tactic `wlog h : n ≤ m using [n m, m n]` produces the following
  states:
    `(n m : ℕ) ⊢ n ≤ m ∨ m ≤ n`
    `(n m : ℕ) (h : n ≤ m) ⊢ p n m`
    `(n m : ℕ) (h : m ≤ n) (this : p n m) ⊢ p m n`

`wlog` supports different calling conventions. The name `h` is used to give a name to the introduced
case hypothesis. If the name is avoided, the default will be `case`.

(1) `wlog : p xs0 using [xs0, …, xsn]`
  Results in the case goal `p xs0 ∨ ⋯ ∨ ps xsn`, the main goal `(case : p xs0) ⊢ g xs0` and the
  invariance goals `(case : p xsi) (this : g xs0) ⊢ g xsi`.

(2) `wlog : p xs0 := r using xs0`
  The expression `r` is a proof of the shape `p xs0 ∨ ⋯ ∨ p xsi`, it is also used to compute the
  variable permutations.

(3) `wlog := r using xs0`
  The expression `r` is a proof of the shape `p xs0 ∨ ⋯ ∨ p xsi`, it is also used to compute the
  variable permutations. This is not as stable as (2), for example `p` cannot be a disjunction.

(4) `wlog : R x y using x y` and `wlog : R x y`
  Produces the case `R x y ∨ R y x`. If `R` is ≤, then the disjunction discharged using linearity.
  If `using x y` is avoided then `x` and `y` are the last two variables appearing in the
  expression `R x y`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title=' Without loss of generality: reduces to one goal under variables permutations.

Given a goal of the form `g xs`, a predicate `p` over a set of variables, as well as variable
permutations `xs_i`. Then `wlog` produces goals of the form

The case goal, i.e. the permutation `xs_i` covers all possible cases:
  `⊢ p xs_0 ∨ ⋯ ∨ p xs_n`
The main goal, i.e. the goal reduced to `xs_0`:
  `(h : p xs_0) ⊢ g xs_0`
The invariant goals, i.e. `g` is invariant under `xs_i`:
  `(h : p xs_i) (this : g xs_0) ⊢ gs xs_i`

Either the permutation is provided, or a proof of the disjunction is provided to compute the
permutation. The disjunction need to be in assoc normal form, e.g. `p₀ ∨ (p₁ ∨ p₂)`. In many cases
the invariant goals can be solved by AC rewriting using `cc` etc.

Example:
  On a state `(n m : ℕ) ⊢ p n m` the tactic `wlog h : n ≤ m using [n m, m n]` produces the following
  states:
    `(n m : ℕ) ⊢ n ≤ m ∨ m ≤ n`
    `(n m : ℕ) (h : n ≤ m) ⊢ p n m`
    `(n m : ℕ) (h : m ≤ n) (this : p n m) ⊢ p m n`

`wlog` supports different calling conventions. The name `h` is used to give a name to the introduced
case hypothesis. If the name is avoided, the default will be `case`.

(1) `wlog : p xs0 using [xs0, …, xsn]`
  Results in the case goal `p xs0 ∨ ⋯ ∨ ps xsn`, the main goal `(case : p xs0) ⊢ g xs0` and the
  invariance goals `(case : p xsi) (this : g xs0) ⊢ g xsi`.

(2) `wlog : p xs0 := r using xs0`
  The expression `r` is a proof of the shape `p xs0 ∨ ⋯ ∨ p xsi`, it is also used to compute the
  variable permutations.

(3) `wlog := r using xs0`
  The expression `r` is a proof of the shape `p xs0 ∨ ⋯ ∨ p xsi`, it is also used to compute the
  variable permutations. This is not as stable as (2), for example `p` cannot be a disjunction.

(4) `wlog : R x y using x y` and `wlog : R x y`
  Produces the case `R x y ∨ R y x`. If `R` is ≤, then the disjunction discharged using linearity.
  If `using x y` is avoided then `x` and `y` are the last two variables appearing in the
  expression `R x y`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title=' Without loss of generality: reduces to one goal under variables permutations.

Given a goal of the form `g xs`, a predicate `p` over a set of variables, as well as variable
permutations `xs_i`. Then `wlog` produces goals of the form

The case goal, i.e. the permutation `xs_i` covers all possible cases:
  `⊢ p xs_0 ∨ ⋯ ∨ p xs_n`
The main goal, i.e. the goal reduced to `xs_0`:
  `(h : p xs_0) ⊢ g xs_0`
The invariant goals, i.e. `g` is invariant under `xs_i`:
  `(h : p xs_i) (this : g xs_0) ⊢ gs xs_i`

Either the permutation is provided, or a proof of the disjunction is provided to compute the
permutation. The disjunction need to be in assoc normal form, e.g. `p₀ ∨ (p₁ ∨ p₂)`. In many cases
the invariant goals can be solved by AC rewriting using `cc` etc.

Example:
  On a state `(n m : ℕ) ⊢ p n m` the tactic `wlog h : n ≤ m using [n m, m n]` produces the following
  states:
    `(n m : ℕ) ⊢ n ≤ m ∨ m ≤ n`
    `(n m : ℕ) (h : n ≤ m) ⊢ p n m`
    `(n m : ℕ) (h : m ≤ n) (this : p n m) ⊢ p m n`

`wlog` supports different calling conventions. The name `h` is used to give a name to the introduced
case hypothesis. If the name is avoided, the default will be `case`.

(1) `wlog : p xs0 using [xs0, …, xsn]`
  Results in the case goal `p xs0 ∨ ⋯ ∨ ps xsn`, the main goal `(case : p xs0) ⊢ g xs0` and the
  invariance goals `(case : p xsi) (this : g xs0) ⊢ g xsi`.

(2) `wlog : p xs0 := r using xs0`
  The expression `r` is a proof of the shape `p xs0 ∨ ⋯ ∨ p xsi`, it is also used to compute the
  variable permutations.

(3) `wlog := r using xs0`
  The expression `r` is a proof of the shape `p xs0 ∨ ⋯ ∨ p xsi`, it is also used to compute the
  variable permutations. This is not as stable as (2), for example `p` cannot be a disjunction.

(4) `wlog : R x y using x y` and `wlog : R x y`
  Produces the case `R x y ∨ R y x`. If `R` is ≤, then the disjunction discharged using linearity.
  If `using x y` is avoided then `x` and `y` are the last two variables appearing in the
  expression `R x y`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='wlog'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='wlog'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='wlog'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='wlog'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='wlog'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='wlog'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='wlog'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='wlog'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;, &#x27;(using ([id*, ...] | id*))?&#x27;, &#x27;tactic.{0} unit?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;, &#x27;(using ([id*, ...] | id*))?&#x27;, &#x27;tactic.{0} unit?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;, &#x27;(using ([id*, ...] | id*))?&#x27;, &#x27;tactic.{0} unit?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;, &#x27;(using ([id*, ...] | id*))?&#x27;, &#x27;tactic.{0} unit?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;, &#x27;(using ([id*, ...] | id*))?&#x27;, &#x27;tactic.{0} unit?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;, &#x27;(using ([id*, ...] | id*))?&#x27;, &#x27;tactic.{0} unit?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;, &#x27;(using ([id*, ...] | id*))?&#x27;, &#x27;tactic.{0} unit?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;, &#x27;(using ([id*, ...] | id*))?&#x27;, &#x27;tactic.{0} unit?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
q r : rat
⊢ @has_le.le.{0} rat rat.has_le (padic_norm p (@has_add.add.{0} rat rat.has_add q r))
    (@max.{0} rat rat.decidable_linear_order (padic_norm p q) (padic_norm p r))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case main
p : nat,
hp : nat.prime p,
q r : rat,
hle :
  @has_le.le.{0} int
    (@preorder.to_has_le.{0} int
       (@partial_order.to_preorder.{0} int
          (@linear_order.to_partial_order.{0} int
             (@linear_ordered_ring.to_linear_order.{0} int
                (@linear_ordered_comm_ring.to_linear_ordered_ring.{0} int
                   (@decidable_linear_ordered_comm_ring.to_linear_ordered_comm_ring.{0} int
                      int.decidable_linear_ordered_comm_ring))))))
    (padic_val_rat p q)
    (padic_val_rat p r)
⊢ @has_le.le.{0} rat rat.has_le (padic_norm p (@has_add.add.{0} rat rat.has_add q r))
    (@max.{0} rat rat.decidable_linear_order (padic_norm p q) (padic_norm p r))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>405      exact nonarchimedean_aux p hle</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='_private.1196388991.nonarchimedean_aux'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hle'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 372, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (p : nat) [hp : nat.prime p] {q r : rat}, @has_le.le.{0} int int.has_le (padic_val_rat p q) (padic_val_rat p r) → @has_le.le.{0} rat rat.has_le (padic_norm p (@has_add.add.{0} rat rat.has_add q r)) (@max.{0} rat rat.decidable_linear_order (padic_norm p q) (padic_norm p r))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_le.le.{0} int (@preorder.to_has_le.{0} int (@partial_order.to_preorder.{0} int (@linear_order.to_partial_order.{0} int (@linear_ordered_ring.to_linear_order.{0} int (@linear_ordered_comm_ring.to_linear_ordered_ring.{0} int (@decidable_linear_ordered_comm_ring.to_linear_ordered_comm_ring.{0} int int.decidable_linear_ordered_comm_ring)))))) (padic_val_rat p q) (padic_val_rat p r)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case main
p : nat,
hp : nat.prime p,
q r : rat,
hle :
  @has_le.le.{0} int
    (@preorder.to_has_le.{0} int
       (@partial_order.to_preorder.{0} int
          (@linear_order.to_partial_order.{0} int
             (@linear_ordered_ring.to_linear_order.{0} int
                (@linear_ordered_comm_ring.to_linear_ordered_ring.{0} int
                   (@decidable_linear_ordered_comm_ring.to_linear_ordered_comm_ring.{0} int
                      int.decidable_linear_ordered_comm_ring))))))
    (padic_val_rat p q)
    (padic_val_rat p r)
⊢ @has_le.le.{0} rat rat.has_le (padic_norm p (@has_add.add.{0} rat rat.has_add q r))
    (@max.{0} rat rat.decidable_linear_order (padic_norm p q) (padic_norm p r))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>406  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>407  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>408  /--</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>409  The p-adic norm respects the triangle inequality: the norm of `p + q` is at most the norm of `p`</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>410  plus the norm of `q`.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>411  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>412  theorem triangle_ineq (q r : ℚ) : padic_norm p (q + r) ≤ padic_norm p q + padic_norm p r :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='blue'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='padic_norm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='q'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='r'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_le.le'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='padic_norm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='q'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='padic_norm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='r'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/rat/basic.lean&#x27;, &#x27;line&#x27;: 46, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 261, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 319, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 261, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 261, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='nat → rat → rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_add.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type} [c : has_le.{0} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat → rat → rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_add.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat → rat → rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='orange'><a title='`rat`, or `ℚ`, is the type of rational numbers. It is defined
 as the set of pairs ⟨n, d⟩ of integers such that `d` is positive and `n` and
 `d` are coprime. This representation is preferred to the quotient
 because without periodic reduction, the numerator and denominator can grow
 exponentially (for example, adding 1/2 to itself repeatedly).'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='If `q ≠ 0`, the p-adic norm of a rational `q` is `p ^ (-(padic_val_rat p q))`.
If `q = 0`, the p-adic norm of `q` is 0.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='If `q ≠ 0`, the p-adic norm of a rational `q` is `p ^ (-(padic_val_rat p q))`.
If `q = 0`, the p-adic norm of `q` is 0.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='If `q ≠ 0`, the p-adic norm of a rational `q` is `p ^ (-(padic_val_rat p q))`.
If `q = 0`, the p-adic norm of `q` is 0.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>413  calc padic_norm p (q + r) ≤ max (padic_norm p q) (padic_norm p r) : padic_norm.nonarchimedean p</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='padic_norm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='q'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='r'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='max'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='padic_norm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='q'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='padic_norm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='r'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='padic_norm.nonarchimedean'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 261, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/functions.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 11}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 261, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;line&#x27;: 261, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;line&#x27;: 401, &#x27;column&#x27;: 18}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='nat → rat → rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_add.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type} [_inst_1 : decidable_linear_order.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='nat → rat → rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='nat → rat → rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ (p : nat) [hp : nat.prime p] {q r : rat}, @has_le.le.{0} rat rat.has_le (padic_norm p (@has_add.add.{0} rat rat.has_add q r)) (@max.{0} rat rat.decidable_linear_order (padic_norm p q) (padic_norm p r))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='If `q ≠ 0`, the p-adic norm of a rational `q` is `p ^ (-(padic_val_rat p q))`.
If `q = 0`, the p-adic norm of `q` is 0.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='If `q ≠ 0`, the p-adic norm of a rational `q` is `p ^ (-(padic_val_rat p q))`.
If `q = 0`, the p-adic norm of `q` is 0.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='If `q ≠ 0`, the p-adic norm of a rational `q` is `p ^ (-(padic_val_rat p q))`.
If `q = 0`, the p-adic norm of `q` is 0.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='The p-adic norm is nonarchimedean: the norm of `p + q` is at most the max of the norm of `p` and
the norm of `q`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>414                         ... ≤ padic_norm p q + padic_norm p r :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='blue'><a title='padic_norm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='q'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='padic_norm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='r'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='red'><a title='{&#x27;line&#x27;: 261, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 261, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='green'><a title='nat → rat → rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_add.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat → rat → rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='orange'><a title='If `q ≠ 0`, the p-adic norm of a rational `q` is `p ^ (-(padic_val_rat p q))`.
If `q = 0`, the p-adic norm of `q` is 0.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='If `q ≠ 0`, the p-adic norm of a rational `q` is `p ^ (-(padic_val_rat p q))`.
If `q = 0`, the p-adic norm of `q` is 0.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>415                           max_le_add_of_nonneg (padic_norm.nonneg p _) (padic_norm.nonneg p _)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='blue'><a title='max_le_add_of_nonneg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='padic_norm.nonneg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='padic_norm.nonneg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/order_functions.lean&#x27;, &#x27;line&#x27;: 252, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 280, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;line&#x27;: 280, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='green'><a title='∀ {α : Type} [_inst_1 : decidable_linear_ordered_comm_group.{0} α] {a b : α}, @ge.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@ordered_comm_monoid.to_partial_order.{0} α (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} α (@decidable_linear_ordered_cancel_comm_monoid.to_ordered_cancel_comm_monoid.{0} α (@decidable_linear_ordered_comm_group.decidable_linear_ordered_cancel_comm_monoid.{0} α _inst_1)))))) a (@has_zero.zero.{0} α (@add_monoid.to_has_zero.{0} α (@add_group.to_add_monoid.{0} α (@add_comm_group.to_add_group.{0} α (@decidable_linear_ordered_comm_group.to_add_comm_group.{0} α _inst_1))))) → @ge.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@ordered_comm_monoid.to_partial_order.{0} α (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} α (@decidable_linear_ordered_cancel_comm_monoid.to_ordered_cancel_comm_monoid.{0} α (@decidable_linear_ordered_comm_group.decidable_linear_ordered_cancel_comm_monoid.{0} α _inst_1)))))) b (@has_zero.zero.{0} α (@add_monoid.to_has_zero.{0} α (@add_group.to_add_monoid.{0} α (@add_comm_group.to_add_group.{0} α (@decidable_linear_ordered_comm_group.to_add_comm_group.{0} α _inst_1))))) → @has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@ordered_comm_monoid.to_partial_order.{0} α (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} α (@decidable_linear_ordered_cancel_comm_monoid.to_ordered_cancel_comm_monoid.{0} α (@decidable_linear_ordered_comm_group.decidable_linear_ordered_cancel_comm_monoid.{0} α _inst_1)))))) (@max.{0} α (@decidable_linear_ordered_cancel_comm_monoid.to_decidable_linear_order.{0} α (@decidable_linear_ordered_comm_group.decidable_linear_ordered_cancel_comm_monoid.{0} α _inst_1)) a b) (@has_add.add.{0} α (@add_semigroup.to_has_add.{0} α (@add_monoid.to_add_semigroup.{0} α (@add_group.to_add_monoid.{0} α (@add_comm_group.to_add_group.{0} α (@decidable_linear_ordered_comm_group.to_add_comm_group.{0} α _inst_1))))) a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ (p : nat) (q : rat), @has_le.le.{0} rat rat.has_le (@has_zero.zero.{0} rat rat.has_zero) (padic_norm p q)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='∀ (p : nat) (q : rat), @has_le.le.{0} rat rat.has_le (@has_zero.zero.{0} rat rat.has_zero) (padic_norm p q)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                               </code><font color='orange'><a title='The p-adic norm is nonnegative.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='The p-adic norm is nonnegative.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>416  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>417  /--</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>418  The p-adic norm of a difference is at most the max of each component. Restates the archimedean</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>419  property of the p-adic norm.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>420  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>421  protected theorem sub {q r : ℚ} : padic_norm p (q - r) ≤ max (padic_norm p q) (padic_norm p r) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='blue'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='padic_norm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='q'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_sub.sub'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='r'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_le.le'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='max'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='padic_norm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='q'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='padic_norm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='r'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/rat/basic.lean&#x27;, &#x27;line&#x27;: 46, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 261, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 315, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 319, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/functions.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 11}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 261, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;line&#x27;: 261, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='nat → rat → rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_sub.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type} [c : has_le.{0} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [_inst_1 : decidable_linear_order.{u} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='nat → rat → rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='nat → rat → rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='orange'><a title='`rat`, or `ℚ`, is the type of rational numbers. It is defined
 as the set of pairs ⟨n, d⟩ of integers such that `d` is positive and `n` and
 `d` are coprime. This representation is preferred to the quotient
 because without periodic reduction, the numerator and denominator can grow
 exponentially (for example, adding 1/2 to itself repeatedly).'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='If `q ≠ 0`, the p-adic norm of a rational `q` is `p ^ (-(padic_val_rat p q))`.
If `q = 0`, the p-adic norm of `q` is 0.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='If `q ≠ 0`, the p-adic norm of a rational `q` is `p ^ (-(padic_val_rat p q))`.
If `q = 0`, the p-adic norm of `q` is 0.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='If `q ≠ 0`, the p-adic norm of a rational `q` is `p ^ (-(padic_val_rat p q))`.
If `q = 0`, the p-adic norm of `q` is 0.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>422  by rw [sub_eq_add_neg, ←padic_norm.neg p r]; apply padic_norm.nonarchimedean</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='sub_eq_add_neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='padic_norm.neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='r'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='padic_norm.nonarchimedean'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 324, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 321, &#x27;column&#x27;: 24}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 401, &#x27;column&#x27;: 18}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : add_group.{0} α] (a b : α), @eq.{1} α (@has_sub.sub.{0} α (@add_group_has_sub.{0} α _inst_1) a b) (@has_add.add.{0} α (@add_semigroup.to_has_add.{0} α (@add_monoid.to_add_semigroup.{0} α (@add_group.to_add_monoid.{0} α _inst_1))) a (@has_neg.neg.{0} α (@add_group.to_has_neg.{0} α _inst_1) b))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (p : nat) [hp : nat.prime p] (q : rat), @eq.{1} rat (padic_norm p (@has_neg.neg.{0} rat rat.has_neg q)) (padic_norm p q)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (p : nat) [hp : nat.prime p] {q r : rat}, @has_le.le.{0} rat rat.has_le (padic_norm p (@has_add.add.{0} rat rat.has_add q r)) (@max.{0} rat rat.decidable_linear_order (padic_norm p q) (padic_norm p r))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`padic_norm p` is symmetric.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The p-adic norm is nonarchimedean: the norm of `p + q` is at most the max of the norm of `p` and
the norm of `q`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='p : nat,
hp : nat.prime p,
q r : rat
⊢ @has_le.le.{0} rat rat.has_le (padic_norm p (@has_sub.sub.{0} rat (@add_group_has_sub.{0} rat rat.add_group) q r))
    (@max.{0} rat rat.decidable_linear_order (padic_norm p q) (padic_norm p r))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
q r : rat
⊢ @has_le.le.{0} rat rat.has_le
    (padic_norm p
       (@has_add.add.{0} rat
          (@add_semigroup.to_has_add.{0} rat
             (@add_monoid.to_add_semigroup.{0} rat (@add_group.to_add_monoid.{0} rat rat.add_group)))
          q
          (@has_neg.neg.{0} rat (@add_group.to_has_neg.{0} rat rat.add_group) r)))
    (@max.{0} rat rat.decidable_linear_order (padic_norm p q) (padic_norm p r))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
q r : rat
⊢ @has_le.le.{0} rat rat.has_le
    (padic_norm p
       (@has_add.add.{0} rat
          (@add_semigroup.to_has_add.{0} rat
             (@add_monoid.to_add_semigroup.{0} rat (@add_group.to_add_monoid.{0} rat rat.add_group)))
          q
          (@has_neg.neg.{0} rat (@add_group.to_has_neg.{0} rat rat.add_group) r)))
    (@max.{0} rat rat.decidable_linear_order (padic_norm p q) (padic_norm p (@has_neg.neg.{0} rat rat.has_neg r)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
q r : rat
⊢ @has_le.le.{0} rat rat.has_le (padic_norm p (@has_sub.sub.{0} rat (@add_group_has_sub.{0} rat rat.add_group) q r))
    (@max.{0} rat rat.decidable_linear_order (padic_norm p q) (padic_norm p r))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>423  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
q r : rat
⊢ @has_le.le.{0} rat rat.has_le (padic_norm p (@has_sub.sub.{0} rat (@add_group_has_sub.{0} rat rat.add_group) q r))
    (@max.{0} rat rat.decidable_linear_order (padic_norm p q) (padic_norm p r))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>424  /--</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>425  If the p-adic norms of `q` and `r` are different, then the norm of `q + r` is equal to the max of</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>426  the norms of `q` and `r`.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>427  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>428  lemma add_eq_max_of_ne {q r : ℚ} (hne : padic_norm p q ≠ padic_norm p r) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='blue'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='padic_norm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='q'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ne'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='padic_norm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='r'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/rat/basic.lean&#x27;, &#x27;line&#x27;: 46, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;line&#x27;: 261, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 97, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 261, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='nat → rat → rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat → rat → rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='orange'><a title='`rat`, or `ℚ`, is the type of rational numbers. It is defined
 as the set of pairs ⟨n, d⟩ of integers such that `d` is positive and `n` and
 `d` are coprime. This representation is preferred to the quotient
 because without periodic reduction, the numerator and denominator can grow
 exponentially (for example, adding 1/2 to itself repeatedly).'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='If `q ≠ 0`, the p-adic norm of a rational `q` is `p ^ (-(padic_val_rat p q))`.
If `q = 0`, the p-adic norm of `q` is 0.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='If `q ≠ 0`, the p-adic norm of a rational `q` is `p ^ (-(padic_val_rat p q))`.
If `q = 0`, the p-adic norm of `q` is 0.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>429    padic_norm p (q + r) = max (padic_norm p q) (padic_norm p r) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='padic_norm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='q'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='r'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='max'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='padic_norm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='q'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='padic_norm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='r'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 261, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/functions.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 11}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 261, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;line&#x27;: 261, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='nat → rat → rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_add.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [_inst_1 : decidable_linear_order.{u} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='nat → rat → rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='nat → rat → rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='If `q ≠ 0`, the p-adic norm of a rational `q` is `p ^ (-(padic_val_rat p q))`.
If `q = 0`, the p-adic norm of `q` is 0.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='If `q ≠ 0`, the p-adic norm of a rational `q` is `p ^ (-(padic_val_rat p q))`.
If `q = 0`, the p-adic norm of `q` is 0.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='If `q ≠ 0`, the p-adic norm of a rational `q` is `p ^ (-(padic_val_rat p q))`.
If `q = 0`, the p-adic norm of `q` is 0.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>430  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
q r : rat,
hne : @ne.{1} rat (padic_norm p q) (padic_norm p r)
⊢ @eq.{1} rat (padic_norm p (@has_add.add.{0} rat rat.has_add q r))
    (@max.{0} rat rat.decidable_linear_order (padic_norm p q) (padic_norm p r))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>431    wlog hle := le_total (padic_norm p r) (padic_norm p q) using [q r],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='le_total'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='r'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='padic_norm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='q'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/wlog.lean&#x27;, &#x27;line&#x27;: 153, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 57, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/wlog.lean&#x27;, &#x27;line&#x27;: 153, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/wlog.lean&#x27;, &#x27;line&#x27;: 153, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/wlog.lean&#x27;, &#x27;line&#x27;: 153, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/wlog.lean&#x27;, &#x27;line&#x27;: 153, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 261, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/wlog.lean&#x27;, &#x27;line&#x27;: 153, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/wlog.lean&#x27;, &#x27;line&#x27;: 153, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/wlog.lean&#x27;, &#x27;line&#x27;: 153, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} (list.{0} (list.{0} name))) (λ (a : option.{0} (list.{0} (list.{0} name))), @option.has_reflect (list.{0} (list.{0} name)) (λ (a : list.{0} (list.{0} name)), @list.reflect (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) `(list.{0} name) a) `(list.{0} (list.{0} name)) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative (list.{0} (list.{0} name)) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit (list.{0} (list.{0} name)) (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) (@has_orelse.orelse.{0 0} lean.parser.{0} (@alternative.to_has_orelse.{0 0} lean.parser.{0} lean.parser.alternative) (list.{0} (list.{0} name)) (@interactive.types.list_of (list.{0} name) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident)) (@functor.map.{0 0} lean.parser.{0} (@applicative.to_functor.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) (list.{0} name) (list.{0} (list.{0} name)) (λ (x : list.{0} name), @list.cons.{0} (list.{0} name) x (@list.nil.{0} (list.{0} name))) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident))))) → opt_param.{1} (tactic.{0} unit) (@has_orelse.orelse.{0 0} tactic.{0} (@alternative.to_has_orelse.{0 0} tactic.{0} tactic.alternative.{0}) unit (tactic.solve_by_elim {backtrack_all_goals := bool.ff, discharger := tactic.done, assumptions := tactic.mk_assumption_set (@decidable.to_bool false decidable.false) (@list.nil.{0} tactic.simp_arg_type) (@list.nil.{0} name), max_rep := @bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)}) (@has_orelse.orelse.{0 0} tactic.{0} (@alternative.to_has_orelse.{0 0} tactic.{0} tactic.alternative.{0}) unit (tactic.tautology bool.tt) (@using_smt unit (@has_bind.and_then.{0 0} unit unit smt_tactic (@monad.to_has_bind.{0 0} smt_tactic smt_tactic.monad) smt_tactic.intros smt_tactic.solve_goals) {cc_cfg := {ignore_instances := bool.tt, ac := bool.tt, ho_fns := @option.none.{0} (list.{0} name), em := bool.tt}, em_cfg := {max_instances := @bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))), max_generation := @bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))}, pre_cfg := {simp_attr := name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) name.anonymous, max_steps := @bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))))))))), zeta := bool.ff}, em_attr := name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) name.anonymous}))) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : linear_order.{0} α] (a b : α), or (@has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@linear_order.to_partial_order.{0} α _inst_1))) a b) (@has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@linear_order.to_partial_order.{0} α _inst_1))) b a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} (list.{0} (list.{0} name))) (λ (a : option.{0} (list.{0} (list.{0} name))), @option.has_reflect (list.{0} (list.{0} name)) (λ (a : list.{0} (list.{0} name)), @list.reflect (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) `(list.{0} name) a) `(list.{0} (list.{0} name)) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative (list.{0} (list.{0} name)) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit (list.{0} (list.{0} name)) (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) (@has_orelse.orelse.{0 0} lean.parser.{0} (@alternative.to_has_orelse.{0 0} lean.parser.{0} lean.parser.alternative) (list.{0} (list.{0} name)) (@interactive.types.list_of (list.{0} name) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident)) (@functor.map.{0 0} lean.parser.{0} (@applicative.to_functor.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) (list.{0} name) (list.{0} (list.{0} name)) (λ (x : list.{0} name), @list.cons.{0} (list.{0} name) x (@list.nil.{0} (list.{0} name))) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident))))) → opt_param.{1} (tactic.{0} unit) (@has_orelse.orelse.{0 0} tactic.{0} (@alternative.to_has_orelse.{0 0} tactic.{0} tactic.alternative.{0}) unit (tactic.solve_by_elim {backtrack_all_goals := bool.ff, discharger := tactic.done, assumptions := tactic.mk_assumption_set (@decidable.to_bool false decidable.false) (@list.nil.{0} tactic.simp_arg_type) (@list.nil.{0} name), max_rep := @bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)}) (@has_orelse.orelse.{0 0} tactic.{0} (@alternative.to_has_orelse.{0 0} tactic.{0} tactic.alternative.{0}) unit (tactic.tautology bool.tt) (@using_smt unit (@has_bind.and_then.{0 0} unit unit smt_tactic (@monad.to_has_bind.{0 0} smt_tactic smt_tactic.monad) smt_tactic.intros smt_tactic.solve_goals) {cc_cfg := {ignore_instances := bool.tt, ac := bool.tt, ho_fns := @option.none.{0} (list.{0} name), em := bool.tt}, em_cfg := {max_instances := @bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))), max_generation := @bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))}, pre_cfg := {simp_attr := name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) name.anonymous, max_steps := @bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))))))))), zeta := bool.ff}, em_attr := name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) name.anonymous}))) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} (list.{0} (list.{0} name))) (λ (a : option.{0} (list.{0} (list.{0} name))), @option.has_reflect (list.{0} (list.{0} name)) (λ (a : list.{0} (list.{0} name)), @list.reflect (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) `(list.{0} name) a) `(list.{0} (list.{0} name)) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative (list.{0} (list.{0} name)) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit (list.{0} (list.{0} name)) (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) (@has_orelse.orelse.{0 0} lean.parser.{0} (@alternative.to_has_orelse.{0 0} lean.parser.{0} lean.parser.alternative) (list.{0} (list.{0} name)) (@interactive.types.list_of (list.{0} name) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident)) (@functor.map.{0 0} lean.parser.{0} (@applicative.to_functor.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) (list.{0} name) (list.{0} (list.{0} name)) (λ (x : list.{0} name), @list.cons.{0} (list.{0} name) x (@list.nil.{0} (list.{0} name))) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident))))) → opt_param.{1} (tactic.{0} unit) (@has_orelse.orelse.{0 0} tactic.{0} (@alternative.to_has_orelse.{0 0} tactic.{0} tactic.alternative.{0}) unit (tactic.solve_by_elim {backtrack_all_goals := bool.ff, discharger := tactic.done, assumptions := tactic.mk_assumption_set (@decidable.to_bool false decidable.false) (@list.nil.{0} tactic.simp_arg_type) (@list.nil.{0} name), max_rep := @bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)}) (@has_orelse.orelse.{0 0} tactic.{0} (@alternative.to_has_orelse.{0 0} tactic.{0} tactic.alternative.{0}) unit (tactic.tautology bool.tt) (@using_smt unit (@has_bind.and_then.{0 0} unit unit smt_tactic (@monad.to_has_bind.{0 0} smt_tactic smt_tactic.monad) smt_tactic.intros smt_tactic.solve_goals) {cc_cfg := {ignore_instances := bool.tt, ac := bool.tt, ho_fns := @option.none.{0} (list.{0} name), em := bool.tt}, em_cfg := {max_instances := @bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))), max_generation := @bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))}, pre_cfg := {simp_attr := name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) name.anonymous, max_steps := @bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))))))))), zeta := bool.ff}, em_attr := name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) name.anonymous}))) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} (list.{0} (list.{0} name))) (λ (a : option.{0} (list.{0} (list.{0} name))), @option.has_reflect (list.{0} (list.{0} name)) (λ (a : list.{0} (list.{0} name)), @list.reflect (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) `(list.{0} name) a) `(list.{0} (list.{0} name)) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative (list.{0} (list.{0} name)) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit (list.{0} (list.{0} name)) (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) (@has_orelse.orelse.{0 0} lean.parser.{0} (@alternative.to_has_orelse.{0 0} lean.parser.{0} lean.parser.alternative) (list.{0} (list.{0} name)) (@interactive.types.list_of (list.{0} name) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident)) (@functor.map.{0 0} lean.parser.{0} (@applicative.to_functor.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) (list.{0} name) (list.{0} (list.{0} name)) (λ (x : list.{0} name), @list.cons.{0} (list.{0} name) x (@list.nil.{0} (list.{0} name))) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident))))) → opt_param.{1} (tactic.{0} unit) (@has_orelse.orelse.{0 0} tactic.{0} (@alternative.to_has_orelse.{0 0} tactic.{0} tactic.alternative.{0}) unit (tactic.solve_by_elim {backtrack_all_goals := bool.ff, discharger := tactic.done, assumptions := tactic.mk_assumption_set (@decidable.to_bool false decidable.false) (@list.nil.{0} tactic.simp_arg_type) (@list.nil.{0} name), max_rep := @bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)}) (@has_orelse.orelse.{0 0} tactic.{0} (@alternative.to_has_orelse.{0 0} tactic.{0} tactic.alternative.{0}) unit (tactic.tautology bool.tt) (@using_smt unit (@has_bind.and_then.{0 0} unit unit smt_tactic (@monad.to_has_bind.{0 0} smt_tactic smt_tactic.monad) smt_tactic.intros smt_tactic.solve_goals) {cc_cfg := {ignore_instances := bool.tt, ac := bool.tt, ho_fns := @option.none.{0} (list.{0} name), em := bool.tt}, em_cfg := {max_instances := @bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))), max_generation := @bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))}, pre_cfg := {simp_attr := name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) name.anonymous, max_steps := @bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))))))))), zeta := bool.ff}, em_attr := name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) name.anonymous}))) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} (list.{0} (list.{0} name))) (λ (a : option.{0} (list.{0} (list.{0} name))), @option.has_reflect (list.{0} (list.{0} name)) (λ (a : list.{0} (list.{0} name)), @list.reflect (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) `(list.{0} name) a) `(list.{0} (list.{0} name)) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative (list.{0} (list.{0} name)) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit (list.{0} (list.{0} name)) (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) (@has_orelse.orelse.{0 0} lean.parser.{0} (@alternative.to_has_orelse.{0 0} lean.parser.{0} lean.parser.alternative) (list.{0} (list.{0} name)) (@interactive.types.list_of (list.{0} name) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident)) (@functor.map.{0 0} lean.parser.{0} (@applicative.to_functor.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) (list.{0} name) (list.{0} (list.{0} name)) (λ (x : list.{0} name), @list.cons.{0} (list.{0} name) x (@list.nil.{0} (list.{0} name))) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident))))) → opt_param.{1} (tactic.{0} unit) (@has_orelse.orelse.{0 0} tactic.{0} (@alternative.to_has_orelse.{0 0} tactic.{0} tactic.alternative.{0}) unit (tactic.solve_by_elim {backtrack_all_goals := bool.ff, discharger := tactic.done, assumptions := tactic.mk_assumption_set (@decidable.to_bool false decidable.false) (@list.nil.{0} tactic.simp_arg_type) (@list.nil.{0} name), max_rep := @bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)}) (@has_orelse.orelse.{0 0} tactic.{0} (@alternative.to_has_orelse.{0 0} tactic.{0} tactic.alternative.{0}) unit (tactic.tautology bool.tt) (@using_smt unit (@has_bind.and_then.{0 0} unit unit smt_tactic (@monad.to_has_bind.{0 0} smt_tactic smt_tactic.monad) smt_tactic.intros smt_tactic.solve_goals) {cc_cfg := {ignore_instances := bool.tt, ac := bool.tt, ho_fns := @option.none.{0} (list.{0} name), em := bool.tt}, em_cfg := {max_instances := @bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))), max_generation := @bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))}, pre_cfg := {simp_attr := name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) name.anonymous, max_steps := @bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))))))))), zeta := bool.ff}, em_attr := name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) name.anonymous}))) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat → rat → rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} (list.{0} (list.{0} name))) (λ (a : option.{0} (list.{0} (list.{0} name))), @option.has_reflect (list.{0} (list.{0} name)) (λ (a : list.{0} (list.{0} name)), @list.reflect (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) `(list.{0} name) a) `(list.{0} (list.{0} name)) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative (list.{0} (list.{0} name)) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit (list.{0} (list.{0} name)) (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) (@has_orelse.orelse.{0 0} lean.parser.{0} (@alternative.to_has_orelse.{0 0} lean.parser.{0} lean.parser.alternative) (list.{0} (list.{0} name)) (@interactive.types.list_of (list.{0} name) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident)) (@functor.map.{0 0} lean.parser.{0} (@applicative.to_functor.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) (list.{0} name) (list.{0} (list.{0} name)) (λ (x : list.{0} name), @list.cons.{0} (list.{0} name) x (@list.nil.{0} (list.{0} name))) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident))))) → opt_param.{1} (tactic.{0} unit) (@has_orelse.orelse.{0 0} tactic.{0} (@alternative.to_has_orelse.{0 0} tactic.{0} tactic.alternative.{0}) unit (tactic.solve_by_elim {backtrack_all_goals := bool.ff, discharger := tactic.done, assumptions := tactic.mk_assumption_set (@decidable.to_bool false decidable.false) (@list.nil.{0} tactic.simp_arg_type) (@list.nil.{0} name), max_rep := @bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)}) (@has_orelse.orelse.{0 0} tactic.{0} (@alternative.to_has_orelse.{0 0} tactic.{0} tactic.alternative.{0}) unit (tactic.tautology bool.tt) (@using_smt unit (@has_bind.and_then.{0 0} unit unit smt_tactic (@monad.to_has_bind.{0 0} smt_tactic smt_tactic.monad) smt_tactic.intros smt_tactic.solve_goals) {cc_cfg := {ignore_instances := bool.tt, ac := bool.tt, ho_fns := @option.none.{0} (list.{0} name), em := bool.tt}, em_cfg := {max_instances := @bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))), max_generation := @bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))}, pre_cfg := {simp_attr := name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) name.anonymous, max_steps := @bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))))))))), zeta := bool.ff}, em_attr := name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) name.anonymous}))) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} (list.{0} (list.{0} name))) (λ (a : option.{0} (list.{0} (list.{0} name))), @option.has_reflect (list.{0} (list.{0} name)) (λ (a : list.{0} (list.{0} name)), @list.reflect (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) `(list.{0} name) a) `(list.{0} (list.{0} name)) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative (list.{0} (list.{0} name)) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit (list.{0} (list.{0} name)) (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) (@has_orelse.orelse.{0 0} lean.parser.{0} (@alternative.to_has_orelse.{0 0} lean.parser.{0} lean.parser.alternative) (list.{0} (list.{0} name)) (@interactive.types.list_of (list.{0} name) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident)) (@functor.map.{0 0} lean.parser.{0} (@applicative.to_functor.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) (list.{0} name) (list.{0} (list.{0} name)) (λ (x : list.{0} name), @list.cons.{0} (list.{0} name) x (@list.nil.{0} (list.{0} name))) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident))))) → opt_param.{1} (tactic.{0} unit) (@has_orelse.orelse.{0 0} tactic.{0} (@alternative.to_has_orelse.{0 0} tactic.{0} tactic.alternative.{0}) unit (tactic.solve_by_elim {backtrack_all_goals := bool.ff, discharger := tactic.done, assumptions := tactic.mk_assumption_set (@decidable.to_bool false decidable.false) (@list.nil.{0} tactic.simp_arg_type) (@list.nil.{0} name), max_rep := @bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)}) (@has_orelse.orelse.{0 0} tactic.{0} (@alternative.to_has_orelse.{0 0} tactic.{0} tactic.alternative.{0}) unit (tactic.tautology bool.tt) (@using_smt unit (@has_bind.and_then.{0 0} unit unit smt_tactic (@monad.to_has_bind.{0 0} smt_tactic smt_tactic.monad) smt_tactic.intros smt_tactic.solve_goals) {cc_cfg := {ignore_instances := bool.tt, ac := bool.tt, ho_fns := @option.none.{0} (list.{0} name), em := bool.tt}, em_cfg := {max_instances := @bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))), max_generation := @bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))}, pre_cfg := {simp_attr := name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) name.anonymous, max_steps := @bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))))))))), zeta := bool.ff}, em_attr := name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) name.anonymous}))) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} (list.{0} (list.{0} name))) (λ (a : option.{0} (list.{0} (list.{0} name))), @option.has_reflect (list.{0} (list.{0} name)) (λ (a : list.{0} (list.{0} name)), @list.reflect (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) `(list.{0} name) a) `(list.{0} (list.{0} name)) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative (list.{0} (list.{0} name)) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit (list.{0} (list.{0} name)) (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) (@has_orelse.orelse.{0 0} lean.parser.{0} (@alternative.to_has_orelse.{0 0} lean.parser.{0} lean.parser.alternative) (list.{0} (list.{0} name)) (@interactive.types.list_of (list.{0} name) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident)) (@functor.map.{0 0} lean.parser.{0} (@applicative.to_functor.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) (list.{0} name) (list.{0} (list.{0} name)) (λ (x : list.{0} name), @list.cons.{0} (list.{0} name) x (@list.nil.{0} (list.{0} name))) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident))))) → opt_param.{1} (tactic.{0} unit) (@has_orelse.orelse.{0 0} tactic.{0} (@alternative.to_has_orelse.{0 0} tactic.{0} tactic.alternative.{0}) unit (tactic.solve_by_elim {backtrack_all_goals := bool.ff, discharger := tactic.done, assumptions := tactic.mk_assumption_set (@decidable.to_bool false decidable.false) (@list.nil.{0} tactic.simp_arg_type) (@list.nil.{0} name), max_rep := @bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)}) (@has_orelse.orelse.{0 0} tactic.{0} (@alternative.to_has_orelse.{0 0} tactic.{0} tactic.alternative.{0}) unit (tactic.tautology bool.tt) (@using_smt unit (@has_bind.and_then.{0 0} unit unit smt_tactic (@monad.to_has_bind.{0 0} smt_tactic smt_tactic.monad) smt_tactic.intros smt_tactic.solve_goals) {cc_cfg := {ignore_instances := bool.tt, ac := bool.tt, ho_fns := @option.none.{0} (list.{0} name), em := bool.tt}, em_cfg := {max_instances := @bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))), max_generation := @bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))}, pre_cfg := {simp_attr := name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) name.anonymous, max_steps := @bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))))))))), zeta := bool.ff}, em_attr := name.mk_string (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) name.anonymous}))) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title=' Without loss of generality: reduces to one goal under variables permutations.

Given a goal of the form `g xs`, a predicate `p` over a set of variables, as well as variable
permutations `xs_i`. Then `wlog` produces goals of the form

The case goal, i.e. the permutation `xs_i` covers all possible cases:
  `⊢ p xs_0 ∨ ⋯ ∨ p xs_n`
The main goal, i.e. the goal reduced to `xs_0`:
  `(h : p xs_0) ⊢ g xs_0`
The invariant goals, i.e. `g` is invariant under `xs_i`:
  `(h : p xs_i) (this : g xs_0) ⊢ gs xs_i`

Either the permutation is provided, or a proof of the disjunction is provided to compute the
permutation. The disjunction need to be in assoc normal form, e.g. `p₀ ∨ (p₁ ∨ p₂)`. In many cases
the invariant goals can be solved by AC rewriting using `cc` etc.

Example:
  On a state `(n m : ℕ) ⊢ p n m` the tactic `wlog h : n ≤ m using [n m, m n]` produces the following
  states:
    `(n m : ℕ) ⊢ n ≤ m ∨ m ≤ n`
    `(n m : ℕ) (h : n ≤ m) ⊢ p n m`
    `(n m : ℕ) (h : m ≤ n) (this : p n m) ⊢ p m n`

`wlog` supports different calling conventions. The name `h` is used to give a name to the introduced
case hypothesis. If the name is avoided, the default will be `case`.

(1) `wlog : p xs0 using [xs0, …, xsn]`
  Results in the case goal `p xs0 ∨ ⋯ ∨ ps xsn`, the main goal `(case : p xs0) ⊢ g xs0` and the
  invariance goals `(case : p xsi) (this : g xs0) ⊢ g xsi`.

(2) `wlog : p xs0 := r using xs0`
  The expression `r` is a proof of the shape `p xs0 ∨ ⋯ ∨ p xsi`, it is also used to compute the
  variable permutations.

(3) `wlog := r using xs0`
  The expression `r` is a proof of the shape `p xs0 ∨ ⋯ ∨ p xsi`, it is also used to compute the
  variable permutations. This is not as stable as (2), for example `p` cannot be a disjunction.

(4) `wlog : R x y using x y` and `wlog : R x y`
  Produces the case `R x y ∨ R y x`. If `R` is ≤, then the disjunction discharged using linearity.
  If `using x y` is avoided then `x` and `y` are the last two variables appearing in the
  expression `R x y`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title=' Without loss of generality: reduces to one goal under variables permutations.

Given a goal of the form `g xs`, a predicate `p` over a set of variables, as well as variable
permutations `xs_i`. Then `wlog` produces goals of the form

The case goal, i.e. the permutation `xs_i` covers all possible cases:
  `⊢ p xs_0 ∨ ⋯ ∨ p xs_n`
The main goal, i.e. the goal reduced to `xs_0`:
  `(h : p xs_0) ⊢ g xs_0`
The invariant goals, i.e. `g` is invariant under `xs_i`:
  `(h : p xs_i) (this : g xs_0) ⊢ gs xs_i`

Either the permutation is provided, or a proof of the disjunction is provided to compute the
permutation. The disjunction need to be in assoc normal form, e.g. `p₀ ∨ (p₁ ∨ p₂)`. In many cases
the invariant goals can be solved by AC rewriting using `cc` etc.

Example:
  On a state `(n m : ℕ) ⊢ p n m` the tactic `wlog h : n ≤ m using [n m, m n]` produces the following
  states:
    `(n m : ℕ) ⊢ n ≤ m ∨ m ≤ n`
    `(n m : ℕ) (h : n ≤ m) ⊢ p n m`
    `(n m : ℕ) (h : m ≤ n) (this : p n m) ⊢ p m n`

`wlog` supports different calling conventions. The name `h` is used to give a name to the introduced
case hypothesis. If the name is avoided, the default will be `case`.

(1) `wlog : p xs0 using [xs0, …, xsn]`
  Results in the case goal `p xs0 ∨ ⋯ ∨ ps xsn`, the main goal `(case : p xs0) ⊢ g xs0` and the
  invariance goals `(case : p xsi) (this : g xs0) ⊢ g xsi`.

(2) `wlog : p xs0 := r using xs0`
  The expression `r` is a proof of the shape `p xs0 ∨ ⋯ ∨ p xsi`, it is also used to compute the
  variable permutations.

(3) `wlog := r using xs0`
  The expression `r` is a proof of the shape `p xs0 ∨ ⋯ ∨ p xsi`, it is also used to compute the
  variable permutations. This is not as stable as (2), for example `p` cannot be a disjunction.

(4) `wlog : R x y using x y` and `wlog : R x y`
  Produces the case `R x y ∨ R y x`. If `R` is ≤, then the disjunction discharged using linearity.
  If `using x y` is avoided then `x` and `y` are the last two variables appearing in the
  expression `R x y`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title=' Without loss of generality: reduces to one goal under variables permutations.

Given a goal of the form `g xs`, a predicate `p` over a set of variables, as well as variable
permutations `xs_i`. Then `wlog` produces goals of the form

The case goal, i.e. the permutation `xs_i` covers all possible cases:
  `⊢ p xs_0 ∨ ⋯ ∨ p xs_n`
The main goal, i.e. the goal reduced to `xs_0`:
  `(h : p xs_0) ⊢ g xs_0`
The invariant goals, i.e. `g` is invariant under `xs_i`:
  `(h : p xs_i) (this : g xs_0) ⊢ gs xs_i`

Either the permutation is provided, or a proof of the disjunction is provided to compute the
permutation. The disjunction need to be in assoc normal form, e.g. `p₀ ∨ (p₁ ∨ p₂)`. In many cases
the invariant goals can be solved by AC rewriting using `cc` etc.

Example:
  On a state `(n m : ℕ) ⊢ p n m` the tactic `wlog h : n ≤ m using [n m, m n]` produces the following
  states:
    `(n m : ℕ) ⊢ n ≤ m ∨ m ≤ n`
    `(n m : ℕ) (h : n ≤ m) ⊢ p n m`
    `(n m : ℕ) (h : m ≤ n) (this : p n m) ⊢ p m n`

`wlog` supports different calling conventions. The name `h` is used to give a name to the introduced
case hypothesis. If the name is avoided, the default will be `case`.

(1) `wlog : p xs0 using [xs0, …, xsn]`
  Results in the case goal `p xs0 ∨ ⋯ ∨ ps xsn`, the main goal `(case : p xs0) ⊢ g xs0` and the
  invariance goals `(case : p xsi) (this : g xs0) ⊢ g xsi`.

(2) `wlog : p xs0 := r using xs0`
  The expression `r` is a proof of the shape `p xs0 ∨ ⋯ ∨ p xsi`, it is also used to compute the
  variable permutations.

(3) `wlog := r using xs0`
  The expression `r` is a proof of the shape `p xs0 ∨ ⋯ ∨ p xsi`, it is also used to compute the
  variable permutations. This is not as stable as (2), for example `p` cannot be a disjunction.

(4) `wlog : R x y using x y` and `wlog : R x y`
  Produces the case `R x y ∨ R y x`. If `R` is ≤, then the disjunction discharged using linearity.
  If `using x y` is avoided then `x` and `y` are the last two variables appearing in the
  expression `R x y`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title=' Without loss of generality: reduces to one goal under variables permutations.

Given a goal of the form `g xs`, a predicate `p` over a set of variables, as well as variable
permutations `xs_i`. Then `wlog` produces goals of the form

The case goal, i.e. the permutation `xs_i` covers all possible cases:
  `⊢ p xs_0 ∨ ⋯ ∨ p xs_n`
The main goal, i.e. the goal reduced to `xs_0`:
  `(h : p xs_0) ⊢ g xs_0`
The invariant goals, i.e. `g` is invariant under `xs_i`:
  `(h : p xs_i) (this : g xs_0) ⊢ gs xs_i`

Either the permutation is provided, or a proof of the disjunction is provided to compute the
permutation. The disjunction need to be in assoc normal form, e.g. `p₀ ∨ (p₁ ∨ p₂)`. In many cases
the invariant goals can be solved by AC rewriting using `cc` etc.

Example:
  On a state `(n m : ℕ) ⊢ p n m` the tactic `wlog h : n ≤ m using [n m, m n]` produces the following
  states:
    `(n m : ℕ) ⊢ n ≤ m ∨ m ≤ n`
    `(n m : ℕ) (h : n ≤ m) ⊢ p n m`
    `(n m : ℕ) (h : m ≤ n) (this : p n m) ⊢ p m n`

`wlog` supports different calling conventions. The name `h` is used to give a name to the introduced
case hypothesis. If the name is avoided, the default will be `case`.

(1) `wlog : p xs0 using [xs0, …, xsn]`
  Results in the case goal `p xs0 ∨ ⋯ ∨ ps xsn`, the main goal `(case : p xs0) ⊢ g xs0` and the
  invariance goals `(case : p xsi) (this : g xs0) ⊢ g xsi`.

(2) `wlog : p xs0 := r using xs0`
  The expression `r` is a proof of the shape `p xs0 ∨ ⋯ ∨ p xsi`, it is also used to compute the
  variable permutations.

(3) `wlog := r using xs0`
  The expression `r` is a proof of the shape `p xs0 ∨ ⋯ ∨ p xsi`, it is also used to compute the
  variable permutations. This is not as stable as (2), for example `p` cannot be a disjunction.

(4) `wlog : R x y using x y` and `wlog : R x y`
  Produces the case `R x y ∨ R y x`. If `R` is ≤, then the disjunction discharged using linearity.
  If `using x y` is avoided then `x` and `y` are the last two variables appearing in the
  expression `R x y`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title=' Without loss of generality: reduces to one goal under variables permutations.

Given a goal of the form `g xs`, a predicate `p` over a set of variables, as well as variable
permutations `xs_i`. Then `wlog` produces goals of the form

The case goal, i.e. the permutation `xs_i` covers all possible cases:
  `⊢ p xs_0 ∨ ⋯ ∨ p xs_n`
The main goal, i.e. the goal reduced to `xs_0`:
  `(h : p xs_0) ⊢ g xs_0`
The invariant goals, i.e. `g` is invariant under `xs_i`:
  `(h : p xs_i) (this : g xs_0) ⊢ gs xs_i`

Either the permutation is provided, or a proof of the disjunction is provided to compute the
permutation. The disjunction need to be in assoc normal form, e.g. `p₀ ∨ (p₁ ∨ p₂)`. In many cases
the invariant goals can be solved by AC rewriting using `cc` etc.

Example:
  On a state `(n m : ℕ) ⊢ p n m` the tactic `wlog h : n ≤ m using [n m, m n]` produces the following
  states:
    `(n m : ℕ) ⊢ n ≤ m ∨ m ≤ n`
    `(n m : ℕ) (h : n ≤ m) ⊢ p n m`
    `(n m : ℕ) (h : m ≤ n) (this : p n m) ⊢ p m n`

`wlog` supports different calling conventions. The name `h` is used to give a name to the introduced
case hypothesis. If the name is avoided, the default will be `case`.

(1) `wlog : p xs0 using [xs0, …, xsn]`
  Results in the case goal `p xs0 ∨ ⋯ ∨ ps xsn`, the main goal `(case : p xs0) ⊢ g xs0` and the
  invariance goals `(case : p xsi) (this : g xs0) ⊢ g xsi`.

(2) `wlog : p xs0 := r using xs0`
  The expression `r` is a proof of the shape `p xs0 ∨ ⋯ ∨ p xsi`, it is also used to compute the
  variable permutations.

(3) `wlog := r using xs0`
  The expression `r` is a proof of the shape `p xs0 ∨ ⋯ ∨ p xsi`, it is also used to compute the
  variable permutations. This is not as stable as (2), for example `p` cannot be a disjunction.

(4) `wlog : R x y using x y` and `wlog : R x y`
  Produces the case `R x y ∨ R y x`. If `R` is ≤, then the disjunction discharged using linearity.
  If `using x y` is avoided then `x` and `y` are the last two variables appearing in the
  expression `R x y`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='If `q ≠ 0`, the p-adic norm of a rational `q` is `p ^ (-(padic_val_rat p q))`.
If `q = 0`, the p-adic norm of `q` is 0.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title=' Without loss of generality: reduces to one goal under variables permutations.

Given a goal of the form `g xs`, a predicate `p` over a set of variables, as well as variable
permutations `xs_i`. Then `wlog` produces goals of the form

The case goal, i.e. the permutation `xs_i` covers all possible cases:
  `⊢ p xs_0 ∨ ⋯ ∨ p xs_n`
The main goal, i.e. the goal reduced to `xs_0`:
  `(h : p xs_0) ⊢ g xs_0`
The invariant goals, i.e. `g` is invariant under `xs_i`:
  `(h : p xs_i) (this : g xs_0) ⊢ gs xs_i`

Either the permutation is provided, or a proof of the disjunction is provided to compute the
permutation. The disjunction need to be in assoc normal form, e.g. `p₀ ∨ (p₁ ∨ p₂)`. In many cases
the invariant goals can be solved by AC rewriting using `cc` etc.

Example:
  On a state `(n m : ℕ) ⊢ p n m` the tactic `wlog h : n ≤ m using [n m, m n]` produces the following
  states:
    `(n m : ℕ) ⊢ n ≤ m ∨ m ≤ n`
    `(n m : ℕ) (h : n ≤ m) ⊢ p n m`
    `(n m : ℕ) (h : m ≤ n) (this : p n m) ⊢ p m n`

`wlog` supports different calling conventions. The name `h` is used to give a name to the introduced
case hypothesis. If the name is avoided, the default will be `case`.

(1) `wlog : p xs0 using [xs0, …, xsn]`
  Results in the case goal `p xs0 ∨ ⋯ ∨ ps xsn`, the main goal `(case : p xs0) ⊢ g xs0` and the
  invariance goals `(case : p xsi) (this : g xs0) ⊢ g xsi`.

(2) `wlog : p xs0 := r using xs0`
  The expression `r` is a proof of the shape `p xs0 ∨ ⋯ ∨ p xsi`, it is also used to compute the
  variable permutations.

(3) `wlog := r using xs0`
  The expression `r` is a proof of the shape `p xs0 ∨ ⋯ ∨ p xsi`, it is also used to compute the
  variable permutations. This is not as stable as (2), for example `p` cannot be a disjunction.

(4) `wlog : R x y using x y` and `wlog : R x y`
  Produces the case `R x y ∨ R y x`. If `R` is ≤, then the disjunction discharged using linearity.
  If `using x y` is avoided then `x` and `y` are the last two variables appearing in the
  expression `R x y`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title=' Without loss of generality: reduces to one goal under variables permutations.

Given a goal of the form `g xs`, a predicate `p` over a set of variables, as well as variable
permutations `xs_i`. Then `wlog` produces goals of the form

The case goal, i.e. the permutation `xs_i` covers all possible cases:
  `⊢ p xs_0 ∨ ⋯ ∨ p xs_n`
The main goal, i.e. the goal reduced to `xs_0`:
  `(h : p xs_0) ⊢ g xs_0`
The invariant goals, i.e. `g` is invariant under `xs_i`:
  `(h : p xs_i) (this : g xs_0) ⊢ gs xs_i`

Either the permutation is provided, or a proof of the disjunction is provided to compute the
permutation. The disjunction need to be in assoc normal form, e.g. `p₀ ∨ (p₁ ∨ p₂)`. In many cases
the invariant goals can be solved by AC rewriting using `cc` etc.

Example:
  On a state `(n m : ℕ) ⊢ p n m` the tactic `wlog h : n ≤ m using [n m, m n]` produces the following
  states:
    `(n m : ℕ) ⊢ n ≤ m ∨ m ≤ n`
    `(n m : ℕ) (h : n ≤ m) ⊢ p n m`
    `(n m : ℕ) (h : m ≤ n) (this : p n m) ⊢ p m n`

`wlog` supports different calling conventions. The name `h` is used to give a name to the introduced
case hypothesis. If the name is avoided, the default will be `case`.

(1) `wlog : p xs0 using [xs0, …, xsn]`
  Results in the case goal `p xs0 ∨ ⋯ ∨ ps xsn`, the main goal `(case : p xs0) ⊢ g xs0` and the
  invariance goals `(case : p xsi) (this : g xs0) ⊢ g xsi`.

(2) `wlog : p xs0 := r using xs0`
  The expression `r` is a proof of the shape `p xs0 ∨ ⋯ ∨ p xsi`, it is also used to compute the
  variable permutations.

(3) `wlog := r using xs0`
  The expression `r` is a proof of the shape `p xs0 ∨ ⋯ ∨ p xsi`, it is also used to compute the
  variable permutations. This is not as stable as (2), for example `p` cannot be a disjunction.

(4) `wlog : R x y using x y` and `wlog : R x y`
  Produces the case `R x y ∨ R y x`. If `R` is ≤, then the disjunction discharged using linearity.
  If `using x y` is avoided then `x` and `y` are the last two variables appearing in the
  expression `R x y`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title=' Without loss of generality: reduces to one goal under variables permutations.

Given a goal of the form `g xs`, a predicate `p` over a set of variables, as well as variable
permutations `xs_i`. Then `wlog` produces goals of the form

The case goal, i.e. the permutation `xs_i` covers all possible cases:
  `⊢ p xs_0 ∨ ⋯ ∨ p xs_n`
The main goal, i.e. the goal reduced to `xs_0`:
  `(h : p xs_0) ⊢ g xs_0`
The invariant goals, i.e. `g` is invariant under `xs_i`:
  `(h : p xs_i) (this : g xs_0) ⊢ gs xs_i`

Either the permutation is provided, or a proof of the disjunction is provided to compute the
permutation. The disjunction need to be in assoc normal form, e.g. `p₀ ∨ (p₁ ∨ p₂)`. In many cases
the invariant goals can be solved by AC rewriting using `cc` etc.

Example:
  On a state `(n m : ℕ) ⊢ p n m` the tactic `wlog h : n ≤ m using [n m, m n]` produces the following
  states:
    `(n m : ℕ) ⊢ n ≤ m ∨ m ≤ n`
    `(n m : ℕ) (h : n ≤ m) ⊢ p n m`
    `(n m : ℕ) (h : m ≤ n) (this : p n m) ⊢ p m n`

`wlog` supports different calling conventions. The name `h` is used to give a name to the introduced
case hypothesis. If the name is avoided, the default will be `case`.

(1) `wlog : p xs0 using [xs0, …, xsn]`
  Results in the case goal `p xs0 ∨ ⋯ ∨ ps xsn`, the main goal `(case : p xs0) ⊢ g xs0` and the
  invariance goals `(case : p xsi) (this : g xs0) ⊢ g xsi`.

(2) `wlog : p xs0 := r using xs0`
  The expression `r` is a proof of the shape `p xs0 ∨ ⋯ ∨ p xsi`, it is also used to compute the
  variable permutations.

(3) `wlog := r using xs0`
  The expression `r` is a proof of the shape `p xs0 ∨ ⋯ ∨ p xsi`, it is also used to compute the
  variable permutations. This is not as stable as (2), for example `p` cannot be a disjunction.

(4) `wlog : R x y using x y` and `wlog : R x y`
  Produces the case `R x y ∨ R y x`. If `R` is ≤, then the disjunction discharged using linearity.
  If `using x y` is avoided then `x` and `y` are the last two variables appearing in the
  expression `R x y`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='wlog'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='wlog'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='wlog'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='wlog'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='wlog'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='wlog'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='wlog'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='wlog'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;, &#x27;(using ([id*, ...] | id*))?&#x27;, &#x27;tactic.{0} unit?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;, &#x27;(using ([id*, ...] | id*))?&#x27;, &#x27;tactic.{0} unit?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;, &#x27;(using ([id*, ...] | id*))?&#x27;, &#x27;tactic.{0} unit?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;, &#x27;(using ([id*, ...] | id*))?&#x27;, &#x27;tactic.{0} unit?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;, &#x27;(using ([id*, ...] | id*))?&#x27;, &#x27;tactic.{0} unit?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;, &#x27;(using ([id*, ...] | id*))?&#x27;, &#x27;tactic.{0} unit?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;, &#x27;(using ([id*, ...] | id*))?&#x27;, &#x27;tactic.{0} unit?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;, &#x27;(using ([id*, ...] | id*))?&#x27;, &#x27;tactic.{0} unit?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
q r : rat,
hne : @ne.{1} rat (padic_norm p q) (padic_norm p r)
⊢ @eq.{1} rat (padic_norm p (@has_add.add.{0} rat rat.has_add q r))
    (@max.{0} rat rat.decidable_linear_order (padic_norm p q) (padic_norm p r))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case main
p : nat,
hp : nat.prime p,
q r : rat,
hle :
  @has_le.le.{0} rat
    (@preorder.to_has_le.{0} rat
       (@partial_order.to_preorder.{0} rat (@linear_order.to_partial_order.{0} rat rat.linear_order)))
    (padic_norm p r)
    (padic_norm p q),
hne : @ne.{1} rat (padic_norm p q) (padic_norm p r)
⊢ @eq.{1} rat (padic_norm p (@has_add.add.{0} rat rat.has_add q r))
    (@max.{0} rat rat.decidable_linear_order (padic_norm p q) (padic_norm p r))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>432    have hlt : padic_norm p r &lt; padic_norm p q, from lt_of_le_of_ne hle hne.symm,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='blue'><a title='r'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_lt.lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='padic_norm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='q'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='lt_of_le_of_ne'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hle'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hne'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 320, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 261, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 136, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 112, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type} [c : has_lt.{0} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat → rat → rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : partial_order.{0} α] {a b : α}, @has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α _inst_1)) a b → @ne.{1} α a b → @has_lt.lt.{0} α (@preorder.to_has_lt.{0} α (@partial_order.to_preorder.{0} α _inst_1)) a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_le.le.{0} rat (@preorder.to_has_le.{0} rat (@partial_order.to_preorder.{0} rat (@linear_order.to_partial_order.{0} rat rat.linear_order))) (padic_norm p r) (padic_norm p q)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@ne.{1} rat (padic_norm p q) (padic_norm p r)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='If `q ≠ 0`, the p-adic norm of a rational `q` is `p ^ (-(padic_val_rat p q))`.
If `q = 0`, the p-adic norm of `q` is 0.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case main
p : nat,
hp : nat.prime p,
q r : rat,
hle :
  @has_le.le.{0} rat
    (@preorder.to_has_le.{0} rat
       (@partial_order.to_preorder.{0} rat (@linear_order.to_partial_order.{0} rat rat.linear_order)))
    (padic_norm p r)
    (padic_norm p q),
hne : @ne.{1} rat (padic_norm p q) (padic_norm p r)
⊢ @eq.{1} rat (padic_norm p (@has_add.add.{0} rat rat.has_add q r))
    (@max.{0} rat rat.decidable_linear_order (padic_norm p q) (padic_norm p r))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
p : nat,
hp : nat.prime p,
q r : rat,
hle :
  @has_le.le.{0} rat
    (@preorder.to_has_le.{0} rat
       (@partial_order.to_preorder.{0} rat (@linear_order.to_partial_order.{0} rat rat.linear_order)))
    (padic_norm p r)
    (padic_norm p q),
hne : @ne.{1} rat (padic_norm p q) (padic_norm p r)
⊢ @has_lt.lt.{0} rat rat.has_lt (padic_norm p r) (padic_norm p q)

p : nat,
hp : nat.prime p,
q r : rat,
hle :
  @has_le.le.{0} rat
    (@preorder.to_has_le.{0} rat
       (@partial_order.to_preorder.{0} rat (@linear_order.to_partial_order.{0} rat rat.linear_order)))
    (padic_norm p r)
    (padic_norm p q),
hne : @ne.{1} rat (padic_norm p q) (padic_norm p r),
hlt : @has_lt.lt.{0} rat rat.has_lt (padic_norm p r) (padic_norm p q)
⊢ @eq.{1} rat (padic_norm p (@has_add.add.{0} rat rat.has_add q r))
    (@max.{0} rat rat.decidable_linear_order (padic_norm p q) (padic_norm p r))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
q r : rat,
hle :
  @has_le.le.{0} rat
    (@preorder.to_has_le.{0} rat
       (@partial_order.to_preorder.{0} rat (@linear_order.to_partial_order.{0} rat rat.linear_order)))
    (padic_norm p r)
    (padic_norm p q),
hne : @ne.{1} rat (padic_norm p q) (padic_norm p r),
hlt : @has_lt.lt.{0} rat rat.has_lt (padic_norm p r) (padic_norm p q)
⊢ @eq.{1} rat (padic_norm p (@has_add.add.{0} rat rat.has_add q r))
    (@max.{0} rat rat.decidable_linear_order (padic_norm p q) (padic_norm p r))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>433    have : padic_norm p q ≤ max (padic_norm p (q + r)) (padic_norm p r), from calc</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='blue'><a title='has_le.le'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='max'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='q'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='padic_norm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='r'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 319, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/functions.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 11}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 261, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type} [c : has_le.{0} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type} [_inst_1 : decidable_linear_order.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type} [c : has_add.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat → rat → rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='If `q ≠ 0`, the p-adic norm of a rational `q` is `p ^ (-(padic_val_rat p q))`.
If `q = 0`, the p-adic norm of `q` is 0.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
q r : rat,
hle :
  @has_le.le.{0} rat
    (@preorder.to_has_le.{0} rat
       (@partial_order.to_preorder.{0} rat (@linear_order.to_partial_order.{0} rat rat.linear_order)))
    (padic_norm p r)
    (padic_norm p q),
hne : @ne.{1} rat (padic_norm p q) (padic_norm p r),
hlt : @has_lt.lt.{0} rat rat.has_lt (padic_norm p r) (padic_norm p q)
⊢ @eq.{1} rat (padic_norm p (@has_add.add.{0} rat rat.has_add q r))
    (@max.{0} rat rat.decidable_linear_order (padic_norm p q) (padic_norm p r))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
p : nat,
hp : nat.prime p,
q r : rat,
hle :
  @has_le.le.{0} rat
    (@preorder.to_has_le.{0} rat
       (@partial_order.to_preorder.{0} rat (@linear_order.to_partial_order.{0} rat rat.linear_order)))
    (padic_norm p r)
    (padic_norm p q),
hne : @ne.{1} rat (padic_norm p q) (padic_norm p r),
hlt : @has_lt.lt.{0} rat rat.has_lt (padic_norm p r) (padic_norm p q)
⊢ @has_le.le.{0} rat rat.has_le (padic_norm p q)
    (@max.{0} rat rat.decidable_linear_order (padic_norm p (@has_add.add.{0} rat rat.has_add q r)) (padic_norm p r))

p : nat,
hp : nat.prime p,
q r : rat,
hle :
  @has_le.le.{0} rat
    (@preorder.to_has_le.{0} rat
       (@partial_order.to_preorder.{0} rat (@linear_order.to_partial_order.{0} rat rat.linear_order)))
    (padic_norm p r)
    (padic_norm p q),
hne : @ne.{1} rat (padic_norm p q) (padic_norm p r),
hlt : @has_lt.lt.{0} rat rat.has_lt (padic_norm p r) (padic_norm p q),
this :
  @has_le.le.{0} rat rat.has_le (padic_norm p q)
    (@max.{0} rat rat.decidable_linear_order (padic_norm p (@has_add.add.{0} rat rat.has_add q r)) (padic_norm p r))
⊢ @eq.{1} rat (padic_norm p (@has_add.add.{0} rat rat.has_add q r))
    (@max.{0} rat rat.decidable_linear_order (padic_norm p q) (padic_norm p r))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>434     padic_norm p q = padic_norm p (q + r - r) : by congr; ring</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='blue'><a title='padic_norm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='q'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='has_sub.sub'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='r'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 261, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 315, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1543, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/ring.lean&#x27;, &#x27;line&#x27;: 508, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat → rat → rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type} [c : has_sub.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse tactic.ring.normalize_mode (λ (a : tactic.ring.normalize_mode), tactic.ring.normalize_mode.has_reflect a) tactic.interactive.ring.mode → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='If `q ≠ 0`, the p-adic norm of a rational `q` is `p ^ (-(padic_val_rat p q))`.
If `q = 0`, the p-adic norm of `q` is 0.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Tactic for solving equations in the language of *commutative* (semi)rings.
 Attempts to prove the goal outright if there is no `at`
 specifier and the target is an equality, but if this
 fails it falls back to rewriting all ring expressions
 into a normal form. When writing a normal form,
 `ring SOP` will use sum-of-products form instead of horner form.
 `ring!` will use a more aggressive reducibility setting to identify atoms.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='congr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='ring'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;(SOP|raw|horner)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
p : nat,
hp : nat.prime p,
q r : rat,
hle :
  @has_le.le.{0} rat
    (@preorder.to_has_le.{0} rat
       (@partial_order.to_preorder.{0} rat (@linear_order.to_partial_order.{0} rat rat.linear_order)))
    (padic_norm p r)
    (padic_norm p q),
hne : @ne.{1} rat (padic_norm p q) (padic_norm p r),
hlt : @has_lt.lt.{0} rat rat.has_lt (padic_norm p r) (padic_norm p q)
⊢ @has_le.le.{0} rat rat.has_le (padic_norm p q)
    (@max.{0} rat rat.decidable_linear_order (padic_norm p (@has_add.add.{0} rat rat.has_add q r)) (padic_norm p r))

p : nat,
hp : nat.prime p,
q r : rat,
hle :
  @has_le.le.{0} rat
    (@preorder.to_has_le.{0} rat
       (@partial_order.to_preorder.{0} rat (@linear_order.to_partial_order.{0} rat rat.linear_order)))
    (padic_norm p r)
    (padic_norm p q),
hne : @ne.{1} rat (padic_norm p q) (padic_norm p r),
hlt : @has_lt.lt.{0} rat rat.has_lt (padic_norm p r) (padic_norm p q),
this :
  @has_le.le.{0} rat rat.has_le (padic_norm p q)
    (@max.{0} rat rat.decidable_linear_order (padic_norm p (@has_add.add.{0} rat rat.has_add q r)) (padic_norm p r))
⊢ @eq.{1} rat (padic_norm p (@has_add.add.{0} rat rat.has_add q r))
    (@max.{0} rat rat.decidable_linear_order (padic_norm p q) (padic_norm p r))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
q r : rat,
hle :
  @has_le.le.{0} rat
    (@preorder.to_has_le.{0} rat
       (@partial_order.to_preorder.{0} rat (@linear_order.to_partial_order.{0} rat rat.linear_order)))
    (padic_norm p r)
    (padic_norm p q),
hne : @ne.{1} rat (padic_norm p q) (padic_norm p r),
hlt : @has_lt.lt.{0} rat rat.has_lt (padic_norm p r) (padic_norm p q)
⊢ @eq.{1} rat (padic_norm p q)
    (padic_norm p
       (@has_sub.sub.{0} rat (@add_group_has_sub.{0} rat rat.add_group) (@has_add.add.{0} rat rat.has_add q r) r))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>435                 ... ≤ max (padic_norm p (q + r)) (padic_norm p (-r)) : padic_norm.nonarchimedean p</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                               </code><font color='blue'><a title='has_neg.neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='padic_norm.nonarchimedean'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/ring.lean&#x27;, &#x27;line&#x27;: 508, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 314, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 401, &#x27;column&#x27;: 18}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse tactic.ring.normalize_mode (λ (a : tactic.ring.normalize_mode), tactic.ring.normalize_mode.has_reflect a) tactic.interactive.ring.mode → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_neg.{0} α], α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (p : nat) [hp : nat.prime p] {q r : rat}, @has_le.le.{0} rat rat.has_le (padic_norm p (@has_add.add.{0} rat rat.has_add q r)) (@max.{0} rat rat.decidable_linear_order (padic_norm p q) (padic_norm p r))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Tactic for solving equations in the language of *commutative* (semi)rings.
 Attempts to prove the goal outright if there is no `at`
 specifier and the target is an equality, but if this
 fails it falls back to rewriting all ring expressions
 into a normal form. When writing a normal form,
 `ring SOP` will use sum-of-products form instead of horner form.
 `ring!` will use a more aggressive reducibility setting to identify atoms.'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The p-adic norm is nonarchimedean: the norm of `p + q` is at most the max of the norm of `p` and
the norm of `q`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='ring'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;(SOP|raw|horner)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
q r : rat,
hle :
  @has_le.le.{0} rat
    (@preorder.to_has_le.{0} rat
       (@partial_order.to_preorder.{0} rat (@linear_order.to_partial_order.{0} rat rat.linear_order)))
    (padic_norm p r)
    (padic_norm p q),
hne : @ne.{1} rat (padic_norm p q) (padic_norm p r),
hlt : @has_lt.lt.{0} rat rat.has_lt (padic_norm p r) (padic_norm p q)
⊢ @eq.{1} rat (padic_norm p q)
    (padic_norm p
       (@has_sub.sub.{0} rat (@add_group_has_sub.{0} rat rat.add_group) (@has_add.add.{0} rat rat.has_add q r) r))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
p : nat,
hp : nat.prime p,
q r : rat,
hle :
  @has_le.le.{0} rat
    (@preorder.to_has_le.{0} rat
       (@partial_order.to_preorder.{0} rat (@linear_order.to_partial_order.{0} rat rat.linear_order)))
    (padic_norm p r)
    (padic_norm p q),
hne : @ne.{1} rat (padic_norm p q) (padic_norm p r),
hlt : @has_lt.lt.{0} rat rat.has_lt (padic_norm p r) (padic_norm p q)
⊢ @has_le.le.{0} rat rat.has_le (padic_norm p q)
    (@max.{0} rat rat.decidable_linear_order (padic_norm p (@has_add.add.{0} rat rat.has_add q r)) (padic_norm p r))

p : nat,
hp : nat.prime p,
q r : rat,
hle :
  @has_le.le.{0} rat
    (@preorder.to_has_le.{0} rat
       (@partial_order.to_preorder.{0} rat (@linear_order.to_partial_order.{0} rat rat.linear_order)))
    (padic_norm p r)
    (padic_norm p q),
hne : @ne.{1} rat (padic_norm p q) (padic_norm p r),
hlt : @has_lt.lt.{0} rat rat.has_lt (padic_norm p r) (padic_norm p q),
this :
  @has_le.le.{0} rat rat.has_le (padic_norm p q)
    (@max.{0} rat rat.decidable_linear_order (padic_norm p (@has_add.add.{0} rat rat.has_add q r)) (padic_norm p r))
⊢ @eq.{1} rat (padic_norm p (@has_add.add.{0} rat rat.has_add q r))
    (@max.{0} rat rat.decidable_linear_order (padic_norm p q) (padic_norm p r))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>436                 ... = max (padic_norm p (q + r)) (padic_norm p r) : by simp,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='blue'><a title='max'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/functions.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 11}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type} [_inst_1 : decidable_linear_order.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
p : nat,
hp : nat.prime p,
q r : rat,
hle :
  @has_le.le.{0} rat
    (@preorder.to_has_le.{0} rat
       (@partial_order.to_preorder.{0} rat (@linear_order.to_partial_order.{0} rat rat.linear_order)))
    (padic_norm p r)
    (padic_norm p q),
hne : @ne.{1} rat (padic_norm p q) (padic_norm p r),
hlt : @has_lt.lt.{0} rat rat.has_lt (padic_norm p r) (padic_norm p q)
⊢ @has_le.le.{0} rat rat.has_le (padic_norm p q)
    (@max.{0} rat rat.decidable_linear_order (padic_norm p (@has_add.add.{0} rat rat.has_add q r)) (padic_norm p r))

p : nat,
hp : nat.prime p,
q r : rat,
hle :
  @has_le.le.{0} rat
    (@preorder.to_has_le.{0} rat
       (@partial_order.to_preorder.{0} rat (@linear_order.to_partial_order.{0} rat rat.linear_order)))
    (padic_norm p r)
    (padic_norm p q),
hne : @ne.{1} rat (padic_norm p q) (padic_norm p r),
hlt : @has_lt.lt.{0} rat rat.has_lt (padic_norm p r) (padic_norm p q),
this :
  @has_le.le.{0} rat rat.has_le (padic_norm p q)
    (@max.{0} rat rat.decidable_linear_order (padic_norm p (@has_add.add.{0} rat rat.has_add q r)) (padic_norm p r))
⊢ @eq.{1} rat (padic_norm p (@has_add.add.{0} rat rat.has_add q r))
    (@max.{0} rat rat.decidable_linear_order (padic_norm p q) (padic_norm p r))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
q r : rat,
hle :
  @has_le.le.{0} rat
    (@preorder.to_has_le.{0} rat
       (@partial_order.to_preorder.{0} rat (@linear_order.to_partial_order.{0} rat rat.linear_order)))
    (padic_norm p r)
    (padic_norm p q),
hne : @ne.{1} rat (padic_norm p q) (padic_norm p r),
hlt : @has_lt.lt.{0} rat rat.has_lt (padic_norm p r) (padic_norm p q)
⊢ @eq.{1} rat
    (@max.{0} rat rat.decidable_linear_order (padic_norm p (@has_add.add.{0} rat rat.has_add q r))
       (padic_norm p (@has_neg.neg.{0} rat rat.has_neg r)))
    (@max.{0} rat rat.decidable_linear_order (padic_norm p (@has_add.add.{0} rat rat.has_add q r)) (padic_norm p r))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
q r : rat,
hle :
  @has_le.le.{0} rat
    (@preorder.to_has_le.{0} rat
       (@partial_order.to_preorder.{0} rat (@linear_order.to_partial_order.{0} rat rat.linear_order)))
    (padic_norm p r)
    (padic_norm p q),
hne : @ne.{1} rat (padic_norm p q) (padic_norm p r),
hlt : @has_lt.lt.{0} rat rat.has_lt (padic_norm p r) (padic_norm p q),
this :
  @has_le.le.{0} rat rat.has_le (padic_norm p q)
    (@max.{0} rat rat.decidable_linear_order (padic_norm p (@has_add.add.{0} rat rat.has_add q r)) (padic_norm p r))
⊢ @eq.{1} rat (padic_norm p (@has_add.add.{0} rat rat.has_add q r))
    (@max.{0} rat rat.decidable_linear_order (padic_norm p q) (padic_norm p r))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>437    have hnge : padic_norm p r ≤ padic_norm p (q + r),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='blue'><a title='padic_norm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='q'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='r'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 261, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat → rat → rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='If `q ≠ 0`, the p-adic norm of a rational `q` is `p ^ (-(padic_val_rat p q))`.
If `q = 0`, the p-adic norm of `q` is 0.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
q r : rat,
hle :
  @has_le.le.{0} rat
    (@preorder.to_has_le.{0} rat
       (@partial_order.to_preorder.{0} rat (@linear_order.to_partial_order.{0} rat rat.linear_order)))
    (padic_norm p r)
    (padic_norm p q),
hne : @ne.{1} rat (padic_norm p q) (padic_norm p r),
hlt : @has_lt.lt.{0} rat rat.has_lt (padic_norm p r) (padic_norm p q),
this :
  @has_le.le.{0} rat rat.has_le (padic_norm p q)
    (@max.{0} rat rat.decidable_linear_order (padic_norm p (@has_add.add.{0} rat rat.has_add q r)) (padic_norm p r))
⊢ @eq.{1} rat (padic_norm p (@has_add.add.{0} rat rat.has_add q r))
    (@max.{0} rat rat.decidable_linear_order (padic_norm p q) (padic_norm p r))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
p : nat,
hp : nat.prime p,
q r : rat,
hle :
  @has_le.le.{0} rat
    (@preorder.to_has_le.{0} rat
       (@partial_order.to_preorder.{0} rat (@linear_order.to_partial_order.{0} rat rat.linear_order)))
    (padic_norm p r)
    (padic_norm p q),
hne : @ne.{1} rat (padic_norm p q) (padic_norm p r),
hlt : @has_lt.lt.{0} rat rat.has_lt (padic_norm p r) (padic_norm p q),
this :
  @has_le.le.{0} rat rat.has_le (padic_norm p q)
    (@max.{0} rat rat.decidable_linear_order (padic_norm p (@has_add.add.{0} rat rat.has_add q r)) (padic_norm p r))
⊢ @has_le.le.{0} rat rat.has_le (padic_norm p r) (padic_norm p (@has_add.add.{0} rat rat.has_add q r))

p : nat,
hp : nat.prime p,
q r : rat,
hle :
  @has_le.le.{0} rat
    (@preorder.to_has_le.{0} rat
       (@partial_order.to_preorder.{0} rat (@linear_order.to_partial_order.{0} rat rat.linear_order)))
    (padic_norm p r)
    (padic_norm p q),
hne : @ne.{1} rat (padic_norm p q) (padic_norm p r),
hlt : @has_lt.lt.{0} rat rat.has_lt (padic_norm p r) (padic_norm p q),
this :
  @has_le.le.{0} rat rat.has_le (padic_norm p q)
    (@max.{0} rat rat.decidable_linear_order (padic_norm p (@has_add.add.{0} rat rat.has_add q r)) (padic_norm p r)),
hnge : @has_le.le.{0} rat rat.has_le (padic_norm p r) (padic_norm p (@has_add.add.{0} rat rat.has_add q r))
⊢ @eq.{1} rat (padic_norm p (@has_add.add.{0} rat rat.has_add q r))
    (@max.{0} rat rat.decidable_linear_order (padic_norm p q) (padic_norm p r))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>438    { apply le_of_not_gt,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='le_of_not_gt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 148, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : linear_order.{0} α] {a b : α}, not (@gt.{0} α (@preorder.to_has_lt.{0} α (@partial_order.to_preorder.{0} α (@linear_order.to_partial_order.{0} α _inst_1))) a b) → @has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@linear_order.to_partial_order.{0} α _inst_1))) a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
p : nat,
hp : nat.prime p,
q r : rat,
hle :
  @has_le.le.{0} rat
    (@preorder.to_has_le.{0} rat
       (@partial_order.to_preorder.{0} rat (@linear_order.to_partial_order.{0} rat rat.linear_order)))
    (padic_norm p r)
    (padic_norm p q),
hne : @ne.{1} rat (padic_norm p q) (padic_norm p r),
hlt : @has_lt.lt.{0} rat rat.has_lt (padic_norm p r) (padic_norm p q),
this :
  @has_le.le.{0} rat rat.has_le (padic_norm p q)
    (@max.{0} rat rat.decidable_linear_order (padic_norm p (@has_add.add.{0} rat rat.has_add q r)) (padic_norm p r))
⊢ @has_le.le.{0} rat rat.has_le (padic_norm p r) (padic_norm p (@has_add.add.{0} rat rat.has_add q r))

p : nat,
hp : nat.prime p,
q r : rat,
hle :
  @has_le.le.{0} rat
    (@preorder.to_has_le.{0} rat
       (@partial_order.to_preorder.{0} rat (@linear_order.to_partial_order.{0} rat rat.linear_order)))
    (padic_norm p r)
    (padic_norm p q),
hne : @ne.{1} rat (padic_norm p q) (padic_norm p r),
hlt : @has_lt.lt.{0} rat rat.has_lt (padic_norm p r) (padic_norm p q),
this :
  @has_le.le.{0} rat rat.has_le (padic_norm p q)
    (@max.{0} rat rat.decidable_linear_order (padic_norm p (@has_add.add.{0} rat rat.has_add q r)) (padic_norm p r)),
hnge : @has_le.le.{0} rat rat.has_le (padic_norm p r) (padic_norm p (@has_add.add.{0} rat rat.has_add q r))
⊢ @eq.{1} rat (padic_norm p (@has_add.add.{0} rat rat.has_add q r))
    (@max.{0} rat rat.decidable_linear_order (padic_norm p q) (padic_norm p r))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
q r : rat,
hle :
  @has_le.le.{0} rat
    (@preorder.to_has_le.{0} rat
       (@partial_order.to_preorder.{0} rat (@linear_order.to_partial_order.{0} rat rat.linear_order)))
    (padic_norm p r)
    (padic_norm p q),
hne : @ne.{1} rat (padic_norm p q) (padic_norm p r),
hlt : @has_lt.lt.{0} rat rat.has_lt (padic_norm p r) (padic_norm p q),
this :
  @has_le.le.{0} rat rat.has_le (padic_norm p q)
    (@max.{0} rat rat.decidable_linear_order (padic_norm p (@has_add.add.{0} rat rat.has_add q r)) (padic_norm p r))
⊢ @has_le.le.{0} rat rat.has_le (padic_norm p r) (padic_norm p (@has_add.add.{0} rat rat.has_add q r))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
q r : rat,
hle :
  @has_le.le.{0} rat
    (@preorder.to_has_le.{0} rat
       (@partial_order.to_preorder.{0} rat (@linear_order.to_partial_order.{0} rat rat.linear_order)))
    (padic_norm p r)
    (padic_norm p q),
hne : @ne.{1} rat (padic_norm p q) (padic_norm p r),
hlt : @has_lt.lt.{0} rat rat.has_lt (padic_norm p r) (padic_norm p q),
this :
  @has_le.le.{0} rat rat.has_le (padic_norm p q)
    (@max.{0} rat rat.decidable_linear_order (padic_norm p (@has_add.add.{0} rat rat.has_add q r)) (padic_norm p r))
⊢ not
    (@gt.{0} rat
       (@preorder.to_has_lt.{0} rat
          (@partial_order.to_preorder.{0} rat (@linear_order.to_partial_order.{0} rat rat.linear_order)))
       (padic_norm p r)
       (padic_norm p (@has_add.add.{0} rat rat.has_add q r)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>439      intro hgt,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 122, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='If the current goal is a Pi/forall `∀ x : t, u` (resp. `let x := t in u`) then `intro` puts `x : t` (resp. `x := t`) in the local context. The new subgoal target is `u`.

If the goal is an arrow `t → u`, then it puts `h : t` in the local context and the new goal target is `u`.

If the goal is neither a Pi/forall nor begins with a let binder, the tactic `intro` applies the tactic `whnf` until an introduction can be applied or the goal is not head reducible. In the latter case, the tactic fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='intro'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
q r : rat,
hle :
  @has_le.le.{0} rat
    (@preorder.to_has_le.{0} rat
       (@partial_order.to_preorder.{0} rat (@linear_order.to_partial_order.{0} rat rat.linear_order)))
    (padic_norm p r)
    (padic_norm p q),
hne : @ne.{1} rat (padic_norm p q) (padic_norm p r),
hlt : @has_lt.lt.{0} rat rat.has_lt (padic_norm p r) (padic_norm p q),
this :
  @has_le.le.{0} rat rat.has_le (padic_norm p q)
    (@max.{0} rat rat.decidable_linear_order (padic_norm p (@has_add.add.{0} rat rat.has_add q r)) (padic_norm p r))
⊢ not
    (@gt.{0} rat
       (@preorder.to_has_lt.{0} rat
          (@partial_order.to_preorder.{0} rat (@linear_order.to_partial_order.{0} rat rat.linear_order)))
       (padic_norm p r)
       (padic_norm p (@has_add.add.{0} rat rat.has_add q r)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
q r : rat,
hle :
  @has_le.le.{0} rat
    (@preorder.to_has_le.{0} rat
       (@partial_order.to_preorder.{0} rat (@linear_order.to_partial_order.{0} rat rat.linear_order)))
    (padic_norm p r)
    (padic_norm p q),
hne : @ne.{1} rat (padic_norm p q) (padic_norm p r),
hlt : @has_lt.lt.{0} rat rat.has_lt (padic_norm p r) (padic_norm p q),
this :
  @has_le.le.{0} rat rat.has_le (padic_norm p q)
    (@max.{0} rat rat.decidable_linear_order (padic_norm p (@has_add.add.{0} rat rat.has_add q r)) (padic_norm p r)),
hgt :
  @gt.{0} rat
    (@preorder.to_has_lt.{0} rat
       (@partial_order.to_preorder.{0} rat (@linear_order.to_partial_order.{0} rat rat.linear_order)))
    (padic_norm p r)
    (padic_norm p (@has_add.add.{0} rat rat.has_add q r))
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>440      rw max_eq_right_of_lt hgt at this,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='max_eq_right_of_lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hgt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/functions.lean&#x27;, &#x27;line&#x27;: 116, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : decidable_linear_order.{0} α] {a b : α}, @has_lt.lt.{0} α (@preorder.to_has_lt.{0} α (@partial_order.to_preorder.{0} α (@linear_order.to_partial_order.{0} α (@decidable_linear_order.to_linear_order.{0} α _inst_1)))) a b → @eq.{1} α (@max.{0} α _inst_1 a b) b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@gt.{0} rat (@preorder.to_has_lt.{0} rat (@partial_order.to_preorder.{0} rat (@linear_order.to_partial_order.{0} rat rat.linear_order))) (padic_norm p r) (padic_norm p (@has_add.add.{0} rat rat.has_add q r))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
q r : rat,
hle :
  @has_le.le.{0} rat
    (@preorder.to_has_le.{0} rat
       (@partial_order.to_preorder.{0} rat (@linear_order.to_partial_order.{0} rat rat.linear_order)))
    (padic_norm p r)
    (padic_norm p q),
hne : @ne.{1} rat (padic_norm p q) (padic_norm p r),
hlt : @has_lt.lt.{0} rat rat.has_lt (padic_norm p r) (padic_norm p q),
this :
  @has_le.le.{0} rat rat.has_le (padic_norm p q)
    (@max.{0} rat rat.decidable_linear_order (padic_norm p (@has_add.add.{0} rat rat.has_add q r)) (padic_norm p r)),
hgt :
  @gt.{0} rat
    (@preorder.to_has_lt.{0} rat
       (@partial_order.to_preorder.{0} rat (@linear_order.to_partial_order.{0} rat rat.linear_order)))
    (padic_norm p r)
    (padic_norm p (@has_add.add.{0} rat rat.has_add q r))
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
q r : rat,
hle :
  @has_le.le.{0} rat
    (@preorder.to_has_le.{0} rat
       (@partial_order.to_preorder.{0} rat (@linear_order.to_partial_order.{0} rat rat.linear_order)))
    (padic_norm p r)
    (padic_norm p q),
hne : @ne.{1} rat (padic_norm p q) (padic_norm p r),
hlt : @has_lt.lt.{0} rat rat.has_lt (padic_norm p r) (padic_norm p q),
hgt :
  @gt.{0} rat
    (@preorder.to_has_lt.{0} rat
       (@partial_order.to_preorder.{0} rat (@linear_order.to_partial_order.{0} rat rat.linear_order)))
    (padic_norm p r)
    (padic_norm p (@has_add.add.{0} rat rat.has_add q r)),
this : @has_le.le.{0} rat rat.has_le (padic_norm p q) (padic_norm p r)
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>441      apply not_lt_of_ge this,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='not_lt_of_ge'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 121, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : preorder.{0} α] {a b : α}, @ge.{0} α (@preorder.to_has_le.{0} α _inst_1) a b → not (@has_lt.lt.{0} α (@preorder.to_has_lt.{0} α _inst_1) a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_le.le.{0} rat rat.has_le (padic_norm p q) (padic_norm p r)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
q r : rat,
hle :
  @has_le.le.{0} rat
    (@preorder.to_has_le.{0} rat
       (@partial_order.to_preorder.{0} rat (@linear_order.to_partial_order.{0} rat rat.linear_order)))
    (padic_norm p r)
    (padic_norm p q),
hne : @ne.{1} rat (padic_norm p q) (padic_norm p r),
hlt : @has_lt.lt.{0} rat rat.has_lt (padic_norm p r) (padic_norm p q),
hgt :
  @gt.{0} rat
    (@preorder.to_has_lt.{0} rat
       (@partial_order.to_preorder.{0} rat (@linear_order.to_partial_order.{0} rat rat.linear_order)))
    (padic_norm p r)
    (padic_norm p (@has_add.add.{0} rat rat.has_add q r)),
this : @has_le.le.{0} rat rat.has_le (padic_norm p q) (padic_norm p r)
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
q r : rat,
hle :
  @has_le.le.{0} rat
    (@preorder.to_has_le.{0} rat
       (@partial_order.to_preorder.{0} rat (@linear_order.to_partial_order.{0} rat rat.linear_order)))
    (padic_norm p r)
    (padic_norm p q),
hne : @ne.{1} rat (padic_norm p q) (padic_norm p r),
hlt : @has_lt.lt.{0} rat rat.has_lt (padic_norm p r) (padic_norm p q),
hgt :
  @gt.{0} rat
    (@preorder.to_has_lt.{0} rat
       (@partial_order.to_preorder.{0} rat (@linear_order.to_partial_order.{0} rat rat.linear_order)))
    (padic_norm p r)
    (padic_norm p (@has_add.add.{0} rat rat.has_add q r)),
this : @has_le.le.{0} rat rat.has_le (padic_norm p q) (padic_norm p r)
⊢ @has_lt.lt.{0} rat (@preorder.to_has_lt.{0} rat rat.preorder) (padic_norm p r) (padic_norm p q)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>442      assumption },</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 227, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic looks in the local context for a hypothesis whose type is equal to the goal target. If it finds one, it uses it to prove the goal, and otherwise it fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='assumption'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
q r : rat,
hle :
  @has_le.le.{0} rat
    (@preorder.to_has_le.{0} rat
       (@partial_order.to_preorder.{0} rat (@linear_order.to_partial_order.{0} rat rat.linear_order)))
    (padic_norm p r)
    (padic_norm p q),
hne : @ne.{1} rat (padic_norm p q) (padic_norm p r),
hlt : @has_lt.lt.{0} rat rat.has_lt (padic_norm p r) (padic_norm p q),
hgt :
  @gt.{0} rat
    (@preorder.to_has_lt.{0} rat
       (@partial_order.to_preorder.{0} rat (@linear_order.to_partial_order.{0} rat rat.linear_order)))
    (padic_norm p r)
    (padic_norm p (@has_add.add.{0} rat rat.has_add q r)),
this : @has_le.le.{0} rat rat.has_le (padic_norm p q) (padic_norm p r)
⊢ @has_lt.lt.{0} rat (@preorder.to_has_lt.{0} rat rat.preorder) (padic_norm p r) (padic_norm p q)'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
q r : rat,
hle :
  @has_le.le.{0} rat
    (@preorder.to_has_le.{0} rat
       (@partial_order.to_preorder.{0} rat (@linear_order.to_partial_order.{0} rat rat.linear_order)))
    (padic_norm p r)
    (padic_norm p q),
hne : @ne.{1} rat (padic_norm p q) (padic_norm p r),
hlt : @has_lt.lt.{0} rat rat.has_lt (padic_norm p r) (padic_norm p q),
this :
  @has_le.le.{0} rat rat.has_le (padic_norm p q)
    (@max.{0} rat rat.decidable_linear_order (padic_norm p (@has_add.add.{0} rat rat.has_add q r)) (padic_norm p r)),
hnge : @has_le.le.{0} rat rat.has_le (padic_norm p r) (padic_norm p (@has_add.add.{0} rat rat.has_add q r))
⊢ @eq.{1} rat (padic_norm p (@has_add.add.{0} rat rat.has_add q r))
    (@max.{0} rat rat.decidable_linear_order (padic_norm p q) (padic_norm p r))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>443    have : padic_norm p q ≤ padic_norm p (q + r), by rwa [max_eq_left hnge] at this,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='blue'><a title='padic_norm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='q'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='r'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='max_eq_left'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hnge'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 261, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 391, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/functions.lean&#x27;, &#x27;line&#x27;: 99, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 391, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 391, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat → rat → rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : decidable_linear_order.{0} α] {a b : α}, @has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@linear_order.to_partial_order.{0} α (@decidable_linear_order.to_linear_order.{0} α _inst_1)))) b a → @eq.{1} α (@max.{0} α _inst_1 a b) a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_le.le.{0} rat rat.has_le (padic_norm p r) (padic_norm p (@has_add.add.{0} rat rat.has_add q r))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='If `q ≠ 0`, the p-adic norm of a rational `q` is `p ^ (-(padic_val_rat p q))`.
If `q = 0`, the p-adic norm of `q` is 0.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='`rewrite` followed by `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='`rewrite` followed by `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`rewrite` followed by `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='rwa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='rwa'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rwa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
q r : rat,
hle :
  @has_le.le.{0} rat
    (@preorder.to_has_le.{0} rat
       (@partial_order.to_preorder.{0} rat (@linear_order.to_partial_order.{0} rat rat.linear_order)))
    (padic_norm p r)
    (padic_norm p q),
hne : @ne.{1} rat (padic_norm p q) (padic_norm p r),
hlt : @has_lt.lt.{0} rat rat.has_lt (padic_norm p r) (padic_norm p q),
this :
  @has_le.le.{0} rat rat.has_le (padic_norm p q)
    (@max.{0} rat rat.decidable_linear_order (padic_norm p (@has_add.add.{0} rat rat.has_add q r)) (padic_norm p r)),
hnge : @has_le.le.{0} rat rat.has_le (padic_norm p r) (padic_norm p (@has_add.add.{0} rat rat.has_add q r))
⊢ @eq.{1} rat (padic_norm p (@has_add.add.{0} rat rat.has_add q r))
    (@max.{0} rat rat.decidable_linear_order (padic_norm p q) (padic_norm p r))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='lime'><a title='p : nat,
hp : nat.prime p,
q r : rat,
hle :
  @has_le.le.{0} rat
    (@preorder.to_has_le.{0} rat
       (@partial_order.to_preorder.{0} rat (@linear_order.to_partial_order.{0} rat rat.linear_order)))
    (padic_norm p r)
    (padic_norm p q),
hne : @ne.{1} rat (padic_norm p q) (padic_norm p r),
hlt : @has_lt.lt.{0} rat rat.has_lt (padic_norm p r) (padic_norm p q),
this :
  @has_le.le.{0} rat rat.has_le (padic_norm p q)
    (@max.{0} rat rat.decidable_linear_order (padic_norm p (@has_add.add.{0} rat rat.has_add q r)) (padic_norm p r)),
hnge : @has_le.le.{0} rat rat.has_le (padic_norm p r) (padic_norm p (@has_add.add.{0} rat rat.has_add q r))
⊢ @has_le.le.{0} rat rat.has_le (padic_norm p q) (padic_norm p (@has_add.add.{0} rat rat.has_add q r))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
q r : rat,
hle :
  @has_le.le.{0} rat
    (@preorder.to_has_le.{0} rat
       (@partial_order.to_preorder.{0} rat (@linear_order.to_partial_order.{0} rat rat.linear_order)))
    (padic_norm p r)
    (padic_norm p q),
hne : @ne.{1} rat (padic_norm p q) (padic_norm p r),
hlt : @has_lt.lt.{0} rat rat.has_lt (padic_norm p r) (padic_norm p q),
hnge : @has_le.le.{0} rat rat.has_le (padic_norm p r) (padic_norm p (@has_add.add.{0} rat rat.has_add q r)),
this : @has_le.le.{0} rat rat.has_le (padic_norm p q) (padic_norm p (@has_add.add.{0} rat rat.has_add q r))
⊢ @has_le.le.{0} rat rat.has_le (padic_norm p q) (padic_norm p (@has_add.add.{0} rat rat.has_add q r))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='lime'><a title='p : nat,
hp : nat.prime p,
q r : rat,
hle :
  @has_le.le.{0} rat
    (@preorder.to_has_le.{0} rat
       (@partial_order.to_preorder.{0} rat (@linear_order.to_partial_order.{0} rat rat.linear_order)))
    (padic_norm p r)
    (padic_norm p q),
hne : @ne.{1} rat (padic_norm p q) (padic_norm p r),
hlt : @has_lt.lt.{0} rat rat.has_lt (padic_norm p r) (padic_norm p q),
this :
  @has_le.le.{0} rat rat.has_le (padic_norm p q)
    (@max.{0} rat rat.decidable_linear_order (padic_norm p (@has_add.add.{0} rat rat.has_add q r)) (padic_norm p r)),
hnge : @has_le.le.{0} rat rat.has_le (padic_norm p r) (padic_norm p (@has_add.add.{0} rat rat.has_add q r)),
this : @has_le.le.{0} rat rat.has_le (padic_norm p q) (padic_norm p (@has_add.add.{0} rat rat.has_add q r))
⊢ @eq.{1} rat (padic_norm p (@has_add.add.{0} rat rat.has_add q r))
    (@max.{0} rat rat.decidable_linear_order (padic_norm p q) (padic_norm p r))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>444    apply _root_.le_antisymm,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='le_antisymm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 45, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : partial_order.{0} α] {a b : α}, @has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α _inst_1)) a b → @has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α _inst_1)) b a → @eq.{1} α a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
q r : rat,
hle :
  @has_le.le.{0} rat
    (@preorder.to_has_le.{0} rat
       (@partial_order.to_preorder.{0} rat (@linear_order.to_partial_order.{0} rat rat.linear_order)))
    (padic_norm p r)
    (padic_norm p q),
hne : @ne.{1} rat (padic_norm p q) (padic_norm p r),
hlt : @has_lt.lt.{0} rat rat.has_lt (padic_norm p r) (padic_norm p q),
this :
  @has_le.le.{0} rat rat.has_le (padic_norm p q)
    (@max.{0} rat rat.decidable_linear_order (padic_norm p (@has_add.add.{0} rat rat.has_add q r)) (padic_norm p r)),
hnge : @has_le.le.{0} rat rat.has_le (padic_norm p r) (padic_norm p (@has_add.add.{0} rat rat.has_add q r)),
this : @has_le.le.{0} rat rat.has_le (padic_norm p q) (padic_norm p (@has_add.add.{0} rat rat.has_add q r))
⊢ @eq.{1} rat (padic_norm p (@has_add.add.{0} rat rat.has_add q r))
    (@max.{0} rat rat.decidable_linear_order (padic_norm p q) (padic_norm p r))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
p : nat,
hp : nat.prime p,
q r : rat,
hle :
  @has_le.le.{0} rat
    (@preorder.to_has_le.{0} rat
       (@partial_order.to_preorder.{0} rat (@linear_order.to_partial_order.{0} rat rat.linear_order)))
    (padic_norm p r)
    (padic_norm p q),
hne : @ne.{1} rat (padic_norm p q) (padic_norm p r),
hlt : @has_lt.lt.{0} rat rat.has_lt (padic_norm p r) (padic_norm p q),
this :
  @has_le.le.{0} rat rat.has_le (padic_norm p q)
    (@max.{0} rat rat.decidable_linear_order (padic_norm p (@has_add.add.{0} rat rat.has_add q r)) (padic_norm p r)),
hnge : @has_le.le.{0} rat rat.has_le (padic_norm p r) (padic_norm p (@has_add.add.{0} rat rat.has_add q r)),
this : @has_le.le.{0} rat rat.has_le (padic_norm p q) (padic_norm p (@has_add.add.{0} rat rat.has_add q r))
⊢ @has_le.le.{0} rat (@preorder.to_has_le.{0} rat (@partial_order.to_preorder.{0} rat rat.partial_order))
    (padic_norm p (@has_add.add.{0} rat rat.has_add q r))
    (@max.{0} rat rat.decidable_linear_order (padic_norm p q) (padic_norm p r))

p : nat,
hp : nat.prime p,
q r : rat,
hle :
  @has_le.le.{0} rat
    (@preorder.to_has_le.{0} rat
       (@partial_order.to_preorder.{0} rat (@linear_order.to_partial_order.{0} rat rat.linear_order)))
    (padic_norm p r)
    (padic_norm p q),
hne : @ne.{1} rat (padic_norm p q) (padic_norm p r),
hlt : @has_lt.lt.{0} rat rat.has_lt (padic_norm p r) (padic_norm p q),
this :
  @has_le.le.{0} rat rat.has_le (padic_norm p q)
    (@max.{0} rat rat.decidable_linear_order (padic_norm p (@has_add.add.{0} rat rat.has_add q r)) (padic_norm p r)),
hnge : @has_le.le.{0} rat rat.has_le (padic_norm p r) (padic_norm p (@has_add.add.{0} rat rat.has_add q r)),
this : @has_le.le.{0} rat rat.has_le (padic_norm p q) (padic_norm p (@has_add.add.{0} rat rat.has_add q r))
⊢ @has_le.le.{0} rat (@preorder.to_has_le.{0} rat (@partial_order.to_preorder.{0} rat rat.partial_order))
    (@max.{0} rat rat.decidable_linear_order (padic_norm p q) (padic_norm p r))
    (padic_norm p (@has_add.add.{0} rat rat.has_add q r))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>445    { apply padic_norm.nonarchimedean p },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='padic_norm.nonarchimedean'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 401, &#x27;column&#x27;: 18}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (p : nat) [hp : nat.prime p] {q r : rat}, @has_le.le.{0} rat rat.has_le (padic_norm p (@has_add.add.{0} rat rat.has_add q r)) (@max.{0} rat rat.decidable_linear_order (padic_norm p q) (padic_norm p r))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The p-adic norm is nonarchimedean: the norm of `p + q` is at most the max of the norm of `p` and
the norm of `q`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
p : nat,
hp : nat.prime p,
q r : rat,
hle :
  @has_le.le.{0} rat
    (@preorder.to_has_le.{0} rat
       (@partial_order.to_preorder.{0} rat (@linear_order.to_partial_order.{0} rat rat.linear_order)))
    (padic_norm p r)
    (padic_norm p q),
hne : @ne.{1} rat (padic_norm p q) (padic_norm p r),
hlt : @has_lt.lt.{0} rat rat.has_lt (padic_norm p r) (padic_norm p q),
this :
  @has_le.le.{0} rat rat.has_le (padic_norm p q)
    (@max.{0} rat rat.decidable_linear_order (padic_norm p (@has_add.add.{0} rat rat.has_add q r)) (padic_norm p r)),
hnge : @has_le.le.{0} rat rat.has_le (padic_norm p r) (padic_norm p (@has_add.add.{0} rat rat.has_add q r)),
this : @has_le.le.{0} rat rat.has_le (padic_norm p q) (padic_norm p (@has_add.add.{0} rat rat.has_add q r))
⊢ @has_le.le.{0} rat (@preorder.to_has_le.{0} rat (@partial_order.to_preorder.{0} rat rat.partial_order))
    (padic_norm p (@has_add.add.{0} rat rat.has_add q r))
    (@max.{0} rat rat.decidable_linear_order (padic_norm p q) (padic_norm p r))

p : nat,
hp : nat.prime p,
q r : rat,
hle :
  @has_le.le.{0} rat
    (@preorder.to_has_le.{0} rat
       (@partial_order.to_preorder.{0} rat (@linear_order.to_partial_order.{0} rat rat.linear_order)))
    (padic_norm p r)
    (padic_norm p q),
hne : @ne.{1} rat (padic_norm p q) (padic_norm p r),
hlt : @has_lt.lt.{0} rat rat.has_lt (padic_norm p r) (padic_norm p q),
this :
  @has_le.le.{0} rat rat.has_le (padic_norm p q)
    (@max.{0} rat rat.decidable_linear_order (padic_norm p (@has_add.add.{0} rat rat.has_add q r)) (padic_norm p r)),
hnge : @has_le.le.{0} rat rat.has_le (padic_norm p r) (padic_norm p (@has_add.add.{0} rat rat.has_add q r)),
this : @has_le.le.{0} rat rat.has_le (padic_norm p q) (padic_norm p (@has_add.add.{0} rat rat.has_add q r))
⊢ @has_le.le.{0} rat (@preorder.to_has_le.{0} rat (@partial_order.to_preorder.{0} rat rat.partial_order))
    (@max.{0} rat rat.decidable_linear_order (padic_norm p q) (padic_norm p r))
    (padic_norm p (@has_add.add.{0} rat rat.has_add q r))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
q r : rat,
hle :
  @has_le.le.{0} rat
    (@preorder.to_has_le.{0} rat
       (@partial_order.to_preorder.{0} rat (@linear_order.to_partial_order.{0} rat rat.linear_order)))
    (padic_norm p r)
    (padic_norm p q),
hne : @ne.{1} rat (padic_norm p q) (padic_norm p r),
hlt : @has_lt.lt.{0} rat rat.has_lt (padic_norm p r) (padic_norm p q),
this :
  @has_le.le.{0} rat rat.has_le (padic_norm p q)
    (@max.{0} rat rat.decidable_linear_order (padic_norm p (@has_add.add.{0} rat rat.has_add q r)) (padic_norm p r)),
hnge : @has_le.le.{0} rat rat.has_le (padic_norm p r) (padic_norm p (@has_add.add.{0} rat rat.has_add q r)),
this : @has_le.le.{0} rat rat.has_le (padic_norm p q) (padic_norm p (@has_add.add.{0} rat rat.has_add q r))
⊢ @has_le.le.{0} rat (@preorder.to_has_le.{0} rat (@partial_order.to_preorder.{0} rat rat.partial_order))
    (padic_norm p (@has_add.add.{0} rat rat.has_add q r))
    (@max.{0} rat rat.decidable_linear_order (padic_norm p q) (padic_norm p r))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
q r : rat,
hle :
  @has_le.le.{0} rat
    (@preorder.to_has_le.{0} rat
       (@partial_order.to_preorder.{0} rat (@linear_order.to_partial_order.{0} rat rat.linear_order)))
    (padic_norm p r)
    (padic_norm p q),
hne : @ne.{1} rat (padic_norm p q) (padic_norm p r),
hlt : @has_lt.lt.{0} rat rat.has_lt (padic_norm p r) (padic_norm p q),
this :
  @has_le.le.{0} rat rat.has_le (padic_norm p q)
    (@max.{0} rat rat.decidable_linear_order (padic_norm p (@has_add.add.{0} rat rat.has_add q r)) (padic_norm p r)),
hnge : @has_le.le.{0} rat rat.has_le (padic_norm p r) (padic_norm p (@has_add.add.{0} rat rat.has_add q r)),
this : @has_le.le.{0} rat rat.has_le (padic_norm p q) (padic_norm p (@has_add.add.{0} rat rat.has_add q r))
⊢ @has_le.le.{0} rat (@preorder.to_has_le.{0} rat (@partial_order.to_preorder.{0} rat rat.partial_order))
    (@max.{0} rat rat.decidable_linear_order (padic_norm p q) (padic_norm p r))
    (padic_norm p (@has_add.add.{0} rat rat.has_add q r))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>446    { rw max_eq_left_of_lt hlt,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='max_eq_left_of_lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hlt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/functions.lean&#x27;, &#x27;line&#x27;: 113, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : decidable_linear_order.{0} α] {a b : α}, @has_lt.lt.{0} α (@preorder.to_has_lt.{0} α (@partial_order.to_preorder.{0} α (@linear_order.to_partial_order.{0} α (@decidable_linear_order.to_linear_order.{0} α _inst_1)))) b a → @eq.{1} α (@max.{0} α _inst_1 a b) a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_lt.lt.{0} rat rat.has_lt (padic_norm p r) (padic_norm p q)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
q r : rat,
hle :
  @has_le.le.{0} rat
    (@preorder.to_has_le.{0} rat
       (@partial_order.to_preorder.{0} rat (@linear_order.to_partial_order.{0} rat rat.linear_order)))
    (padic_norm p r)
    (padic_norm p q),
hne : @ne.{1} rat (padic_norm p q) (padic_norm p r),
hlt : @has_lt.lt.{0} rat rat.has_lt (padic_norm p r) (padic_norm p q),
this :
  @has_le.le.{0} rat rat.has_le (padic_norm p q)
    (@max.{0} rat rat.decidable_linear_order (padic_norm p (@has_add.add.{0} rat rat.has_add q r)) (padic_norm p r)),
hnge : @has_le.le.{0} rat rat.has_le (padic_norm p r) (padic_norm p (@has_add.add.{0} rat rat.has_add q r)),
this : @has_le.le.{0} rat rat.has_le (padic_norm p q) (padic_norm p (@has_add.add.{0} rat rat.has_add q r))
⊢ @has_le.le.{0} rat (@preorder.to_has_le.{0} rat (@partial_order.to_preorder.{0} rat rat.partial_order))
    (@max.{0} rat rat.decidable_linear_order (padic_norm p q) (padic_norm p r))
    (padic_norm p (@has_add.add.{0} rat rat.has_add q r))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
q r : rat,
hle :
  @has_le.le.{0} rat
    (@preorder.to_has_le.{0} rat
       (@partial_order.to_preorder.{0} rat (@linear_order.to_partial_order.{0} rat rat.linear_order)))
    (padic_norm p r)
    (padic_norm p q),
hne : @ne.{1} rat (padic_norm p q) (padic_norm p r),
hlt : @has_lt.lt.{0} rat rat.has_lt (padic_norm p r) (padic_norm p q),
this :
  @has_le.le.{0} rat rat.has_le (padic_norm p q)
    (@max.{0} rat rat.decidable_linear_order (padic_norm p (@has_add.add.{0} rat rat.has_add q r)) (padic_norm p r)),
hnge : @has_le.le.{0} rat rat.has_le (padic_norm p r) (padic_norm p (@has_add.add.{0} rat rat.has_add q r)),
this : @has_le.le.{0} rat rat.has_le (padic_norm p q) (padic_norm p (@has_add.add.{0} rat rat.has_add q r))
⊢ @has_le.le.{0} rat (@preorder.to_has_le.{0} rat (@partial_order.to_preorder.{0} rat rat.partial_order))
    (padic_norm p q)
    (padic_norm p (@has_add.add.{0} rat rat.has_add q r))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>447      assumption }</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 227, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic looks in the local context for a hypothesis whose type is equal to the goal target. If it finds one, it uses it to prove the goal, and otherwise it fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='assumption'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
q r : rat,
hle :
  @has_le.le.{0} rat
    (@preorder.to_has_le.{0} rat
       (@partial_order.to_preorder.{0} rat (@linear_order.to_partial_order.{0} rat rat.linear_order)))
    (padic_norm p r)
    (padic_norm p q),
hne : @ne.{1} rat (padic_norm p q) (padic_norm p r),
hlt : @has_lt.lt.{0} rat rat.has_lt (padic_norm p r) (padic_norm p q),
this :
  @has_le.le.{0} rat rat.has_le (padic_norm p q)
    (@max.{0} rat rat.decidable_linear_order (padic_norm p (@has_add.add.{0} rat rat.has_add q r)) (padic_norm p r)),
hnge : @has_le.le.{0} rat rat.has_le (padic_norm p r) (padic_norm p (@has_add.add.{0} rat rat.has_add q r)),
this : @has_le.le.{0} rat rat.has_le (padic_norm p q) (padic_norm p (@has_add.add.{0} rat rat.has_add q r))
⊢ @has_le.le.{0} rat (@preorder.to_has_le.{0} rat (@partial_order.to_preorder.{0} rat rat.partial_order))
    (padic_norm p q)
    (padic_norm p (@has_add.add.{0} rat rat.has_add q r))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>448  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>449  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>450  /--</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>451  The p-adic norm is an absolute value: positive-definite and multiplicative, satisfying the triangle</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>452  inequality.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>453  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>454  instance : is_absolute_value (padic_norm p) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='is_absolute_value'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='padic_norm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/cau_seq.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 261, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : discrete_linear_ordered_field.{u_1} α] {β : Type u_2} [_inst_2 : ring.{u_2} β], (β → α) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='nat → rat → rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title=' A function f is an absolute value if it is nonnegative, zero only at 0, additive, and
multiplicative.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='If `q ≠ 0`, the p-adic norm of a rational `q` is `p ^ (-(padic_val_rat p q))`.
If `q = 0`, the p-adic norm of `q` is 0.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>455  { abv_nonneg := padic_norm.nonneg p,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='padic_norm.nonneg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='red'><a title='{&#x27;line&#x27;: 280, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='green'><a title='∀ (p : nat) (q : rat), @has_le.le.{0} rat rat.has_le (@has_zero.zero.{0} rat rat.has_zero) (padic_norm p q)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='The p-adic norm is nonnegative.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>456    abv_eq_zero :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>457      begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='lime'><a title='p : nat,
hp : nat.prime p
⊢ ∀ {x : rat},
    iff
      (@eq.{1} rat (padic_norm p x)
         (@has_zero.zero.{0} rat
            (@no_zero_divisors.to_has_zero.{0} rat
               (@domain.to_no_zero_divisors.{0} rat
                  (@division_ring.to_domain.{0} rat
                     (@field.to_division_ring.{0} rat
                        (@linear_ordered_field.to_field.{0} rat
                           (@discrete_linear_ordered_field.to_linear_ordered_field.{0} rat
                              rat.discrete_linear_ordered_field))))))))
      (@eq.{1} rat x
         (@has_zero.zero.{0} rat
            (@mul_zero_class.to_has_zero.{0} rat
               (@semiring.to_mul_zero_class.{0} rat
                  (@ring.to_semiring.{0} rat
                     (@domain.to_ring.{0} rat (@division_ring.to_domain.{0} rat rat.division_ring)))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>458        intros,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p
⊢ ∀ {x : rat},
    iff
      (@eq.{1} rat (padic_norm p x)
         (@has_zero.zero.{0} rat
            (@no_zero_divisors.to_has_zero.{0} rat
               (@domain.to_no_zero_divisors.{0} rat
                  (@division_ring.to_domain.{0} rat
                     (@field.to_division_ring.{0} rat
                        (@linear_ordered_field.to_field.{0} rat
                           (@discrete_linear_ordered_field.to_linear_ordered_field.{0} rat
                              rat.discrete_linear_ordered_field))))))))
      (@eq.{1} rat x
         (@has_zero.zero.{0} rat
            (@mul_zero_class.to_has_zero.{0} rat
               (@semiring.to_mul_zero_class.{0} rat
                  (@ring.to_semiring.{0} rat
                     (@domain.to_ring.{0} rat (@division_ring.to_domain.{0} rat rat.division_ring)))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
x : rat
⊢ iff
    (@eq.{1} rat (padic_norm p x)
       (@has_zero.zero.{0} rat
          (@no_zero_divisors.to_has_zero.{0} rat
             (@domain.to_no_zero_divisors.{0} rat
                (@division_ring.to_domain.{0} rat
                   (@field.to_division_ring.{0} rat
                      (@linear_ordered_field.to_field.{0} rat
                         (@discrete_linear_ordered_field.to_linear_ordered_field.{0} rat
                            rat.discrete_linear_ordered_field))))))))
    (@eq.{1} rat x
       (@has_zero.zero.{0} rat
          (@mul_zero_class.to_has_zero.{0} rat
             (@semiring.to_mul_zero_class.{0} rat
                (@ring.to_semiring.{0} rat
                   (@domain.to_ring.{0} rat (@division_ring.to_domain.{0} rat rat.division_ring)))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>459        constructor; intro,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 988, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 122, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='This tactic applies to a goal such that its conclusion is an inductive type (say `I`). It tries to apply each constructor of `I` until it succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='If the current goal is a Pi/forall `∀ x : t, u` (resp. `let x := t in u`) then `intro` puts `x : t` (resp. `x := t`) in the local context. The new subgoal target is `u`.

If the goal is an arrow `t → u`, then it puts `h : t` in the local context and the new goal target is `u`.

If the goal is neither a Pi/forall nor begins with a let binder, the tactic `intro` applies the tactic `whnf` until an introduction can be applied or the goal is not head reducible. In the latter case, the tactic fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='constructor'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='intro'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
x : rat
⊢ iff
    (@eq.{1} rat (padic_norm p x)
       (@has_zero.zero.{0} rat
          (@no_zero_divisors.to_has_zero.{0} rat
             (@domain.to_no_zero_divisors.{0} rat
                (@division_ring.to_domain.{0} rat
                   (@field.to_division_ring.{0} rat
                      (@linear_ordered_field.to_field.{0} rat
                         (@discrete_linear_ordered_field.to_linear_ordered_field.{0} rat
                            rat.discrete_linear_ordered_field))))))))
    (@eq.{1} rat x
       (@has_zero.zero.{0} rat
          (@mul_zero_class.to_has_zero.{0} rat
             (@semiring.to_mul_zero_class.{0} rat
                (@ring.to_semiring.{0} rat
                   (@domain.to_ring.{0} rat (@division_ring.to_domain.{0} rat rat.division_ring)))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
p : nat,
hp : nat.prime p,
x : rat,
a :
  @eq.{1} rat (padic_norm p x)
    (@has_zero.zero.{0} rat
       (@no_zero_divisors.to_has_zero.{0} rat
          (@domain.to_no_zero_divisors.{0} rat
             (@division_ring.to_domain.{0} rat
                (@field.to_division_ring.{0} rat
                   (@linear_ordered_field.to_field.{0} rat
                      (@discrete_linear_ordered_field.to_linear_ordered_field.{0} rat
                         rat.discrete_linear_ordered_field)))))))
⊢ @eq.{1} rat x
    (@has_zero.zero.{0} rat
       (@mul_zero_class.to_has_zero.{0} rat
          (@semiring.to_mul_zero_class.{0} rat
             (@ring.to_semiring.{0} rat
                (@domain.to_ring.{0} rat (@division_ring.to_domain.{0} rat rat.division_ring))))))

p : nat,
hp : nat.prime p,
x : rat,
a :
  @eq.{1} rat x
    (@has_zero.zero.{0} rat
       (@mul_zero_class.to_has_zero.{0} rat
          (@semiring.to_mul_zero_class.{0} rat
             (@ring.to_semiring.{0} rat
                (@domain.to_ring.{0} rat (@division_ring.to_domain.{0} rat rat.division_ring))))))
⊢ @eq.{1} rat (padic_norm p x)
    (@has_zero.zero.{0} rat
       (@no_zero_divisors.to_has_zero.{0} rat
          (@domain.to_no_zero_divisors.{0} rat
             (@division_ring.to_domain.{0} rat
                (@field.to_division_ring.{0} rat
                   (@linear_ordered_field.to_field.{0} rat
                      (@discrete_linear_ordered_field.to_linear_ordered_field.{0} rat
                         rat.discrete_linear_ordered_field)))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>460        { apply zero_of_padic_norm_eq_zero p, assumption },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='padic_norm.zero_of_padic_norm_eq_zero'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 328, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 227, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (p : nat) [hp : nat.prime p] {q : rat}, @eq.{1} rat (padic_norm p q) (@has_zero.zero.{0} rat rat.has_zero) → @eq.{1} rat q (@has_zero.zero.{0} rat rat.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='If the p-adic norm of `q` is 0, then `q` is 0.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic looks in the local context for a hypothesis whose type is equal to the goal target. If it finds one, it uses it to prove the goal, and otherwise it fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='assumption'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
p : nat,
hp : nat.prime p,
x : rat,
a :
  @eq.{1} rat (padic_norm p x)
    (@has_zero.zero.{0} rat
       (@no_zero_divisors.to_has_zero.{0} rat
          (@domain.to_no_zero_divisors.{0} rat
             (@division_ring.to_domain.{0} rat
                (@field.to_division_ring.{0} rat
                   (@linear_ordered_field.to_field.{0} rat
                      (@discrete_linear_ordered_field.to_linear_ordered_field.{0} rat
                         rat.discrete_linear_ordered_field)))))))
⊢ @eq.{1} rat x
    (@has_zero.zero.{0} rat
       (@mul_zero_class.to_has_zero.{0} rat
          (@semiring.to_mul_zero_class.{0} rat
             (@ring.to_semiring.{0} rat
                (@domain.to_ring.{0} rat (@division_ring.to_domain.{0} rat rat.division_ring))))))

p : nat,
hp : nat.prime p,
x : rat,
a :
  @eq.{1} rat x
    (@has_zero.zero.{0} rat
       (@mul_zero_class.to_has_zero.{0} rat
          (@semiring.to_mul_zero_class.{0} rat
             (@ring.to_semiring.{0} rat
                (@domain.to_ring.{0} rat (@division_ring.to_domain.{0} rat rat.division_ring))))))
⊢ @eq.{1} rat (padic_norm p x)
    (@has_zero.zero.{0} rat
       (@no_zero_divisors.to_has_zero.{0} rat
          (@domain.to_no_zero_divisors.{0} rat
             (@division_ring.to_domain.{0} rat
                (@field.to_division_ring.{0} rat
                   (@linear_ordered_field.to_field.{0} rat
                      (@discrete_linear_ordered_field.to_linear_ordered_field.{0} rat
                         rat.discrete_linear_ordered_field)))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
x : rat,
a :
  @eq.{1} rat (padic_norm p x)
    (@has_zero.zero.{0} rat
       (@no_zero_divisors.to_has_zero.{0} rat
          (@domain.to_no_zero_divisors.{0} rat
             (@division_ring.to_domain.{0} rat
                (@field.to_division_ring.{0} rat
                   (@linear_ordered_field.to_field.{0} rat
                      (@discrete_linear_ordered_field.to_linear_ordered_field.{0} rat
                         rat.discrete_linear_ordered_field)))))))
⊢ @eq.{1} rat x
    (@has_zero.zero.{0} rat
       (@mul_zero_class.to_has_zero.{0} rat
          (@semiring.to_mul_zero_class.{0} rat
             (@ring.to_semiring.{0} rat
                (@domain.to_ring.{0} rat (@division_ring.to_domain.{0} rat rat.division_ring))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
x : rat,
a :
  @eq.{1} rat (padic_norm p x)
    (@has_zero.zero.{0} rat
       (@no_zero_divisors.to_has_zero.{0} rat
          (@domain.to_no_zero_divisors.{0} rat
             (@division_ring.to_domain.{0} rat
                (@field.to_division_ring.{0} rat
                   (@linear_ordered_field.to_field.{0} rat
                      (@discrete_linear_ordered_field.to_linear_ordered_field.{0} rat
                         rat.discrete_linear_ordered_field)))))))
⊢ @eq.{1} rat (padic_norm p x) (@has_zero.zero.{0} rat rat.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
x : rat,
a :
  @eq.{1} rat x
    (@has_zero.zero.{0} rat
       (@mul_zero_class.to_has_zero.{0} rat
          (@semiring.to_mul_zero_class.{0} rat
             (@ring.to_semiring.{0} rat
                (@domain.to_ring.{0} rat (@division_ring.to_domain.{0} rat rat.division_ring))))))
⊢ @eq.{1} rat (padic_norm p x)
    (@has_zero.zero.{0} rat
       (@no_zero_divisors.to_has_zero.{0} rat
          (@domain.to_no_zero_divisors.{0} rat
             (@division_ring.to_domain.{0} rat
                (@field.to_division_ring.{0} rat
                   (@linear_ordered_field.to_field.{0} rat
                      (@discrete_linear_ordered_field.to_linear_ordered_field.{0} rat
                         rat.discrete_linear_ordered_field)))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>461        { simp [*] }</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
x : rat,
a :
  @eq.{1} rat x
    (@has_zero.zero.{0} rat
       (@mul_zero_class.to_has_zero.{0} rat
          (@semiring.to_mul_zero_class.{0} rat
             (@ring.to_semiring.{0} rat
                (@domain.to_ring.{0} rat (@division_ring.to_domain.{0} rat rat.division_ring))))))
⊢ @eq.{1} rat (padic_norm p x)
    (@has_zero.zero.{0} rat
       (@no_zero_divisors.to_has_zero.{0} rat
          (@domain.to_no_zero_divisors.{0} rat
             (@division_ring.to_domain.{0} rat
                (@field.to_division_ring.{0} rat
                   (@linear_ordered_field.to_field.{0} rat
                      (@discrete_linear_ordered_field.to_linear_ordered_field.{0} rat
                         rat.discrete_linear_ordered_field)))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>462      end,</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>463    abv_add := padic_norm.triangle_ineq p,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='padic_norm.triangle_ineq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;line&#x27;: 412, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='∀ (p : nat) [hp : nat.prime p] (q r : rat), @has_le.le.{0} rat rat.has_le (padic_norm p (@has_add.add.{0} rat rat.has_add q r)) (@has_add.add.{0} rat rat.has_add (padic_norm p q) (padic_norm p r))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='The p-adic norm respects the triangle inequality: the norm of `p + q` is at most the norm of `p`
plus the norm of `q`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>464    abv_mul := padic_norm.mul p }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='padic_norm.mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;line&#x27;: 340, &#x27;column&#x27;: 26}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='∀ (p : nat) [hp : nat.prime p] (q r : rat), @eq.{1} rat (padic_norm p (@has_mul.mul.{0} rat rat.has_mul q r)) (@has_mul.mul.{0} rat rat.has_mul (padic_norm p q) (padic_norm p r))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='The p-adic norm is multiplicative.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>465  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>466  /--</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>467  If `p^n` divides an integer `z`, then the p-adic norm of `z` is at most `p^(-n)`.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>468  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>469  lemma le_of_dvd {n : ℕ} {z : ℤ} (hd : ↑(p^n) ∣ z) : padic_norm p z ≤ ↑p ^ (-n : ℤ) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='blue'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='coe'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_pow.pow'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_dvd.dvd'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='padic_norm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_le.le'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='coe'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_pow.pow'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_neg.neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 293, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/int/basic.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/coe.lean&#x27;, &#x27;line&#x27;: 67, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 340, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 317, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 261, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 319, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/coe.lean&#x27;, &#x27;line&#x27;: 67, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 340, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 314, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/int/basic.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {a b : Type} [_inst_1 : has_lift_t.{1 1} a b], a → b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α β : Type} [c : has_pow.{0 0} α β], α → β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type} [c : has_dvd.{0} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='nat → rat → rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_le.{0} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {a b : Type} [_inst_1 : has_lift_t.{1 1} a b], a → b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α β : Type} [c : has_pow.{0 0} α β], α → β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type} [c : has_neg.{0} α], α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                    </code><font color='orange'><a title='If `q ≠ 0`, the p-adic norm of a rational `q` is `p ^ (-(padic_val_rat p q))`.
If `q = 0`, the p-adic norm of `q` is 0.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>470  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
n : nat,
z : int,
hd :
  @has_dvd.dvd.{0} int (@comm_semiring_has_dvd.{0} int int.comm_semiring)
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
       (@has_pow.pow.{0 0} nat nat nat.has_pow p n))
    z
⊢ @has_le.le.{0} rat rat.has_le
    (padic_norm p
       (@coe.{1 1} int rat
          (@coe_to_lift.{1 1} int rat
             (@coe_base.{1 1} int rat (@int.cast_coe.{0} rat rat.has_neg rat.has_zero rat.has_one rat.has_add)))
          z))
    (@has_pow.pow.{0 0} rat int (@int.has_pow.{0} rat rat.division_ring)
       (@coe.{1 1} nat rat
          (@coe_to_lift.{1 1} nat rat
             (@coe_base.{1 1} nat rat (@nat.cast_coe.{0} rat rat.has_zero rat.has_one rat.has_add)))
          p)
       (@has_neg.neg.{0} int int.has_neg
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) n)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>471    unfold padic_norm, split_ifs with hz hz,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1411, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/split_ifs.lean&#x27;, &#x27;line&#x27;: 84, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.unfold_config {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.ff, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.ff, beta := bool.tt, eta := bool.ff, proj := bool.ff, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.ff, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Given defined constants `e₁ ... eₙ`, `unfold e₁ ... eₙ` iteratively unfolds all occurrences in the target of the main goal, using equational lemmas associated with the definitions.

As with `simp`, the `at` modifier can be used to specify locations for the unfolding.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title=' Splits all if-then-else-expressions into multiple goals.

Given a goal of the form `g (if p then x else y)`, `split_ifs` will produce
two goals: `p ⊢ g x` and `¬p ⊢ g y`.

If there are multiple ite-expressions, then `split_ifs` will split them all,
starting with a top-most one whose condition does not contain another
ite-expression.

`split_ifs at *` splits all ite-expressions in all hypotheses as well as the goal.

`split_ifs with h₁ h₂ h₃` overrides the default names for the hypotheses.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='unfold'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='split_ifs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id*&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.unfold_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
n : nat,
z : int,
hd :
  @has_dvd.dvd.{0} int (@comm_semiring_has_dvd.{0} int int.comm_semiring)
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
       (@has_pow.pow.{0 0} nat nat nat.has_pow p n))
    z
⊢ @has_le.le.{0} rat rat.has_le
    (padic_norm p
       (@coe.{1 1} int rat
          (@coe_to_lift.{1 1} int rat
             (@coe_base.{1 1} int rat (@int.cast_coe.{0} rat rat.has_neg rat.has_zero rat.has_one rat.has_add)))
          z))
    (@has_pow.pow.{0 0} rat int (@int.has_pow.{0} rat rat.division_ring)
       (@coe.{1 1} nat rat
          (@coe_to_lift.{1 1} nat rat
             (@coe_base.{1 1} nat rat (@nat.cast_coe.{0} rat rat.has_zero rat.has_one rat.has_add)))
          p)
       (@has_neg.neg.{0} int int.has_neg
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) n)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
n : nat,
z : int,
hd :
  @has_dvd.dvd.{0} int (@comm_semiring_has_dvd.{0} int int.comm_semiring)
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
       (@has_pow.pow.{0 0} nat nat nat.has_pow p n))
    z
⊢ @has_le.le.{0} rat rat.has_le
    (@ite.{1}
       (@eq.{1} rat
          (@coe.{1 1} int rat
             (@coe_to_lift.{1 1} int rat
                (@coe_base.{1 1} int rat (@int.cast_coe.{0} rat rat.has_neg rat.has_zero rat.has_one rat.has_add)))
             z)
          (@has_zero.zero.{0} rat rat.has_zero))
       (rat.decidable_eq
          (@coe.{1 1} int rat
             (@coe_to_lift.{1 1} int rat
                (@coe_base.{1 1} int rat (@int.cast_coe.{0} rat rat.has_neg rat.has_zero rat.has_one rat.has_add)))
             z)
          (@has_zero.zero.{0} rat rat.has_zero))
       rat
       (@has_zero.zero.{0} rat rat.has_zero)
       (@has_pow.pow.{0 0} rat int (@int.has_pow.{0} rat rat.division_ring)
          (@coe.{1 1} nat rat
             (@coe_to_lift.{1 1} nat rat
                (@coe_base.{1 1} nat rat (@nat.cast_coe.{0} rat rat.has_zero rat.has_one rat.has_add)))
             p)
          (@has_neg.neg.{0} int int.has_neg
             (padic_val_rat p
                (@coe.{1 1} int rat
                   (@coe_to_lift.{1 1} int rat
                      (@coe_base.{1 1} int rat
                         (@int.cast_coe.{0} rat rat.has_neg rat.has_zero rat.has_one rat.has_add)))
                   z)))))
    (@has_pow.pow.{0 0} rat int (@int.has_pow.{0} rat rat.division_ring)
       (@coe.{1 1} nat rat
          (@coe_to_lift.{1 1} nat rat
             (@coe_base.{1 1} nat rat (@nat.cast_coe.{0} rat rat.has_zero rat.has_one rat.has_add)))
          p)
       (@has_neg.neg.{0} int int.has_neg
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) n)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
p : nat,
hp : nat.prime p,
n : nat,
z : int,
hd :
  @has_dvd.dvd.{0} int (@comm_semiring_has_dvd.{0} int int.comm_semiring)
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
       (@has_pow.pow.{0 0} nat nat nat.has_pow p n))
    z,
hz :
  @eq.{1} rat
    (@coe.{1 1} int rat
       (@coe_to_lift.{1 1} int rat
          (@coe_base.{1 1} int rat (@int.cast_coe.{0} rat rat.has_neg rat.has_zero rat.has_one rat.has_add)))
       z)
    (@has_zero.zero.{0} rat rat.has_zero)
⊢ @has_le.le.{0} rat rat.has_le (@has_zero.zero.{0} rat rat.has_zero)
    (@has_pow.pow.{0 0} rat int (@int.has_pow.{0} rat rat.division_ring)
       (@coe.{1 1} nat rat
          (@coe_to_lift.{1 1} nat rat
             (@coe_base.{1 1} nat rat (@nat.cast_coe.{0} rat rat.has_zero rat.has_one rat.has_add)))
          p)
       (@has_neg.neg.{0} int int.has_neg
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) n)))

p : nat,
hp : nat.prime p,
n : nat,
z : int,
hd :
  @has_dvd.dvd.{0} int (@comm_semiring_has_dvd.{0} int int.comm_semiring)
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
       (@has_pow.pow.{0 0} nat nat nat.has_pow p n))
    z,
hz :
  not
    (@eq.{1} rat
       (@coe.{1 1} int rat
          (@coe_to_lift.{1 1} int rat
             (@coe_base.{1 1} int rat (@int.cast_coe.{0} rat rat.has_neg rat.has_zero rat.has_one rat.has_add)))
          z)
       (@has_zero.zero.{0} rat rat.has_zero))
⊢ @has_le.le.{0} rat rat.has_le
    (@has_pow.pow.{0 0} rat int (@int.has_pow.{0} rat rat.division_ring)
       (@coe.{1 1} nat rat
          (@coe_to_lift.{1 1} nat rat
             (@coe_base.{1 1} nat rat (@nat.cast_coe.{0} rat rat.has_zero rat.has_one rat.has_add)))
          p)
       (@has_neg.neg.{0} int int.has_neg
          (padic_val_rat p
             (@coe.{1 1} int rat
                (@coe_to_lift.{1 1} int rat
                   (@coe_base.{1 1} int rat (@int.cast_coe.{0} rat rat.has_neg rat.has_zero rat.has_one rat.has_add)))
                z))))
    (@has_pow.pow.{0 0} rat int (@int.has_pow.{0} rat rat.division_ring)
       (@coe.{1 1} nat rat
          (@coe_to_lift.{1 1} nat rat
             (@coe_base.{1 1} nat rat (@nat.cast_coe.{0} rat rat.has_zero rat.has_one rat.has_add)))
          p)
       (@has_neg.neg.{0} int int.has_neg
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) n)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>472    { apply fpow_nonneg_of_nonneg,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='fpow_nonneg_of_nonneg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/field_power.lean&#x27;, &#x27;line&#x27;: 122, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {K : Type} [_inst_1 : discrete_linear_ordered_field.{0} K] {a : K}, @has_le.le.{0} K (@preorder.to_has_le.{0} K (@partial_order.to_preorder.{0} K (@ordered_comm_monoid.to_partial_order.{0} K (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} K (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} K (@ordered_ring.to_ordered_semiring.{0} K (@linear_ordered_ring.to_ordered_ring.{0} K (@linear_ordered_field.to_linear_ordered_ring.{0} K (@discrete_linear_ordered_field.to_linear_ordered_field.{0} K _inst_1))))))))) (@has_zero.zero.{0} K (@no_zero_divisors.to_has_zero.{0} K (@domain.to_no_zero_divisors.{0} K (@division_ring.to_domain.{0} K (@field.to_division_ring.{0} K (@linear_ordered_field.to_field.{0} K (@discrete_linear_ordered_field.to_linear_ordered_field.{0} K _inst_1))))))) a → ∀ (z : int), @has_le.le.{0} K (@preorder.to_has_le.{0} K (@partial_order.to_preorder.{0} K (@ordered_comm_monoid.to_partial_order.{0} K (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} K (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} K (@ordered_ring.to_ordered_semiring.{0} K (@linear_ordered_ring.to_ordered_ring.{0} K (@linear_ordered_field.to_linear_ordered_ring.{0} K (@discrete_linear_ordered_field.to_linear_ordered_field.{0} K _inst_1))))))))) (@has_zero.zero.{0} K (@no_zero_divisors.to_has_zero.{0} K (@domain.to_no_zero_divisors.{0} K (@division_ring.to_domain.{0} K (@field.to_division_ring.{0} K (@linear_ordered_field.to_field.{0} K (@discrete_linear_ordered_field.to_linear_ordered_field.{0} K _inst_1))))))) (@has_pow.pow.{0 0} K int (@int.has_pow.{0} K (@field.to_division_ring.{0} K (@linear_ordered_field.to_field.{0} K (@discrete_linear_ordered_field.to_linear_ordered_field.{0} K _inst_1)))) a z)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
p : nat,
hp : nat.prime p,
n : nat,
z : int,
hd :
  @has_dvd.dvd.{0} int (@comm_semiring_has_dvd.{0} int int.comm_semiring)
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
       (@has_pow.pow.{0 0} nat nat nat.has_pow p n))
    z,
hz :
  @eq.{1} rat
    (@coe.{1 1} int rat
       (@coe_to_lift.{1 1} int rat
          (@coe_base.{1 1} int rat (@int.cast_coe.{0} rat rat.has_neg rat.has_zero rat.has_one rat.has_add)))
       z)
    (@has_zero.zero.{0} rat rat.has_zero)
⊢ @has_le.le.{0} rat rat.has_le (@has_zero.zero.{0} rat rat.has_zero)
    (@has_pow.pow.{0 0} rat int (@int.has_pow.{0} rat rat.division_ring)
       (@coe.{1 1} nat rat
          (@coe_to_lift.{1 1} nat rat
             (@coe_base.{1 1} nat rat (@nat.cast_coe.{0} rat rat.has_zero rat.has_one rat.has_add)))
          p)
       (@has_neg.neg.{0} int int.has_neg
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) n)))

p : nat,
hp : nat.prime p,
n : nat,
z : int,
hd :
  @has_dvd.dvd.{0} int (@comm_semiring_has_dvd.{0} int int.comm_semiring)
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
       (@has_pow.pow.{0 0} nat nat nat.has_pow p n))
    z,
hz :
  not
    (@eq.{1} rat
       (@coe.{1 1} int rat
          (@coe_to_lift.{1 1} int rat
             (@coe_base.{1 1} int rat (@int.cast_coe.{0} rat rat.has_neg rat.has_zero rat.has_one rat.has_add)))
          z)
       (@has_zero.zero.{0} rat rat.has_zero))
⊢ @has_le.le.{0} rat rat.has_le
    (@has_pow.pow.{0 0} rat int (@int.has_pow.{0} rat rat.division_ring)
       (@coe.{1 1} nat rat
          (@coe_to_lift.{1 1} nat rat
             (@coe_base.{1 1} nat rat (@nat.cast_coe.{0} rat rat.has_zero rat.has_one rat.has_add)))
          p)
       (@has_neg.neg.{0} int int.has_neg
          (padic_val_rat p
             (@coe.{1 1} int rat
                (@coe_to_lift.{1 1} int rat
                   (@coe_base.{1 1} int rat (@int.cast_coe.{0} rat rat.has_neg rat.has_zero rat.has_one rat.has_add)))
                z))))
    (@has_pow.pow.{0 0} rat int (@int.has_pow.{0} rat rat.division_ring)
       (@coe.{1 1} nat rat
          (@coe_to_lift.{1 1} nat rat
             (@coe_base.{1 1} nat rat (@nat.cast_coe.{0} rat rat.has_zero rat.has_one rat.has_add)))
          p)
       (@has_neg.neg.{0} int int.has_neg
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) n)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
n : nat,
z : int,
hd :
  @has_dvd.dvd.{0} int (@comm_semiring_has_dvd.{0} int int.comm_semiring)
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
       (@has_pow.pow.{0 0} nat nat nat.has_pow p n))
    z,
hz :
  @eq.{1} rat
    (@coe.{1 1} int rat
       (@coe_to_lift.{1 1} int rat
          (@coe_base.{1 1} int rat (@int.cast_coe.{0} rat rat.has_neg rat.has_zero rat.has_one rat.has_add)))
       z)
    (@has_zero.zero.{0} rat rat.has_zero)
⊢ @has_le.le.{0} rat rat.has_le (@has_zero.zero.{0} rat rat.has_zero)
    (@has_pow.pow.{0 0} rat int (@int.has_pow.{0} rat rat.division_ring)
       (@coe.{1 1} nat rat
          (@coe_to_lift.{1 1} nat rat
             (@coe_base.{1 1} nat rat (@nat.cast_coe.{0} rat rat.has_zero rat.has_one rat.has_add)))
          p)
       (@has_neg.neg.{0} int int.has_neg
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) n)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
n : nat,
z : int,
hd :
  @has_dvd.dvd.{0} int (@comm_semiring_has_dvd.{0} int int.comm_semiring)
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
       (@has_pow.pow.{0 0} nat nat nat.has_pow p n))
    z,
hz :
  @eq.{1} rat
    (@coe.{1 1} int rat
       (@coe_to_lift.{1 1} int rat
          (@coe_base.{1 1} int rat (@int.cast_coe.{0} rat rat.has_neg rat.has_zero rat.has_one rat.has_add)))
       z)
    (@has_zero.zero.{0} rat rat.has_zero)
⊢ @has_le.le.{0} rat
    (@preorder.to_has_le.{0} rat
       (@partial_order.to_preorder.{0} rat
          (@ordered_comm_monoid.to_partial_order.{0} rat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} rat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} rat
                   (@ordered_ring.to_ordered_semiring.{0} rat
                      (@linear_ordered_ring.to_ordered_ring.{0} rat
                         (@linear_ordered_field.to_linear_ordered_ring.{0} rat
                            (@discrete_linear_ordered_field.to_linear_ordered_field.{0} rat
                               rat.discrete_linear_ordered_field)))))))))
    (@has_zero.zero.{0} rat
       (@no_zero_divisors.to_has_zero.{0} rat
          (@domain.to_no_zero_divisors.{0} rat
             (@division_ring.to_domain.{0} rat
                (@field.to_division_ring.{0} rat
                   (@linear_ordered_field.to_field.{0} rat
                      (@discrete_linear_ordered_field.to_linear_ordered_field.{0} rat
                         rat.discrete_linear_ordered_field)))))))
    (@coe.{1 1} nat rat
       (@coe_to_lift.{1 1} nat rat
          (@coe_base.{1 1} nat rat (@nat.cast_coe.{0} rat rat.has_zero rat.has_one rat.has_add)))
       p)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>473      exact_mod_cast le_of_lt hp.pos },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='blue'><a title='le_of_lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/norm_cast.lean&#x27;, &#x27;line&#x27;: 335, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 99, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/norm_cast.lean&#x27;, &#x27;line&#x27;: 335, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/nat/prime.lean&#x27;, &#x27;line&#x27;: 93, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/norm_cast.lean&#x27;, &#x27;line&#x27;: 335, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : preorder.{0} α] {a b : α}, @has_lt.lt.{0} α (@preorder.to_has_lt.{0} α _inst_1) a b → @has_le.le.{0} α (@preorder.to_has_le.{0} α _inst_1) a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat.prime p'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Normalize the goal and the given expression,
then close the goal with exact.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='Normalize the goal and the given expression,
then close the goal with exact.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='Normalize the goal and the given expression,
then close the goal with exact.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact_mod_cast'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='exact_mod_cast'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='exact_mod_cast'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
n : nat,
z : int,
hd :
  @has_dvd.dvd.{0} int (@comm_semiring_has_dvd.{0} int int.comm_semiring)
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
       (@has_pow.pow.{0 0} nat nat nat.has_pow p n))
    z,
hz :
  @eq.{1} rat
    (@coe.{1 1} int rat
       (@coe_to_lift.{1 1} int rat
          (@coe_base.{1 1} int rat (@int.cast_coe.{0} rat rat.has_neg rat.has_zero rat.has_one rat.has_add)))
       z)
    (@has_zero.zero.{0} rat rat.has_zero)
⊢ @has_le.le.{0} rat
    (@preorder.to_has_le.{0} rat
       (@partial_order.to_preorder.{0} rat
          (@ordered_comm_monoid.to_partial_order.{0} rat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} rat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} rat
                   (@ordered_ring.to_ordered_semiring.{0} rat
                      (@linear_ordered_ring.to_ordered_ring.{0} rat
                         (@linear_ordered_field.to_linear_ordered_ring.{0} rat
                            (@discrete_linear_ordered_field.to_linear_ordered_field.{0} rat
                               rat.discrete_linear_ordered_field)))))))))
    (@has_zero.zero.{0} rat
       (@no_zero_divisors.to_has_zero.{0} rat
          (@domain.to_no_zero_divisors.{0} rat
             (@division_ring.to_domain.{0} rat
                (@field.to_division_ring.{0} rat
                   (@linear_ordered_field.to_field.{0} rat
                      (@discrete_linear_ordered_field.to_linear_ordered_field.{0} rat
                         rat.discrete_linear_ordered_field)))))))
    (@coe.{1 1} nat rat
       (@coe_to_lift.{1 1} nat rat
          (@coe_base.{1 1} nat rat (@nat.cast_coe.{0} rat rat.has_zero rat.has_one rat.has_add)))
       p)'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
n : nat,
z : int,
hd :
  @has_dvd.dvd.{0} int (@comm_semiring_has_dvd.{0} int int.comm_semiring)
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
       (@has_pow.pow.{0 0} nat nat nat.has_pow p n))
    z,
hz :
  not
    (@eq.{1} rat
       (@coe.{1 1} int rat
          (@coe_to_lift.{1 1} int rat
             (@coe_base.{1 1} int rat (@int.cast_coe.{0} rat rat.has_neg rat.has_zero rat.has_one rat.has_add)))
          z)
       (@has_zero.zero.{0} rat rat.has_zero))
⊢ @has_le.le.{0} rat rat.has_le
    (@has_pow.pow.{0 0} rat int (@int.has_pow.{0} rat rat.division_ring)
       (@coe.{1 1} nat rat
          (@coe_to_lift.{1 1} nat rat
             (@coe_base.{1 1} nat rat (@nat.cast_coe.{0} rat rat.has_zero rat.has_one rat.has_add)))
          p)
       (@has_neg.neg.{0} int int.has_neg
          (padic_val_rat p
             (@coe.{1 1} int rat
                (@coe_to_lift.{1 1} int rat
                   (@coe_base.{1 1} int rat (@int.cast_coe.{0} rat rat.has_neg rat.has_zero rat.has_one rat.has_add)))
                z))))
    (@has_pow.pow.{0 0} rat int (@int.has_pow.{0} rat rat.division_ring)
       (@coe.{1 1} nat rat
          (@coe_to_lift.{1 1} nat rat
             (@coe_base.{1 1} nat rat (@nat.cast_coe.{0} rat rat.has_zero rat.has_one rat.has_add)))
          p)
       (@has_neg.neg.{0} int int.has_neg
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) n)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>474    { apply fpow_le_of_le,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='fpow_le_of_le'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/field_power.lean&#x27;, &#x27;line&#x27;: 130, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {K : Type} [_inst_1 : discrete_linear_ordered_field.{0} K] {x : K}, @has_le.le.{0} K (@preorder.to_has_le.{0} K (@partial_order.to_preorder.{0} K (@ordered_comm_monoid.to_partial_order.{0} K (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} K (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} K (@ordered_ring.to_ordered_semiring.{0} K (@linear_ordered_ring.to_ordered_ring.{0} K (@linear_ordered_field.to_linear_ordered_ring.{0} K (@discrete_linear_ordered_field.to_linear_ordered_field.{0} K _inst_1))))))))) (@has_one.one.{0} K (@zero_ne_one_class.to_has_one.{0} K (@domain.to_zero_ne_one_class.{0} K (@division_ring.to_domain.{0} K (@field.to_division_ring.{0} K (@linear_ordered_field.to_field.{0} K (@discrete_linear_ordered_field.to_linear_ordered_field.{0} K _inst_1))))))) x → ∀ {a b : int}, @has_le.le.{0} int int.has_le a b → @has_le.le.{0} K (@preorder.to_has_le.{0} K (@partial_order.to_preorder.{0} K (@ordered_comm_monoid.to_partial_order.{0} K (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} K (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} K (@ordered_ring.to_ordered_semiring.{0} K (@linear_ordered_ring.to_ordered_ring.{0} K (@linear_ordered_field.to_linear_ordered_ring.{0} K (@discrete_linear_ordered_field.to_linear_ordered_field.{0} K _inst_1))))))))) (@has_pow.pow.{0 0} K int (@int.has_pow.{0} K (@field.to_division_ring.{0} K (@linear_ordered_field.to_field.{0} K (@discrete_linear_ordered_field.to_linear_ordered_field.{0} K _inst_1)))) x a) (@has_pow.pow.{0 0} K int (@int.has_pow.{0} K (@field.to_division_ring.{0} K (@linear_ordered_field.to_field.{0} K (@discrete_linear_ordered_field.to_linear_ordered_field.{0} K _inst_1)))) x b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
n : nat,
z : int,
hd :
  @has_dvd.dvd.{0} int (@comm_semiring_has_dvd.{0} int int.comm_semiring)
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
       (@has_pow.pow.{0 0} nat nat nat.has_pow p n))
    z,
hz :
  not
    (@eq.{1} rat
       (@coe.{1 1} int rat
          (@coe_to_lift.{1 1} int rat
             (@coe_base.{1 1} int rat (@int.cast_coe.{0} rat rat.has_neg rat.has_zero rat.has_one rat.has_add)))
          z)
       (@has_zero.zero.{0} rat rat.has_zero))
⊢ @has_le.le.{0} rat rat.has_le
    (@has_pow.pow.{0 0} rat int (@int.has_pow.{0} rat rat.division_ring)
       (@coe.{1 1} nat rat
          (@coe_to_lift.{1 1} nat rat
             (@coe_base.{1 1} nat rat (@nat.cast_coe.{0} rat rat.has_zero rat.has_one rat.has_add)))
          p)
       (@has_neg.neg.{0} int int.has_neg
          (padic_val_rat p
             (@coe.{1 1} int rat
                (@coe_to_lift.{1 1} int rat
                   (@coe_base.{1 1} int rat (@int.cast_coe.{0} rat rat.has_neg rat.has_zero rat.has_one rat.has_add)))
                z))))
    (@has_pow.pow.{0 0} rat int (@int.has_pow.{0} rat rat.division_ring)
       (@coe.{1 1} nat rat
          (@coe_to_lift.{1 1} nat rat
             (@coe_base.{1 1} nat rat (@nat.cast_coe.{0} rat rat.has_zero rat.has_one rat.has_add)))
          p)
       (@has_neg.neg.{0} int int.has_neg
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) n)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
p : nat,
hp : nat.prime p,
n : nat,
z : int,
hd :
  @has_dvd.dvd.{0} int (@comm_semiring_has_dvd.{0} int int.comm_semiring)
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
       (@has_pow.pow.{0 0} nat nat nat.has_pow p n))
    z,
hz :
  not
    (@eq.{1} rat
       (@coe.{1 1} int rat
          (@coe_to_lift.{1 1} int rat
             (@coe_base.{1 1} int rat (@int.cast_coe.{0} rat rat.has_neg rat.has_zero rat.has_one rat.has_add)))
          z)
       (@has_zero.zero.{0} rat rat.has_zero))
⊢ @has_le.le.{0} rat
    (@preorder.to_has_le.{0} rat
       (@partial_order.to_preorder.{0} rat
          (@ordered_comm_monoid.to_partial_order.{0} rat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} rat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} rat
                   (@ordered_ring.to_ordered_semiring.{0} rat
                      (@linear_ordered_ring.to_ordered_ring.{0} rat
                         (@linear_ordered_field.to_linear_ordered_ring.{0} rat
                            (@discrete_linear_ordered_field.to_linear_ordered_field.{0} rat
                               rat.discrete_linear_ordered_field)))))))))
    (@has_one.one.{0} rat
       (@zero_ne_one_class.to_has_one.{0} rat
          (@domain.to_zero_ne_one_class.{0} rat
             (@division_ring.to_domain.{0} rat
                (@field.to_division_ring.{0} rat
                   (@linear_ordered_field.to_field.{0} rat
                      (@discrete_linear_ordered_field.to_linear_ordered_field.{0} rat
                         rat.discrete_linear_ordered_field)))))))
    (@coe.{1 1} nat rat
       (@coe_to_lift.{1 1} nat rat
          (@coe_base.{1 1} nat rat (@nat.cast_coe.{0} rat rat.has_zero rat.has_one rat.has_add)))
       p)

p : nat,
hp : nat.prime p,
n : nat,
z : int,
hd :
  @has_dvd.dvd.{0} int (@comm_semiring_has_dvd.{0} int int.comm_semiring)
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
       (@has_pow.pow.{0 0} nat nat nat.has_pow p n))
    z,
hz :
  not
    (@eq.{1} rat
       (@coe.{1 1} int rat
          (@coe_to_lift.{1 1} int rat
             (@coe_base.{1 1} int rat (@int.cast_coe.{0} rat rat.has_neg rat.has_zero rat.has_one rat.has_add)))
          z)
       (@has_zero.zero.{0} rat rat.has_zero))
⊢ @has_le.le.{0} int int.has_le
    (@has_neg.neg.{0} int int.has_neg
       (padic_val_rat p
          (@coe.{1 1} int rat
             (@coe_to_lift.{1 1} int rat
                (@coe_base.{1 1} int rat (@int.cast_coe.{0} rat rat.has_neg rat.has_zero rat.has_one rat.has_add)))
             z)))
    (@has_neg.neg.{0} int int.has_neg
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) n))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>475      exact_mod_cast le_of_lt hp.one_lt,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='blue'><a title='le_of_lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/norm_cast.lean&#x27;, &#x27;line&#x27;: 335, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 99, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/norm_cast.lean&#x27;, &#x27;line&#x27;: 335, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/nat/prime.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : preorder.{0} α] {a b : α}, @has_lt.lt.{0} α (@preorder.to_has_lt.{0} α _inst_1) a b → @has_le.le.{0} α (@preorder.to_has_le.{0} α _inst_1) a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat.prime p'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Normalize the goal and the given expression,
then close the goal with exact.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='Normalize the goal and the given expression,
then close the goal with exact.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact_mod_cast'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='exact_mod_cast'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
p : nat,
hp : nat.prime p,
n : nat,
z : int,
hd :
  @has_dvd.dvd.{0} int (@comm_semiring_has_dvd.{0} int int.comm_semiring)
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
       (@has_pow.pow.{0 0} nat nat nat.has_pow p n))
    z,
hz :
  not
    (@eq.{1} rat
       (@coe.{1 1} int rat
          (@coe_to_lift.{1 1} int rat
             (@coe_base.{1 1} int rat (@int.cast_coe.{0} rat rat.has_neg rat.has_zero rat.has_one rat.has_add)))
          z)
       (@has_zero.zero.{0} rat rat.has_zero))
⊢ @has_le.le.{0} rat
    (@preorder.to_has_le.{0} rat
       (@partial_order.to_preorder.{0} rat
          (@ordered_comm_monoid.to_partial_order.{0} rat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} rat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} rat
                   (@ordered_ring.to_ordered_semiring.{0} rat
                      (@linear_ordered_ring.to_ordered_ring.{0} rat
                         (@linear_ordered_field.to_linear_ordered_ring.{0} rat
                            (@discrete_linear_ordered_field.to_linear_ordered_field.{0} rat
                               rat.discrete_linear_ordered_field)))))))))
    (@has_one.one.{0} rat
       (@zero_ne_one_class.to_has_one.{0} rat
          (@domain.to_zero_ne_one_class.{0} rat
             (@division_ring.to_domain.{0} rat
                (@field.to_division_ring.{0} rat
                   (@linear_ordered_field.to_field.{0} rat
                      (@discrete_linear_ordered_field.to_linear_ordered_field.{0} rat
                         rat.discrete_linear_ordered_field)))))))
    (@coe.{1 1} nat rat
       (@coe_to_lift.{1 1} nat rat
          (@coe_base.{1 1} nat rat (@nat.cast_coe.{0} rat rat.has_zero rat.has_one rat.has_add)))
       p)

p : nat,
hp : nat.prime p,
n : nat,
z : int,
hd :
  @has_dvd.dvd.{0} int (@comm_semiring_has_dvd.{0} int int.comm_semiring)
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
       (@has_pow.pow.{0 0} nat nat nat.has_pow p n))
    z,
hz :
  not
    (@eq.{1} rat
       (@coe.{1 1} int rat
          (@coe_to_lift.{1 1} int rat
             (@coe_base.{1 1} int rat (@int.cast_coe.{0} rat rat.has_neg rat.has_zero rat.has_one rat.has_add)))
          z)
       (@has_zero.zero.{0} rat rat.has_zero))
⊢ @has_le.le.{0} int int.has_le
    (@has_neg.neg.{0} int int.has_neg
       (padic_val_rat p
          (@coe.{1 1} int rat
             (@coe_to_lift.{1 1} int rat
                (@coe_base.{1 1} int rat (@int.cast_coe.{0} rat rat.has_neg rat.has_zero rat.has_one rat.has_add)))
             z)))
    (@has_neg.neg.{0} int int.has_neg
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) n))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
n : nat,
z : int,
hd :
  @has_dvd.dvd.{0} int (@comm_semiring_has_dvd.{0} int int.comm_semiring)
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
       (@has_pow.pow.{0 0} nat nat nat.has_pow p n))
    z,
hz :
  not
    (@eq.{1} rat
       (@coe.{1 1} int rat
          (@coe_to_lift.{1 1} int rat
             (@coe_base.{1 1} int rat (@int.cast_coe.{0} rat rat.has_neg rat.has_zero rat.has_one rat.has_add)))
          z)
       (@has_zero.zero.{0} rat rat.has_zero))
⊢ @has_le.le.{0} int int.has_le
    (@has_neg.neg.{0} int int.has_neg
       (padic_val_rat p
          (@coe.{1 1} int rat
             (@coe_to_lift.{1 1} int rat
                (@coe_base.{1 1} int rat (@int.cast_coe.{0} rat rat.has_neg rat.has_zero rat.has_one rat.has_add)))
             z)))
    (@has_neg.neg.{0} int int.has_neg
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) n))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>476      apply neg_le_neg,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='neg_le_neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/ordered_group.lean&#x27;, &#x27;line&#x27;: 212, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : ordered_comm_group.{0} α] {a b : α}, @has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@ordered_comm_group.to_partial_order.{0} α _inst_1))) a b → @has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@ordered_comm_group.to_partial_order.{0} α _inst_1))) (@has_neg.neg.{0} α (@add_group.to_has_neg.{0} α (@add_comm_group.to_add_group.{0} α (@ordered_comm_group.to_add_comm_group.{0} α _inst_1))) b) (@has_neg.neg.{0} α (@add_group.to_has_neg.{0} α (@add_comm_group.to_add_group.{0} α (@ordered_comm_group.to_add_comm_group.{0} α _inst_1))) a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
n : nat,
z : int,
hd :
  @has_dvd.dvd.{0} int (@comm_semiring_has_dvd.{0} int int.comm_semiring)
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
       (@has_pow.pow.{0 0} nat nat nat.has_pow p n))
    z,
hz :
  not
    (@eq.{1} rat
       (@coe.{1 1} int rat
          (@coe_to_lift.{1 1} int rat
             (@coe_base.{1 1} int rat (@int.cast_coe.{0} rat rat.has_neg rat.has_zero rat.has_one rat.has_add)))
          z)
       (@has_zero.zero.{0} rat rat.has_zero))
⊢ @has_le.le.{0} int int.has_le
    (@has_neg.neg.{0} int int.has_neg
       (padic_val_rat p
          (@coe.{1 1} int rat
             (@coe_to_lift.{1 1} int rat
                (@coe_base.{1 1} int rat (@int.cast_coe.{0} rat rat.has_neg rat.has_zero rat.has_one rat.has_add)))
             z)))
    (@has_neg.neg.{0} int int.has_neg
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) n))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
n : nat,
z : int,
hd :
  @has_dvd.dvd.{0} int (@comm_semiring_has_dvd.{0} int int.comm_semiring)
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
       (@has_pow.pow.{0 0} nat nat nat.has_pow p n))
    z,
hz :
  not
    (@eq.{1} rat
       (@coe.{1 1} int rat
          (@coe_to_lift.{1 1} int rat
             (@coe_base.{1 1} int rat (@int.cast_coe.{0} rat rat.has_neg rat.has_zero rat.has_one rat.has_add)))
          z)
       (@has_zero.zero.{0} rat rat.has_zero))
⊢ @has_le.le.{0} int
    (@preorder.to_has_le.{0} int
       (@partial_order.to_preorder.{0} int
          (@ordered_comm_group.to_partial_order.{0} int
             (@ordered_ring.to_ordered_comm_group.{0} int
                (@linear_ordered_ring.to_ordered_ring.{0} int
                   (@linear_ordered_comm_ring.to_linear_ordered_ring.{0} int
                      (@decidable_linear_ordered_comm_ring.to_linear_ordered_comm_ring.{0} int
                         int.decidable_linear_ordered_comm_ring)))))))
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) n)
    (padic_val_rat p
       (@coe.{1 1} int rat
          (@coe_to_lift.{1 1} int rat
             (@coe_base.{1 1} int rat (@int.cast_coe.{0} rat rat.has_neg rat.has_zero rat.has_one rat.has_add)))
          z))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>477      rw padic_val_rat_of_int _ hp.ne_one _,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='padic_val_rat.padic_val_rat_of_int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='hp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 111, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/nat/prime.lean&#x27;, &#x27;line&#x27;: 42, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {p : nat} (z : int) (hp : @ne.{1} nat p (@has_one.one.{0} nat nat.has_one)) (hz : @ne.{1} int z (@has_zero.zero.{0} int int.has_zero)), @eq.{1} int (padic_val_rat p (@coe.{1 1} int rat (@coe_to_lift.{1 1} int rat (@coe_base.{1 1} int rat (@int.cast_coe.{0} rat rat.has_neg rat.has_zero rat.has_one rat.has_add))) z)) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (@roption.get.{0} nat (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p) z) (@iff.mpr (@multiplicity.finite.{0} int int.comm_semiring (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p) z) (and (@ne.{1} nat (int.nat_abs (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)) (@has_one.one.{0} nat nat.has_one)) (@ne.{1} int z (@has_zero.zero.{0} int int.has_zero))) (@multiplicity.finite_int_iff (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p) z) (@and.intro (@ne.{1} nat (int.nat_abs (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)) (@has_one.one.{0} nat nat.has_one)) (@ne.{1} int z (@has_zero.zero.{0} int int.has_zero)) hp hz))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat.prime p'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The p-adic value of an integer `z ≠ 0` is the multiplicity of `p` in `z`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
n : nat,
z : int,
hd :
  @has_dvd.dvd.{0} int (@comm_semiring_has_dvd.{0} int int.comm_semiring)
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
       (@has_pow.pow.{0 0} nat nat nat.has_pow p n))
    z,
hz :
  not
    (@eq.{1} rat
       (@coe.{1 1} int rat
          (@coe_to_lift.{1 1} int rat
             (@coe_base.{1 1} int rat (@int.cast_coe.{0} rat rat.has_neg rat.has_zero rat.has_one rat.has_add)))
          z)
       (@has_zero.zero.{0} rat rat.has_zero))
⊢ @has_le.le.{0} int
    (@preorder.to_has_le.{0} int
       (@partial_order.to_preorder.{0} int
          (@ordered_comm_group.to_partial_order.{0} int
             (@ordered_ring.to_ordered_comm_group.{0} int
                (@linear_ordered_ring.to_ordered_ring.{0} int
                   (@linear_ordered_comm_ring.to_linear_ordered_ring.{0} int
                      (@decidable_linear_ordered_comm_ring.to_linear_ordered_comm_ring.{0} int
                         int.decidable_linear_ordered_comm_ring)))))))
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) n)
    (padic_val_rat p
       (@coe.{1 1} int rat
          (@coe_to_lift.{1 1} int rat
             (@coe_base.{1 1} int rat (@int.cast_coe.{0} rat rat.has_neg rat.has_zero rat.has_one rat.has_add)))
          z))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
p : nat,
hp : nat.prime p,
n : nat,
z : int,
hd :
  @has_dvd.dvd.{0} int (@comm_semiring_has_dvd.{0} int int.comm_semiring)
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
       (@has_pow.pow.{0 0} nat nat nat.has_pow p n))
    z,
hz :
  not
    (@eq.{1} rat
       (@coe.{1 1} int rat
          (@coe_to_lift.{1 1} int rat
             (@coe_base.{1 1} int rat (@int.cast_coe.{0} rat rat.has_neg rat.has_zero rat.has_one rat.has_add)))
          z)
       (@has_zero.zero.{0} rat rat.has_zero))
⊢ @has_le.le.{0} int
    (@preorder.to_has_le.{0} int
       (@partial_order.to_preorder.{0} int
          (@ordered_comm_group.to_partial_order.{0} int
             (@ordered_ring.to_ordered_comm_group.{0} int
                (@linear_ordered_ring.to_ordered_ring.{0} int
                   (@linear_ordered_comm_ring.to_linear_ordered_ring.{0} int
                      (@decidable_linear_ordered_comm_ring.to_linear_ordered_comm_ring.{0} int
                         int.decidable_linear_ordered_comm_ring)))))))
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) n)
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
       (@roption.get.{0} nat
          (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
             z)
          (@iff.mpr
             (@multiplicity.finite.{0} int int.comm_semiring
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                z)
             (and
                (@ne.{1} nat
                   (int.nat_abs
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                   (@has_one.one.{0} nat nat.has_one))
                (@ne.{1} int z (@has_zero.zero.{0} int int.has_zero)))
             (@multiplicity.finite_int_iff
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                z)
             (@and.intro
                (@ne.{1} nat
                   (int.nat_abs
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                   (@has_one.one.{0} nat nat.has_one))
                (@ne.{1} int z (@has_zero.zero.{0} int int.has_zero))
                (@nat.prime.ne_one p hp)
                ?m_1))))

p : nat,
hp : nat.prime p,
n : nat,
z : int,
hd :
  @has_dvd.dvd.{0} int (@comm_semiring_has_dvd.{0} int int.comm_semiring)
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
       (@has_pow.pow.{0 0} nat nat nat.has_pow p n))
    z,
hz :
  not
    (@eq.{1} rat
       (@coe.{1 1} int rat
          (@coe_to_lift.{1 1} int rat
             (@coe_base.{1 1} int rat (@int.cast_coe.{0} rat rat.has_neg rat.has_zero rat.has_one rat.has_add)))
          z)
       (@has_zero.zero.{0} rat rat.has_zero))
⊢ @ne.{1} int z (@has_zero.zero.{0} int int.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>478      { norm_cast,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/norm_cast.lean&#x27;, &#x27;line&#x27;: 305, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='Normalize casts at the given locations by moving them &quot;upwards&quot;.
As opposed to simp, norm_cast can be used without necessarily
closing the goal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='norm_cast'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
p : nat,
hp : nat.prime p,
n : nat,
z : int,
hd :
  @has_dvd.dvd.{0} int (@comm_semiring_has_dvd.{0} int int.comm_semiring)
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
       (@has_pow.pow.{0 0} nat nat nat.has_pow p n))
    z,
hz :
  not
    (@eq.{1} rat
       (@coe.{1 1} int rat
          (@coe_to_lift.{1 1} int rat
             (@coe_base.{1 1} int rat (@int.cast_coe.{0} rat rat.has_neg rat.has_zero rat.has_one rat.has_add)))
          z)
       (@has_zero.zero.{0} rat rat.has_zero))
⊢ @has_le.le.{0} int
    (@preorder.to_has_le.{0} int
       (@partial_order.to_preorder.{0} int
          (@ordered_comm_group.to_partial_order.{0} int
             (@ordered_ring.to_ordered_comm_group.{0} int
                (@linear_ordered_ring.to_ordered_ring.{0} int
                   (@linear_ordered_comm_ring.to_linear_ordered_ring.{0} int
                      (@decidable_linear_ordered_comm_ring.to_linear_ordered_comm_ring.{0} int
                         int.decidable_linear_ordered_comm_ring)))))))
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) n)
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
       (@roption.get.{0} nat
          (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
             z)
          (@iff.mpr
             (@multiplicity.finite.{0} int int.comm_semiring
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                z)
             (and
                (@ne.{1} nat
                   (int.nat_abs
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                   (@has_one.one.{0} nat nat.has_one))
                (@ne.{1} int z (@has_zero.zero.{0} int int.has_zero)))
             (@multiplicity.finite_int_iff
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                z)
             (@and.intro
                (@ne.{1} nat
                   (int.nat_abs
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                   (@has_one.one.{0} nat nat.has_one))
                (@ne.{1} int z (@has_zero.zero.{0} int int.has_zero))
                (@nat.prime.ne_one p hp)
                ?m_1))))

p : nat,
hp : nat.prime p,
n : nat,
z : int,
hd :
  @has_dvd.dvd.{0} int (@comm_semiring_has_dvd.{0} int int.comm_semiring)
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
       (@has_pow.pow.{0 0} nat nat nat.has_pow p n))
    z,
hz :
  not
    (@eq.{1} rat
       (@coe.{1 1} int rat
          (@coe_to_lift.{1 1} int rat
             (@coe_base.{1 1} int rat (@int.cast_coe.{0} rat rat.has_neg rat.has_zero rat.has_one rat.has_add)))
          z)
       (@has_zero.zero.{0} rat rat.has_zero))
⊢ @ne.{1} int z (@has_zero.zero.{0} int int.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
n : nat,
z : int,
hd :
  @has_dvd.dvd.{0} int (@comm_semiring_has_dvd.{0} int int.comm_semiring)
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
       (@has_pow.pow.{0 0} nat nat nat.has_pow p n))
    z,
hz :
  not
    (@eq.{1} rat
       (@coe.{1 1} int rat
          (@coe_to_lift.{1 1} int rat
             (@coe_base.{1 1} int rat (@int.cast_coe.{0} rat rat.has_neg rat.has_zero rat.has_one rat.has_add)))
          z)
       (@has_zero.zero.{0} rat rat.has_zero))
⊢ @has_le.le.{0} int
    (@preorder.to_has_le.{0} int
       (@partial_order.to_preorder.{0} int
          (@ordered_comm_group.to_partial_order.{0} int
             (@ordered_ring.to_ordered_comm_group.{0} int
                (@linear_ordered_ring.to_ordered_ring.{0} int
                   (@linear_ordered_comm_ring.to_linear_ordered_ring.{0} int
                      (@decidable_linear_ordered_comm_ring.to_linear_ordered_comm_ring.{0} int
                         int.decidable_linear_ordered_comm_ring)))))))
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) n)
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
       (@roption.get.{0} nat
          (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
             z)
          (@iff.mpr
             (@multiplicity.finite.{0} int int.comm_semiring
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                z)
             (and
                (@ne.{1} nat
                   (int.nat_abs
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                   (@has_one.one.{0} nat nat.has_one))
                (@ne.{1} int z (@has_zero.zero.{0} int int.has_zero)))
             (@multiplicity.finite_int_iff
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                z)
             (@and.intro
                (@ne.{1} nat
                   (int.nat_abs
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                   (@has_one.one.{0} nat nat.has_one))
                (@ne.{1} int z (@has_zero.zero.{0} int int.has_zero))
                (@nat.prime.ne_one p hp)
                ?m_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
n : nat,
z : int,
hd :
  @has_dvd.dvd.{0} int (@comm_semiring_has_dvd.{0} int int.comm_semiring)
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
       (@has_pow.pow.{0 0} nat nat nat.has_pow p n))
    z,
hz :
  not
    (@eq.{1} rat
       (@coe.{1 1} int rat
          (@coe_to_lift.{1 1} int rat
             (@coe_base.{1 1} int rat (@int.cast_coe.{0} rat rat.has_neg rat.has_zero rat.has_one rat.has_add)))
          z)
       (@has_zero.zero.{0} rat rat.has_zero))
⊢ @has_le.le.{0} nat nat.has_le n
    (@roption.get.{0} nat
       (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
          z)
       (@iff.mpr
          (@multiplicity.finite.{0} int int.comm_semiring
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
             z)
          (and
             (@ne.{1} nat
                (int.nat_abs (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                (@has_one.one.{0} nat nat.has_one))
             (@ne.{1} int z (@has_zero.zero.{0} int int.has_zero)))
          (@multiplicity.finite_int_iff
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
             z)
          (@and.intro
             (@ne.{1} nat
                (int.nat_abs (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                (@has_one.one.{0} nat nat.has_one))
             (@ne.{1} int z (@has_zero.zero.{0} int int.has_zero))
             (@nat.prime.ne_one p hp)
             ?m_1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>479        rw [← enat.coe_le_coe, enat.coe_get],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='enat.coe_le_coe'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='enat.coe_get'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/nat/enat.lean&#x27;, &#x27;line&#x27;: 80, &#x27;column&#x27;: 25}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/nat/enat.lean&#x27;, &#x27;line&#x27;: 62, &#x27;column&#x27;: 27}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {x y : nat}, iff (@has_le.le.{0} enat enat.has_le (@coe.{1 1} nat enat (@coe_to_lift.{1 1} nat enat (@coe_base.{1 1} nat enat enat.has_coe)) x) (@coe.{1 1} nat enat (@coe_to_lift.{1 1} nat enat (@coe_base.{1 1} nat enat enat.has_coe)) y)) (@has_le.le.{0} nat nat.has_le x y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {x : enat} (h : @roption.dom.{0} nat x), @eq.{1} enat (@coe.{1 1} nat enat (@coe_to_lift.{1 1} nat enat (@coe_base.{1 1} nat enat enat.has_coe)) (@roption.get.{0} nat x h)) x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
n : nat,
z : int,
hd :
  @has_dvd.dvd.{0} int (@comm_semiring_has_dvd.{0} int int.comm_semiring)
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
       (@has_pow.pow.{0 0} nat nat nat.has_pow p n))
    z,
hz :
  not
    (@eq.{1} rat
       (@coe.{1 1} int rat
          (@coe_to_lift.{1 1} int rat
             (@coe_base.{1 1} int rat (@int.cast_coe.{0} rat rat.has_neg rat.has_zero rat.has_one rat.has_add)))
          z)
       (@has_zero.zero.{0} rat rat.has_zero))
⊢ @has_le.le.{0} nat nat.has_le n
    (@roption.get.{0} nat
       (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
          z)
       (@iff.mpr
          (@multiplicity.finite.{0} int int.comm_semiring
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
             z)
          (and
             (@ne.{1} nat
                (int.nat_abs (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                (@has_one.one.{0} nat nat.has_one))
             (@ne.{1} int z (@has_zero.zero.{0} int int.has_zero)))
          (@multiplicity.finite_int_iff
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
             z)
          (@and.intro
             (@ne.{1} nat
                (int.nat_abs (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                (@has_one.one.{0} nat nat.has_one))
             (@ne.{1} int z (@has_zero.zero.{0} int int.has_zero))
             (@nat.prime.ne_one p hp)
             ?m_1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
n : nat,
z : int,
hd :
  @has_dvd.dvd.{0} int (@comm_semiring_has_dvd.{0} int int.comm_semiring)
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
       (@has_pow.pow.{0 0} nat nat nat.has_pow p n))
    z,
hz :
  not
    (@eq.{1} rat
       (@coe.{1 1} int rat
          (@coe_to_lift.{1 1} int rat
             (@coe_base.{1 1} int rat (@int.cast_coe.{0} rat rat.has_neg rat.has_zero rat.has_one rat.has_add)))
          z)
       (@has_zero.zero.{0} rat rat.has_zero))
⊢ @has_le.le.{0} enat enat.has_le
    (@coe.{1 1} nat enat (@coe_to_lift.{1 1} nat enat (@coe_base.{1 1} nat enat enat.has_coe)) n)
    (@coe.{1 1} nat enat (@coe_to_lift.{1 1} nat enat (@coe_base.{1 1} nat enat enat.has_coe))
       (@roption.get.{0} nat
          (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
             z)
          (@iff.mpr
             (@multiplicity.finite.{0} int int.comm_semiring
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                z)
             (and
                (@ne.{1} nat
                   (int.nat_abs
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                   (@has_one.one.{0} nat nat.has_one))
                (@ne.{1} int z (@has_zero.zero.{0} int int.has_zero)))
             (@multiplicity.finite_int_iff
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
                z)
             (@and.intro
                (@ne.{1} nat
                   (int.nat_abs
                      (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p))
                   (@has_one.one.{0} nat nat.has_one))
                (@ne.{1} int z (@has_zero.zero.{0} int int.has_zero))
                (@nat.prime.ne_one p hp)
                ?m_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
n : nat,
z : int,
hd :
  @has_dvd.dvd.{0} int (@comm_semiring_has_dvd.{0} int int.comm_semiring)
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
       (@has_pow.pow.{0 0} nat nat nat.has_pow p n))
    z,
hz :
  not
    (@eq.{1} rat
       (@coe.{1 1} int rat
          (@coe_to_lift.{1 1} int rat
             (@coe_base.{1 1} int rat (@int.cast_coe.{0} rat rat.has_neg rat.has_zero rat.has_one rat.has_add)))
          z)
       (@has_zero.zero.{0} rat rat.has_zero))
⊢ @has_le.le.{0} enat enat.has_le
    (@coe.{1 1} nat enat (@coe_to_lift.{1 1} nat enat (@coe_base.{1 1} nat enat enat.has_coe)) n)
    (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
       z)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>480        apply multiplicity.le_multiplicity_of_pow_dvd,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='multiplicity.le_multiplicity_of_pow_dvd'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/ring_theory/multiplicity.lean&#x27;, &#x27;line&#x27;: 93, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : comm_semiring.{0} α] [_inst_2 : @decidable_rel.{1} α (@has_dvd.dvd.{0} α (@comm_semiring_has_dvd.{0} α _inst_1))] {a b : α} {k : nat}, @has_dvd.dvd.{0} α (@comm_semiring_has_dvd.{0} α _inst_1) (@has_pow.pow.{0 0} α nat (@monoid.has_pow.{0} α (@semiring.to_monoid.{0} α (@comm_semiring.to_semiring.{0} α _inst_1))) a k) b → @has_le.le.{0} enat enat.has_le (@coe.{1 1} nat enat (@coe_to_lift.{1 1} nat enat (@coe_base.{1 1} nat enat enat.has_coe)) k) (@multiplicity.{0} α _inst_1 (λ (a b : α), _inst_2 a b) a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
n : nat,
z : int,
hd :
  @has_dvd.dvd.{0} int (@comm_semiring_has_dvd.{0} int int.comm_semiring)
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
       (@has_pow.pow.{0 0} nat nat nat.has_pow p n))
    z,
hz :
  not
    (@eq.{1} rat
       (@coe.{1 1} int rat
          (@coe_to_lift.{1 1} int rat
             (@coe_base.{1 1} int rat (@int.cast_coe.{0} rat rat.has_neg rat.has_zero rat.has_one rat.has_add)))
          z)
       (@has_zero.zero.{0} rat rat.has_zero))
⊢ @has_le.le.{0} enat enat.has_le
    (@coe.{1 1} nat enat (@coe_to_lift.{1 1} nat enat (@coe_base.{1 1} nat enat enat.has_coe)) n)
    (@multiplicity.{0} int int.comm_semiring (λ (a b : int), int.decidable_dvd a b)
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
       z)'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
n : nat,
z : int,
hd :
  @has_dvd.dvd.{0} int (@comm_semiring_has_dvd.{0} int int.comm_semiring)
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
       (@has_pow.pow.{0 0} nat nat nat.has_pow p n))
    z,
hz :
  not
    (@eq.{1} rat
       (@coe.{1 1} int rat
          (@coe_to_lift.{1 1} int rat
             (@coe_base.{1 1} int rat (@int.cast_coe.{0} rat rat.has_neg rat.has_zero rat.has_one rat.has_add)))
          z)
       (@has_zero.zero.{0} rat rat.has_zero))
⊢ @has_dvd.dvd.{0} int (@comm_semiring_has_dvd.{0} int int.comm_semiring)
    (@has_pow.pow.{0 0} int nat
       (@monoid.has_pow.{0} int (@semiring.to_monoid.{0} int (@comm_semiring.to_semiring.{0} int int.comm_semiring)))
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
       n)
    z'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>481        exact_mod_cast hd },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='blue'><a title='hd'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/norm_cast.lean&#x27;, &#x27;line&#x27;: 335, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/norm_cast.lean&#x27;, &#x27;line&#x27;: 335, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_dvd.dvd.{0} int (@comm_semiring_has_dvd.{0} int int.comm_semiring) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) (@has_pow.pow.{0 0} nat nat nat.has_pow p n)) z'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='Normalize the goal and the given expression,
then close the goal with exact.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Normalize the goal and the given expression,
then close the goal with exact.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='exact_mod_cast'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact_mod_cast'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
n : nat,
z : int,
hd :
  @has_dvd.dvd.{0} int (@comm_semiring_has_dvd.{0} int int.comm_semiring)
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
       (@has_pow.pow.{0 0} nat nat nat.has_pow p n))
    z,
hz :
  not
    (@eq.{1} rat
       (@coe.{1 1} int rat
          (@coe_to_lift.{1 1} int rat
             (@coe_base.{1 1} int rat (@int.cast_coe.{0} rat rat.has_neg rat.has_zero rat.has_one rat.has_add)))
          z)
       (@has_zero.zero.{0} rat rat.has_zero))
⊢ @has_dvd.dvd.{0} int (@comm_semiring_has_dvd.{0} int int.comm_semiring)
    (@has_pow.pow.{0 0} int nat
       (@monoid.has_pow.{0} int (@semiring.to_monoid.{0} int (@comm_semiring.to_semiring.{0} int int.comm_semiring)))
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) p)
       n)
    z'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
n : nat,
z : int,
hd :
  @has_dvd.dvd.{0} int (@comm_semiring_has_dvd.{0} int int.comm_semiring)
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
       (@has_pow.pow.{0 0} nat nat nat.has_pow p n))
    z,
hz :
  not
    (@eq.{1} rat
       (@coe.{1 1} int rat
          (@coe_to_lift.{1 1} int rat
             (@coe_base.{1 1} int rat (@int.cast_coe.{0} rat rat.has_neg rat.has_zero rat.has_one rat.has_add)))
          z)
       (@has_zero.zero.{0} rat rat.has_zero))
⊢ @ne.{1} int z (@has_zero.zero.{0} int int.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>482      { exact_mod_cast hz }}</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='blue'><a title='hz'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/norm_cast.lean&#x27;, &#x27;line&#x27;: 335, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/norm_cast.lean&#x27;, &#x27;line&#x27;: 335, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='not (@eq.{1} rat (@coe.{1 1} int rat (@coe_to_lift.{1 1} int rat (@coe_base.{1 1} int rat (@int.cast_coe.{0} rat rat.has_neg rat.has_zero rat.has_one rat.has_add))) z) (@has_zero.zero.{0} rat rat.has_zero))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='Normalize the goal and the given expression,
then close the goal with exact.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Normalize the goal and the given expression,
then close the goal with exact.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='exact_mod_cast'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact_mod_cast'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='p : nat,
hp : nat.prime p,
n : nat,
z : int,
hd :
  @has_dvd.dvd.{0} int (@comm_semiring_has_dvd.{0} int int.comm_semiring)
    (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe))
       (@has_pow.pow.{0 0} nat nat nat.has_pow p n))
    z,
hz :
  not
    (@eq.{1} rat
       (@coe.{1 1} int rat
          (@coe_to_lift.{1 1} int rat
             (@coe_base.{1 1} int rat (@int.cast_coe.{0} rat rat.has_neg rat.has_zero rat.has_one rat.has_add)))
          z)
       (@has_zero.zero.{0} rat rat.has_zero))
⊢ @ne.{1} int z (@has_zero.zero.{0} int int.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>483  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>484  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>485  end padic_norm</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>486  end padic_norm</code></pre>
</body>