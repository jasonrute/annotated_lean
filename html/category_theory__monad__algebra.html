<head>
<meta charset="UTF-8">
<link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro&display=swap" rel="stylesheet">
</head>

<body>
<pre>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  1  /-</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  2  Copyright (c) 2019 Scott Morrison. All rights reserved.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  3  Released under Apache 2.0 license as described in the file LICENSE.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  4  Authors: Scott Morrison</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  5  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  6  import category_theory.monad.basic</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/monad/basic.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  7  import category_theory.adjunction.basic</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/adjunction/basic.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  8  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  9  /-!</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 10  # Eilenberg-Moore algebras for a monad</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 11  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 12  This file defines Eilenberg-Moore algebras for a monad, and provides the category instance for them.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 13  Further it defines the adjoint pair of free and forgetful functors, respectively</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 14  from and to the original category.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 15  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 16  ## References</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 17  * [Riehl, *Category theory in context*, Section 5.2.4][riehl2017]</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 18  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 19  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 20  namespace category_theory</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 21  open category</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 22  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 23  universes v₁ u₁ -- declare the `v`&#x27;s first; see `category_theory.category` for an explanation</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 24  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 25  variables {C : Type u₁} [𝒞 : category.{v₁} C]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 61, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='category_theory.category.{v₁ u₁} C'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='orange'><a title='The typeclass `category C` describes morphisms associated to objects of type `C`.
The universe levels of the objects and morphisms are unconstrained, and will often need to be
specified explicitly, as `category.{v} C`. (See also `large_category` and `small_category`.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 26  include 𝒞</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 27  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 28  namespace monad</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 29  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 30  /-- An Eilenberg-Moore algebra for a monad `T`.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 31      cf Definition 5.2.3 in [Riehl][riehl2017]. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 32  structure algebra (T : C ⥤ C) [monad.{v₁} T] : Type (max u₁ v₁) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='category_theory.monad'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='T'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/monad/basic.lean&#x27;, &#x27;line&#x27;: 16, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type u₁) [_inst_1 : category_theory.category.{v₁ u₁} C] (D : Type u₁) [_inst_2 : category_theory.category.{v₁ u₁} D], Type (max v₁ u₁)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C], @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 → Type (max u₁ v₁)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 33  (A : C)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 34  (a : T.obj A ⟶ A)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='T'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='A'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='A'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [_inst_1 : category_theory.category.{v₁ u₁} C] {D : Type u₁} [_inst_2 : category_theory.category.{v₁ u₁} D], @category_theory.functor.{v₁ v₁ u₁ u₁} C _inst_1 D _inst_2 → C → D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u₁} [c : category_theory.has_hom.{v₁ u₁} obj], obj → obj → Type v₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 35  (unit&#x27; : (η_ T).app A ≫ a = 𝟙 A . obviously)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='category_theory.monad.η'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='T'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.nat_trans.app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='A'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='auto_param'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.category_struct.id'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='A'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='A'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/monad/basic.lean&#x27;, &#x27;line&#x27;: 16, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/name.lean&#x27;, &#x27;line&#x27;: 19, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] (T : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞) [c : @category_theory.monad.{v₁ u₁} C 𝒞 T], @category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁)} (@category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞) (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁)} (@category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞) (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁)} (@category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞) (@category_theory.functor.category.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞))) (@category_theory.functor.id.{v₁ u₁} C 𝒞) T'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₁} [𝒟 : category_theory.category.{v₁ u₁} D] {F G : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟}, @category_theory.nat_trans.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 F G → Π (X : C), @category_theory.has_hom.hom.{v₁ u₁} D (@category_theory.category_struct.to_has_hom.{v₁ u₁} D (@category_theory.category.to_category_struct.{v₁ u₁} D 𝒟)) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 G X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u₁} [c : category_theory.category_struct.{v₁ u₁} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj c) X Y → @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj c) Y Z → @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T A) A'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → name → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u₁} [c : category_theory.category_struct.{v₁ u₁} obj] (X : obj), @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj c) X X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='orange'><a title='Gadget for automatic parameter support. This is similar to the opt_param gadget, but it uses
   the tactic declaration names tac_name to synthesize the argument.
   Like opt_param, this gadget only affects elaboration.
   For example, the tactic will *not* be invoked during type class resolution.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 36  (assoc&#x27; : ((μ_ T).app A ≫ a) = (T.map a ≫ a) . obviously)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='category_theory.monad.μ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='T'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.nat_trans.app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='A'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='auto_param'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='T'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/monad/basic.lean&#x27;, &#x27;line&#x27;: 16, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/name.lean&#x27;, &#x27;line&#x27;: 19, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] (T : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞) [c : @category_theory.monad.{v₁ u₁} C 𝒞 T], @category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁)} (@category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞) (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁)} (@category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞) (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁)} (@category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞) (@category_theory.functor.category.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞))) (@category_theory.functor.comp.{v₁ v₁ v₁ u₁ u₁ u₁} C 𝒞 C 𝒞 C 𝒞 T T) T'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₁} [𝒟 : category_theory.category.{v₁ u₁} D] {F G : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟}, @category_theory.nat_trans.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 F G → Π (X : C), @category_theory.has_hom.hom.{v₁ u₁} D (@category_theory.category_struct.to_has_hom.{v₁ u₁} D (@category_theory.category.to_category_struct.{v₁ u₁} D 𝒟)) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 G X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u₁} [c : category_theory.category_struct.{v₁ u₁} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj c) X Y → @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj c) Y Z → @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T A) A'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Prop → name → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [_inst_1 : category_theory.category.{v₁ u₁} C] {D : Type u₁} [_inst_2 : category_theory.category.{v₁ u₁} D] (c : @category_theory.functor.{v₁ v₁ u₁ u₁} C _inst_1 D _inst_2) {X Y : C}, @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C _inst_1)) X Y → @category_theory.has_hom.hom.{v₁ u₁} D (@category_theory.category_struct.to_has_hom.{v₁ u₁} D (@category_theory.category.to_category_struct.{v₁ u₁} D _inst_2)) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C _inst_1 D _inst_2 c X) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C _inst_1 D _inst_2 c Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T A) A'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u₁} [c : category_theory.category_struct.{v₁ u₁} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj c) X Y → @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj c) Y Z → @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T A) A'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='orange'><a title='Gadget for automatic parameter support. This is similar to the opt_param gadget, but it uses
   the tactic declaration names tac_name to synthesize the argument.
   Like opt_param, this gadget only affects elaboration.
   For example, the tactic will *not* be invoked during type class resolution.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 37  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 38  restate_axiom algebra.unit&#x27;</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 39  restate_axiom algebra.assoc&#x27;</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 40  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 41  namespace algebra</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 42  variables {T : C ⥤ C} [monad.{v₁} T]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='T'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='_inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/monad/basic.lean&#x27;, &#x27;line&#x27;: 16, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='green'><a title='@category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@category_theory.monad.{v₁ u₁} C 𝒞 T'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 43  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 44  @[ext] structure hom (A B : algebra T) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='blue'><a title='category_theory.monad.algebra'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='T'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='red'><a title='{&#x27;line&#x27;: 32, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] (T : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞) [_inst_1 : @category_theory.monad.{v₁ u₁} C 𝒞 T], Type (max u₁ v₁)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='lemmas usable by `ext` tactic'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='An Eilenberg-Moore algebra for a monad `T`.
   cf Definition 5.2.3 in [Riehl][riehl2017].'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 45  (f : A.A ⟶ B.A)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='A'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.monad.algebra.A'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='B'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.monad.algebra.A'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 32, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 32, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {T : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞} [_inst_1 : @category_theory.monad.{v₁ u₁} C 𝒞 T], @category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1 → C'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u₁} [c : category_theory.has_hom.{v₁ u₁} obj], obj → obj → Type v₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {T : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞} [_inst_1 : @category_theory.monad.{v₁ u₁} C 𝒞 T], @category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1 → C'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 46  (h&#x27; : T.map f ≫ B.a = A.a ≫ f . obviously)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='T'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='B'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.monad.algebra.a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='auto_param'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='A'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.monad.algebra.a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 32, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/name.lean&#x27;, &#x27;line&#x27;: 19, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 32, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [_inst_1 : category_theory.category.{v₁ u₁} C] {D : Type u₁} [_inst_2 : category_theory.category.{v₁ u₁} D] (c : @category_theory.functor.{v₁ v₁ u₁ u₁} C _inst_1 D _inst_2) {X Y : C}, @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C _inst_1)) X Y → @category_theory.has_hom.hom.{v₁ u₁} D (@category_theory.category_struct.to_has_hom.{v₁ u₁} D (@category_theory.category.to_category_struct.{v₁ u₁} D _inst_2)) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C _inst_1 D _inst_2 c X) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C _inst_1 D _inst_2 c Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 A) (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 B)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u₁} [c : category_theory.category_struct.{v₁ u₁} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj c) X Y → @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj c) Y Z → @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {T : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞} [_inst_1 : @category_theory.monad.{v₁ u₁} C 𝒞 T] (c : @category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1), @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 c)) (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 c)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → name → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {T : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞} [_inst_1 : @category_theory.monad.{v₁ u₁} C 𝒞 T] (c : @category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1), @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 c)) (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 c)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u₁} [c : category_theory.category_struct.{v₁ u₁} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj c) X Y → @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj c) Y Z → @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 A) (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 B)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 A) (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 B)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title='Gadget for automatic parameter support. This is similar to the opt_param gadget, but it uses
   the tactic declaration names tac_name to synthesize the argument.
   Like opt_param, this gadget only affects elaboration.
   For example, the tactic will *not* be invoked during type class resolution.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
T : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞,
_inst_1 : @category_theory.monad.{v₁ u₁} C 𝒞 T
⊢ ∀ (X : @category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1),
    @eq.{v₁+1}
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 X)
         (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 X))
      (@category_theory.monad.algebra.hom.f.{v₁ u₁} C 𝒞 T _inst_1 X X
         (@category_theory.category_struct.id.{v₁ (max u₁ v₁)}
            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
            (@category_theory.category.to_category_struct.{v₁ (max u₁ v₁)}
               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))
            X))
      (@category_theory.category_struct.id.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
         (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 X))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 47  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 48  restate_axiom hom.h&#x27;</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 49  attribute [simp] hom.h</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='category_theory.monad.algebra.hom.h'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='green'><a title='∀ {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {T : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞} [_inst_1 : @category_theory.monad.{v₁ u₁} C 𝒞 T] {A B : @category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1} (c : @category_theory.monad.algebra.hom.{v₁ u₁} C 𝒞 T _inst_1 A B), @eq.{v₁+1} (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 A)) (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 B)) (@category_theory.category_struct.comp.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 A)) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 B)) (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 B) (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 A) (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 B) (@category_theory.monad.algebra.hom.f.{v₁ u₁} C 𝒞 T _inst_1 A B c)) (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 B)) (@category_theory.category_struct.comp.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 A)) (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 A) (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 B) (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 A) (@category_theory.monad.algebra.hom.f.{v₁ u₁} C 𝒞 T _inst_1 A B c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 50  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 51  namespace hom</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 52  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 53  @[simps] def id (A : algebra T) : hom A A :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='blue'><a title='category_theory.monad.algebra'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='T'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='category_theory.monad.algebra.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='A'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='A'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='red'><a title='{&#x27;line&#x27;: 32, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] (T : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞) [_inst_1 : @category_theory.monad.{v₁ u₁} C 𝒞 T], Type (max u₁ v₁)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {T : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞} [_inst_1 : @category_theory.monad.{v₁ u₁} C 𝒞 T], @category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1 → @category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1 → Type v₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Automatically derive lemmas specifying the projections of this declaration.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='An Eilenberg-Moore algebra for a monad `T`.
   cf Definition 5.2.3 in [Riehl][riehl2017].'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 54  { f := 𝟙 A.A }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='obviously'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='category_theory.category_struct.id'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='A'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.monad.algebra.A'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 32, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Π {obj : Type u₁} [c : category_theory.category_struct.{v₁ u₁} obj] (X : obj), @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj c) X X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {T : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞} [_inst_1 : @category_theory.monad.{v₁ u₁} C 𝒞 T], @category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1 → C'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `obviously` tactic is a &quot;replaceable&quot; tactic, which means that its meaning is defined by tactics that are defined later with the `@[obviously]` attribute. It is intended for use with `auto_param`s for structure fields.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 55  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 56  @[simps] def comp {P Q R : algebra T} (f : hom P Q) (g : hom Q R) : hom P R :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='blue'><a title='category_theory.monad.algebra'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='T'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='category_theory.monad.algebra.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='P'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Q'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='category_theory.monad.algebra.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Q'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='category_theory.monad.algebra.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='P'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='red'><a title='{&#x27;line&#x27;: 32, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] (T : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞) [_inst_1 : @category_theory.monad.{v₁ u₁} C 𝒞 T], Type (max u₁ v₁)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {T : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞} [_inst_1 : @category_theory.monad.{v₁ u₁} C 𝒞 T], @category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1 → @category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1 → Type v₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {T : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞} [_inst_1 : @category_theory.monad.{v₁ u₁} C 𝒞 T], @category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1 → @category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1 → Type v₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {T : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞} [_inst_1 : @category_theory.monad.{v₁ u₁} C 𝒞 T], @category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1 → @category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1 → Type v₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Automatically derive lemmas specifying the projections of this declaration.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title='An Eilenberg-Moore algebra for a monad `T`.
   cf Definition 5.2.3 in [Riehl][riehl2017].'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 57  { f := f.f ≫ g.f,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.monad.algebra.hom.f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.monad.algebra.hom.f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@category_theory.monad.algebra.hom.{v₁ u₁} C 𝒞 T _inst_1 P Q'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {T : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞} [_inst_1 : @category_theory.monad.{v₁ u₁} C 𝒞 T] {A B : @category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1}, @category_theory.monad.algebra.hom.{v₁ u₁} C 𝒞 T _inst_1 A B → @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 A) (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 B)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u₁} [c : category_theory.category_struct.{v₁ u₁} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj c) X Y → @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj c) Y Z → @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.monad.algebra.hom.{v₁ u₁} C 𝒞 T _inst_1 Q R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {T : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞} [_inst_1 : @category_theory.monad.{v₁ u₁} C 𝒞 T] {A B : @category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1}, @category_theory.monad.algebra.hom.{v₁ u₁} C 𝒞 T _inst_1 A B → @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 A) (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 B)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 58    h&#x27; := by rw [functor.map_comp, category.assoc, g.h, ←category.assoc, f.h, category.assoc] }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='category_theory.functor.map_comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.category.assoc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='category_theory.category.assoc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='category_theory.category.assoc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {C : Type u₁} [_inst_1 : category_theory.category.{v₁ u₁} C] {D : Type u₁} [_inst_2 : category_theory.category.{v₁ u₁} D] (c : @category_theory.functor.{v₁ v₁ u₁ u₁} C _inst_1 D _inst_2) {X Y Z : C} (f : @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C _inst_1)) X Y) (g : @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C _inst_1)) Y Z), @eq.{v₁+1} (@category_theory.has_hom.hom.{v₁ u₁} D (@category_theory.category_struct.to_has_hom.{v₁ u₁} D (@category_theory.category.to_category_struct.{v₁ u₁} D _inst_2)) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C _inst_1 D _inst_2 c X) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C _inst_1 D _inst_2 c Z)) (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C _inst_1 D _inst_2 c X Z (@category_theory.category_struct.comp.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C _inst_1) X Y Z f g)) (@category_theory.category_struct.comp.{v₁ u₁} D (@category_theory.category.to_category_struct.{v₁ u₁} D _inst_2) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C _inst_1 D _inst_2 c X) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C _inst_1 D _inst_2 c Y) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C _inst_1 D _inst_2 c Z) (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C _inst_1 D _inst_2 c X Y f) (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C _inst_1 D _inst_2 c Y Z g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (obj : Type u₁) [c : category_theory.category.{v₁ u₁} obj] {W X Y Z : obj} (f : @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c)) W X) (g : @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c)) X Y) (h : @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c)) Y Z), @eq.{v₁+1} (@category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c)) W Z) (@category_theory.category_struct.comp.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c) W Y Z (@category_theory.category_struct.comp.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c) W X Y f g) h) (@category_theory.category_struct.comp.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c) W X Z f (@category_theory.category_struct.comp.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c) X Y Z g h))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{v₁+1} (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Q)) (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 R)) (@category_theory.category_struct.comp.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Q)) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 R)) (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 R) (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Q) (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 R) (@category_theory.monad.algebra.hom.f.{v₁ u₁} C 𝒞 T _inst_1 Q R g)) (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 R)) (@category_theory.category_struct.comp.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Q)) (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Q) (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 R) (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 Q) (@category_theory.monad.algebra.hom.f.{v₁ u₁} C 𝒞 T _inst_1 Q R g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (obj : Type u₁) [c : category_theory.category.{v₁ u₁} obj] {W X Y Z : obj} (f : @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c)) W X) (g : @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c)) X Y) (h : @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c)) Y Z), @eq.{v₁+1} (@category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c)) W Z) (@category_theory.category_struct.comp.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c) W Y Z (@category_theory.category_struct.comp.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c) W X Y f g) h) (@category_theory.category_struct.comp.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c) W X Z f (@category_theory.category_struct.comp.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c) X Y Z g h))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{v₁+1} (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 P)) (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Q)) (@category_theory.category_struct.comp.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 P)) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Q)) (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Q) (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 P) (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Q) (@category_theory.monad.algebra.hom.f.{v₁ u₁} C 𝒞 T _inst_1 P Q f)) (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 Q)) (@category_theory.category_struct.comp.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 P)) (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 P) (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Q) (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 P) (@category_theory.monad.algebra.hom.f.{v₁ u₁} C 𝒞 T _inst_1 P Q f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (obj : Type u₁) [c : category_theory.category.{v₁ u₁} obj] {W X Y Z : obj} (f : @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c)) W X) (g : @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c)) X Y) (h : @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c)) Y Z), @eq.{v₁+1} (@category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c)) W Z) (@category_theory.category_struct.comp.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c) W Y Z (@category_theory.category_struct.comp.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c) W X Y f g) h) (@category_theory.category_struct.comp.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c) W X Z f (@category_theory.category_struct.comp.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c) X Y Z g h))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
T : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞,
_inst_1 : @category_theory.monad.{v₁ u₁} C 𝒞 T,
P Q R : @category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1,
f : @category_theory.monad.algebra.hom.{v₁ u₁} C 𝒞 T _inst_1 P Q,
g : @category_theory.monad.algebra.hom.{v₁ u₁} C 𝒞 T _inst_1 Q R
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 P))
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 R))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 P))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 R))
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 R)
       (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 P)
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 R)
          (@category_theory.category_struct.comp.{v₁ u₁} C
             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
             (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 P)
             (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Q)
             (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 R)
             (@category_theory.monad.algebra.hom.f.{v₁ u₁} C 𝒞 T _inst_1 P Q f)
             (@category_theory.monad.algebra.hom.f.{v₁ u₁} C 𝒞 T _inst_1 Q R g)))
       (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 R))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 P))
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 P)
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 R)
       (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 P)
       (@category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 P)
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Q)
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 R)
          (@category_theory.monad.algebra.hom.f.{v₁ u₁} C 𝒞 T _inst_1 P Q f)
          (@category_theory.monad.algebra.hom.f.{v₁ u₁} C 𝒞 T _inst_1 Q R g)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
T : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞,
_inst_1 : @category_theory.monad.{v₁ u₁} C 𝒞 T,
P Q R : @category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1,
f : @category_theory.monad.algebra.hom.{v₁ u₁} C 𝒞 T _inst_1 P Q,
g : @category_theory.monad.algebra.hom.{v₁ u₁} C 𝒞 T _inst_1 Q R
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 P))
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 R))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 P))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 R))
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 R)
       (@category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 P))
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Q))
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 R))
          (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 P)
             (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Q)
             (@category_theory.monad.algebra.hom.f.{v₁ u₁} C 𝒞 T _inst_1 P Q f))
          (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Q)
             (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 R)
             (@category_theory.monad.algebra.hom.f.{v₁ u₁} C 𝒞 T _inst_1 Q R g)))
       (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 R))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 P))
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 P)
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 R)
       (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 P)
       (@category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 P)
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Q)
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 R)
          (@category_theory.monad.algebra.hom.f.{v₁ u₁} C 𝒞 T _inst_1 P Q f)
          (@category_theory.monad.algebra.hom.f.{v₁ u₁} C 𝒞 T _inst_1 Q R g)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
T : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞,
_inst_1 : @category_theory.monad.{v₁ u₁} C 𝒞 T,
P Q R : @category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1,
f : @category_theory.monad.algebra.hom.{v₁ u₁} C 𝒞 T _inst_1 P Q,
g : @category_theory.monad.algebra.hom.{v₁ u₁} C 𝒞 T _inst_1 Q R
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 P))
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 R))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 P))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Q))
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 R)
       (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 P)
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Q)
          (@category_theory.monad.algebra.hom.f.{v₁ u₁} C 𝒞 T _inst_1 P Q f))
       (@category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Q))
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 R))
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 R)
          (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Q)
             (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 R)
             (@category_theory.monad.algebra.hom.f.{v₁ u₁} C 𝒞 T _inst_1 Q R g))
          (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 R)))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 P))
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 P)
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 R)
       (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 P)
       (@category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 P)
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Q)
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 R)
          (@category_theory.monad.algebra.hom.f.{v₁ u₁} C 𝒞 T _inst_1 P Q f)
          (@category_theory.monad.algebra.hom.f.{v₁ u₁} C 𝒞 T _inst_1 Q R g)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
T : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞,
_inst_1 : @category_theory.monad.{v₁ u₁} C 𝒞 T,
P Q R : @category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1,
f : @category_theory.monad.algebra.hom.{v₁ u₁} C 𝒞 T _inst_1 P Q,
g : @category_theory.monad.algebra.hom.{v₁ u₁} C 𝒞 T _inst_1 Q R
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 P))
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 R))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 P))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Q))
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 R)
       (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 P)
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Q)
          (@category_theory.monad.algebra.hom.f.{v₁ u₁} C 𝒞 T _inst_1 P Q f))
       (@category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Q))
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Q)
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 R)
          (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 Q)
          (@category_theory.monad.algebra.hom.f.{v₁ u₁} C 𝒞 T _inst_1 Q R g)))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 P))
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 P)
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 R)
       (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 P)
       (@category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 P)
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Q)
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 R)
          (@category_theory.monad.algebra.hom.f.{v₁ u₁} C 𝒞 T _inst_1 P Q f)
          (@category_theory.monad.algebra.hom.f.{v₁ u₁} C 𝒞 T _inst_1 Q R g)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
T : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞,
_inst_1 : @category_theory.monad.{v₁ u₁} C 𝒞 T,
P Q R : @category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1,
f : @category_theory.monad.algebra.hom.{v₁ u₁} C 𝒞 T _inst_1 P Q,
g : @category_theory.monad.algebra.hom.{v₁ u₁} C 𝒞 T _inst_1 Q R
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 P))
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 R))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 P))
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Q)
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 R)
       (@category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 P))
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Q))
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Q)
          (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 P)
             (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Q)
             (@category_theory.monad.algebra.hom.f.{v₁ u₁} C 𝒞 T _inst_1 P Q f))
          (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 Q))
       (@category_theory.monad.algebra.hom.f.{v₁ u₁} C 𝒞 T _inst_1 Q R g))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 P))
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 P)
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 R)
       (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 P)
       (@category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 P)
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Q)
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 R)
          (@category_theory.monad.algebra.hom.f.{v₁ u₁} C 𝒞 T _inst_1 P Q f)
          (@category_theory.monad.algebra.hom.f.{v₁ u₁} C 𝒞 T _inst_1 Q R g)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
T : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞,
_inst_1 : @category_theory.monad.{v₁ u₁} C 𝒞 T,
P Q R : @category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1,
f : @category_theory.monad.algebra.hom.{v₁ u₁} C 𝒞 T _inst_1 P Q,
g : @category_theory.monad.algebra.hom.{v₁ u₁} C 𝒞 T _inst_1 Q R
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 P))
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 R))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 P))
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Q)
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 R)
       (@category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 P))
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 P)
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Q)
          (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 P)
          (@category_theory.monad.algebra.hom.f.{v₁ u₁} C 𝒞 T _inst_1 P Q f))
       (@category_theory.monad.algebra.hom.f.{v₁ u₁} C 𝒞 T _inst_1 Q R g))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 P))
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 P)
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 R)
       (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 P)
       (@category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 P)
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Q)
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 R)
          (@category_theory.monad.algebra.hom.f.{v₁ u₁} C 𝒞 T _inst_1 P Q f)
          (@category_theory.monad.algebra.hom.f.{v₁ u₁} C 𝒞 T _inst_1 Q R g)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
T : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞,
_inst_1 : @category_theory.monad.{v₁ u₁} C 𝒞 T,
P Q R : @category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1,
f : @category_theory.monad.algebra.hom.{v₁ u₁} C 𝒞 T _inst_1 P Q,
g : @category_theory.monad.algebra.hom.{v₁ u₁} C 𝒞 T _inst_1 Q R
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 P))
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 R))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 P))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 R))
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 R)
       (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 P)
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 R)
          (@category_theory.category_struct.comp.{v₁ u₁} C
             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
             (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 P)
             (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Q)
             (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 R)
             (@category_theory.monad.algebra.hom.f.{v₁ u₁} C 𝒞 T _inst_1 P Q f)
             (@category_theory.monad.algebra.hom.f.{v₁ u₁} C 𝒞 T _inst_1 Q R g)))
       (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 R))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 P))
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 P)
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 R)
       (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 P)
       (@category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 P)
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Q)
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 R)
          (@category_theory.monad.algebra.hom.f.{v₁ u₁} C 𝒞 T _inst_1 P Q f)
          (@category_theory.monad.algebra.hom.f.{v₁ u₁} C 𝒞 T _inst_1 Q R g)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 59  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 60  end hom</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 61  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 62  /-- The category of Eilenberg-Moore algebras for a monad.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 63      cf Definition 5.2.4 in [Riehl][riehl2017]. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 64  @[simps] instance EilenbergMoore : category (algebra T) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='blue'><a title='category_theory.category'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.monad.algebra'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='T'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 61, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 32, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='green'><a title='Type u → Type (max u (v+1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] (T : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞) [_inst_1 : @category_theory.monad.{v₁ u₁} C 𝒞 T], Type (max u₁ v₁)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Automatically derive lemmas specifying the projections of this declaration.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='orange'><a title='The typeclass `category C` describes morphisms associated to objects of type `C`.
The universe levels of the objects and morphisms are unconstrained, and will often need to be
specified explicitly, as `category.{v} C`. (See also `large_category` and `small_category`.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An Eilenberg-Moore algebra for a monad `T`.
   cf Definition 5.2.3 in [Riehl][riehl2017].'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 65  { hom := hom,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='obviously'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='category_theory.monad.algebra.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {T : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞} [_inst_1 : @category_theory.monad.{v₁ u₁} C 𝒞 T], @category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1 → @category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1 → Type v₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `obviously` tactic is a &quot;replaceable&quot; tactic, which means that its meaning is defined by tactics that are defined later with the `@[obviously]` attribute. It is intended for use with `auto_param`s for structure fields.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 66    id := hom.id,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='category_theory.monad.algebra.hom.id'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;line&#x27;: 53, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {T : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞} [_inst_1 : @category_theory.monad.{v₁ u₁} C 𝒞 T] (A : @category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1), @category_theory.monad.algebra.hom.{v₁ u₁} C 𝒞 T _inst_1 A A'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 67    comp := @hom.comp _ _ _ _ }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='category_theory.monad.algebra.hom.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;line&#x27;: 56, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {T : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞} [_inst_1 : @category_theory.monad.{v₁ u₁} C 𝒞 T] {P Q R : @category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1}, @category_theory.monad.algebra.hom.{v₁ u₁} C 𝒞 T _inst_1 P Q → @category_theory.monad.algebra.hom.{v₁ u₁} C 𝒞 T _inst_1 Q R → @category_theory.monad.algebra.hom.{v₁ u₁} C 𝒞 T _inst_1 P R'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 68  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 69  end algebra</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 70  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 71  variables (T : C ⥤ C) [monad.{v₁} T]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='category_theory.monad'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/monad/basic.lean&#x27;, &#x27;line&#x27;: 16, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='green'><a title='Π (C : Type u₁) [_inst_1 : category_theory.category.{v₁ u₁} C] (D : Type u₁) [_inst_2 : category_theory.category.{v₁ u₁} D], Type (max v₁ u₁)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C], @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 → Type (max u₁ v₁)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 72  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 73  @[simps] def forget : algebra T ⥤ C :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='blue'><a title='category_theory.monad.algebra'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='T'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='red'><a title='{&#x27;line&#x27;: 32, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] (T : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞) [_inst_1 : @category_theory.monad.{v₁ u₁} C 𝒞 T], Type (max u₁ v₁)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type (max u₁ v₁)) [_inst_1 : category_theory.category.{v₁ (max u₁ v₁)} C] (D : Type u₁) [_inst_2 : category_theory.category.{v₁ u₁} D], Type (max u₁ v₁)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Automatically derive lemmas specifying the projections of this declaration.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='An Eilenberg-Moore algebra for a monad `T`.
   cf Definition 5.2.3 in [Riehl][riehl2017].'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 74  { obj := λ A, A.A,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='obviously'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='A'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='A'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.monad.algebra.A'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;line&#x27;: 32, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {T : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞} [_inst_1 : @category_theory.monad.{v₁ u₁} C 𝒞 T], @category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1 → C'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `obviously` tactic is a &quot;replaceable&quot; tactic, which means that its meaning is defined by tactics that are defined later with the `@[obviously]` attribute. It is intended for use with `auto_param`s for structure fields.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 75    map := λ A B f, f.f }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='A'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='B'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.monad.algebra.hom.f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v₁ (max u₁ v₁)} (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.category_struct.to_has_hom.{v₁ (max u₁ v₁)} (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.category.to_category_struct.{v₁ (max u₁ v₁)} (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))) A B'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.has_hom.hom.{v₁ (max u₁ v₁)} (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.category_struct.to_has_hom.{v₁ (max u₁ v₁)} (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.category.to_category_struct.{v₁ (max u₁ v₁)} (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))) A B'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {T : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞} [_inst_1 : @category_theory.monad.{v₁ u₁} C 𝒞 T] {A B : @category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1}, @category_theory.monad.algebra.hom.{v₁ u₁} C 𝒞 T _inst_1 A B → @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 A) (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 B)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 76  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 77  @[simps] def free : C ⥤ algebra T :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.monad.algebra'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='T'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 32, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type u₁) [_inst_1 : category_theory.category.{v₁ u₁} C] (D : Type (max u₁ v₁)) [_inst_2 : category_theory.category.{v₁ (max u₁ v₁)} D], Type (max u₁ v₁)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] (T : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞) [_inst_1 : @category_theory.monad.{v₁ u₁} C 𝒞 T], Type (max u₁ v₁)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Automatically derive lemmas specifying the projections of this declaration.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An Eilenberg-Moore algebra for a monad `T`.
   cf Definition 5.2.3 in [Riehl][riehl2017].'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 78  { obj := λ X,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='obviously'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `obviously` tactic is a &quot;replaceable&quot; tactic, which means that its meaning is defined by tactics that are defined later with the `@[obviously]` attribute. It is intended for use with `auto_param`s for structure fields.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 79    { A := T.obj X,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='obviously'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='T'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [_inst_1 : category_theory.category.{v₁ u₁} C] {D : Type u₁} [_inst_2 : category_theory.category.{v₁ u₁} D], @category_theory.functor.{v₁ v₁ u₁ u₁} C _inst_1 D _inst_2 → C → D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `obviously` tactic is a &quot;replaceable&quot; tactic, which means that its meaning is defined by tactics that are defined later with the `@[obviously]` attribute. It is intended for use with `auto_param`s for structure fields.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 80      a := (μ_ T).app X,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='category_theory.monad.μ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='T'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.nat_trans.app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/monad/basic.lean&#x27;, &#x27;line&#x27;: 16, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] (T : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞) [c : @category_theory.monad.{v₁ u₁} C 𝒞 T], @category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁)} (@category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞) (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁)} (@category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞) (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁)} (@category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞) (@category_theory.functor.category.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞))) (@category_theory.functor.comp.{v₁ v₁ v₁ u₁ u₁ u₁} C 𝒞 C 𝒞 C 𝒞 T T) T'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₁} [𝒟 : category_theory.category.{v₁ u₁} D] {F G : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟}, @category_theory.nat_trans.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 F G → Π (X : C), @category_theory.has_hom.hom.{v₁ u₁} D (@category_theory.category_struct.to_has_hom.{v₁ u₁} D (@category_theory.category.to_category_struct.{v₁ u₁} D 𝒟)) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 G X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 81      assoc&#x27; := (monad.assoc T _).symm },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='category_theory.monad.assoc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='T'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='eq.symm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/monad/basic.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 198, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='green'><a title='∀ {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] (T : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞) [c : @category_theory.monad.{v₁ u₁} C 𝒞 T] (X : C), @eq.{v₁+1} (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)) (@category_theory.category_struct.comp.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X) (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X) (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 (@category_theory.functor.comp.{v₁ v₁ v₁ u₁ u₁ u₁} C 𝒞 C 𝒞 C 𝒞 T T) T (@category_theory.monad.μ.{v₁ u₁} C 𝒞 T c) X)) (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 (@category_theory.functor.comp.{v₁ v₁ v₁ u₁ u₁ u₁} C 𝒞 C 𝒞 C 𝒞 T T) T (@category_theory.monad.μ.{v₁ u₁} C 𝒞 T c) X)) (@category_theory.category_struct.comp.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X) (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 (@category_theory.functor.comp.{v₁ v₁ v₁ u₁ u₁ u₁} C 𝒞 C 𝒞 C 𝒞 T T) T (@category_theory.monad.μ.{v₁ u₁} C 𝒞 T c) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)) (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 (@category_theory.functor.comp.{v₁ v₁ v₁ u₁ u₁ u₁} C 𝒞 C 𝒞 C 𝒞 T T) T (@category_theory.monad.μ.{v₁ u₁} C 𝒞 T c) X))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {α : Type v₁} {a b : α}, @eq.{v₁+1} α a b → @eq.{v₁+1} α b a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 82    map := λ X Y f,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 83    { f := T.map f,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='T'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='@category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [_inst_1 : category_theory.category.{v₁ u₁} C] {D : Type u₁} [_inst_2 : category_theory.category.{v₁ u₁} D] (c : @category_theory.functor.{v₁ v₁ u₁ u₁} C _inst_1 D _inst_2) {X Y : C}, @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C _inst_1)) X Y → @category_theory.has_hom.hom.{v₁ u₁} D (@category_theory.category_struct.to_has_hom.{v₁ u₁} D (@category_theory.category.to_category_struct.{v₁ u₁} D _inst_2)) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C _inst_1 D _inst_2 c X) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C _inst_1 D _inst_2 c Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 84      h&#x27; := by erw (μ_ T).naturality } }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='blue'><a title='category_theory.monad.μ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='T'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/monad/basic.lean&#x27;, &#x27;line&#x27;: 16, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] (T : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞) [c : @category_theory.monad.{v₁ u₁} C 𝒞 T], @category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁)} (@category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞) (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁)} (@category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞) (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁)} (@category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞) (@category_theory.functor.category.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞))) (@category_theory.functor.comp.{v₁ v₁ v₁ u₁ u₁ u₁} C 𝒞 C 𝒞 C 𝒞 T T) T'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
T : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞,
_inst_1 : @category_theory.monad.{v₁ u₁} C 𝒞 T,
X Y : C,
f :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    Y
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
             (@category_theory.monad.algebra.mk.{v₁ u₁} C 𝒞 T _inst_1
                (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                   (@category_theory.functor.comp.{v₁ v₁ v₁ u₁ u₁ u₁} C 𝒞 C 𝒞 C 𝒞 T T)
                   T
                   (@category_theory.monad.μ.{v₁ u₁} C 𝒞 T _inst_1)
                   X)
                (@id.{0}
                   (∀ (X : C),
                      @eq.{v₁+1}
                        (@category_theory.has_hom.hom.{v₁ u₁} C
                           (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                              (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                           (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                              (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                              (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                           (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                        (@category_theory.category_struct.comp.{v₁ u₁} C
                           (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                           (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                              (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                              (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                           (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                              (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                           (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                           (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                              (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                              T
                              (@category_theory.monad.η.{v₁ u₁} C 𝒞 T _inst_1)
                              (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                           (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                              (@category_theory.functor.comp.{v₁ v₁ v₁ u₁ u₁ u₁} C 𝒞 C 𝒞 C 𝒞 T T)
                              T
                              (@category_theory.monad.μ.{v₁ u₁} C 𝒞 T _inst_1)
                              X))
                        (@category_theory.category_struct.id.{v₁ u₁} C
                           (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                           (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)))
                   (λ (X : C),
                      @eq.mpr.{0}
                        (@eq.{v₁+1}
                           (@category_theory.has_hom.hom.{v₁ u₁} C
                              (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                 (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                              (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                              (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                           (@category_theory.category_struct.comp.{v₁ u₁} C
                              (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                              (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                              (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                 (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                              (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                              (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                 (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                                 T
                                 (@category_theory.monad.η.{v₁ u₁} C 𝒞 T _inst_1)
                                 (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                              (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                 (@category_theory.functor.comp.{v₁ v₁ v₁ u₁ u₁ u₁} C 𝒞 C 𝒞 C 𝒞 T
                                    T)
                                 T
                                 (@category_theory.monad.μ.{v₁ u₁} C 𝒞 T _inst_1)
                                 X))
                           (@category_theory.category_struct.id.{v₁ u₁} C
                              (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                              (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)))
                        true
                        (@id.{0}
                           (@eq.{1} Prop
                              (@eq.{v₁+1}
                                 (@category_theory.has_hom.hom.{v₁ u₁} C
                                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                    (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                                    (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                                 (@category_theory.category_struct.comp.{v₁ u₁} C
                                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                    (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                                    (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                                    (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                                    (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                       (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                                       T
                                       (@category_theory.monad.η.{v₁ u₁} C 𝒞 T _inst_1)
                                       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                                    (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                       (@category_theory.functor.comp.{v₁ v₁ v₁ u₁ u₁ u₁} C 𝒞 C 𝒞 C
                                          𝒞
                                          T
                                          T)
                                       T
                                       (@category_theory.monad.μ.{v₁ u₁} C 𝒞 T _inst_1)
                                       X))
                                 (@category_theory.category_struct.id.{v₁ u₁} C
                                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                    (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)))
                              true)
                           (@eq.trans.{1} Prop
                              (@eq.{v₁+1}
                                 (@category_theory.has_hom.hom.{v₁ u₁} C
                                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                    (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                                    (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                                 (@category_theory.category_struct.comp.{v₁ u₁} C
                                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                    (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                                    (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                                    (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                                    (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                       (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                                       T
                                       (@category_theory.monad.η.{v₁ u₁} C 𝒞 T _inst_1)
                                       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                                    (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                       (@category_theory.functor.comp.{v₁ v₁ v₁ u₁ u₁ u₁} C 𝒞 C 𝒞 C
                                          𝒞
                                          T
                                          T)
                                       T
                                       (@category_theory.monad.μ.{v₁ u₁} C 𝒞 T _inst_1)
                                       X))
                                 (@category_theory.category_struct.id.{v₁ u₁} C
                                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                    (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)))
                              (@eq.{v₁+1}
                                 (@category_theory.has_hom.hom.{v₁ u₁} C
                                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                    (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                                    (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                                 (@category_theory.category_struct.id.{v₁ u₁} C
                                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                    (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                                 (@category_theory.category_struct.id.{v₁ u₁} C
                                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                    (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)))
                              true
                              ((λ
                                (a a_1 :
                                  @category_theory.has_hom.hom.{v₁ u₁} C
                                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                    (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                                    (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                                (e_1 :
                                  @eq.{v₁+1}
                                    (@category_theory.has_hom.hom.{v₁ u₁} C
                                       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                                       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                                    a
                                    a_1)
                                (a_2 a_3 :
                                  @category_theory.has_hom.hom.{v₁ u₁} C
                                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                    (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                                    (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                                (e_2 :
                                  @eq.{v₁+1}
                                    (@category_theory.has_hom.hom.{v₁ u₁} C
                                       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                                       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                                    a_2
                                    a_3),
                                  @congr.{v₁+1 1}
                                    (@category_theory.has_hom.hom.{v₁ u₁} C
                                       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                                       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                                    Prop
                                    (@eq.{v₁+1}
                                       (@category_theory.has_hom.hom.{v₁ u₁} C
                                          (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                                          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                                       a)
                                    (@eq.{v₁+1}
                                       (@category_theory.has_hom.hom.{v₁ u₁} C
                                          (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                                          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                                       a_1)
                                    a_2
                                    a_3
                                    (@congr_arg.{v₁+1 (max (v₁+1) 1)}
                                       (@category_theory.has_hom.hom.{v₁ u₁} C
                                          (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                                          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                                       (@category_theory.has_hom.hom.{v₁ u₁} C
                                          (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                                          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X) →
                                        Prop)
                                       a
                                       a_1
                                       (@eq.{v₁+1}
                                          (@category_theory.has_hom.hom.{v₁ u₁} C
                                             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                                             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)))
                                       e_1)
                                    e_2)
                                 (@category_theory.category_struct.comp.{v₁ u₁} C
                                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                    (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                                    (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                                    (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                                    (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                       (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                                       T
                                       (@category_theory.monad.η.{v₁ u₁} C 𝒞 T _inst_1)
                                       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                                    (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                       (@category_theory.functor.comp.{v₁ v₁ v₁ u₁ u₁ u₁} C 𝒞 C 𝒞 C
                                          𝒞
                                          T
                                          T)
                                       T
                                       (@category_theory.monad.μ.{v₁ u₁} C 𝒞 T _inst_1)
                                       X))
                                 (@category_theory.category_struct.id.{v₁ u₁} C
                                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                    (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                                 (@category_theory.monad.left_unit.{v₁ u₁} C 𝒞 T _inst_1 X)
                                 (@category_theory.category_struct.id.{v₁ u₁} C
                                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                    (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                                 (@category_theory.category_struct.id.{v₁ u₁} C
                                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                    (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                                 (@eq.refl.{v₁+1}
                                    (@category_theory.has_hom.hom.{v₁ u₁} C
                                       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                                       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                                    (@category_theory.category_struct.id.{v₁ u₁} C
                                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))))
                              (@propext
                                 (@eq.{v₁+1}
                                    (@category_theory.has_hom.hom.{v₁ u₁} C
                                       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                                       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                                    (@category_theory.category_struct.id.{v₁ u₁} C
                                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                                    (@category_theory.category_struct.id.{v₁ u₁} C
                                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)))
                                 true
                                 (@eq_self_iff_true.{v₁+1}
                                    (@category_theory.has_hom.hom.{v₁ u₁} C
                                       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                                       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                                    (@category_theory.category_struct.id.{v₁ u₁} C
                                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))))))
                        trivial)
                   X)
                (@eq.symm.{v₁+1}
                   (@category_theory.has_hom.hom.{v₁ u₁} C
                      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                      (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)))
                      (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                   (@category_theory.category_struct.comp.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                      (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)))
                      (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                      (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                      (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                         (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                            (@category_theory.functor.comp.{v₁ v₁ v₁ u₁ u₁ u₁} C 𝒞 C 𝒞 C 𝒞 T T)
                            T
                            (@category_theory.monad.μ.{v₁ u₁} C 𝒞 T _inst_1)
                            X))
                      (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                         (@category_theory.functor.comp.{v₁ v₁ v₁ u₁ u₁ u₁} C 𝒞 C 𝒞 C 𝒞 T T)
                         T
                         (@category_theory.monad.μ.{v₁ u₁} C 𝒞 T _inst_1)
                         X))
                   (@category_theory.category_struct.comp.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                      (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)))
                      (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                      (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                      (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                         (@category_theory.functor.comp.{v₁ v₁ v₁ u₁ u₁ u₁} C 𝒞 C 𝒞 C 𝒞 T T)
                         T
                         (@category_theory.monad.μ.{v₁ u₁} C 𝒞 T _inst_1)
                         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                      (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                         (@category_theory.functor.comp.{v₁ v₁ v₁ u₁ u₁ u₁} C 𝒞 C 𝒞 C 𝒞 T T)
                         T
                         (@category_theory.monad.μ.{v₁ u₁} C 𝒞 T _inst_1)
                         X))
                   (@category_theory.monad.assoc.{v₁ u₁} C 𝒞 T _inst_1 X)))))
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.monad.algebra.mk.{v₁ u₁} C 𝒞 T _inst_1
             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T Y)
             (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                (@category_theory.functor.comp.{v₁ v₁ v₁ u₁ u₁ u₁} C 𝒞 C 𝒞 C 𝒞 T T)
                T
                (@category_theory.monad.μ.{v₁ u₁} C 𝒞 T _inst_1)
                Y)
             (@id.{0}
                (∀ (X : C),
                   @eq.{v₁+1}
                     (@category_theory.has_hom.hom.{v₁ u₁} C
                        (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                           (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                        (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                           (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                           (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                        (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                     (@category_theory.category_struct.comp.{v₁ u₁} C
                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                        (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                           (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                           (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                        (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                           (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                        (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                        (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                           (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                           T
                           (@category_theory.monad.η.{v₁ u₁} C 𝒞 T _inst_1)
                           (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                        (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                           (@category_theory.functor.comp.{v₁ v₁ v₁ u₁ u₁ u₁} C 𝒞 C 𝒞 C 𝒞 T T)
                           T
                           (@category_theory.monad.μ.{v₁ u₁} C 𝒞 T _inst_1)
                           X))
                     (@category_theory.category_struct.id.{v₁ u₁} C
                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                        (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)))
                (λ (X : C),
                   @eq.mpr.{0}
                     (@eq.{v₁+1}
                        (@category_theory.has_hom.hom.{v₁ u₁} C
                           (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                              (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                           (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                           (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                        (@category_theory.category_struct.comp.{v₁ u₁} C
                           (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                           (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                           (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                              (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                           (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                           (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                              (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                              T
                              (@category_theory.monad.η.{v₁ u₁} C 𝒞 T _inst_1)
                              (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                           (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                              (@category_theory.functor.comp.{v₁ v₁ v₁ u₁ u₁ u₁} C 𝒞 C 𝒞 C 𝒞 T T)
                              T
                              (@category_theory.monad.μ.{v₁ u₁} C 𝒞 T _inst_1)
                              X))
                        (@category_theory.category_struct.id.{v₁ u₁} C
                           (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                           (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)))
                     true
                     (@id.{0}
                        (@eq.{1} Prop
                           (@eq.{v₁+1}
                              (@category_theory.has_hom.hom.{v₁ u₁} C
                                 (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                 (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                                 (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                              (@category_theory.category_struct.comp.{v₁ u₁} C
                                 (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                 (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                                 (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                    (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                                 (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                                 (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                    (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                                    T
                                    (@category_theory.monad.η.{v₁ u₁} C 𝒞 T _inst_1)
                                    (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                                 (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                    (@category_theory.functor.comp.{v₁ v₁ v₁ u₁ u₁ u₁} C 𝒞 C 𝒞 C 𝒞
                                       T
                                       T)
                                    T
                                    (@category_theory.monad.μ.{v₁ u₁} C 𝒞 T _inst_1)
                                    X))
                              (@category_theory.category_struct.id.{v₁ u₁} C
                                 (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                 (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)))
                           true)
                        (@eq.trans.{1} Prop
                           (@eq.{v₁+1}
                              (@category_theory.has_hom.hom.{v₁ u₁} C
                                 (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                 (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                                 (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                              (@category_theory.category_struct.comp.{v₁ u₁} C
                                 (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                 (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                                 (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                    (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                                 (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                                 (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                    (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                                    T
                                    (@category_theory.monad.η.{v₁ u₁} C 𝒞 T _inst_1)
                                    (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                                 (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                    (@category_theory.functor.comp.{v₁ v₁ v₁ u₁ u₁ u₁} C 𝒞 C 𝒞 C 𝒞
                                       T
                                       T)
                                    T
                                    (@category_theory.monad.μ.{v₁ u₁} C 𝒞 T _inst_1)
                                    X))
                              (@category_theory.category_struct.id.{v₁ u₁} C
                                 (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                 (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)))
                           (@eq.{v₁+1}
                              (@category_theory.has_hom.hom.{v₁ u₁} C
                                 (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                 (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                                 (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                              (@category_theory.category_struct.id.{v₁ u₁} C
                                 (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                 (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                              (@category_theory.category_struct.id.{v₁ u₁} C
                                 (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                 (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)))
                           true
                           ((λ
                             (a a_1 :
                               @category_theory.has_hom.hom.{v₁ u₁} C
                                 (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                 (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                                 (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                             (e_1 :
                               @eq.{v₁+1}
                                 (@category_theory.has_hom.hom.{v₁ u₁} C
                                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                    (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                                    (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                                 a
                                 a_1)
                             (a_2 a_3 :
                               @category_theory.has_hom.hom.{v₁ u₁} C
                                 (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                 (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                                 (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                             (e_2 :
                               @eq.{v₁+1}
                                 (@category_theory.has_hom.hom.{v₁ u₁} C
                                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                    (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                                    (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                                 a_2
                                 a_3),
                               @congr.{v₁+1 1}
                                 (@category_theory.has_hom.hom.{v₁ u₁} C
                                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                    (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                                    (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                                 Prop
                                 (@eq.{v₁+1}
                                    (@category_theory.has_hom.hom.{v₁ u₁} C
                                       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                                       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                                    a)
                                 (@eq.{v₁+1}
                                    (@category_theory.has_hom.hom.{v₁ u₁} C
                                       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                                       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                                    a_1)
                                 a_2
                                 a_3
                                 (@congr_arg.{v₁+1 (max (v₁+1) 1)}
                                    (@category_theory.has_hom.hom.{v₁ u₁} C
                                       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                                       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                                    (@category_theory.has_hom.hom.{v₁ u₁} C
                                       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                                       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X) →
                                     Prop)
                                    a
                                    a_1
                                    (@eq.{v₁+1}
                                       (@category_theory.has_hom.hom.{v₁ u₁} C
                                          (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                                          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)))
                                    e_1)
                                 e_2)
                              (@category_theory.category_struct.comp.{v₁ u₁} C
                                 (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                 (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                                 (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                    (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                                 (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                                 (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                    (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                                    T
                                    (@category_theory.monad.η.{v₁ u₁} C 𝒞 T _inst_1)
                                    (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                                 (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                    (@category_theory.functor.comp.{v₁ v₁ v₁ u₁ u₁ u₁} C 𝒞 C 𝒞 C 𝒞
                                       T
                                       T)
                                    T
                                    (@category_theory.monad.μ.{v₁ u₁} C 𝒞 T _inst_1)
                                    X))
                              (@category_theory.category_struct.id.{v₁ u₁} C
                                 (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                 (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                              (@category_theory.monad.left_unit.{v₁ u₁} C 𝒞 T _inst_1 X)
                              (@category_theory.category_struct.id.{v₁ u₁} C
                                 (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                 (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                              (@category_theory.category_struct.id.{v₁ u₁} C
                                 (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                 (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                              (@eq.refl.{v₁+1}
                                 (@category_theory.has_hom.hom.{v₁ u₁} C
                                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                    (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                                    (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                                 (@category_theory.category_struct.id.{v₁ u₁} C
                                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                    (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))))
                           (@propext
                              (@eq.{v₁+1}
                                 (@category_theory.has_hom.hom.{v₁ u₁} C
                                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                    (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                                    (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                                 (@category_theory.category_struct.id.{v₁ u₁} C
                                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                    (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                                 (@category_theory.category_struct.id.{v₁ u₁} C
                                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                    (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)))
                              true
                              (@eq_self_iff_true.{v₁+1}
                                 (@category_theory.has_hom.hom.{v₁ u₁} C
                                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                    (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                                    (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                                 (@category_theory.category_struct.id.{v₁ u₁} C
                                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                    (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))))))
                     trivial)
                Y)
             (@eq.symm.{v₁+1}
                (@category_theory.has_hom.hom.{v₁ u₁} C
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                   (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                      (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T Y)))
                   (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T Y))
                (@category_theory.category_struct.comp.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                   (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                      (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T Y)))
                   (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                      (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T Y))
                   (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T Y)
                   (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                      (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T Y))
                      (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T Y)
                      (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                         (@category_theory.functor.comp.{v₁ v₁ v₁ u₁ u₁ u₁} C 𝒞 C 𝒞 C 𝒞 T T)
                         T
                         (@category_theory.monad.μ.{v₁ u₁} C 𝒞 T _inst_1)
                         Y))
                   (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                      (@category_theory.functor.comp.{v₁ v₁ v₁ u₁ u₁ u₁} C 𝒞 C 𝒞 C 𝒞 T T)
                      T
                      (@category_theory.monad.μ.{v₁ u₁} C 𝒞 T _inst_1)
                      Y))
                (@category_theory.category_struct.comp.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                   (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                      (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T Y)))
                   (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                      (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T Y))
                   (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T Y)
                   (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                      (@category_theory.functor.comp.{v₁ v₁ v₁ u₁ u₁ u₁} C 𝒞 C 𝒞 C 𝒞 T T)
                      T
                      (@category_theory.monad.μ.{v₁ u₁} C 𝒞 T _inst_1)
                      (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T Y))
                   (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 (… 𝒞 C 𝒞 T T) T … Y))
                …))))
    …
    …'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 85  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 86  /-- The adjunction between the free and forgetful constructions for Eilenberg-Moore algebras for a monad.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 87      cf Lemma 5.2.8 of [Riehl][riehl2017]. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 88  def adj : free T ⊣ forget T :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 89  adjunction.mk_of_hom_equiv</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 90  { hom_equiv := λ X Y,</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 91    { to_fun := λ f, (η_ T).app X ≫ f.f,</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 92      inv_fun := λ f,</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 93      { f := T.map f ≫ Y.a,</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 94        h&#x27; :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 95        begin</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 96          dsimp, simp,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1239, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='`dsimp` is similar to `simp`, except that it only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 97          conv { to_rhs, rw [←category.assoc, ←(μ_ T).naturality, category.assoc], erw algebra.assoc },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='blue'><a title='category_theory.category.assoc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='category_theory.monad.μ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='T'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='category_theory.category.assoc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='category_theory.monad.algebra.assoc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 68, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/monad/basic.lean&#x27;, &#x27;line&#x27;: 16, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/converter/interactive.lean&#x27;, &#x27;line&#x27;: 102, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/converter/interactive.lean&#x27;, &#x27;line&#x27;: 102, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit name (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.ident)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) (lean.parser.pexpr std.prec.max))) → conv.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit name (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.ident)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) (lean.parser.pexpr std.prec.max))) → conv.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (obj : Type u₁) [c : category_theory.category.{v₁ u₁} obj] {W X Y Z : obj} (f : @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c)) W X) (g : @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c)) X Y) (h : @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c)) Y Z), @eq.{v₁+1} (@category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c)) W Z) (@category_theory.category_struct.comp.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c) W Y Z (@category_theory.category_struct.comp.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c) W X Y f g) h) (@category_theory.category_struct.comp.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c) W X Z f (@category_theory.category_struct.comp.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c) X Y Z g h))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] (T : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞) [c : @category_theory.monad.{v₁ u₁} C 𝒞 T], @category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁)} (@category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞) (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁)} (@category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞) (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁)} (@category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞) (@category_theory.functor.category.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞))) (@category_theory.functor.comp.{v₁ v₁ v₁ u₁ u₁ u₁} C 𝒞 C 𝒞 C 𝒞 T T) T'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (obj : Type u₁) [c : category_theory.category.{v₁ u₁} obj] {W X Y Z : obj} (f : @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c)) W X) (g : @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c)) X Y) (h : @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c)) Y Z), @eq.{v₁+1} (@category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c)) W Z) (@category_theory.category_struct.comp.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c) W Y Z (@category_theory.category_struct.comp.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c) W X Y f g) h) (@category_theory.category_struct.comp.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c) W X Z f (@category_theory.category_struct.comp.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c) X Y Z g h))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit name (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.ident)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) (lean.parser.pexpr std.prec.max))) → conv.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {T : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞} [_inst_1 : @category_theory.monad.{v₁ u₁} C 𝒞 T] (c : @category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1), @eq.{v₁+1} (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 c))) (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 c)) (@category_theory.category_struct.comp.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 c))) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 c)) (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 c) (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 (@category_theory.functor.comp.{v₁ v₁ v₁ u₁ u₁ u₁} C 𝒞 C 𝒞 C 𝒞 T T) T (@category_theory.monad.μ.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 c)) (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 c)) (@category_theory.category_struct.comp.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 c))) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 c)) (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 c) (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 c)) (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 c) (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 c)) (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit name (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.ident)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) (lean.parser.pexpr std.prec.max))) → conv.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='conv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='to_rhs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='conv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='conv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='conv'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;(at id)?&#x27;, &#x27;(in expr)?&#x27;, &#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;(at id)?&#x27;, &#x27;(in expr)?&#x27;, &#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;(at id)?&#x27;, &#x27;(in expr)?&#x27;, &#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;(at id)?&#x27;, &#x27;(in expr)?&#x27;, &#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
T : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞,
_inst_1 : @category_theory.monad.{v₁ u₁} C 𝒞 T,
X : C,
Y : @category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1,
f :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) u₁}
       (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
       (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
       C
       𝒞
       (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)
       Y)
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)))
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
       (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
          (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X
             (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
             f))
       (@category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)))
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
          (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
             (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
             (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 Y))
          (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 Y)))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
       (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
          (@category_theory.functor.comp.{v₁ v₁ v₁ u₁ u₁ u₁} C 𝒞 C 𝒞 C 𝒞 T T)
          T
          (@category_theory.monad.μ.{v₁ u₁} C 𝒞 T _inst_1)
          X)
       (@category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
          (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X
             (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
             f)
          (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 Y)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
T : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞,
_inst_1 : @category_theory.monad.{v₁ u₁} C 𝒞 T,
X : C,
Y : @category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1,
f :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) u₁}
       (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
       (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
       C
       𝒞
       (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)
       Y)
| @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)))
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
       (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
          (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X
             (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
             f))
       (@category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)))
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
          (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
             (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
             (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 Y))
          (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 Y)))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
       (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
          (@category_theory.functor.comp.{v₁ v₁ v₁ u₁ u₁ u₁} C 𝒞 C 𝒞 C 𝒞 T T)
          T
          (@category_theory.monad.μ.{v₁ u₁} C 𝒞 T _inst_1)
          X)
       (@category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
          (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X
             (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
             f)
          (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 Y)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
T : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞,
_inst_1 : @category_theory.monad.{v₁ u₁} C 𝒞 T,
X : C,
Y : @category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1,
f :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) u₁}
       (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
       (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
       C
       𝒞
       (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)
       Y)
| @category_theory.category_struct.comp.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
    (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
    (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
    (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
    (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
       (@category_theory.functor.comp.{v₁ v₁ v₁ u₁ u₁ u₁} C 𝒞 C 𝒞 C 𝒞 T T)
       T
       (@category_theory.monad.μ.{v₁ u₁} C 𝒞 T _inst_1)
       X)
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
       (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
          f)
       (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 Y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
T : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞,
_inst_1 : @category_theory.monad.{v₁ u₁} C 𝒞 T,
X : C,
Y : @category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1,
f :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) u₁}
       (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
       (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
       C
       𝒞
       (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)
       Y)
| @category_theory.category_struct.comp.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
    (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
    (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
    (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
       (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
          (@category_theory.functor.comp.{v₁ v₁ v₁ u₁ u₁ u₁} C 𝒞 C 𝒞 C 𝒞 T T)
          T
          (@category_theory.monad.μ.{v₁ u₁} C 𝒞 T _inst_1)
          X)
       (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
          f))
    (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
T : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞,
_inst_1 : @category_theory.monad.{v₁ u₁} C 𝒞 T,
X : C,
Y : @category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1,
f :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) u₁}
       (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
       (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
       C
       𝒞
       (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)
       Y)
| @category_theory.category_struct.comp.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
    (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
    (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
    (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
          (@category_theory.functor.comp.{v₁ v₁ v₁ u₁ u₁ u₁} C 𝒞 C 𝒞 C 𝒞 T T)
          X)
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
          (@category_theory.functor.comp.{v₁ v₁ v₁ u₁ u₁ u₁} C 𝒞 C 𝒞 C 𝒞 T T)
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
       (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
          (@category_theory.functor.comp.{v₁ v₁ v₁ u₁ u₁ u₁} C 𝒞 C 𝒞 C 𝒞 T T)
          X
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
          f)
       (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
          (@category_theory.functor.comp.{v₁ v₁ v₁ u₁ u₁ u₁} C 𝒞 C 𝒞 C 𝒞 T T)
          T
          (@category_theory.monad.μ.{v₁ u₁} C 𝒞 T _inst_1)
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)))
    (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
T : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞,
_inst_1 : @category_theory.monad.{v₁ u₁} C 𝒞 T,
X : C,
Y : @category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1,
f :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) u₁}
       (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
       (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
       C
       𝒞
       (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)
       Y)
| @category_theory.category_struct.comp.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
    (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
    (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
       (@category_theory.functor.comp.{v₁ v₁ v₁ u₁ u₁ u₁} C 𝒞 C 𝒞 C 𝒞 T T)
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
    (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
    (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
       (@category_theory.functor.comp.{v₁ v₁ v₁ u₁ u₁ u₁} C 𝒞 C 𝒞 C 𝒞 T T)
       X
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
       f)
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
          (@category_theory.functor.comp.{v₁ v₁ v₁ u₁ u₁ u₁} C 𝒞 C 𝒞 C 𝒞 T T)
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
       (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
          (@category_theory.functor.comp.{v₁ v₁ v₁ u₁ u₁ u₁} C 𝒞 C 𝒞 C 𝒞 T T)
          T
          (@category_theory.monad.μ.{v₁ u₁} C 𝒞 T _inst_1)
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
       (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 Y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
T : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞,
_inst_1 : @category_theory.monad.{v₁ u₁} C 𝒞 T,
X : C,
Y : @category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1,
f :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) u₁}
       (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
       (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
       C
       𝒞
       (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)
       Y)
| @category_theory.category_struct.comp.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
    (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
    (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
       (@category_theory.functor.comp.{v₁ v₁ v₁ u₁ u₁ u₁} C 𝒞 C 𝒞 C 𝒞 T T)
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
    (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
    (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
       (@category_theory.functor.comp.{v₁ v₁ v₁ u₁ u₁ u₁} C 𝒞 C 𝒞 C 𝒞 T T)
       X
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
       f)
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
       (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
          (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 Y))
       (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 Y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
T : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞,
_inst_1 : @category_theory.monad.{v₁ u₁} C 𝒞 T,
X : C,
Y : @category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1,
f :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) u₁}
       (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
       (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
       C
       𝒞
       (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)
       Y)
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)))
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
       (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
          (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X
             (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
             f))
       (@category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)))
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
          (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
             (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
             (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 Y))
          (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 Y)))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
          (@category_theory.functor.comp.{v₁ v₁ v₁ u₁ u₁ u₁} C 𝒞 C 𝒞 C 𝒞 T T)
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
       (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
          (@category_theory.functor.comp.{v₁ v₁ v₁ u₁ u₁ u₁} C 𝒞 C 𝒞 C 𝒞 T T)
          X
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
          f)
       (@category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)))
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
          (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
             (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
             (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 Y))
          (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 Y)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 98          refl,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1263, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='Shorter name for the tactic `reflexivity`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
T : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞,
_inst_1 : @category_theory.monad.{v₁ u₁} C 𝒞 T,
X : C,
Y : @category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1,
f :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) u₁}
       (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
       (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
       C
       𝒞
       (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)
       Y)
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)))
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
       (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
          (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X
             (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
             f))
       (@category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)))
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
          (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
             (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
             (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 Y))
          (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 Y)))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
          (@category_theory.functor.comp.{v₁ v₁ v₁ u₁ u₁ u₁} C 𝒞 C 𝒞 C 𝒞 T T)
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
       (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
          (@category_theory.functor.comp.{v₁ v₁ v₁ u₁ u₁ u₁} C 𝒞 C 𝒞 C 𝒞 T T)
          X
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
          f)
       (@category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)))
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
          (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
             (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
             (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 Y))
          (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 Y)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 99        end },</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>100      left_inv := λ f,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='green'><a title='@category_theory.has_hom.hom.{v₁ (max u₁ v₁)} (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.category_struct.to_has_hom.{v₁ (max u₁ v₁)} (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.category.to_category_struct.{v₁ (max u₁ v₁)} (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1))) (@category_theory.functor.obj.{v₁ v₁ u₁ (max u₁ v₁)} C 𝒞 (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.free.{v₁ u₁} C 𝒞 T _inst_1) X) Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>101      begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
T : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞,
_inst_1 : @category_theory.monad.{v₁ u₁} C 𝒞 T,
X : C,
Y : @category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1,
f :
  @category_theory.has_hom.hom.{v₁ (max u₁ v₁)} (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
    (@category_theory.category_struct.to_has_hom.{v₁ (max u₁ v₁)}
       (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
       (@category_theory.category.to_category_struct.{v₁ (max u₁ v₁)}
          (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
          (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)))
    (@category_theory.functor.obj.{v₁ v₁ u₁ (max u₁ v₁)} C 𝒞
       (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
       (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
       (@category_theory.monad.free.{v₁ u₁} C 𝒞 T _inst_1)
       X)
    Y
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ (max u₁ v₁)} (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
       (@category_theory.category_struct.to_has_hom.{v₁ (max u₁ v₁)}
          (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
          (@category_theory.category.to_category_struct.{v₁ (max u₁ v₁)}
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)))
       (@category_theory.functor.obj.{v₁ v₁ u₁ (max u₁ v₁)} C 𝒞
          (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
          (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
          (@category_theory.monad.free.{v₁ u₁} C 𝒞 T _inst_1)
          X)
       Y)
    ((λ
      (f :
        @category_theory.has_hom.hom.{v₁ u₁} C
          (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
          X
          (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) u₁}
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             C
             𝒞
             (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)
             Y)),
        @category_theory.monad.algebra.hom.mk.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.functor.obj.{v₁ v₁ u₁ (max u₁ v₁)} C 𝒞
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.free.{v₁ u₁} C 𝒞 T _inst_1)
             X)
          Y
          (@category_theory.category_struct.comp.{v₁ u₁} C
             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
             (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                (@category_theory.functor.obj.{v₁ v₁ u₁ (max u₁ v₁)} C 𝒞
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.free.{v₁ u₁} C 𝒞 T _inst_1)
                   X))
             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) u₁}
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)
                   Y))
             (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
             (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X
                (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) u₁}
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)
                   Y)
                f)
             (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 Y))
          (@id.{0}
             (@eq.{v₁+1}
                (@category_theory.has_hom.hom.{v₁ u₁} C
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                   (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                      (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                         (@category_theory.functor.obj.{v₁ v₁ u₁ (max u₁ v₁)} C 𝒞
                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                            (@category_theory.monad.free.{v₁ u₁} C 𝒞 T _inst_1)
                            X)))
                   (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                (@category_theory.category_struct.comp.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                   (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                      (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                         (@category_theory.functor.obj.{v₁ v₁ u₁ (max u₁ v₁)} C 𝒞
                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                            (@category_theory.monad.free.{v₁ u₁} C 𝒞 T _inst_1)
                            X)))
                   (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                      (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                   (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                   (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                      (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                         (@category_theory.functor.obj.{v₁ v₁ u₁ (max u₁ v₁)} C 𝒞
                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                            (@category_theory.monad.free.{v₁ u₁} C 𝒞 T _inst_1)
                            X))
                      (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                      (@category_theory.category_struct.comp.{v₁ u₁} C
                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                         (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                            (@category_theory.functor.obj.{v₁ v₁ u₁ (max u₁ v₁)} C 𝒞
                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                               (@category_theory.monad.free.{v₁ u₁} C 𝒞 T _inst_1)
                               X))
                         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                            (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) u₁}
                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                               C
                               𝒞
                               (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)
                               Y))
                         (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                         (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X
                            (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) u₁}
                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                               C
                               𝒞
                               (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)
                               Y)
                            f)
                         (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 Y)))
                   (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 Y))
                (@category_theory.category_struct.comp.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                   (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                      (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                         (@category_theory.functor.obj.{v₁ v₁ u₁ (max u₁ v₁)} C 𝒞
                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                            (@category_theory.monad.free.{v₁ u₁} C 𝒞 T _inst_1)
                            X)))
                   (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                      (@category_theory.functor.obj.{v₁ v₁ u₁ (max u₁ v₁)} C 𝒞
                         (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                         (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                         (@category_theory.monad.free.{v₁ u₁} C 𝒞 T _inst_1)
                         X))
                   (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                   (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
                      (@category_theory.functor.obj.{v₁ v₁ u₁ (max u₁ v₁)} C 𝒞
                         (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                         (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                         (@category_theory.monad.free.{v₁ u₁} C 𝒞 T _inst_1)
                         X))
                   (@category_theory.category_struct.comp.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                      (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                         (@category_theory.functor.obj.{v₁ v₁ u₁ (max u₁ v₁)} C 𝒞
                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                            (@category_theory.monad.free.{v₁ u₁} C 𝒞 T _inst_1)
                            X))
                      (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                         (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) u₁}
                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                            C
                            𝒞
                            (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)
                            Y))
                      (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                      (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X
                         (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) u₁}
                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                            C
                            𝒞
                            (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)
                            Y)
                         f)
                      (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 Y))))
             (@eq.mpr.{0}
                (@eq.{v₁+1}
                   (@category_theory.has_hom.hom.{v₁ u₁} C
                      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                      (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                      (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                   (@category_theory.category_struct.comp.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                      (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                      (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                         (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                      (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                      (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                         (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                         (@category_theory.category_struct.comp.{v₁ u₁} C
                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                               (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                            (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                            (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X
                               (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                               f)
                            (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 Y)))
                      (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 Y))
                   (@category_theory.category_struct.comp.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                      (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                      (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                      (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                      (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                         (@category_theory.functor.comp.{v₁ v₁ v₁ u₁ u₁ u₁} C 𝒞 C 𝒞 C 𝒞 T T)
                         T
                         (@category_theory.monad.μ.{v₁ u₁} C 𝒞 T _inst_1)
                         X)
                      (@category_theory.category_struct.comp.{v₁ u₁} C
                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                            (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                         (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                         (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X
                            (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                            f)
                         (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 Y))))
                (@eq.{v₁+1}
                   (@category_theory.has_hom.hom.{v₁ u₁} C
                      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                      (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                      (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                   (@category_theory.category_struct.comp.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                      (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                      (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                            (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)))
                      (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                      (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                            (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                         (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X
                            (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                            f))
                      (@category_theory.category_struct.comp.{v₁ u₁} C
                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                               (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)))
                         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                            (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                         (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                         (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                               (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                            (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                            (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 Y))
                         (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 Y)))
                   (@category_theory.category_struct.comp.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                      (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                      (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                      (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                      (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                         (@category_theory.functor.comp.{v₁ v₁ v₁ u₁ u₁ u₁} C 𝒞 C 𝒞 C 𝒞 T T)
                         T
                         (@category_theory.monad.μ.{v₁ u₁} C 𝒞 T _inst_1)
                         X)
                      (@category_theory.category_struct.comp.{v₁ u₁} C
                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                            (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                         (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                         (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X
                            (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                            f)
                         (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 Y))))
                (@id.{0}
                   (@eq.{1} Prop
                      (@eq.{v₁+1}
                         (@category_theory.has_hom.hom.{v₁ u₁} C
                            (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                            (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                         (@category_theory.category_struct.comp.{v₁ u₁} C
                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                               (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                            (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                            (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                               (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                               (@category_theory.category_struct.comp.{v₁ u₁} C
                                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                     (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                                  (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                                  (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X
                                     (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                                     f)
                                  (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 Y)))
                            (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 Y))
                         (@category_theory.category_struct.comp.{v₁ u₁} C
                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                            (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                            (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                               (@category_theory.functor.comp.{v₁ v₁ v₁ u₁ u₁ u₁} C 𝒞 C 𝒞 C 𝒞 T T)
                               T
                               (@category_theory.monad.μ.{v₁ u₁} C 𝒞 T _inst_1)
                               X)
                            (@category_theory.category_struct.comp.{v₁ u₁} C
                               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                  (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                               (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                               (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X
                                  (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                                  f)
                               (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 Y))))
                      (@eq.{v₁+1}
                         (@category_theory.has_hom.hom.{v₁ u₁} C
                            (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                            (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                         (@category_theory.category_struct.comp.{v₁ u₁} C
                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                  (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)))
                            (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                            (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                  (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                               (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X
                                  (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                                  f))
                            (@category_theory.category_struct.comp.{v₁ u₁} C
                               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                     (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)))
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                  (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                               (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                               (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                     (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                                  (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                                  (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 Y))
                               (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 Y)))
                         (@category_theory.category_struct.comp.{v₁ u₁} C
                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                            (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                            (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                               (@category_theory.functor.comp.{v₁ v₁ v₁ u₁ u₁ u₁} C 𝒞 C 𝒞 C 𝒞 T T)
                               T
                               (@category_theory.monad.μ.{v₁ u₁} C 𝒞 T _inst_1)
                               X)
                            (@category_theory.category_struct.comp.{v₁ u₁} C
                               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                  (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                               (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                               (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X
                                  (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                                  f)
                               (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 Y)))))
                   ((λ
                     (a a_1 :
                       @category_theory.has_hom.hom.{v₁ u₁} C
                         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                         (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                     (e_1 :
                       @eq.{v₁+1}
                         (@category_theory.has_hom.hom.{v₁ u₁} C
                            (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                            (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                         a
                         a_1)
                     (a_2 a_3 :
                       @category_theory.has_hom.hom.{v₁ u₁} C
                         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                         (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                     (e_2 :
                       @eq.{v₁+1}
                         (@category_theory.has_hom.hom.{v₁ u₁} C
                            (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                            (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                         a_2
                         a_3),
                       @congr.{v₁+1 1}
                         (@category_theory.has_hom.hom.{v₁ u₁} C
                            (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                            (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                         Prop
                         (@eq.{v₁+1}
                            (@category_theory.has_hom.hom.{v₁ u₁} C
                               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                               (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                            a)
                         (@eq.{v₁+1}
                            (@category_theory.has_hom.hom.{v₁ u₁} C
                               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                               (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                            a_1)
                         a_2
                         a_3
                         (@congr_arg.{v₁+1 (max (v₁+1) 1)}
                            (@category_theory.has_hom.hom.{v₁ u₁} C
                               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                               (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                            (@category_theory.has_hom.hom.{v₁ u₁} C
                               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                               (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y) →
                             Prop)
                            a
                            a_1
                            (@eq.{v₁+1}
                               (@category_theory.has_hom.hom.{v₁ u₁} C
                                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                     (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                                  (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)))
                            e_1)
                         e_2)
                      (@category_theory.category_struct.comp.{v₁ u₁} C
                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                            (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                         (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                         (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                            (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                            (@category_theory.category_struct.comp.{v₁ u₁} C
                               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                  (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                               (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                               (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X
                                  (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                                  f)
                               (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 Y)))
                         (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 Y))
                      (@category_theory.category_struct.comp.{v₁ u₁} C
                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                               (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)))
                         (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                         (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                               (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                            (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X
                               (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                               f))
                         (@category_theory.category_struct.comp.{v₁ u₁} C
                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                  (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)))
                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                               (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                            (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                            (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                  (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                               (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                               (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 Y))
                            (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 Y)))
                      (@eq.trans.{v₁+1}
                         (@category_theory.has_hom.hom.{v₁ u₁} C
                            (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                            (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                         (@category_theory.category_struct.comp.{v₁ u₁} C
                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                               (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                            (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                            (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                               (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                               (@category_theory.category_struct.comp.{v₁ u₁} C
                                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                     (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                                  (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                                  (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X
                                     (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                                     f)
                                  (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 Y)))
                            (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 Y))
                         (@category_theory.category_struct.comp.{v₁ u₁} C
                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                               (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                            (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                            (@category_theory.category_struct.comp.{v₁ u₁} C
                               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                     (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)))
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                  (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                               (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                     (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                                  (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X
                                     (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                                     f))
                               (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                     (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                                  (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                                  …))
                            …)
                         …
                         …
                         …)
                      …
                      …
                      …))
                …)))
       …)
    f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>102        ext1, dsimp,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/ext.lean&#x27;, &#x27;line&#x27;: 312, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1239, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse tactic.ext_patt (λ (a : tactic.ext_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) tactic.ext_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='`ext1 id` selects and apply one extensionality lemma (with attribute
`ext`), using `id`, if provided, to name a local constant
introduced by the lemma. If `id` is omitted, the local constant is
named automatically, as per `intro`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`dsimp` is similar to `simp`, except that it only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='ext1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;((patt) | patt_list)*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
T : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞,
_inst_1 : @category_theory.monad.{v₁ u₁} C 𝒞 T,
X : C,
Y : @category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1,
f :
  @category_theory.has_hom.hom.{v₁ (max u₁ v₁)} (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
    (@category_theory.category_struct.to_has_hom.{v₁ (max u₁ v₁)}
       (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
       (@category_theory.category.to_category_struct.{v₁ (max u₁ v₁)}
          (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
          (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)))
    (@category_theory.functor.obj.{v₁ v₁ u₁ (max u₁ v₁)} C 𝒞
       (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
       (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
       (@category_theory.monad.free.{v₁ u₁} C 𝒞 T _inst_1)
       X)
    Y
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ (max u₁ v₁)} (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
       (@category_theory.category_struct.to_has_hom.{v₁ (max u₁ v₁)}
          (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
          (@category_theory.category.to_category_struct.{v₁ (max u₁ v₁)}
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)))
       (@category_theory.functor.obj.{v₁ v₁ u₁ (max u₁ v₁)} C 𝒞
          (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
          (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
          (@category_theory.monad.free.{v₁ u₁} C 𝒞 T _inst_1)
          X)
       Y)
    ((λ
      (f :
        @category_theory.has_hom.hom.{v₁ u₁} C
          (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
          X
          (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) u₁}
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             C
             𝒞
             (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)
             Y)),
        @category_theory.monad.algebra.hom.mk.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.functor.obj.{v₁ v₁ u₁ (max u₁ v₁)} C 𝒞
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.free.{v₁ u₁} C 𝒞 T _inst_1)
             X)
          Y
          (@category_theory.category_struct.comp.{v₁ u₁} C
             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
             (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                (@category_theory.functor.obj.{v₁ v₁ u₁ (max u₁ v₁)} C 𝒞
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.free.{v₁ u₁} C 𝒞 T _inst_1)
                   X))
             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) u₁}
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)
                   Y))
             (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
             (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X
                (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) u₁}
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   C
                   𝒞
                   (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)
                   Y)
                f)
             (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 Y))
          (@id.{0}
             (@eq.{v₁+1}
                (@category_theory.has_hom.hom.{v₁ u₁} C
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                   (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                      (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                         (@category_theory.functor.obj.{v₁ v₁ u₁ (max u₁ v₁)} C 𝒞
                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                            (@category_theory.monad.free.{v₁ u₁} C 𝒞 T _inst_1)
                            X)))
                   (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                (@category_theory.category_struct.comp.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                   (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                      (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                         (@category_theory.functor.obj.{v₁ v₁ u₁ (max u₁ v₁)} C 𝒞
                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                            (@category_theory.monad.free.{v₁ u₁} C 𝒞 T _inst_1)
                            X)))
                   (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                      (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                   (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                   (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                      (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                         (@category_theory.functor.obj.{v₁ v₁ u₁ (max u₁ v₁)} C 𝒞
                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                            (@category_theory.monad.free.{v₁ u₁} C 𝒞 T _inst_1)
                            X))
                      (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                      (@category_theory.category_struct.comp.{v₁ u₁} C
                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                         (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                            (@category_theory.functor.obj.{v₁ v₁ u₁ (max u₁ v₁)} C 𝒞
                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                               (@category_theory.monad.free.{v₁ u₁} C 𝒞 T _inst_1)
                               X))
                         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                            (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) u₁}
                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                               C
                               𝒞
                               (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)
                               Y))
                         (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                         (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X
                            (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) u₁}
                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                               C
                               𝒞
                               (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)
                               Y)
                            f)
                         (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 Y)))
                   (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 Y))
                (@category_theory.category_struct.comp.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                   (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                      (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                         (@category_theory.functor.obj.{v₁ v₁ u₁ (max u₁ v₁)} C 𝒞
                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                            (@category_theory.monad.free.{v₁ u₁} C 𝒞 T _inst_1)
                            X)))
                   (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                      (@category_theory.functor.obj.{v₁ v₁ u₁ (max u₁ v₁)} C 𝒞
                         (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                         (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                         (@category_theory.monad.free.{v₁ u₁} C 𝒞 T _inst_1)
                         X))
                   (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                   (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
                      (@category_theory.functor.obj.{v₁ v₁ u₁ (max u₁ v₁)} C 𝒞
                         (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                         (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                         (@category_theory.monad.free.{v₁ u₁} C 𝒞 T _inst_1)
                         X))
                   (@category_theory.category_struct.comp.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                      (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                         (@category_theory.functor.obj.{v₁ v₁ u₁ (max u₁ v₁)} C 𝒞
                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                            (@category_theory.monad.free.{v₁ u₁} C 𝒞 T _inst_1)
                            X))
                      (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                         (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) u₁}
                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                            C
                            𝒞
                            (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)
                            Y))
                      (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                      (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X
                         (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) u₁}
                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                            C
                            𝒞
                            (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)
                            Y)
                         f)
                      (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 Y))))
             (@eq.mpr.{0}
                (@eq.{v₁+1}
                   (@category_theory.has_hom.hom.{v₁ u₁} C
                      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                      (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                      (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                   (@category_theory.category_struct.comp.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                      (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                      (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                         (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                      (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                      (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                         (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                         (@category_theory.category_struct.comp.{v₁ u₁} C
                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                               (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                            (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                            (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X
                               (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                               f)
                            (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 Y)))
                      (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 Y))
                   (@category_theory.category_struct.comp.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                      (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                      (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                      (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                      (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                         (@category_theory.functor.comp.{v₁ v₁ v₁ u₁ u₁ u₁} C 𝒞 C 𝒞 C 𝒞 T T)
                         T
                         (@category_theory.monad.μ.{v₁ u₁} C 𝒞 T _inst_1)
                         X)
                      (@category_theory.category_struct.comp.{v₁ u₁} C
                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                            (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                         (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                         (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X
                            (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                            f)
                         (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 Y))))
                (@eq.{v₁+1}
                   (@category_theory.has_hom.hom.{v₁ u₁} C
                      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                      (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                      (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                   (@category_theory.category_struct.comp.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                      (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                      (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                            (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)))
                      (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                      (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                            (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                         (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X
                            (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                            f))
                      (@category_theory.category_struct.comp.{v₁ u₁} C
                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                               (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)))
                         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                            (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                         (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                         (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                               (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                            (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                            (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 Y))
                         (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 Y)))
                   (@category_theory.category_struct.comp.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                      (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                      (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                      (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                      (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                         (@category_theory.functor.comp.{v₁ v₁ v₁ u₁ u₁ u₁} C 𝒞 C 𝒞 C 𝒞 T T)
                         T
                         (@category_theory.monad.μ.{v₁ u₁} C 𝒞 T _inst_1)
                         X)
                      (@category_theory.category_struct.comp.{v₁ u₁} C
                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                            (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                         (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                         (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X
                            (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                            f)
                         (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 Y))))
                (@id.{0}
                   (@eq.{1} Prop
                      (@eq.{v₁+1}
                         (@category_theory.has_hom.hom.{v₁ u₁} C
                            (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                            (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                         (@category_theory.category_struct.comp.{v₁ u₁} C
                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                               (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                            (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                            (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                               (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                               (@category_theory.category_struct.comp.{v₁ u₁} C
                                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                     (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                                  (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                                  (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X
                                     (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                                     f)
                                  (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 Y)))
                            (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 Y))
                         (@category_theory.category_struct.comp.{v₁ u₁} C
                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                            (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                            (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                               (@category_theory.functor.comp.{v₁ v₁ v₁ u₁ u₁ u₁} C 𝒞 C 𝒞 C 𝒞 T T)
                               T
                               (@category_theory.monad.μ.{v₁ u₁} C 𝒞 T _inst_1)
                               X)
                            (@category_theory.category_struct.comp.{v₁ u₁} C
                               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                  (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                               (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                               (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X
                                  (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                                  f)
                               (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 Y))))
                      (@eq.{v₁+1}
                         (@category_theory.has_hom.hom.{v₁ u₁} C
                            (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                            (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                         (@category_theory.category_struct.comp.{v₁ u₁} C
                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                  (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)))
                            (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                            (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                  (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                               (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X
                                  (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                                  f))
                            (@category_theory.category_struct.comp.{v₁ u₁} C
                               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                     (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)))
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                  (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                               (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                               (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                     (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                                  (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                                  (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 Y))
                               (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 Y)))
                         (@category_theory.category_struct.comp.{v₁ u₁} C
                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                            (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                            (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                               (@category_theory.functor.comp.{v₁ v₁ v₁ u₁ u₁ u₁} C 𝒞 C 𝒞 C 𝒞 T T)
                               T
                               (@category_theory.monad.μ.{v₁ u₁} C 𝒞 T _inst_1)
                               X)
                            (@category_theory.category_struct.comp.{v₁ u₁} C
                               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                  (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                               (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                               (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X
                                  (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                                  f)
                               (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 Y)))))
                   ((λ
                     (a a_1 :
                       @category_theory.has_hom.hom.{v₁ u₁} C
                         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                         (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                     (e_1 :
                       @eq.{v₁+1}
                         (@category_theory.has_hom.hom.{v₁ u₁} C
                            (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                            (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                         a
                         a_1)
                     (a_2 a_3 :
                       @category_theory.has_hom.hom.{v₁ u₁} C
                         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                         (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                     (e_2 :
                       @eq.{v₁+1}
                         (@category_theory.has_hom.hom.{v₁ u₁} C
                            (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                            (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                         a_2
                         a_3),
                       @congr.{v₁+1 1}
                         (@category_theory.has_hom.hom.{v₁ u₁} C
                            (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                            (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                         Prop
                         (@eq.{v₁+1}
                            (@category_theory.has_hom.hom.{v₁ u₁} C
                               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                               (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                            a)
                         (@eq.{v₁+1}
                            (@category_theory.has_hom.hom.{v₁ u₁} C
                               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                               (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                            a_1)
                         a_2
                         a_3
                         (@congr_arg.{v₁+1 (max (v₁+1) 1)}
                            (@category_theory.has_hom.hom.{v₁ u₁} C
                               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                               (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                            (@category_theory.has_hom.hom.{v₁ u₁} C
                               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                               (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y) →
                             Prop)
                            a
                            a_1
                            (@eq.{v₁+1}
                               (@category_theory.has_hom.hom.{v₁ u₁} C
                                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                     (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                                  (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)))
                            e_1)
                         e_2)
                      (@category_theory.category_struct.comp.{v₁ u₁} C
                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                            (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                         (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                         (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                            (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                            (@category_theory.category_struct.comp.{v₁ u₁} C
                               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                  (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                               (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                               (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X
                                  (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                                  f)
                               (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 Y)))
                         (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 Y))
                      (@category_theory.category_struct.comp.{v₁ u₁} C
                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                               (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)))
                         (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                         (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                               (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                            (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X
                               (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                               f))
                         (@category_theory.category_struct.comp.{v₁ u₁} C
                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                  (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)))
                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                               (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                            (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                            (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                  (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                               (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                               (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 Y))
                            (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 Y)))
                      (@eq.trans.{v₁+1}
                         (@category_theory.has_hom.hom.{v₁ u₁} C
                            (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                            (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                         (@category_theory.category_struct.comp.{v₁ u₁} C
                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                               (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                            (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                            (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                               (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                               (@category_theory.category_struct.comp.{v₁ u₁} C
                                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                     (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                                  (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                                  (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X
                                     (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                                     f)
                                  (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 Y)))
                            (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 Y))
                         (@category_theory.category_struct.comp.{v₁ u₁} C
                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                               (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                            (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                            (@category_theory.category_struct.comp.{v₁ u₁} C
                               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                     (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)))
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                  (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                               (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                     (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                                  (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X
                                     (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                                     f))
                               (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                     (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                                  (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                                  …))
                            …)
                         …
                         …
                         …)
                      …
                      …
                      …))
                …)))
       …)
    f'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
T : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞,
_inst_1 : @category_theory.monad.{v₁ u₁} C 𝒞 T,
X : C,
Y : @category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1,
f :
  @category_theory.has_hom.hom.{v₁ (max u₁ v₁)} (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
    (@category_theory.category_struct.to_has_hom.{v₁ (max u₁ v₁)}
       (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
       (@category_theory.category.to_category_struct.{v₁ (max u₁ v₁)}
          (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
          (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)))
    (@category_theory.functor.obj.{v₁ v₁ u₁ (max u₁ v₁)} C 𝒞
       (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
       (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
       (@category_theory.monad.free.{v₁ u₁} C 𝒞 T _inst_1)
       X)
    Y
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.functor.obj.{v₁ v₁ u₁ (max u₁ v₁)} C 𝒞
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.free.{v₁ u₁} C 𝒞 T _inst_1)
             X))
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
    (@category_theory.monad.algebra.hom.f.{v₁ u₁} C 𝒞 T _inst_1
       (@category_theory.functor.obj.{v₁ v₁ u₁ (max u₁ v₁)} C 𝒞
          (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
          (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
          (@category_theory.monad.free.{v₁ u₁} C 𝒞 T _inst_1)
          X)
       Y
       ((λ
         (f :
           @category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X
             (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) u₁}
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)
                Y)),
           @category_theory.monad.algebra.hom.mk.{v₁ u₁} C 𝒞 T _inst_1
             (@category_theory.functor.obj.{v₁ v₁ u₁ (max u₁ v₁)} C 𝒞
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.free.{v₁ u₁} C 𝒞 T _inst_1)
                X)
             Y
             (@category_theory.category_struct.comp.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                   (@category_theory.functor.obj.{v₁ v₁ u₁ (max u₁ v₁)} C 𝒞
                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                      (@category_theory.monad.free.{v₁ u₁} C 𝒞 T _inst_1)
                      X))
                (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                   (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) u₁}
                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                      C
                      𝒞
                      (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)
                      Y))
                (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X
                   (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) u₁}
                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                      C
                      𝒞
                      (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)
                      Y)
                   f)
                (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 Y))
             (@id.{0}
                (@eq.{v₁+1}
                   (@category_theory.has_hom.hom.{v₁ u₁} C
                      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                      (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                         (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                            (@category_theory.functor.obj.{v₁ v₁ u₁ (max u₁ v₁)} C 𝒞
                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                               (@category_theory.monad.free.{v₁ u₁} C 𝒞 T _inst_1)
                               X)))
                      (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                   (@category_theory.category_struct.comp.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                      (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                         (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                            (@category_theory.functor.obj.{v₁ v₁ u₁ (max u₁ v₁)} C 𝒞
                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                               (@category_theory.monad.free.{v₁ u₁} C 𝒞 T _inst_1)
                               X)))
                      (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                         (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                      (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                      (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                         (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                            (@category_theory.functor.obj.{v₁ v₁ u₁ (max u₁ v₁)} C 𝒞
                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                               (@category_theory.monad.free.{v₁ u₁} C 𝒞 T _inst_1)
                               X))
                         (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                         (@category_theory.category_struct.comp.{v₁ u₁} C
                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                            (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                               (@category_theory.functor.obj.{v₁ v₁ u₁ (max u₁ v₁)} C 𝒞
                                  (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                  (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                  (@category_theory.monad.free.{v₁ u₁} C 𝒞 T _inst_1)
                                  X))
                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                               (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) u₁}
                                  (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                  (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                  C
                                  𝒞
                                  (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)
                                  Y))
                            (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                            (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X
                               (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) u₁}
                                  (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                  (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                  C
                                  𝒞
                                  (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)
                                  Y)
                               f)
                            (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 Y)))
                      (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 Y))
                   (@category_theory.category_struct.comp.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                      (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                         (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                            (@category_theory.functor.obj.{v₁ v₁ u₁ (max u₁ v₁)} C 𝒞
                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                               (@category_theory.monad.free.{v₁ u₁} C 𝒞 T _inst_1)
                               X)))
                      (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                         (@category_theory.functor.obj.{v₁ v₁ u₁ (max u₁ v₁)} C 𝒞
                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                            (@category_theory.monad.free.{v₁ u₁} C 𝒞 T _inst_1)
                            X))
                      (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                      (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
                         (@category_theory.functor.obj.{v₁ v₁ u₁ (max u₁ v₁)} C 𝒞
                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                            (@category_theory.monad.free.{v₁ u₁} C 𝒞 T _inst_1)
                            X))
                      (@category_theory.category_struct.comp.{v₁ u₁} C
                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                         (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                            (@category_theory.functor.obj.{v₁ v₁ u₁ (max u₁ v₁)} C 𝒞
                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                               (@category_theory.monad.free.{v₁ u₁} C 𝒞 T _inst_1)
                               X))
                         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                            (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) u₁}
                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                               C
                               𝒞
                               (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)
                               Y))
                         (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                         (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X
                            (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) u₁}
                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                               C
                               𝒞
                               (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)
                               Y)
                            f)
                         (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 Y))))
                (@eq.mpr.{0}
                   (@eq.{v₁+1}
                      (@category_theory.has_hom.hom.{v₁ u₁} C
                         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                         (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                      (@category_theory.category_struct.comp.{v₁ u₁} C
                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                            (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                         (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                         (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                            (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                            (@category_theory.category_struct.comp.{v₁ u₁} C
                               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                  (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                               (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                               (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X
                                  (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                                  f)
                               (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 Y)))
                         (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 Y))
                      (@category_theory.category_struct.comp.{v₁ u₁} C
                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                         (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                         (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                            (@category_theory.functor.comp.{v₁ v₁ v₁ u₁ u₁ u₁} C 𝒞 C 𝒞 C 𝒞 T T)
                            T
                            (@category_theory.monad.μ.{v₁ u₁} C 𝒞 T _inst_1)
                            X)
                         (@category_theory.category_struct.comp.{v₁ u₁} C
                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                               (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                            (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                            (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X
                               (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                               f)
                            (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 Y))))
                   (@eq.{v₁+1}
                      (@category_theory.has_hom.hom.{v₁ u₁} C
                         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                         (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                      (@category_theory.category_struct.comp.{v₁ u₁} C
                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                               (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)))
                         (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                         (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                               (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                            (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X
                               (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                               f))
                         (@category_theory.category_struct.comp.{v₁ u₁} C
                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                  (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)))
                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                               (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                            (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                            (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                  (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                               (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                               (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 Y))
                            (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 Y)))
                      (@category_theory.category_struct.comp.{v₁ u₁} C
                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                         (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                         (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                            (@category_theory.functor.comp.{v₁ v₁ v₁ u₁ u₁ u₁} C 𝒞 C 𝒞 C 𝒞 T T)
                            T
                            (@category_theory.monad.μ.{v₁ u₁} C 𝒞 T _inst_1)
                            X)
                         (@category_theory.category_struct.comp.{v₁ u₁} C
                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                               (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                            (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                            (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X
                               (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                               f)
                            (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 Y))))
                   (@id.{0}
                      (@eq.{1} Prop
                         (@eq.{v₁+1}
                            (@category_theory.has_hom.hom.{v₁ u₁} C
                               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                               (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                            (@category_theory.category_struct.comp.{v₁ u₁} C
                               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                  (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                               (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                               (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                                  (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                                  (@category_theory.category_struct.comp.{v₁ u₁} C
                                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                     (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                                     (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                        (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                                     (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                                     (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X
                                        (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                                        f)
                                     (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 Y)))
                               (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 Y))
                            (@category_theory.category_struct.comp.{v₁ u₁} C
                               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                               (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                               (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                  (@category_theory.functor.comp.{v₁ v₁ v₁ u₁ u₁ u₁} C 𝒞 C 𝒞 C 𝒞 T
                                     T)
                                  T
                                  (@category_theory.monad.μ.{v₁ u₁} C 𝒞 T _inst_1)
                                  X)
                               (@category_theory.category_struct.comp.{v₁ u₁} C
                                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                     (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                                  (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                                  (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X
                                     (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                                     f)
                                  (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 Y))))
                         (@eq.{v₁+1}
                            (@category_theory.has_hom.hom.{v₁ u₁} C
                               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                               (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                            (@category_theory.category_struct.comp.{v₁ u₁} C
                               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                     (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)))
                               (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                               (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                     (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                                  (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X
                                     (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                                     f))
                               (@category_theory.category_struct.comp.{v₁ u₁} C
                                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                     (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                        (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)))
                                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                     (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                                  (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                                  (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                     (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                        (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                                     (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                                     (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 Y))
                                  (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 Y)))
                            (@category_theory.category_struct.comp.{v₁ u₁} C
                               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                               (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                               (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                  (@category_theory.functor.comp.{v₁ v₁ v₁ u₁ u₁ u₁} C 𝒞 C 𝒞 C 𝒞 T
                                     T)
                                  T
                                  (@category_theory.monad.μ.{v₁ u₁} C 𝒞 T _inst_1)
                                  X)
                               (@category_theory.category_struct.comp.{v₁ u₁} C
                                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                     (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                                  (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                                  (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X
                                     (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                                     f)
                                  (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 Y)))))
                      ((λ
                        (a a_1 :
                          @category_theory.has_hom.hom.{v₁ u₁} C
                            (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                            (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                        (e_1 :
                          @eq.{v₁+1}
                            (@category_theory.has_hom.hom.{v₁ u₁} C
                               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                               (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                            a
                            a_1)
                        (a_2 a_3 :
                          @category_theory.has_hom.hom.{v₁ u₁} C
                            (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                            (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                        (e_2 :
                          @eq.{v₁+1}
                            (@category_theory.has_hom.hom.{v₁ u₁} C
                               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                               (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                            a_2
                            a_3),
                          @congr.{v₁+1 1}
                            (@category_theory.has_hom.hom.{v₁ u₁} C
                               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                               (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                            Prop
                            (@eq.{v₁+1}
                               (@category_theory.has_hom.hom.{v₁ u₁} C
                                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                     (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                                  (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                               a)
                            (@eq.{v₁+1}
                               (@category_theory.has_hom.hom.{v₁ u₁} C
                                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                     (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                                  (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                               a_1)
                            a_2
                            a_3
                            (@congr_arg.{v₁+1 (max (v₁+1) 1)}
                               (@category_theory.has_hom.hom.{v₁ u₁} C
                                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                     (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                                  (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                               (@category_theory.has_hom.hom.{v₁ u₁} C
                                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                     (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                                  (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y) →
                                Prop)
                               a
                               a_1
                               (@eq.{v₁+1}
                                  (@category_theory.has_hom.hom.{v₁ u₁} C
                                     (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                     (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                        (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                                     (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)))
                               e_1)
                            e_2)
                         (@category_theory.category_struct.comp.{v₁ u₁} C
                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                               (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                            (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                            (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                               (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                               (@category_theory.category_struct.comp.{v₁ u₁} C
                                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                     (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                                  (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                                  (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X
                                     (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                                     f)
                                  (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 Y)))
                            (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 Y))
                         (@category_theory.category_struct.comp.{v₁ u₁} C
                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                  (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)))
                            (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                            (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                  (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                               (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X
                                  (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                                  f))
                            (@category_theory.category_struct.comp.{v₁ u₁} C
                               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                     (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)))
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                  (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                               (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                               (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                     (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                                  (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                                  (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 Y))
                               (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 Y)))
                         (@eq.trans.{v₁+1}
                            (@category_theory.has_hom.hom.{v₁ u₁} C
                               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                               (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                            (@category_theory.category_struct.comp.{v₁ u₁} C
                               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                  (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                               (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                               (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                                  (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                                  (@category_theory.category_struct.comp.{v₁ u₁} C
                                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                     (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                                     (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                        (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                                     (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                                     (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X
                                        (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                                        f)
                                     (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 Y)))
                               (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 Y))
                            (@category_theory.category_struct.comp.{v₁ u₁} C
                               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                  (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                               (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                               (@category_theory.category_struct.comp.{v₁ u₁} C
                                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                     (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                     (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                        (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)))
                                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                     (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                                  (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                     (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                                     (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                        (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                                     (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X
                                        (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                                        f))
                                  (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T … … …))
                               …)
                            …
                            …
                            …)
                         …
                         …
                         …))
                   …)))
          …))
    …'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
T : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞,
_inst_1 : @category_theory.monad.{v₁ u₁} C 𝒞 T,
X : C,
Y : @category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1,
f :
  @category_theory.has_hom.hom.{v₁ (max u₁ v₁)} (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
    (@category_theory.category_struct.to_has_hom.{v₁ (max u₁ v₁)}
       (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
       (@category_theory.category.to_category_struct.{v₁ (max u₁ v₁)}
          (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
          (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)))
    (@category_theory.functor.obj.{v₁ v₁ u₁ (max u₁ v₁)} C 𝒞
       (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
       (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
       (@category_theory.monad.free.{v₁ u₁} C 𝒞 T _inst_1)
       X)
    Y
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
       (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
          (@category_theory.category_struct.comp.{v₁ u₁} C
             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
             X
             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
             (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
             (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                T
                (@category_theory.monad.η.{v₁ u₁} C 𝒞 T _inst_1)
                X)
             (@category_theory.monad.algebra.hom.f.{v₁ u₁} C 𝒞 T _inst_1
                (@category_theory.functor.obj.{v₁ v₁ u₁ (max u₁ v₁)} C 𝒞
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.free.{v₁ u₁} C 𝒞 T _inst_1)
                   X)
                Y
                f)))
       (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 Y))
    (@category_theory.monad.algebra.hom.f.{v₁ u₁} C 𝒞 T _inst_1
       (@category_theory.functor.obj.{v₁ v₁ u₁ (max u₁ v₁)} C 𝒞
          (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
          (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
          (@category_theory.monad.free.{v₁ u₁} C 𝒞 T _inst_1)
          X)
       Y
       f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>103        simp only [free_obj_a, functor.map_comp, algebra.hom.h, category.assoc],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='category_theory.monad.free_obj_a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.functor.map_comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.monad.algebra.hom.h'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.category.assoc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 77, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {C : Type ?l_1} [𝒞 : category_theory.category.{?l_2 ?l_1} C] (T : @category_theory.functor.{?l_2 ?l_2 ?l_1 ?l_1} C 𝒞 C 𝒞) [_inst_1 : @category_theory.monad.{?l_2 ?l_1} C 𝒞 T] (X : C), @eq.{?l_2+1} (@category_theory.has_hom.hom.{?l_2 ?l_1} C (@category_theory.category_struct.to_has_hom.{?l_2 ?l_1} C (@category_theory.category.to_category_struct.{?l_2 ?l_1} C 𝒞)) (@category_theory.functor.obj.{?l_2 ?l_2 ?l_1 ?l_1} C 𝒞 C 𝒞 (@category_theory.functor.comp.{?l_2 ?l_2 ?l_2 ?l_1 ?l_1 ?l_1} C 𝒞 C 𝒞 C 𝒞 T T) X) (@category_theory.functor.obj.{?l_2 ?l_2 ?l_1 ?l_1} C 𝒞 C 𝒞 T X)) (@category_theory.monad.algebra.a.{?l_2 ?l_1} C 𝒞 T _inst_1 (@category_theory.functor.obj.{?l_2 ?l_2 ?l_1 (max ?l_1 ?l_2)} C 𝒞 (@category_theory.monad.algebra.{?l_2 ?l_1} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{?l_2 ?l_1} C 𝒞 T _inst_1) (@category_theory.monad.free.{?l_2 ?l_1} C 𝒞 T _inst_1) X)) (@category_theory.nat_trans.app.{?l_2 ?l_2 ?l_1 ?l_1} C 𝒞 C 𝒞 (@category_theory.functor.comp.{?l_2 ?l_2 ?l_2 ?l_1 ?l_1 ?l_1} C 𝒞 C 𝒞 C 𝒞 T T) T (@category_theory.monad.μ.{?l_2 ?l_1} C 𝒞 T _inst_1) X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {C : Type ?l_1} [_inst_1 : category_theory.category.{?l_2 ?l_1} C] {D : Type ?l_3} [_inst_2 : category_theory.category.{?l_4 ?l_3} D] (c : @category_theory.functor.{?l_2 ?l_4 ?l_1 ?l_3} C _inst_1 D _inst_2) {X Y Z : C} (f : @category_theory.has_hom.hom.{?l_2 ?l_1} C (@category_theory.category_struct.to_has_hom.{?l_2 ?l_1} C (@category_theory.category.to_category_struct.{?l_2 ?l_1} C _inst_1)) X Y) (g : @category_theory.has_hom.hom.{?l_2 ?l_1} C (@category_theory.category_struct.to_has_hom.{?l_2 ?l_1} C (@category_theory.category.to_category_struct.{?l_2 ?l_1} C _inst_1)) Y Z), @eq.{?l_4+1} (@category_theory.has_hom.hom.{?l_4 ?l_3} D (@category_theory.category_struct.to_has_hom.{?l_4 ?l_3} D (@category_theory.category.to_category_struct.{?l_4 ?l_3} D _inst_2)) (@category_theory.functor.obj.{?l_2 ?l_4 ?l_1 ?l_3} C _inst_1 D _inst_2 c X) (@category_theory.functor.obj.{?l_2 ?l_4 ?l_1 ?l_3} C _inst_1 D _inst_2 c Z)) (@category_theory.functor.map.{?l_2 ?l_4 ?l_1 ?l_3} C _inst_1 D _inst_2 c X Z (@category_theory.category_struct.comp.{?l_2 ?l_1} C (@category_theory.category.to_category_struct.{?l_2 ?l_1} C _inst_1) X Y Z f g)) (@category_theory.category_struct.comp.{?l_4 ?l_3} D (@category_theory.category.to_category_struct.{?l_4 ?l_3} D _inst_2) (@category_theory.functor.obj.{?l_2 ?l_4 ?l_1 ?l_3} C _inst_1 D _inst_2 c X) (@category_theory.functor.obj.{?l_2 ?l_4 ?l_1 ?l_3} C _inst_1 D _inst_2 c Y) (@category_theory.functor.obj.{?l_2 ?l_4 ?l_1 ?l_3} C _inst_1 D _inst_2 c Z) (@category_theory.functor.map.{?l_2 ?l_4 ?l_1 ?l_3} C _inst_1 D _inst_2 c X Y f) (@category_theory.functor.map.{?l_2 ?l_4 ?l_1 ?l_3} C _inst_1 D _inst_2 c Y Z g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {C : Type ?l_1} [𝒞 : category_theory.category.{?l_2 ?l_1} C] {T : @category_theory.functor.{?l_2 ?l_2 ?l_1 ?l_1} C 𝒞 C 𝒞} [_inst_1 : @category_theory.monad.{?l_2 ?l_1} C 𝒞 T] {A B : @category_theory.monad.algebra.{?l_2 ?l_1} C 𝒞 T _inst_1} (c : @category_theory.monad.algebra.hom.{?l_2 ?l_1} C 𝒞 T _inst_1 A B), @eq.{?l_2+1} (@category_theory.has_hom.hom.{?l_2 ?l_1} C (@category_theory.category_struct.to_has_hom.{?l_2 ?l_1} C (@category_theory.category.to_category_struct.{?l_2 ?l_1} C 𝒞)) (@category_theory.functor.obj.{?l_2 ?l_2 ?l_1 ?l_1} C 𝒞 C 𝒞 T (@category_theory.monad.algebra.A.{?l_2 ?l_1} C 𝒞 T _inst_1 A)) (@category_theory.monad.algebra.A.{?l_2 ?l_1} C 𝒞 T _inst_1 B)) (@category_theory.category_struct.comp.{?l_2 ?l_1} C (@category_theory.category.to_category_struct.{?l_2 ?l_1} C 𝒞) (@category_theory.functor.obj.{?l_2 ?l_2 ?l_1 ?l_1} C 𝒞 C 𝒞 T (@category_theory.monad.algebra.A.{?l_2 ?l_1} C 𝒞 T _inst_1 A)) (@category_theory.functor.obj.{?l_2 ?l_2 ?l_1 ?l_1} C 𝒞 C 𝒞 T (@category_theory.monad.algebra.A.{?l_2 ?l_1} C 𝒞 T _inst_1 B)) (@category_theory.monad.algebra.A.{?l_2 ?l_1} C 𝒞 T _inst_1 B) (@category_theory.functor.map.{?l_2 ?l_2 ?l_1 ?l_1} C 𝒞 C 𝒞 T (@category_theory.monad.algebra.A.{?l_2 ?l_1} C 𝒞 T _inst_1 A) (@category_theory.monad.algebra.A.{?l_2 ?l_1} C 𝒞 T _inst_1 B) (@category_theory.monad.algebra.hom.f.{?l_2 ?l_1} C 𝒞 T _inst_1 A B c)) (@category_theory.monad.algebra.a.{?l_2 ?l_1} C 𝒞 T _inst_1 B)) (@category_theory.category_struct.comp.{?l_2 ?l_1} C (@category_theory.category.to_category_struct.{?l_2 ?l_1} C 𝒞) (@category_theory.functor.obj.{?l_2 ?l_2 ?l_1 ?l_1} C 𝒞 C 𝒞 T (@category_theory.monad.algebra.A.{?l_2 ?l_1} C 𝒞 T _inst_1 A)) (@category_theory.monad.algebra.A.{?l_2 ?l_1} C 𝒞 T _inst_1 A) (@category_theory.monad.algebra.A.{?l_2 ?l_1} C 𝒞 T _inst_1 B) (@category_theory.monad.algebra.a.{?l_2 ?l_1} C 𝒞 T _inst_1 A) (@category_theory.monad.algebra.hom.f.{?l_2 ?l_1} C 𝒞 T _inst_1 A B c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (obj : Type ?l_1) [c : category_theory.category.{?l_2 ?l_1} obj] {W X Y Z : obj} (f : @category_theory.has_hom.hom.{?l_2 ?l_1} obj (@category_theory.category_struct.to_has_hom.{?l_2 ?l_1} obj (@category_theory.category.to_category_struct.{?l_2 ?l_1} obj c)) W X) (g : @category_theory.has_hom.hom.{?l_2 ?l_1} obj (@category_theory.category_struct.to_has_hom.{?l_2 ?l_1} obj (@category_theory.category.to_category_struct.{?l_2 ?l_1} obj c)) X Y) (h : @category_theory.has_hom.hom.{?l_2 ?l_1} obj (@category_theory.category_struct.to_has_hom.{?l_2 ?l_1} obj (@category_theory.category.to_category_struct.{?l_2 ?l_1} obj c)) Y Z), @eq.{?l_2+1} (@category_theory.has_hom.hom.{?l_2 ?l_1} obj (@category_theory.category_struct.to_has_hom.{?l_2 ?l_1} obj (@category_theory.category.to_category_struct.{?l_2 ?l_1} obj c)) W Z) (@category_theory.category_struct.comp.{?l_2 ?l_1} obj (@category_theory.category.to_category_struct.{?l_2 ?l_1} obj c) W Y Z (@category_theory.category_struct.comp.{?l_2 ?l_1} obj (@category_theory.category.to_category_struct.{?l_2 ?l_1} obj c) W X Y f g) h) (@category_theory.category_struct.comp.{?l_2 ?l_1} obj (@category_theory.category.to_category_struct.{?l_2 ?l_1} obj c) W X Z f (@category_theory.category_struct.comp.{?l_2 ?l_1} obj (@category_theory.category.to_category_struct.{?l_2 ?l_1} obj c) X Y Z g h))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
T : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞,
_inst_1 : @category_theory.monad.{v₁ u₁} C 𝒞 T,
X : C,
Y : @category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1,
f :
  @category_theory.has_hom.hom.{v₁ (max u₁ v₁)} (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
    (@category_theory.category_struct.to_has_hom.{v₁ (max u₁ v₁)}
       (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
       (@category_theory.category.to_category_struct.{v₁ (max u₁ v₁)}
          (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
          (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)))
    (@category_theory.functor.obj.{v₁ v₁ u₁ (max u₁ v₁)} C 𝒞
       (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
       (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
       (@category_theory.monad.free.{v₁ u₁} C 𝒞 T _inst_1)
       X)
    Y
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
       (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
          (@category_theory.category_struct.comp.{v₁ u₁} C
             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
             X
             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
             (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
             (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                T
                (@category_theory.monad.η.{v₁ u₁} C 𝒞 T _inst_1)
                X)
             (@category_theory.monad.algebra.hom.f.{v₁ u₁} C 𝒞 T _inst_1
                (@category_theory.functor.obj.{v₁ v₁ u₁ (max u₁ v₁)} C 𝒞
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.free.{v₁ u₁} C 𝒞 T _inst_1)
                   X)
                Y
                f)))
       (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 Y))
    (@category_theory.monad.algebra.hom.f.{v₁ u₁} C 𝒞 T _inst_1
       (@category_theory.functor.obj.{v₁ v₁ u₁ (max u₁ v₁)} C 𝒞
          (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
          (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
          (@category_theory.monad.free.{v₁ u₁} C 𝒞 T _inst_1)
          X)
       Y
       f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
T : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞,
_inst_1 : @category_theory.monad.{v₁ u₁} C 𝒞 T,
X : C,
Y : @category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1,
f :
  @category_theory.has_hom.hom.{v₁ (max u₁ v₁)} (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
    (@category_theory.category_struct.to_has_hom.{v₁ (max u₁ v₁)}
       (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
       (@category_theory.category.to_category_struct.{v₁ (max u₁ v₁)}
          (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
          (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)))
    (@category_theory.functor.obj.{v₁ v₁ u₁ (max u₁ v₁)} C 𝒞
       (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
       (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
       (@category_theory.monad.free.{v₁ u₁} C 𝒞 T _inst_1)
       X)
    Y
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
       (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
          (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
             (@category_theory.functor.id.{v₁ u₁} C 𝒞)
             T
             (@category_theory.monad.η.{v₁ u₁} C 𝒞 T _inst_1)
             X))
       (@category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                (@category_theory.functor.obj.{v₁ v₁ u₁ (max u₁ v₁)} C 𝒞
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.free.{v₁ u₁} C 𝒞 T _inst_1)
                   X)))
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
             (@category_theory.functor.obj.{v₁ v₁ u₁ (max u₁ v₁)} C 𝒞
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.free.{v₁ u₁} C 𝒞 T _inst_1)
                X))
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
          (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ u₁ u₁ u₁} C 𝒞 C 𝒞 C 𝒞 T T)
             T
             (@category_theory.monad.μ.{v₁ u₁} C 𝒞 T _inst_1)
             X)
          (@category_theory.monad.algebra.hom.f.{v₁ u₁} C 𝒞 T _inst_1
             (@category_theory.functor.obj.{v₁ v₁ u₁ (max u₁ v₁)} C 𝒞
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.free.{v₁ u₁} C 𝒞 T _inst_1)
                X)
             Y
             f)))
    (@category_theory.monad.algebra.hom.f.{v₁ u₁} C 𝒞 T _inst_1
       (@category_theory.functor.obj.{v₁ v₁ u₁ (max u₁ v₁)} C 𝒞
          (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
          (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
          (@category_theory.monad.free.{v₁ u₁} C 𝒞 T _inst_1)
          X)
       Y
       f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>104        erw [←category.assoc, monad.right_unit, id_comp],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='category_theory.category.assoc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.monad.right_unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.category.id_comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/monad/basic.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (obj : Type u₁) [c : category_theory.category.{v₁ u₁} obj] {W X Y Z : obj} (f : @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c)) W X) (g : @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c)) X Y) (h : @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c)) Y Z), @eq.{v₁+1} (@category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c)) W Z) (@category_theory.category_struct.comp.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c) W Y Z (@category_theory.category_struct.comp.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c) W X Y f g) h) (@category_theory.category_struct.comp.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c) W X Z f (@category_theory.category_struct.comp.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c) X Y Z g h))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] (T : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞) [c : @category_theory.monad.{v₁ u₁} C 𝒞 T] (X : C), @eq.{v₁+1} (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)) (@category_theory.category_struct.comp.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X) (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X) (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 (@category_theory.functor.id.{v₁ u₁} C 𝒞) T (@category_theory.monad.η.{v₁ u₁} C 𝒞 T c) X)) (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 (@category_theory.functor.comp.{v₁ v₁ v₁ u₁ u₁ u₁} C 𝒞 C 𝒞 C 𝒞 T T) T (@category_theory.monad.μ.{v₁ u₁} C 𝒞 T c) X)) (@category_theory.category_struct.id.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (obj : Type u₁) [c : category_theory.category.{v₁ u₁} obj] {X Y : obj} (f : @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c)) X Y), @eq.{v₁+1} (@category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c)) X Y) (@category_theory.category_struct.comp.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c) X X Y (@category_theory.category_struct.id.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c) X) f) f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
T : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞,
_inst_1 : @category_theory.monad.{v₁ u₁} C 𝒞 T,
X : C,
Y : @category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1,
f :
  @category_theory.has_hom.hom.{v₁ (max u₁ v₁)} (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
    (@category_theory.category_struct.to_has_hom.{v₁ (max u₁ v₁)}
       (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
       (@category_theory.category.to_category_struct.{v₁ (max u₁ v₁)}
          (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
          (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)))
    (@category_theory.functor.obj.{v₁ v₁ u₁ (max u₁ v₁)} C 𝒞
       (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
       (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
       (@category_theory.monad.free.{v₁ u₁} C 𝒞 T _inst_1)
       X)
    Y
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
       (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
          (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
             (@category_theory.functor.id.{v₁ u₁} C 𝒞)
             T
             (@category_theory.monad.η.{v₁ u₁} C 𝒞 T _inst_1)
             X))
       (@category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                (@category_theory.functor.obj.{v₁ v₁ u₁ (max u₁ v₁)} C 𝒞
                   (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                   (@category_theory.monad.free.{v₁ u₁} C 𝒞 T _inst_1)
                   X)))
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
             (@category_theory.functor.obj.{v₁ v₁ u₁ (max u₁ v₁)} C 𝒞
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.free.{v₁ u₁} C 𝒞 T _inst_1)
                X))
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
          (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ u₁ u₁ u₁} C 𝒞 C 𝒞 C 𝒞 T T)
             T
             (@category_theory.monad.μ.{v₁ u₁} C 𝒞 T _inst_1)
             X)
          (@category_theory.monad.algebra.hom.f.{v₁ u₁} C 𝒞 T _inst_1
             (@category_theory.functor.obj.{v₁ v₁ u₁ (max u₁ v₁)} C 𝒞
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.free.{v₁ u₁} C 𝒞 T _inst_1)
                X)
             Y
             f)))
    (@category_theory.monad.algebra.hom.f.{v₁ u₁} C 𝒞 T _inst_1
       (@category_theory.functor.obj.{v₁ v₁ u₁ (max u₁ v₁)} C 𝒞
          (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
          (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
          (@category_theory.monad.free.{v₁ u₁} C 𝒞 T _inst_1)
          X)
       Y
       f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
T : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞,
_inst_1 : @category_theory.monad.{v₁ u₁} C 𝒞 T,
X : C,
Y : @category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1,
f :
  @category_theory.has_hom.hom.{v₁ (max u₁ v₁)} (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
    (@category_theory.category_struct.to_has_hom.{v₁ (max u₁ v₁)}
       (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
       (@category_theory.category.to_category_struct.{v₁ (max u₁ v₁)}
          (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
          (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)))
    (@category_theory.functor.obj.{v₁ v₁ u₁ (max u₁ v₁)} C 𝒞
       (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
       (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
       (@category_theory.monad.free.{v₁ u₁} C 𝒞 T _inst_1)
       X)
    Y
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.functor.obj.{v₁ v₁ u₁ (max u₁ v₁)} C 𝒞
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.free.{v₁ u₁} C 𝒞 T _inst_1)
             X))
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
       (@category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
             (@category_theory.functor.obj.{v₁ v₁ u₁ (max u₁ v₁)} C 𝒞
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.free.{v₁ u₁} C 𝒞 T _inst_1)
                X))
          (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X
             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
             (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                T
                (@category_theory.monad.η.{v₁ u₁} C 𝒞 T _inst_1)
                X))
          (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
             (@category_theory.functor.comp.{v₁ v₁ v₁ u₁ u₁ u₁} C 𝒞 C 𝒞 C 𝒞 T T)
             T
             (@category_theory.monad.μ.{v₁ u₁} C 𝒞 T _inst_1)
             X))
       (@category_theory.monad.algebra.hom.f.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.functor.obj.{v₁ v₁ u₁ (max u₁ v₁)} C 𝒞
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.free.{v₁ u₁} C 𝒞 T _inst_1)
             X)
          Y
          f))
    (@category_theory.monad.algebra.hom.f.{v₁ u₁} C 𝒞 T _inst_1
       (@category_theory.functor.obj.{v₁ v₁ u₁ (max u₁ v₁)} C 𝒞
          (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
          (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
          (@category_theory.monad.free.{v₁ u₁} C 𝒞 T _inst_1)
          X)
       Y
       f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
T : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞,
_inst_1 : @category_theory.monad.{v₁ u₁} C 𝒞 T,
X : C,
Y : @category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1,
f :
  @category_theory.has_hom.hom.{v₁ (max u₁ v₁)} (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
    (@category_theory.category_struct.to_has_hom.{v₁ (max u₁ v₁)}
       (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
       (@category_theory.category.to_category_struct.{v₁ (max u₁ v₁)}
          (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
          (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)))
    (@category_theory.functor.obj.{v₁ v₁ u₁ (max u₁ v₁)} C 𝒞
       (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
       (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
       (@category_theory.monad.free.{v₁ u₁} C 𝒞 T _inst_1)
       X)
    Y
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.functor.obj.{v₁ v₁ u₁ (max u₁ v₁)} C 𝒞
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.free.{v₁ u₁} C 𝒞 T _inst_1)
             X))
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
       (@category_theory.category_struct.id.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
       (@category_theory.monad.algebra.hom.f.{v₁ u₁} C 𝒞 T _inst_1
          (@category_theory.functor.obj.{v₁ v₁ u₁ (max u₁ v₁)} C 𝒞
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.free.{v₁ u₁} C 𝒞 T _inst_1)
             X)
          Y
          f))
    (@category_theory.monad.algebra.hom.f.{v₁ u₁} C 𝒞 T _inst_1
       (@category_theory.functor.obj.{v₁ v₁ u₁ (max u₁ v₁)} C 𝒞
          (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
          (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
          (@category_theory.monad.free.{v₁ u₁} C 𝒞 T _inst_1)
          X)
       Y
       f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>105      end,</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>106      right_inv := λ f,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='green'><a title='@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) u₁} (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1) C 𝒞 (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1) Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>107      begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
T : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞,
_inst_1 : @category_theory.monad.{v₁ u₁} C 𝒞 T,
X : C,
Y : @category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1,
f :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) u₁}
       (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
       (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
       C
       𝒞
       (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)
       Y)
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       X
       (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) u₁}
          (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
          (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
          C
          𝒞
          (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)
          Y))
    ((λ
      (f :
        @category_theory.has_hom.hom.{v₁ (max u₁ v₁)}
          (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
          (@category_theory.category_struct.to_has_hom.{v₁ (max u₁ v₁)}
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.category.to_category_struct.{v₁ (max u₁ v₁)}
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)))
          (@category_theory.functor.obj.{v₁ v₁ u₁ (max u₁ v₁)} C 𝒞
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.free.{v₁ u₁} C 𝒞 T _inst_1)
             X)
          Y),
        @category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          X
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
          (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) u₁}
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             C
             𝒞
             (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)
             Y)
          (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
             (@category_theory.functor.id.{v₁ u₁} C 𝒞)
             T
             (@category_theory.monad.η.{v₁ u₁} C 𝒞 T _inst_1)
             X)
          (@category_theory.monad.algebra.hom.f.{v₁ u₁} C 𝒞 T _inst_1
             (@category_theory.functor.obj.{v₁ v₁ u₁ (max u₁ v₁)} C 𝒞
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.free.{v₁ u₁} C 𝒞 T _inst_1)
                X)
             Y
             f))
       ((λ
         (f :
           @category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X
             (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) u₁}
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)
                Y)),
           @category_theory.monad.algebra.hom.mk.{v₁ u₁} C 𝒞 T _inst_1
             (@category_theory.functor.obj.{v₁ v₁ u₁ (max u₁ v₁)} C 𝒞
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.free.{v₁ u₁} C 𝒞 T _inst_1)
                X)
             Y
             (@category_theory.category_struct.comp.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                   (@category_theory.functor.obj.{v₁ v₁ u₁ (max u₁ v₁)} C 𝒞
                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                      (@category_theory.monad.free.{v₁ u₁} C 𝒞 T _inst_1)
                      X))
                (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                   (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) u₁}
                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                      C
                      𝒞
                      (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)
                      Y))
                (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X
                   (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) u₁}
                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                      C
                      𝒞
                      (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)
                      Y)
                   f)
                (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 Y))
             (@id.{0}
                (@eq.{v₁+1}
                   (@category_theory.has_hom.hom.{v₁ u₁} C
                      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                      (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                         (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                            (@category_theory.functor.obj.{v₁ v₁ u₁ (max u₁ v₁)} C 𝒞
                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                               (@category_theory.monad.free.{v₁ u₁} C 𝒞 T _inst_1)
                               X)))
                      (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                   (@category_theory.category_struct.comp.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                      (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                         (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                            (@category_theory.functor.obj.{v₁ v₁ u₁ (max u₁ v₁)} C 𝒞
                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                               (@category_theory.monad.free.{v₁ u₁} C 𝒞 T _inst_1)
                               X)))
                      (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                         (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                      (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                      (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                         (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                            (@category_theory.functor.obj.{v₁ v₁ u₁ (max u₁ v₁)} C 𝒞
                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                               (@category_theory.monad.free.{v₁ u₁} C 𝒞 T _inst_1)
                               X))
                         (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                         (@category_theory.category_struct.comp.{v₁ u₁} C
                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                            (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                               (@category_theory.functor.obj.{v₁ v₁ u₁ (max u₁ v₁)} C 𝒞
                                  (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                  (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                  (@category_theory.monad.free.{v₁ u₁} C 𝒞 T _inst_1)
                                  X))
                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                               (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) u₁}
                                  (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                  (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                  C
                                  𝒞
                                  (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)
                                  Y))
                            (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                            (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X
                               (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) u₁}
                                  (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                  (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                  C
                                  𝒞
                                  (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)
                                  Y)
                               f)
                            (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 Y)))
                      (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 Y))
                   (@category_theory.category_struct.comp.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                      (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                         (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                            (@category_theory.functor.obj.{v₁ v₁ u₁ (max u₁ v₁)} C 𝒞
                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                               (@category_theory.monad.free.{v₁ u₁} C 𝒞 T _inst_1)
                               X)))
                      (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                         (@category_theory.functor.obj.{v₁ v₁ u₁ (max u₁ v₁)} C 𝒞
                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                            (@category_theory.monad.free.{v₁ u₁} C 𝒞 T _inst_1)
                            X))
                      (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                      (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
                         (@category_theory.functor.obj.{v₁ v₁ u₁ (max u₁ v₁)} C 𝒞
                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                            (@category_theory.monad.free.{v₁ u₁} C 𝒞 T _inst_1)
                            X))
                      (@category_theory.category_struct.comp.{v₁ u₁} C
                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                         (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                            (@category_theory.functor.obj.{v₁ v₁ u₁ (max u₁ v₁)} C 𝒞
                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                               (@category_theory.monad.free.{v₁ u₁} C 𝒞 T _inst_1)
                               X))
                         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                            (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) u₁}
                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                               C
                               𝒞
                               (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)
                               Y))
                         (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                         (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X
                            (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) u₁}
                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                               C
                               𝒞
                               (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)
                               Y)
                            f)
                         (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 Y))))
                (@eq.mpr.{0}
                   (@eq.{v₁+1}
                      (@category_theory.has_hom.hom.{v₁ u₁} C
                         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                         (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                      (@category_theory.category_struct.comp.{v₁ u₁} C
                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                            (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                         (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                         (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                            (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                            (@category_theory.category_struct.comp.{v₁ u₁} C
                               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                  (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                               (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                               (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X
                                  (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                                  f)
                               (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 Y)))
                         (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 Y))
                      (@category_theory.category_struct.comp.{v₁ u₁} C
                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                         (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                         (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                            (@category_theory.functor.comp.{v₁ v₁ v₁ u₁ u₁ u₁} C 𝒞 C 𝒞 C 𝒞 T T)
                            T
                            (@category_theory.monad.μ.{v₁ u₁} C 𝒞 T _inst_1)
                            X)
                         (@category_theory.category_struct.comp.{v₁ u₁} C
                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                               (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                            (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                            (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X
                               (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                               f)
                            (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 Y))))
                   (@eq.{v₁+1}
                      (@category_theory.has_hom.hom.{v₁ u₁} C
                         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                         (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                      (@category_theory.category_struct.comp.{v₁ u₁} C
                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                               (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)))
                         (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                         (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                               (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                            (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X
                               (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                               f))
                         (@category_theory.category_struct.comp.{v₁ u₁} C
                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                  (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)))
                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                               (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                            (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                            (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                  (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                               (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                               (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 Y))
                            (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 Y)))
                      (@category_theory.category_struct.comp.{v₁ u₁} C
                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                         (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                         (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                            (@category_theory.functor.comp.{v₁ v₁ v₁ u₁ u₁ u₁} C 𝒞 C 𝒞 C 𝒞 T T)
                            T
                            (@category_theory.monad.μ.{v₁ u₁} C 𝒞 T _inst_1)
                            X)
                         (@category_theory.category_struct.comp.{v₁ u₁} C
                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                               (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                            (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                            (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X
                               (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                               f)
                            (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 Y))))
                   (@id.{0}
                      (@eq.{1} Prop
                         (@eq.{v₁+1}
                            (@category_theory.has_hom.hom.{v₁ u₁} C
                               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                               (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                            (@category_theory.category_struct.comp.{v₁ u₁} C
                               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                  (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                               (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                               (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                                  (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                                  (@category_theory.category_struct.comp.{v₁ u₁} C
                                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                     (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                                     (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                        (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                                     (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                                     (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X
                                        (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                                        f)
                                     (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 Y)))
                               (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 Y))
                            (@category_theory.category_struct.comp.{v₁ u₁} C
                               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                               (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                               (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                  (@category_theory.functor.comp.{v₁ v₁ v₁ u₁ u₁ u₁} C 𝒞 C 𝒞 C 𝒞 T
                                     T)
                                  T
                                  (@category_theory.monad.μ.{v₁ u₁} C 𝒞 T _inst_1)
                                  X)
                               (@category_theory.category_struct.comp.{v₁ u₁} C
                                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                     (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                                  (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                                  (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X
                                     (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                                     f)
                                  (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 Y))))
                         (@eq.{v₁+1}
                            (@category_theory.has_hom.hom.{v₁ u₁} C
                               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                               (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                            (@category_theory.category_struct.comp.{v₁ u₁} C
                               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                     (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)))
                               (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                               (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                     (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                                  (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X
                                     (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                                     f))
                               (@category_theory.category_struct.comp.{v₁ u₁} C
                                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                     (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                        (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)))
                                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                     (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                                  (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                                  (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                     (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                        (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                                     (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                                     (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 Y))
                                  (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 Y)))
                            (@category_theory.category_struct.comp.{v₁ u₁} C
                               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                               (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                               (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                  (@category_theory.functor.comp.{v₁ v₁ v₁ u₁ u₁ u₁} C 𝒞 C 𝒞 C 𝒞 T
                                     T)
                                  T
                                  (@category_theory.monad.μ.{v₁ u₁} C 𝒞 T _inst_1)
                                  X)
                               (@category_theory.category_struct.comp.{v₁ u₁} C
                                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                     (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                                  (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                                  (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X
                                     (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                                     f)
                                  (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 Y)))))
                      ((λ
                        (a a_1 :
                          @category_theory.has_hom.hom.{v₁ u₁} C
                            (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                            (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                        (e_1 :
                          @eq.{v₁+1}
                            (@category_theory.has_hom.hom.{v₁ u₁} C
                               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                               (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                            a
                            a_1)
                        (a_2 a_3 :
                          @category_theory.has_hom.hom.{v₁ u₁} C
                            (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                            (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                        (e_2 :
                          @eq.{v₁+1}
                            (@category_theory.has_hom.hom.{v₁ u₁} C
                               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                               (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                            a_2
                            a_3),
                          @congr.{v₁+1 1}
                            (@category_theory.has_hom.hom.{v₁ u₁} C
                               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                               (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                            Prop
                            (@eq.{v₁+1}
                               (@category_theory.has_hom.hom.{v₁ u₁} C
                                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                     (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                                  (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                               a)
                            (@eq.{v₁+1}
                               (@category_theory.has_hom.hom.{v₁ u₁} C
                                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                     (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                                  (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                               a_1)
                            a_2
                            a_3
                            (@congr_arg.{v₁+1 (max (v₁+1) 1)}
                               (@category_theory.has_hom.hom.{v₁ u₁} C
                                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                     (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                                  (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                               (@category_theory.has_hom.hom.{v₁ u₁} C
                                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                     (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                                  (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y) →
                                Prop)
                               a
                               a_1
                               (@eq.{v₁+1}
                                  (@category_theory.has_hom.hom.{v₁ u₁} C
                                     (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                     (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                        (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                                     (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)))
                               e_1)
                            e_2)
                         (@category_theory.category_struct.comp.{v₁ u₁} C
                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                               (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                            (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                            (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                               (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                               (@category_theory.category_struct.comp.{v₁ u₁} C
                                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                     (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                                  (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                                  (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X
                                     (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                                     f)
                                  (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 Y)))
                            (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 Y))
                         (@category_theory.category_struct.comp.{v₁ u₁} C
                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                  (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)))
                            (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                            (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                  (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                               (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X
                                  (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                                  f))
                            (@category_theory.category_struct.comp.{v₁ u₁} C
                               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                     (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)))
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                  (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                               (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                               (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                     (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                                  (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                                  (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 Y))
                               (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 Y)))
                         (@eq.trans.{v₁+1}
                            (@category_theory.has_hom.hom.{v₁ u₁} C
                               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                               (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                            (@category_theory.category_struct.comp.{v₁ u₁} C
                               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                  (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                               (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                               (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                                  (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                                  (@category_theory.category_struct.comp.{v₁ u₁} C
                                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                     (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                                     (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                        (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                                     (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                                     (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X
                                        (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                                        f)
                                     (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 Y)))
                               (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 Y))
                            (@category_theory.category_struct.comp.{v₁ u₁} C
                               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                  (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                               (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                               (@category_theory.category_struct.comp.{v₁ u₁} C
                                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T …)
                                  …
                                  …
                                  …
                                  …)
                               …)
                            …
                            …
                            …)
                         …
                         …
                         …))
                   …)))
          f))
    f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>108        dsimp,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1239, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='`dsimp` is similar to `simp`, except that it only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
T : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞,
_inst_1 : @category_theory.monad.{v₁ u₁} C 𝒞 T,
X : C,
Y : @category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1,
f :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) u₁}
       (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
       (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
       C
       𝒞
       (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)
       Y)
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       X
       (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) u₁}
          (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
          (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
          C
          𝒞
          (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)
          Y))
    ((λ
      (f :
        @category_theory.has_hom.hom.{v₁ (max u₁ v₁)}
          (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
          (@category_theory.category_struct.to_has_hom.{v₁ (max u₁ v₁)}
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.category.to_category_struct.{v₁ (max u₁ v₁)}
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)))
          (@category_theory.functor.obj.{v₁ v₁ u₁ (max u₁ v₁)} C 𝒞
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.free.{v₁ u₁} C 𝒞 T _inst_1)
             X)
          Y),
        @category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          X
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
          (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) u₁}
             (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
             C
             𝒞
             (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)
             Y)
          (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
             (@category_theory.functor.id.{v₁ u₁} C 𝒞)
             T
             (@category_theory.monad.η.{v₁ u₁} C 𝒞 T _inst_1)
             X)
          (@category_theory.monad.algebra.hom.f.{v₁ u₁} C 𝒞 T _inst_1
             (@category_theory.functor.obj.{v₁ v₁ u₁ (max u₁ v₁)} C 𝒞
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.free.{v₁ u₁} C 𝒞 T _inst_1)
                X)
             Y
             f))
       ((λ
         (f :
           @category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X
             (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) u₁}
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                C
                𝒞
                (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)
                Y)),
           @category_theory.monad.algebra.hom.mk.{v₁ u₁} C 𝒞 T _inst_1
             (@category_theory.functor.obj.{v₁ v₁ u₁ (max u₁ v₁)} C 𝒞
                (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                (@category_theory.monad.free.{v₁ u₁} C 𝒞 T _inst_1)
                X)
             Y
             (@category_theory.category_struct.comp.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                   (@category_theory.functor.obj.{v₁ v₁ u₁ (max u₁ v₁)} C 𝒞
                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                      (@category_theory.monad.free.{v₁ u₁} C 𝒞 T _inst_1)
                      X))
                (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                   (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) u₁}
                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                      C
                      𝒞
                      (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)
                      Y))
                (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X
                   (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) u₁}
                      (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                      (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                      C
                      𝒞
                      (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)
                      Y)
                   f)
                (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 Y))
             (@id.{0}
                (@eq.{v₁+1}
                   (@category_theory.has_hom.hom.{v₁ u₁} C
                      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                      (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                         (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                            (@category_theory.functor.obj.{v₁ v₁ u₁ (max u₁ v₁)} C 𝒞
                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                               (@category_theory.monad.free.{v₁ u₁} C 𝒞 T _inst_1)
                               X)))
                      (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                   (@category_theory.category_struct.comp.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                      (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                         (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                            (@category_theory.functor.obj.{v₁ v₁ u₁ (max u₁ v₁)} C 𝒞
                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                               (@category_theory.monad.free.{v₁ u₁} C 𝒞 T _inst_1)
                               X)))
                      (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                         (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                      (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                      (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                         (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                            (@category_theory.functor.obj.{v₁ v₁ u₁ (max u₁ v₁)} C 𝒞
                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                               (@category_theory.monad.free.{v₁ u₁} C 𝒞 T _inst_1)
                               X))
                         (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                         (@category_theory.category_struct.comp.{v₁ u₁} C
                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                            (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                               (@category_theory.functor.obj.{v₁ v₁ u₁ (max u₁ v₁)} C 𝒞
                                  (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                  (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                  (@category_theory.monad.free.{v₁ u₁} C 𝒞 T _inst_1)
                                  X))
                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                               (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) u₁}
                                  (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                  (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                  C
                                  𝒞
                                  (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)
                                  Y))
                            (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                            (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X
                               (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) u₁}
                                  (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                                  (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                                  C
                                  𝒞
                                  (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)
                                  Y)
                               f)
                            (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 Y)))
                      (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 Y))
                   (@category_theory.category_struct.comp.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                      (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                         (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                            (@category_theory.functor.obj.{v₁ v₁ u₁ (max u₁ v₁)} C 𝒞
                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                               (@category_theory.monad.free.{v₁ u₁} C 𝒞 T _inst_1)
                               X)))
                      (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                         (@category_theory.functor.obj.{v₁ v₁ u₁ (max u₁ v₁)} C 𝒞
                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                            (@category_theory.monad.free.{v₁ u₁} C 𝒞 T _inst_1)
                            X))
                      (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                      (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1
                         (@category_theory.functor.obj.{v₁ v₁ u₁ (max u₁ v₁)} C 𝒞
                            (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                            (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                            (@category_theory.monad.free.{v₁ u₁} C 𝒞 T _inst_1)
                            X))
                      (@category_theory.category_struct.comp.{v₁ u₁} C
                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                         (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1
                            (@category_theory.functor.obj.{v₁ v₁ u₁ (max u₁ v₁)} C 𝒞
                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                               (@category_theory.monad.free.{v₁ u₁} C 𝒞 T _inst_1)
                               X))
                         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                            (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) u₁}
                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                               C
                               𝒞
                               (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)
                               Y))
                         (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                         (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X
                            (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) u₁}
                               (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
                               (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
                               C
                               𝒞
                               (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)
                               Y)
                            f)
                         (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 Y))))
                (@eq.mpr.{0}
                   (@eq.{v₁+1}
                      (@category_theory.has_hom.hom.{v₁ u₁} C
                         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                         (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                      (@category_theory.category_struct.comp.{v₁ u₁} C
                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                            (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                         (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                         (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                            (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                            (@category_theory.category_struct.comp.{v₁ u₁} C
                               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                  (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                               (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                               (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X
                                  (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                                  f)
                               (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 Y)))
                         (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 Y))
                      (@category_theory.category_struct.comp.{v₁ u₁} C
                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                         (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                         (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                            (@category_theory.functor.comp.{v₁ v₁ v₁ u₁ u₁ u₁} C 𝒞 C 𝒞 C 𝒞 T T)
                            T
                            (@category_theory.monad.μ.{v₁ u₁} C 𝒞 T _inst_1)
                            X)
                         (@category_theory.category_struct.comp.{v₁ u₁} C
                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                               (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                            (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                            (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X
                               (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                               f)
                            (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 Y))))
                   (@eq.{v₁+1}
                      (@category_theory.has_hom.hom.{v₁ u₁} C
                         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                         (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                      (@category_theory.category_struct.comp.{v₁ u₁} C
                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                               (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)))
                         (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                         (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                               (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                            (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X
                               (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                               f))
                         (@category_theory.category_struct.comp.{v₁ u₁} C
                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                  (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)))
                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                               (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                            (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                            (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                  (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                               (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                               (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 Y))
                            (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 Y)))
                      (@category_theory.category_struct.comp.{v₁ u₁} C
                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                         (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                         (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                            (@category_theory.functor.comp.{v₁ v₁ v₁ u₁ u₁ u₁} C 𝒞 C 𝒞 C 𝒞 T T)
                            T
                            (@category_theory.monad.μ.{v₁ u₁} C 𝒞 T _inst_1)
                            X)
                         (@category_theory.category_struct.comp.{v₁ u₁} C
                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                               (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                            (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                            (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X
                               (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                               f)
                            (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 Y))))
                   (@id.{0}
                      (@eq.{1} Prop
                         (@eq.{v₁+1}
                            (@category_theory.has_hom.hom.{v₁ u₁} C
                               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                               (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                            (@category_theory.category_struct.comp.{v₁ u₁} C
                               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                  (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                               (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                               (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                                  (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                                  (@category_theory.category_struct.comp.{v₁ u₁} C
                                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                     (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                                     (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                        (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                                     (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                                     (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X
                                        (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                                        f)
                                     (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 Y)))
                               (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 Y))
                            (@category_theory.category_struct.comp.{v₁ u₁} C
                               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                               (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                               (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                  (@category_theory.functor.comp.{v₁ v₁ v₁ u₁ u₁ u₁} C 𝒞 C 𝒞 C 𝒞 T
                                     T)
                                  T
                                  (@category_theory.monad.μ.{v₁ u₁} C 𝒞 T _inst_1)
                                  X)
                               (@category_theory.category_struct.comp.{v₁ u₁} C
                                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                     (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                                  (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                                  (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X
                                     (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                                     f)
                                  (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 Y))))
                         (@eq.{v₁+1}
                            (@category_theory.has_hom.hom.{v₁ u₁} C
                               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                               (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                            (@category_theory.category_struct.comp.{v₁ u₁} C
                               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                     (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)))
                               (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                               (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                     (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                                  (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X
                                     (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                                     f))
                               (@category_theory.category_struct.comp.{v₁ u₁} C
                                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                     (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                        (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)))
                                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                     (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                                  (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                                  (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                     (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                        (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                                     (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                                     (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 Y))
                                  (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 Y)))
                            (@category_theory.category_struct.comp.{v₁ u₁} C
                               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                               (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                               (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                  (@category_theory.functor.comp.{v₁ v₁ v₁ u₁ u₁ u₁} C 𝒞 C 𝒞 C 𝒞 T
                                     T)
                                  T
                                  (@category_theory.monad.μ.{v₁ u₁} C 𝒞 T _inst_1)
                                  X)
                               (@category_theory.category_struct.comp.{v₁ u₁} C
                                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                     (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                                  (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                                  (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X
                                     (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                                     f)
                                  (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 Y)))))
                      ((λ
                        (a a_1 :
                          @category_theory.has_hom.hom.{v₁ u₁} C
                            (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                            (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                        (e_1 :
                          @eq.{v₁+1}
                            (@category_theory.has_hom.hom.{v₁ u₁} C
                               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                               (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                            a
                            a_1)
                        (a_2 a_3 :
                          @category_theory.has_hom.hom.{v₁ u₁} C
                            (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                            (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                        (e_2 :
                          @eq.{v₁+1}
                            (@category_theory.has_hom.hom.{v₁ u₁} C
                               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                               (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                            a_2
                            a_3),
                          @congr.{v₁+1 1}
                            (@category_theory.has_hom.hom.{v₁ u₁} C
                               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                               (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                            Prop
                            (@eq.{v₁+1}
                               (@category_theory.has_hom.hom.{v₁ u₁} C
                                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                     (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                                  (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                               a)
                            (@eq.{v₁+1}
                               (@category_theory.has_hom.hom.{v₁ u₁} C
                                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                     (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                                  (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                               a_1)
                            a_2
                            a_3
                            (@congr_arg.{v₁+1 (max (v₁+1) 1)}
                               (@category_theory.has_hom.hom.{v₁ u₁} C
                                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                     (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                                  (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                               (@category_theory.has_hom.hom.{v₁ u₁} C
                                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                     (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                                  (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y) →
                                Prop)
                               a
                               a_1
                               (@eq.{v₁+1}
                                  (@category_theory.has_hom.hom.{v₁ u₁} C
                                     (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                     (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                        (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                                     (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)))
                               e_1)
                            e_2)
                         (@category_theory.category_struct.comp.{v₁ u₁} C
                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                               (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                            (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                            (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                               (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                               (@category_theory.category_struct.comp.{v₁ u₁} C
                                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                     (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                                  (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                                  (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X
                                     (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                                     f)
                                  (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 Y)))
                            (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 Y))
                         (@category_theory.category_struct.comp.{v₁ u₁} C
                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                            (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                  (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)))
                            (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                            (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                  (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                               (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X
                                  (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                                  f))
                            (@category_theory.category_struct.comp.{v₁ u₁} C
                               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                     (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)))
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                  (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                               (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                               (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                     (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                                  (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                                  (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 Y))
                               (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 Y)))
                         (@eq.trans.{v₁+1}
                            (@category_theory.has_hom.hom.{v₁ u₁} C
                               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                               (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                            (@category_theory.category_struct.comp.{v₁ u₁} C
                               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                  (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                               (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                               (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                                  (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                                  (@category_theory.category_struct.comp.{v₁ u₁} C
                                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                     (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
                                     (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                        (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                                     (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                                     (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X
                                        (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                                        f)
                                     (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 Y)))
                               (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 Y))
                            (@category_theory.category_struct.comp.{v₁ u₁} C
                               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X))
                               (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
                                  (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
                               (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
                               (@category_theory.category_struct.comp.{v₁ u₁} C
                                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                  (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T …)
                                  …
                                  …
                                  …
                                  …)
                               …)
                            …
                            …
                            …)
                         …
                         …
                         …))
                   …)))
          f))
    f'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
T : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞,
_inst_1 : @category_theory.monad.{v₁ u₁} C 𝒞 T,
X : C,
Y : @category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1,
f :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) u₁}
       (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
       (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
       C
       𝒞
       (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)
       Y)
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       X
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       X
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
       (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
          (@category_theory.functor.id.{v₁ u₁} C 𝒞)
          T
          (@category_theory.monad.η.{v₁ u₁} C 𝒞 T _inst_1)
          X)
       (@category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
          (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X
             (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
             f)
          (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 Y)))
    f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>109        erw [←category.assoc, ←(η_ T).naturality, functor.id_map,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='category_theory.category.assoc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='category_theory.monad.η'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='T'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='category_theory.functor.id_map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/monad/basic.lean&#x27;, &#x27;line&#x27;: 16, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 62, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (obj : Type u₁) [c : category_theory.category.{v₁ u₁} obj] {W X Y Z : obj} (f : @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c)) W X) (g : @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c)) X Y) (h : @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c)) Y Z), @eq.{v₁+1} (@category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c)) W Z) (@category_theory.category_struct.comp.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c) W Y Z (@category_theory.category_struct.comp.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c) W X Y f g) h) (@category_theory.category_struct.comp.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c) W X Z f (@category_theory.category_struct.comp.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c) X Y Z g h))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] (T : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞) [c : @category_theory.monad.{v₁ u₁} C 𝒞 T], @category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁)} (@category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞) (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁)} (@category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞) (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁)} (@category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞) (@category_theory.functor.category.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞))) (@category_theory.functor.id.{v₁ u₁} C 𝒞) T'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {X Y : C} (f : @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X Y), @eq.{v₁+1} (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 (@category_theory.functor.id.{v₁ u₁} C 𝒞) X) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 (@category_theory.functor.id.{v₁ u₁} C 𝒞) Y)) (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 (@category_theory.functor.id.{v₁ u₁} C 𝒞) X Y f) f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
T : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞,
_inst_1 : @category_theory.monad.{v₁ u₁} C 𝒞 T,
X : C,
Y : @category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1,
f :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) u₁}
       (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
       (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
       C
       𝒞
       (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)
       Y)
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       X
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       X
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
       (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
          (@category_theory.functor.id.{v₁ u₁} C 𝒞)
          T
          (@category_theory.monad.η.{v₁ u₁} C 𝒞 T _inst_1)
          X)
       (@category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
          (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X
             (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
             f)
          (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 Y)))
    f'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
T : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞,
_inst_1 : @category_theory.monad.{v₁ u₁} C 𝒞 T,
X : C,
Y : @category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1,
f :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) u₁}
       (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
       (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
       C
       𝒞
       (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)
       Y)
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       X
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       X
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
       (@category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          X
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X)
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
          (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
             (@category_theory.functor.id.{v₁ u₁} C 𝒞)
             T
             (@category_theory.monad.η.{v₁ u₁} C 𝒞 T _inst_1)
             X)
          (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T X
             (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
             f))
       (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 Y))
    f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
T : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞,
_inst_1 : @category_theory.monad.{v₁ u₁} C 𝒞 T,
X : C,
Y : @category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1,
f :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) u₁}
       (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
       (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
       C
       𝒞
       (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)
       Y)
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       X
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       X
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
       (@category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
             (@category_theory.functor.id.{v₁ u₁} C 𝒞)
             X)
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
             (@category_theory.functor.id.{v₁ u₁} C 𝒞)
             (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
          (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
             (@category_theory.functor.id.{v₁ u₁} C 𝒞)
             X
             (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
             f)
          (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
             (@category_theory.functor.id.{v₁ u₁} C 𝒞)
             T
             (@category_theory.monad.η.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)))
       (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 Y))
    f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
T : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞,
_inst_1 : @category_theory.monad.{v₁ u₁} C 𝒞 T,
X : C,
Y : @category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1,
f :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) u₁}
       (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
       (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
       C
       𝒞
       (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)
       Y)
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       X
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       X
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
       (@category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
             (@category_theory.functor.id.{v₁ u₁} C 𝒞)
             X)
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
             (@category_theory.functor.id.{v₁ u₁} C 𝒞)
             (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
          f
          (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
             (@category_theory.functor.id.{v₁ u₁} C 𝒞)
             T
             (@category_theory.monad.η.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)))
       (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 Y))
    f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>110              category.assoc, Y.unit, comp_id],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='category_theory.category.assoc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='category_theory.category.comp_id'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (obj : Type u₁) [c : category_theory.category.{v₁ u₁} obj] {W X Y Z : obj} (f : @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c)) W X) (g : @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c)) X Y) (h : @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c)) Y Z), @eq.{v₁+1} (@category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c)) W Z) (@category_theory.category_struct.comp.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c) W Y Z (@category_theory.category_struct.comp.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c) W X Y f g) h) (@category_theory.category_struct.comp.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c) W X Z f (@category_theory.category_struct.comp.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c) X Y Z g h))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{v₁+1} (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y) (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)) (@category_theory.category_struct.comp.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞) (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)) (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y) (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 (@category_theory.functor.id.{v₁ u₁} C 𝒞) T (@category_theory.monad.η.{v₁ u₁} C 𝒞 T _inst_1) (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)) (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 Y)) (@category_theory.category_struct.id.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞) (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (obj : Type u₁) [c : category_theory.category.{v₁ u₁} obj] {X Y : obj} (f : @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c)) X Y), @eq.{v₁+1} (@category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c)) X Y) (@category_theory.category_struct.comp.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c) X Y Y f (@category_theory.category_struct.id.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c) Y)) f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
T : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞,
_inst_1 : @category_theory.monad.{v₁ u₁} C 𝒞 T,
X : C,
Y : @category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1,
f :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) u₁}
       (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
       (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
       C
       𝒞
       (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)
       Y)
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       X
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       X
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
       (@category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
             (@category_theory.functor.id.{v₁ u₁} C 𝒞)
             X)
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
             (@category_theory.functor.id.{v₁ u₁} C 𝒞)
             (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
          f
          (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
             (@category_theory.functor.id.{v₁ u₁} C 𝒞)
             T
             (@category_theory.monad.η.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)))
       (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 Y))
    f'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
T : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞,
_inst_1 : @category_theory.monad.{v₁ u₁} C 𝒞 T,
X : C,
Y : @category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1,
f :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) u₁}
       (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
       (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
       C
       𝒞
       (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)
       Y)
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       X
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       X
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
          (@category_theory.functor.id.{v₁ u₁} C 𝒞)
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
       f
       (@category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
             (@category_theory.functor.id.{v₁ u₁} C 𝒞)
             (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 T
             (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
          (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
             (@category_theory.functor.id.{v₁ u₁} C 𝒞)
             T
             (@category_theory.monad.η.{v₁ u₁} C 𝒞 T _inst_1)
             (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
          (@category_theory.monad.algebra.a.{v₁ u₁} C 𝒞 T _inst_1 Y)))
    f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
T : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞,
_inst_1 : @category_theory.monad.{v₁ u₁} C 𝒞 T,
X : C,
Y : @category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1,
f :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    (@category_theory.functor.obj.{v₁ v₁ (max u₁ v₁) u₁}
       (@category_theory.monad.algebra.{v₁ u₁} C 𝒞 T _inst_1)
       (@category_theory.monad.algebra.EilenbergMoore.{v₁ u₁} C 𝒞 T _inst_1)
       C
       𝒞
       (@category_theory.monad.forget.{v₁ u₁} C 𝒞 T _inst_1)
       Y)
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       X
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       X
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
          (@category_theory.functor.id.{v₁ u₁} C 𝒞)
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y))
       (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)
       f
       (@category_theory.category_struct.id.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          (@category_theory.monad.algebra.A.{v₁ u₁} C 𝒞 T _inst_1 Y)))
    f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>111      end }}</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>112  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>113  end monad</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>114  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>115  end category_theory</code></pre>
</body>