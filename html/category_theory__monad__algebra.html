<head>
<meta charset="UTF-8">
<link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro&display=swap" rel="stylesheet">
</head>

<body>
<pre>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  1  /-</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  2  Copyright (c) 2019 Scott Morrison. All rights reserved.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  3  Released under Apache 2.0 license as described in the file LICENSE.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  4  Authors: Scott Morrison</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  5  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  6  import category_theory.monad.basic</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/monad/basic.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  7  import category_theory.adjunction.basic</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/adjunction/basic.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  8  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  9  /-!</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 10  # Eilenberg-Moore algebras for a monad</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 11  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 12  This file defines Eilenberg-Moore algebras for a monad, and provides the category instance for them.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 13  Further it defines the adjoint pair of free and forgetful functors, respectively</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 14  from and to the original category.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 15  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 16  ## References</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 17  * [Riehl, *Category theory in context*, Section 5.2.4][riehl2017]</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 18  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 19  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 20  namespace category_theory</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 21  open category</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 22  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 23  universes vâ‚ uâ‚ -- declare the `v`&#x27;s first; see `category_theory.category` for an explanation</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 24  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 25  variables {C : Type uâ‚} [ğ’ : category.{vâ‚} C]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='ğ’'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 61, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='green'><a title='Type uâ‚'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='category_theory.category.{vâ‚ uâ‚} C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='orange'><a title='The typeclass `category C` describes morphisms associated to objects of type `C`.
The universe levels of the objects and morphisms are unconstrained, and will often need to be
specified explicitly, as `category.{v} C`. (See also `large_category` and `small_category`.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 26  include ğ’</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 27  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 28  namespace monad</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 29  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 30  /-- An Eilenberg-Moore algebra for a monad `T`.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 31      cf Definition 5.2.3 in [Riehl][riehl2017]. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 32  structure algebra (T : C â¥¤ C) [monad.{vâ‚} T] : Type (max uâ‚ vâ‚) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='category_theory.monad'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='T'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/monad/basic.lean&#x27;, &#x27;line&#x27;: 16, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='green'><a title='Type uâ‚'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  (C : Type uâ‚) [_inst_1 : category_theory.category.{vâ‚ uâ‚} C] (D : Type uâ‚) [_inst_2 : category_theory.category.{vâ‚ uâ‚} D], Type (max vâ‚ uâ‚)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type uâ‚'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Î  {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C], @category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ â†’ Type (max uâ‚ vâ‚)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 33  (A : C)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Type uâ‚'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 34  (a : T.obj A âŸ¶ A)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='T'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='A'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='A'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  {C : Type uâ‚} [_inst_1 : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚} [_inst_2 : category_theory.category.{vâ‚ uâ‚} D], @category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C _inst_1 D _inst_2 â†’ C â†’ D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {obj : Type uâ‚} [c : category_theory.has_hom.{vâ‚ uâ‚} obj], obj â†’ obj â†’ Type vâ‚'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 35  (unit&#x27; : (Î·_ T).app A â‰« a = ğŸ™ A . obviously)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='category_theory.monad.Î·'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='T'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.nat_trans.app'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='A'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='auto_param'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.category_struct.id'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='A'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='A'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/monad/basic.lean&#x27;, &#x27;line&#x27;: 16, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/name.lean&#x27;, &#x27;line&#x27;: 19, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='Î  {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] (T : @category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’) [c : @category_theory.monad.{vâ‚ uâ‚} C ğ’ T], @category_theory.has_hom.hom.{(max uâ‚ vâ‚) (max vâ‚ uâ‚)} (@category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’) (@category_theory.category_struct.to_has_hom.{(max uâ‚ vâ‚) (max vâ‚ uâ‚)} (@category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’) (@category_theory.category.to_category_struct.{(max uâ‚ vâ‚) (max vâ‚ uâ‚)} (@category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’) (@category_theory.functor.category.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’))) (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’) T'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚} [ğ’Ÿ : category_theory.category.{vâ‚ uâ‚} D] {F G : @category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ D ğ’Ÿ}, @category_theory.nat_trans.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ D ğ’Ÿ F G â†’ Î  (X : C), @category_theory.has_hom.hom.{vâ‚ uâ‚} D (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} D (@category_theory.category.to_category_struct.{vâ‚ uâ‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ D ğ’Ÿ F X) (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ D ğ’Ÿ G X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {obj : Type uâ‚} [c : category_theory.category_struct.{vâ‚ uâ‚} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{vâ‚ uâ‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} obj c) X Y â†’ @category_theory.has_hom.hom.{vâ‚ uâ‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} obj c) Y Z â†’ @category_theory.has_hom.hom.{vâ‚ uâ‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T A) A'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop â†’ name â†’ Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {obj : Type uâ‚} [c : category_theory.category_struct.{vâ‚ uâ‚} obj] (X : obj), @category_theory.has_hom.hom.{vâ‚ uâ‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} obj c) X X'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='orange'><a title='Gadget for automatic parameter support. This is similar to the opt_param gadget, but it uses
   the tactic declaration names tac_name to synthesize the argument.
   Like opt_param, this gadget only affects elaboration.
   For example, the tactic will *not* be invoked during type class resolution.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 36  (assoc&#x27; : ((Î¼_ T).app A â‰« a) = (T.map a â‰« a) . obviously)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='category_theory.monad.Î¼'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='T'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.nat_trans.app'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='A'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='auto_param'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='T'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/monad/basic.lean&#x27;, &#x27;line&#x27;: 16, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/name.lean&#x27;, &#x27;line&#x27;: 19, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='Î  {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] (T : @category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’) [c : @category_theory.monad.{vâ‚ uâ‚} C ğ’ T], @category_theory.has_hom.hom.{(max uâ‚ vâ‚) (max vâ‚ uâ‚)} (@category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’) (@category_theory.category_struct.to_has_hom.{(max uâ‚ vâ‚) (max vâ‚ uâ‚)} (@category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’) (@category_theory.category.to_category_struct.{(max uâ‚ vâ‚) (max vâ‚ uâ‚)} (@category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’) (@category_theory.functor.category.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’))) (@category_theory.functor.comp.{vâ‚ vâ‚ vâ‚ uâ‚ uâ‚ uâ‚} C ğ’ C ğ’ C ğ’ T T) T'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚} [ğ’Ÿ : category_theory.category.{vâ‚ uâ‚} D] {F G : @category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ D ğ’Ÿ}, @category_theory.nat_trans.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ D ğ’Ÿ F G â†’ Î  (X : C), @category_theory.has_hom.hom.{vâ‚ uâ‚} D (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} D (@category_theory.category.to_category_struct.{vâ‚ uâ‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ D ğ’Ÿ F X) (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ D ğ’Ÿ G X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {obj : Type uâ‚} [c : category_theory.category_struct.{vâ‚ uâ‚} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{vâ‚ uâ‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} obj c) X Y â†’ @category_theory.has_hom.hom.{vâ‚ uâ‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} obj c) Y Z â†’ @category_theory.has_hom.hom.{vâ‚ uâ‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T A) A'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Prop â†’ name â†’ Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  {C : Type uâ‚} [_inst_1 : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚} [_inst_2 : category_theory.category.{vâ‚ uâ‚} D] (c : @category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C _inst_1 D _inst_2) {X Y : C}, @category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C _inst_1)) X Y â†’ @category_theory.has_hom.hom.{vâ‚ uâ‚} D (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} D (@category_theory.category.to_category_struct.{vâ‚ uâ‚} D _inst_2)) (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C _inst_1 D _inst_2 c X) (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C _inst_1 D _inst_2 c Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T A) A'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {obj : Type uâ‚} [c : category_theory.category_struct.{vâ‚ uâ‚} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{vâ‚ uâ‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} obj c) X Y â†’ @category_theory.has_hom.hom.{vâ‚ uâ‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} obj c) Y Z â†’ @category_theory.has_hom.hom.{vâ‚ uâ‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T A) A'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='orange'><a title='Gadget for automatic parameter support. This is similar to the opt_param gadget, but it uses
   the tactic declaration names tac_name to synthesize the argument.
   Like opt_param, this gadget only affects elaboration.
   For example, the tactic will *not* be invoked during type class resolution.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 37  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 38  restate_axiom algebra.unit&#x27;</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 39  restate_axiom algebra.assoc&#x27;</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 40  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 41  namespace algebra</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 42  variables {T : C â¥¤ C} [monad.{vâ‚} T]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='T'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='_inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/monad/basic.lean&#x27;, &#x27;line&#x27;: 16, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='green'><a title='@category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@category_theory.monad.{vâ‚ uâ‚} C ğ’ T'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 43  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 44  @[ext] structure hom (A B : algebra T) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='blue'><a title='category_theory.monad.algebra'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='T'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='red'><a title='{&#x27;line&#x27;: 32, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='green'><a title='Î  {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] (T : @category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’) [_inst_1 : @category_theory.monad.{vâ‚ uâ‚} C ğ’ T], Type (max uâ‚ vâ‚)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='lemmas usable by `ext` tactic'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='An Eilenberg-Moore algebra for a monad `T`.
   cf Definition 5.2.3 in [Riehl][riehl2017].'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 45  (f : A.A âŸ¶ B.A)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='A'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.monad.algebra.A'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='B'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.monad.algebra.A'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 32, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 32, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] {T : @category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’} [_inst_1 : @category_theory.monad.{vâ‚ uâ‚} C ğ’ T], @category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1 â†’ C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {obj : Type uâ‚} [c : category_theory.has_hom.{vâ‚ uâ‚} obj], obj â†’ obj â†’ Type vâ‚'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] {T : @category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’} [_inst_1 : @category_theory.monad.{vâ‚ uâ‚} C ğ’ T], @category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1 â†’ C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 46  (h&#x27; : T.map f â‰« B.a = A.a â‰« f . obviously)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='T'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='B'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.monad.algebra.a'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='auto_param'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='A'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.monad.algebra.a'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 32, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/name.lean&#x27;, &#x27;line&#x27;: 19, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 32, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  {C : Type uâ‚} [_inst_1 : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚} [_inst_2 : category_theory.category.{vâ‚ uâ‚} D] (c : @category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C _inst_1 D _inst_2) {X Y : C}, @category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C _inst_1)) X Y â†’ @category_theory.has_hom.hom.{vâ‚ uâ‚} D (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} D (@category_theory.category.to_category_struct.{vâ‚ uâ‚} D _inst_2)) (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C _inst_1 D _inst_2 c X) (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C _inst_1 D _inst_2 c Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 A) (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 B)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {obj : Type uâ‚} [c : category_theory.category_struct.{vâ‚ uâ‚} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{vâ‚ uâ‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} obj c) X Y â†’ @category_theory.has_hom.hom.{vâ‚ uâ‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} obj c) Y Z â†’ @category_theory.has_hom.hom.{vâ‚ uâ‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] {T : @category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’} [_inst_1 : @category_theory.monad.{vâ‚ uâ‚} C ğ’ T] (c : @category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1), @category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 c)) (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 c)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop â†’ name â†’ Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] {T : @category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’} [_inst_1 : @category_theory.monad.{vâ‚ uâ‚} C ğ’ T] (c : @category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1), @category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 c)) (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 c)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {obj : Type uâ‚} [c : category_theory.category_struct.{vâ‚ uâ‚} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{vâ‚ uâ‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} obj c) X Y â†’ @category_theory.has_hom.hom.{vâ‚ uâ‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} obj c) Y Z â†’ @category_theory.has_hom.hom.{vâ‚ uâ‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 A) (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 B)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 A) (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 B)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title='Gadget for automatic parameter support. This is similar to the opt_param gadget, but it uses
   the tactic declaration names tac_name to synthesize the argument.
   Like opt_param, this gadget only affects elaboration.
   For example, the tactic will *not* be invoked during type class resolution.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
T : @category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’,
_inst_1 : @category_theory.monad.{vâ‚ uâ‚} C ğ’ T
âŠ¢ âˆ€ (X : @category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1),
    @eq.{vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 X)
         (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 X))
      (@category_theory.monad.algebra.hom.f.{vâ‚ uâ‚} C ğ’ T _inst_1 X X
         (@category_theory.category_struct.id.{vâ‚ (max uâ‚ vâ‚)}
            (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
            (@category_theory.category.to_category_struct.{vâ‚ (max uâ‚ vâ‚)}
               (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
               (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1))
            X))
      (@category_theory.category_struct.id.{vâ‚ uâ‚} C
         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
         (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 X))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 47  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 48  restate_axiom hom.h&#x27;</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 49  attribute [simp] hom.h</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='category_theory.monad.algebra.hom.h'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='green'><a title='âˆ€ {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] {T : @category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’} [_inst_1 : @category_theory.monad.{vâ‚ uâ‚} C ğ’ T] {A B : @category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1} (c : @category_theory.monad.algebra.hom.{vâ‚ uâ‚} C ğ’ T _inst_1 A B), @eq.{vâ‚+1} (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 A)) (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 B)) (@category_theory.category_struct.comp.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’) (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 A)) (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 B)) (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 B) (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 A) (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 B) (@category_theory.monad.algebra.hom.f.{vâ‚ uâ‚} C ğ’ T _inst_1 A B c)) (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 B)) (@category_theory.category_struct.comp.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’) (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 A)) (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 A) (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 B) (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 A) (@category_theory.monad.algebra.hom.f.{vâ‚ uâ‚} C ğ’ T _inst_1 A B c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 50  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 51  namespace hom</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 52  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 53  @[simps] def id (A : algebra T) : hom A A :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='blue'><a title='category_theory.monad.algebra'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='T'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='category_theory.monad.algebra.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='A'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='A'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='red'><a title='{&#x27;line&#x27;: 32, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='green'><a title='Î  {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] (T : @category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’) [_inst_1 : @category_theory.monad.{vâ‚ uâ‚} C ğ’ T], Type (max uâ‚ vâ‚)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Î  {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] {T : @category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’} [_inst_1 : @category_theory.monad.{vâ‚ uâ‚} C ğ’ T], @category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1 â†’ @category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1 â†’ Type vâ‚'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Automatically derive lemmas specifying the projections of this declaration.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='An Eilenberg-Moore algebra for a monad `T`.
   cf Definition 5.2.3 in [Riehl][riehl2017].'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 54  { f := ğŸ™ A.A }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='obviously'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='category_theory.category_struct.id'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='A'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.monad.algebra.A'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 32, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Î  {obj : Type uâ‚} [c : category_theory.category_struct.{vâ‚ uâ‚} obj] (X : obj), @category_theory.has_hom.hom.{vâ‚ uâ‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} obj c) X X'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] {T : @category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’} [_inst_1 : @category_theory.monad.{vâ‚ uâ‚} C ğ’ T], @category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1 â†’ C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `obviously` tactic is a &quot;replaceable&quot; tactic, which means that its meaning is defined by tactics that are defined later with the `@[obviously]` attribute. It is intended for use with `auto_param`s for structure fields.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 55  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 56  @[simps] def comp {P Q R : algebra T} (f : hom P Q) (g : hom Q R) : hom P R :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='blue'><a title='category_theory.monad.algebra'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='T'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='category_theory.monad.algebra.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='P'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Q'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='category_theory.monad.algebra.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Q'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='category_theory.monad.algebra.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='P'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='red'><a title='{&#x27;line&#x27;: 32, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='green'><a title='Î  {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] (T : @category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’) [_inst_1 : @category_theory.monad.{vâ‚ uâ‚} C ğ’ T], Type (max uâ‚ vâ‚)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Î  {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] {T : @category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’} [_inst_1 : @category_theory.monad.{vâ‚ uâ‚} C ğ’ T], @category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1 â†’ @category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1 â†’ Type vâ‚'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Î  {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] {T : @category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’} [_inst_1 : @category_theory.monad.{vâ‚ uâ‚} C ğ’ T], @category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1 â†’ @category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1 â†’ Type vâ‚'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Î  {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] {T : @category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’} [_inst_1 : @category_theory.monad.{vâ‚ uâ‚} C ğ’ T], @category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1 â†’ @category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1 â†’ Type vâ‚'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Automatically derive lemmas specifying the projections of this declaration.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title='An Eilenberg-Moore algebra for a monad `T`.
   cf Definition 5.2.3 in [Riehl][riehl2017].'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 57  { f := f.f â‰« g.f,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.monad.algebra.hom.f'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.monad.algebra.hom.f'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@category_theory.monad.algebra.hom.{vâ‚ uâ‚} C ğ’ T _inst_1 P Q'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] {T : @category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’} [_inst_1 : @category_theory.monad.{vâ‚ uâ‚} C ğ’ T] {A B : @category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1}, @category_theory.monad.algebra.hom.{vâ‚ uâ‚} C ğ’ T _inst_1 A B â†’ @category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 A) (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 B)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {obj : Type uâ‚} [c : category_theory.category_struct.{vâ‚ uâ‚} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{vâ‚ uâ‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} obj c) X Y â†’ @category_theory.has_hom.hom.{vâ‚ uâ‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} obj c) Y Z â†’ @category_theory.has_hom.hom.{vâ‚ uâ‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.monad.algebra.hom.{vâ‚ uâ‚} C ğ’ T _inst_1 Q R'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] {T : @category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’} [_inst_1 : @category_theory.monad.{vâ‚ uâ‚} C ğ’ T] {A B : @category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1}, @category_theory.monad.algebra.hom.{vâ‚ uâ‚} C ğ’ T _inst_1 A B â†’ @category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 A) (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 B)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 58    h&#x27; := by rw [functor.map_comp, category.assoc, g.h, â†category.assoc, f.h, category.assoc] }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='category_theory.functor.map_comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.category.assoc'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='category_theory.category.assoc'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='category_theory.category.assoc'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (Î» (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='âˆ€ {C : Type uâ‚} [_inst_1 : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚} [_inst_2 : category_theory.category.{vâ‚ uâ‚} D] (c : @category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C _inst_1 D _inst_2) {X Y Z : C} (f : @category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C _inst_1)) X Y) (g : @category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C _inst_1)) Y Z), @eq.{vâ‚+1} (@category_theory.has_hom.hom.{vâ‚ uâ‚} D (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} D (@category_theory.category.to_category_struct.{vâ‚ uâ‚} D _inst_2)) (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C _inst_1 D _inst_2 c X) (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C _inst_1 D _inst_2 c Z)) (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C _inst_1 D _inst_2 c X Z (@category_theory.category_struct.comp.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C _inst_1) X Y Z f g)) (@category_theory.category_struct.comp.{vâ‚ uâ‚} D (@category_theory.category.to_category_struct.{vâ‚ uâ‚} D _inst_2) (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C _inst_1 D _inst_2 c X) (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C _inst_1 D _inst_2 c Y) (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C _inst_1 D _inst_2 c Z) (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C _inst_1 D _inst_2 c X Y f) (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C _inst_1 D _inst_2 c Y Z g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (Î» (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='âˆ€ (obj : Type uâ‚) [c : category_theory.category.{vâ‚ uâ‚} obj] {W X Y Z : obj} (f : @category_theory.has_hom.hom.{vâ‚ uâ‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} obj (@category_theory.category.to_category_struct.{vâ‚ uâ‚} obj c)) W X) (g : @category_theory.has_hom.hom.{vâ‚ uâ‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} obj (@category_theory.category.to_category_struct.{vâ‚ uâ‚} obj c)) X Y) (h : @category_theory.has_hom.hom.{vâ‚ uâ‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} obj (@category_theory.category.to_category_struct.{vâ‚ uâ‚} obj c)) Y Z), @eq.{vâ‚+1} (@category_theory.has_hom.hom.{vâ‚ uâ‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} obj (@category_theory.category.to_category_struct.{vâ‚ uâ‚} obj c)) W Z) (@category_theory.category_struct.comp.{vâ‚ uâ‚} obj (@category_theory.category.to_category_struct.{vâ‚ uâ‚} obj c) W Y Z (@category_theory.category_struct.comp.{vâ‚ uâ‚} obj (@category_theory.category.to_category_struct.{vâ‚ uâ‚} obj c) W X Y f g) h) (@category_theory.category_struct.comp.{vâ‚ uâ‚} obj (@category_theory.category.to_category_struct.{vâ‚ uâ‚} obj c) W X Z f (@category_theory.category_struct.comp.{vâ‚ uâ‚} obj (@category_theory.category.to_category_struct.{vâ‚ uâ‚} obj c) X Y Z g h))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (Î» (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{vâ‚+1} (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Q)) (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 R)) (@category_theory.category_struct.comp.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’) (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Q)) (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 R)) (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 R) (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Q) (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 R) (@category_theory.monad.algebra.hom.f.{vâ‚ uâ‚} C ğ’ T _inst_1 Q R g)) (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 R)) (@category_theory.category_struct.comp.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’) (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Q)) (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Q) (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 R) (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 Q) (@category_theory.monad.algebra.hom.f.{vâ‚ uâ‚} C ğ’ T _inst_1 Q R g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (Î» (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='âˆ€ (obj : Type uâ‚) [c : category_theory.category.{vâ‚ uâ‚} obj] {W X Y Z : obj} (f : @category_theory.has_hom.hom.{vâ‚ uâ‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} obj (@category_theory.category.to_category_struct.{vâ‚ uâ‚} obj c)) W X) (g : @category_theory.has_hom.hom.{vâ‚ uâ‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} obj (@category_theory.category.to_category_struct.{vâ‚ uâ‚} obj c)) X Y) (h : @category_theory.has_hom.hom.{vâ‚ uâ‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} obj (@category_theory.category.to_category_struct.{vâ‚ uâ‚} obj c)) Y Z), @eq.{vâ‚+1} (@category_theory.has_hom.hom.{vâ‚ uâ‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} obj (@category_theory.category.to_category_struct.{vâ‚ uâ‚} obj c)) W Z) (@category_theory.category_struct.comp.{vâ‚ uâ‚} obj (@category_theory.category.to_category_struct.{vâ‚ uâ‚} obj c) W Y Z (@category_theory.category_struct.comp.{vâ‚ uâ‚} obj (@category_theory.category.to_category_struct.{vâ‚ uâ‚} obj c) W X Y f g) h) (@category_theory.category_struct.comp.{vâ‚ uâ‚} obj (@category_theory.category.to_category_struct.{vâ‚ uâ‚} obj c) W X Z f (@category_theory.category_struct.comp.{vâ‚ uâ‚} obj (@category_theory.category.to_category_struct.{vâ‚ uâ‚} obj c) X Y Z g h))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (Î» (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{vâ‚+1} (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 P)) (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Q)) (@category_theory.category_struct.comp.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’) (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 P)) (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Q)) (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Q) (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 P) (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Q) (@category_theory.monad.algebra.hom.f.{vâ‚ uâ‚} C ğ’ T _inst_1 P Q f)) (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 Q)) (@category_theory.category_struct.comp.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’) (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 P)) (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 P) (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Q) (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 P) (@category_theory.monad.algebra.hom.f.{vâ‚ uâ‚} C ğ’ T _inst_1 P Q f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (Î» (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='âˆ€ (obj : Type uâ‚) [c : category_theory.category.{vâ‚ uâ‚} obj] {W X Y Z : obj} (f : @category_theory.has_hom.hom.{vâ‚ uâ‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} obj (@category_theory.category.to_category_struct.{vâ‚ uâ‚} obj c)) W X) (g : @category_theory.has_hom.hom.{vâ‚ uâ‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} obj (@category_theory.category.to_category_struct.{vâ‚ uâ‚} obj c)) X Y) (h : @category_theory.has_hom.hom.{vâ‚ uâ‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} obj (@category_theory.category.to_category_struct.{vâ‚ uâ‚} obj c)) Y Z), @eq.{vâ‚+1} (@category_theory.has_hom.hom.{vâ‚ uâ‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} obj (@category_theory.category.to_category_struct.{vâ‚ uâ‚} obj c)) W Z) (@category_theory.category_struct.comp.{vâ‚ uâ‚} obj (@category_theory.category.to_category_struct.{vâ‚ uâ‚} obj c) W Y Z (@category_theory.category_struct.comp.{vâ‚ uâ‚} obj (@category_theory.category.to_category_struct.{vâ‚ uâ‚} obj c) W X Y f g) h) (@category_theory.category_struct.comp.{vâ‚ uâ‚} obj (@category_theory.category.to_category_struct.{vâ‚ uâ‚} obj c) W X Z f (@category_theory.category_struct.comp.{vâ‚ uâ‚} obj (@category_theory.category.to_category_struct.{vâ‚ uâ‚} obj c) X Y Z g h))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (Î» (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;([ (â†? expr), ... ] | â†? expr)&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;([ (â†? expr), ... ] | â†? expr)&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;([ (â†? expr), ... ] | â†? expr)&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (â†? expr), ... ] | â†? expr)&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;([ (â†? expr), ... ] | â†? expr)&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (â†? expr), ... ] | â†? expr)&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;([ (â†? expr), ... ] | â†? expr)&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
T : @category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’,
_inst_1 : @category_theory.monad.{vâ‚ uâ‚} C ğ’ T,
P Q R : @category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1,
f : @category_theory.monad.algebra.hom.{vâ‚ uâ‚} C ğ’ T _inst_1 P Q,
g : @category_theory.monad.algebra.hom.{vâ‚ uâ‚} C ğ’ T _inst_1 Q R
âŠ¢ @eq.{vâ‚+1}
    (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
       (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
          (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 P))
       (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 R))
    (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
          (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 P))
       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
          (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 R))
       (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 R)
       (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
          (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 P)
          (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 R)
          (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
             (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
             (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 P)
             (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Q)
             (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 R)
             (@category_theory.monad.algebra.hom.f.{vâ‚ uâ‚} C ğ’ T _inst_1 P Q f)
             (@category_theory.monad.algebra.hom.f.{vâ‚ uâ‚} C ğ’ T _inst_1 Q R g)))
       (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 R))
    (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
          (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 P))
       (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 P)
       (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 R)
       (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 P)
       (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
          (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 P)
          (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Q)
          (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 R)
          (@category_theory.monad.algebra.hom.f.{vâ‚ uâ‚} C ğ’ T _inst_1 P Q f)
          (@category_theory.monad.algebra.hom.f.{vâ‚ uâ‚} C ğ’ T _inst_1 Q R g)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
T : @category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’,
_inst_1 : @category_theory.monad.{vâ‚ uâ‚} C ğ’ T,
P Q R : @category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1,
f : @category_theory.monad.algebra.hom.{vâ‚ uâ‚} C ğ’ T _inst_1 P Q,
g : @category_theory.monad.algebra.hom.{vâ‚ uâ‚} C ğ’ T _inst_1 Q R
âŠ¢ @eq.{vâ‚+1}
    (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
       (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
          (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 P))
       (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 R))
    (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
          (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 P))
       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
          (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 R))
       (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 R)
       (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
             (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 P))
          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
             (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Q))
          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
             (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 R))
          (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
             (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 P)
             (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Q)
             (@category_theory.monad.algebra.hom.f.{vâ‚ uâ‚} C ğ’ T _inst_1 P Q f))
          (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
             (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Q)
             (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 R)
             (@category_theory.monad.algebra.hom.f.{vâ‚ uâ‚} C ğ’ T _inst_1 Q R g)))
       (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 R))
    (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
          (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 P))
       (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 P)
       (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 R)
       (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 P)
       (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
          (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 P)
          (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Q)
          (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 R)
          (@category_theory.monad.algebra.hom.f.{vâ‚ uâ‚} C ğ’ T _inst_1 P Q f)
          (@category_theory.monad.algebra.hom.f.{vâ‚ uâ‚} C ğ’ T _inst_1 Q R g)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
T : @category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’,
_inst_1 : @category_theory.monad.{vâ‚ uâ‚} C ğ’ T,
P Q R : @category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1,
f : @category_theory.monad.algebra.hom.{vâ‚ uâ‚} C ğ’ T _inst_1 P Q,
g : @category_theory.monad.algebra.hom.{vâ‚ uâ‚} C ğ’ T _inst_1 Q R
âŠ¢ @eq.{vâ‚+1}
    (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
       (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
          (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 P))
       (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 R))
    (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
          (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 P))
       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
          (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Q))
       (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 R)
       (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
          (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 P)
          (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Q)
          (@category_theory.monad.algebra.hom.f.{vâ‚ uâ‚} C ğ’ T _inst_1 P Q f))
       (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
             (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Q))
          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
             (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 R))
          (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 R)
          (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
             (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Q)
             (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 R)
             (@category_theory.monad.algebra.hom.f.{vâ‚ uâ‚} C ğ’ T _inst_1 Q R g))
          (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 R)))
    (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
          (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 P))
       (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 P)
       (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 R)
       (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 P)
       (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
          (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 P)
          (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Q)
          (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 R)
          (@category_theory.monad.algebra.hom.f.{vâ‚ uâ‚} C ğ’ T _inst_1 P Q f)
          (@category_theory.monad.algebra.hom.f.{vâ‚ uâ‚} C ğ’ T _inst_1 Q R g)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
T : @category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’,
_inst_1 : @category_theory.monad.{vâ‚ uâ‚} C ğ’ T,
P Q R : @category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1,
f : @category_theory.monad.algebra.hom.{vâ‚ uâ‚} C ğ’ T _inst_1 P Q,
g : @category_theory.monad.algebra.hom.{vâ‚ uâ‚} C ğ’ T _inst_1 Q R
âŠ¢ @eq.{vâ‚+1}
    (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
       (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
          (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 P))
       (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 R))
    (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
          (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 P))
       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
          (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Q))
       (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 R)
       (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
          (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 P)
          (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Q)
          (@category_theory.monad.algebra.hom.f.{vâ‚ uâ‚} C ğ’ T _inst_1 P Q f))
       (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
             (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Q))
          (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Q)
          (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 R)
          (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 Q)
          (@category_theory.monad.algebra.hom.f.{vâ‚ uâ‚} C ğ’ T _inst_1 Q R g)))
    (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
          (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 P))
       (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 P)
       (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 R)
       (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 P)
       (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
          (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 P)
          (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Q)
          (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 R)
          (@category_theory.monad.algebra.hom.f.{vâ‚ uâ‚} C ğ’ T _inst_1 P Q f)
          (@category_theory.monad.algebra.hom.f.{vâ‚ uâ‚} C ğ’ T _inst_1 Q R g)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
T : @category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’,
_inst_1 : @category_theory.monad.{vâ‚ uâ‚} C ğ’ T,
P Q R : @category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1,
f : @category_theory.monad.algebra.hom.{vâ‚ uâ‚} C ğ’ T _inst_1 P Q,
g : @category_theory.monad.algebra.hom.{vâ‚ uâ‚} C ğ’ T _inst_1 Q R
âŠ¢ @eq.{vâ‚+1}
    (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
       (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
          (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 P))
       (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 R))
    (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
          (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 P))
       (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Q)
       (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 R)
       (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
             (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 P))
          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
             (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Q))
          (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Q)
          (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
             (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 P)
             (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Q)
             (@category_theory.monad.algebra.hom.f.{vâ‚ uâ‚} C ğ’ T _inst_1 P Q f))
          (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 Q))
       (@category_theory.monad.algebra.hom.f.{vâ‚ uâ‚} C ğ’ T _inst_1 Q R g))
    (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
          (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 P))
       (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 P)
       (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 R)
       (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 P)
       (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
          (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 P)
          (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Q)
          (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 R)
          (@category_theory.monad.algebra.hom.f.{vâ‚ uâ‚} C ğ’ T _inst_1 P Q f)
          (@category_theory.monad.algebra.hom.f.{vâ‚ uâ‚} C ğ’ T _inst_1 Q R g)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
T : @category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’,
_inst_1 : @category_theory.monad.{vâ‚ uâ‚} C ğ’ T,
P Q R : @category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1,
f : @category_theory.monad.algebra.hom.{vâ‚ uâ‚} C ğ’ T _inst_1 P Q,
g : @category_theory.monad.algebra.hom.{vâ‚ uâ‚} C ğ’ T _inst_1 Q R
âŠ¢ @eq.{vâ‚+1}
    (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
       (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
          (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 P))
       (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 R))
    (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
          (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 P))
       (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Q)
       (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 R)
       (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
             (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 P))
          (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 P)
          (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Q)
          (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 P)
          (@category_theory.monad.algebra.hom.f.{vâ‚ uâ‚} C ğ’ T _inst_1 P Q f))
       (@category_theory.monad.algebra.hom.f.{vâ‚ uâ‚} C ğ’ T _inst_1 Q R g))
    (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
          (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 P))
       (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 P)
       (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 R)
       (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 P)
       (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
          (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 P)
          (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Q)
          (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 R)
          (@category_theory.monad.algebra.hom.f.{vâ‚ uâ‚} C ğ’ T _inst_1 P Q f)
          (@category_theory.monad.algebra.hom.f.{vâ‚ uâ‚} C ğ’ T _inst_1 Q R g)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
T : @category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’,
_inst_1 : @category_theory.monad.{vâ‚ uâ‚} C ğ’ T,
P Q R : @category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1,
f : @category_theory.monad.algebra.hom.{vâ‚ uâ‚} C ğ’ T _inst_1 P Q,
g : @category_theory.monad.algebra.hom.{vâ‚ uâ‚} C ğ’ T _inst_1 Q R
âŠ¢ @eq.{vâ‚+1}
    (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
       (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
          (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 P))
       (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 R))
    (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
          (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 P))
       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
          (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 R))
       (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 R)
       (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
          (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 P)
          (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 R)
          (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
             (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
             (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 P)
             (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Q)
             (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 R)
             (@category_theory.monad.algebra.hom.f.{vâ‚ uâ‚} C ğ’ T _inst_1 P Q f)
             (@category_theory.monad.algebra.hom.f.{vâ‚ uâ‚} C ğ’ T _inst_1 Q R g)))
       (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 R))
    (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
          (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 P))
       (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 P)
       (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 R)
       (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 P)
       (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
          (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 P)
          (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Q)
          (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 R)
          (@category_theory.monad.algebra.hom.f.{vâ‚ uâ‚} C ğ’ T _inst_1 P Q f)
          (@category_theory.monad.algebra.hom.f.{vâ‚ uâ‚} C ğ’ T _inst_1 Q R g)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 59  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 60  end hom</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 61  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 62  /-- The category of Eilenberg-Moore algebras for a monad.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 63      cf Definition 5.2.4 in [Riehl][riehl2017]. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 64  @[simps] instance EilenbergMoore : category (algebra T) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='blue'><a title='category_theory.category'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.monad.algebra'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='T'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 61, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 32, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='green'><a title='Type u â†’ Type (max u (v+1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Î  {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] (T : @category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’) [_inst_1 : @category_theory.monad.{vâ‚ uâ‚} C ğ’ T], Type (max uâ‚ vâ‚)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Automatically derive lemmas specifying the projections of this declaration.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='orange'><a title='The typeclass `category C` describes morphisms associated to objects of type `C`.
The universe levels of the objects and morphisms are unconstrained, and will often need to be
specified explicitly, as `category.{v} C`. (See also `large_category` and `small_category`.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An Eilenberg-Moore algebra for a monad `T`.
   cf Definition 5.2.3 in [Riehl][riehl2017].'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 65  { hom := hom,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='obviously'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='category_theory.monad.algebra.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Î  {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] {T : @category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’} [_inst_1 : @category_theory.monad.{vâ‚ uâ‚} C ğ’ T], @category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1 â†’ @category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1 â†’ Type vâ‚'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `obviously` tactic is a &quot;replaceable&quot; tactic, which means that its meaning is defined by tactics that are defined later with the `@[obviously]` attribute. It is intended for use with `auto_param`s for structure fields.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 66    id := hom.id,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='category_theory.monad.algebra.hom.id'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;line&#x27;: 53, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Î  {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] {T : @category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’} [_inst_1 : @category_theory.monad.{vâ‚ uâ‚} C ğ’ T] (A : @category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1), @category_theory.monad.algebra.hom.{vâ‚ uâ‚} C ğ’ T _inst_1 A A'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 67    comp := @hom.comp _ _ _ _ }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='category_theory.monad.algebra.hom.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;line&#x27;: 56, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Î  {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] {T : @category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’} [_inst_1 : @category_theory.monad.{vâ‚ uâ‚} C ğ’ T] {P Q R : @category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1}, @category_theory.monad.algebra.hom.{vâ‚ uâ‚} C ğ’ T _inst_1 P Q â†’ @category_theory.monad.algebra.hom.{vâ‚ uâ‚} C ğ’ T _inst_1 Q R â†’ @category_theory.monad.algebra.hom.{vâ‚ uâ‚} C ğ’ T _inst_1 P R'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 68  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 69  end algebra</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 70  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 71  variables (T : C â¥¤ C) [monad.{vâ‚} T]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='category_theory.monad'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/monad/basic.lean&#x27;, &#x27;line&#x27;: 16, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='green'><a title='Î  (C : Type uâ‚) [_inst_1 : category_theory.category.{vâ‚ uâ‚} C] (D : Type uâ‚) [_inst_2 : category_theory.category.{vâ‚ uâ‚} D], Type (max vâ‚ uâ‚)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Î  {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C], @category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ â†’ Type (max uâ‚ vâ‚)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 72  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 73  @[simps] def forget : algebra T â¥¤ C :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='blue'><a title='category_theory.monad.algebra'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='T'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='red'><a title='{&#x27;line&#x27;: 32, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='green'><a title='Î  {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] (T : @category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’) [_inst_1 : @category_theory.monad.{vâ‚ uâ‚} C ğ’ T], Type (max uâ‚ vâ‚)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  (C : Type (max uâ‚ vâ‚)) [_inst_1 : category_theory.category.{vâ‚ (max uâ‚ vâ‚)} C] (D : Type uâ‚) [_inst_2 : category_theory.category.{vâ‚ uâ‚} D], Type (max uâ‚ vâ‚)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type uâ‚'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Automatically derive lemmas specifying the projections of this declaration.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='An Eilenberg-Moore algebra for a monad `T`.
   cf Definition 5.2.3 in [Riehl][riehl2017].'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 74  { obj := Î» A, A.A,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='obviously'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='A'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='A'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.monad.algebra.A'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;line&#x27;: 32, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] {T : @category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’} [_inst_1 : @category_theory.monad.{vâ‚ uâ‚} C ğ’ T], @category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1 â†’ C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `obviously` tactic is a &quot;replaceable&quot; tactic, which means that its meaning is defined by tactics that are defined later with the `@[obviously]` attribute. It is intended for use with `auto_param`s for structure fields.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 75    map := Î» A B f, f.f }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='A'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='B'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.monad.algebra.hom.f'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='red'><a title='{&#x27;line&#x27;: 44, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{vâ‚ (max uâ‚ vâ‚)} (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1) (@category_theory.category_struct.to_has_hom.{vâ‚ (max uâ‚ vâ‚)} (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1) (@category_theory.category.to_category_struct.{vâ‚ (max uâ‚ vâ‚)} (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1))) A B'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.has_hom.hom.{vâ‚ (max uâ‚ vâ‚)} (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1) (@category_theory.category_struct.to_has_hom.{vâ‚ (max uâ‚ vâ‚)} (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1) (@category_theory.category.to_category_struct.{vâ‚ (max uâ‚ vâ‚)} (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1))) A B'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] {T : @category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’} [_inst_1 : @category_theory.monad.{vâ‚ uâ‚} C ğ’ T] {A B : @category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1}, @category_theory.monad.algebra.hom.{vâ‚ uâ‚} C ğ’ T _inst_1 A B â†’ @category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 A) (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 B)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 76  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 77  @[simps] def free : C â¥¤ algebra T :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.monad.algebra'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='T'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 32, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='green'><a title='Type uâ‚'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  (C : Type uâ‚) [_inst_1 : category_theory.category.{vâ‚ uâ‚} C] (D : Type (max uâ‚ vâ‚)) [_inst_2 : category_theory.category.{vâ‚ (max uâ‚ vâ‚)} D], Type (max uâ‚ vâ‚)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] (T : @category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’) [_inst_1 : @category_theory.monad.{vâ‚ uâ‚} C ğ’ T], Type (max uâ‚ vâ‚)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Automatically derive lemmas specifying the projections of this declaration.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An Eilenberg-Moore algebra for a monad `T`.
   cf Definition 5.2.3 in [Riehl][riehl2017].'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 78  { obj := Î» X,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='obviously'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `obviously` tactic is a &quot;replaceable&quot; tactic, which means that its meaning is defined by tactics that are defined later with the `@[obviously]` attribute. It is intended for use with `auto_param`s for structure fields.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 79    { A := T.obj X,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='obviously'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='T'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  {C : Type uâ‚} [_inst_1 : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚} [_inst_2 : category_theory.category.{vâ‚ uâ‚} D], @category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C _inst_1 D _inst_2 â†’ C â†’ D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `obviously` tactic is a &quot;replaceable&quot; tactic, which means that its meaning is defined by tactics that are defined later with the `@[obviously]` attribute. It is intended for use with `auto_param`s for structure fields.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 80      a := (Î¼_ T).app X,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='category_theory.monad.Î¼'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='T'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.nat_trans.app'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/monad/basic.lean&#x27;, &#x27;line&#x27;: 16, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='Î  {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] (T : @category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’) [c : @category_theory.monad.{vâ‚ uâ‚} C ğ’ T], @category_theory.has_hom.hom.{(max uâ‚ vâ‚) (max vâ‚ uâ‚)} (@category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’) (@category_theory.category_struct.to_has_hom.{(max uâ‚ vâ‚) (max vâ‚ uâ‚)} (@category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’) (@category_theory.category.to_category_struct.{(max uâ‚ vâ‚) (max vâ‚ uâ‚)} (@category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’) (@category_theory.functor.category.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’))) (@category_theory.functor.comp.{vâ‚ vâ‚ vâ‚ uâ‚ uâ‚ uâ‚} C ğ’ C ğ’ C ğ’ T T) T'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚} [ğ’Ÿ : category_theory.category.{vâ‚ uâ‚} D] {F G : @category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ D ğ’Ÿ}, @category_theory.nat_trans.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ D ğ’Ÿ F G â†’ Î  (X : C), @category_theory.has_hom.hom.{vâ‚ uâ‚} D (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} D (@category_theory.category.to_category_struct.{vâ‚ uâ‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ D ğ’Ÿ F X) (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ D ğ’Ÿ G X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 81      assoc&#x27; := (monad.assoc T _).symm },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='category_theory.monad.assoc'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='T'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='eq.symm'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/monad/basic.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 198, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='green'><a title='âˆ€ {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] (T : @category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’) [c : @category_theory.monad.{vâ‚ uâ‚} C ğ’ T] (X : C), @eq.{vâ‚+1} (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))) (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)) (@category_theory.category_struct.comp.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’) (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))) (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)) (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X) (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)) (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X) (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ (@category_theory.functor.comp.{vâ‚ vâ‚ vâ‚ uâ‚ uâ‚ uâ‚} C ğ’ C ğ’ C ğ’ T T) T (@category_theory.monad.Î¼.{vâ‚ uâ‚} C ğ’ T c) X)) (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ (@category_theory.functor.comp.{vâ‚ vâ‚ vâ‚ uâ‚ uâ‚ uâ‚} C ğ’ C ğ’ C ğ’ T T) T (@category_theory.monad.Î¼.{vâ‚ uâ‚} C ğ’ T c) X)) (@category_theory.category_struct.comp.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’) (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))) (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)) (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X) (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ (@category_theory.functor.comp.{vâ‚ vâ‚ vâ‚ uâ‚ uâ‚ uâ‚} C ğ’ C ğ’ C ğ’ T T) T (@category_theory.monad.Î¼.{vâ‚ uâ‚} C ğ’ T c) (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)) (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ (@category_theory.functor.comp.{vâ‚ vâ‚ vâ‚ uâ‚ uâ‚ uâ‚} C ğ’ C ğ’ C ğ’ T T) T (@category_theory.monad.Î¼.{vâ‚ uâ‚} C ğ’ T c) X))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='âˆ€ {Î± : Type vâ‚} {a b : Î±}, @eq.{vâ‚+1} Î± a b â†’ @eq.{vâ‚+1} Î± b a'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 82    map := Î» X Y f,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 83    { f := T.map f,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='T'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='@category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  {C : Type uâ‚} [_inst_1 : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚} [_inst_2 : category_theory.category.{vâ‚ uâ‚} D] (c : @category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C _inst_1 D _inst_2) {X Y : C}, @category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C _inst_1)) X Y â†’ @category_theory.has_hom.hom.{vâ‚ uâ‚} D (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} D (@category_theory.category.to_category_struct.{vâ‚ uâ‚} D _inst_2)) (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C _inst_1 D _inst_2 c X) (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C _inst_1 D _inst_2 c Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 84      h&#x27; := by erw (Î¼_ T).naturality } }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='blue'><a title='category_theory.monad.Î¼'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='T'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/monad/basic.lean&#x27;, &#x27;line&#x27;: 16, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (Î» (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] (T : @category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’) [c : @category_theory.monad.{vâ‚ uâ‚} C ğ’ T], @category_theory.has_hom.hom.{(max uâ‚ vâ‚) (max vâ‚ uâ‚)} (@category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’) (@category_theory.category_struct.to_has_hom.{(max uâ‚ vâ‚) (max vâ‚ uâ‚)} (@category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’) (@category_theory.category.to_category_struct.{(max uâ‚ vâ‚) (max vâ‚ uâ‚)} (@category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’) (@category_theory.functor.category.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’))) (@category_theory.functor.comp.{vâ‚ vâ‚ vâ‚ uâ‚ uâ‚ uâ‚} C ğ’ C ğ’ C ğ’ T T) T'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (Î» (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (Î» (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;([ (â†? expr), ... ] | â†? expr)&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (â†? expr), ... ] | â†? expr)&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (â†? expr), ... ] | â†? expr)&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
T : @category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’,
_inst_1 : @category_theory.monad.{vâ‚ uâ‚} C ğ’ T,
X Y : C,
f :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X
    Y
âŠ¢ @eq.{vâ‚+1}
    (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
       (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
          (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1
             (@category_theory.monad.algebra.mk.{vâ‚ uâ‚} C ğ’ T _inst_1
                (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                   (@category_theory.functor.comp.{vâ‚ vâ‚ vâ‚ uâ‚ uâ‚ uâ‚} C ğ’ C ğ’ C ğ’ T T)
                   T
                   (@category_theory.monad.Î¼.{vâ‚ uâ‚} C ğ’ T _inst_1)
                   X)
                (@id.{0}
                   (âˆ€ (X : C),
                      @eq.{vâ‚+1}
                        (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                           (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                              (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                           (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                              (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                              (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                           (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                        (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                           (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                           (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                              (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                              (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                           (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                              (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                           (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                           (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                              (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                              T
                              (@category_theory.monad.Î·.{vâ‚ uâ‚} C ğ’ T _inst_1)
                              (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                           (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                              (@category_theory.functor.comp.{vâ‚ vâ‚ vâ‚ uâ‚ uâ‚ uâ‚} C ğ’ C ğ’ C ğ’ T T)
                              T
                              (@category_theory.monad.Î¼.{vâ‚ uâ‚} C ğ’ T _inst_1)
                              X))
                        (@category_theory.category_struct.id.{vâ‚ uâ‚} C
                           (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                           (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)))
                   (Î» (X : C),
                      @eq.mpr.{0}
                        (@eq.{vâ‚+1}
                           (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                              (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                 (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                              (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                              (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                           (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                              (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                              (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                              (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                 (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                              (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                              (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                 (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                                 T
                                 (@category_theory.monad.Î·.{vâ‚ uâ‚} C ğ’ T _inst_1)
                                 (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                              (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                 (@category_theory.functor.comp.{vâ‚ vâ‚ vâ‚ uâ‚ uâ‚ uâ‚} C ğ’ C ğ’ C ğ’ T
                                    T)
                                 T
                                 (@category_theory.monad.Î¼.{vâ‚ uâ‚} C ğ’ T _inst_1)
                                 X))
                           (@category_theory.category_struct.id.{vâ‚ uâ‚} C
                              (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                              (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)))
                        true
                        (@id.{0}
                           (@eq.{1} Prop
                              (@eq.{vâ‚+1}
                                 (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                    (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                                    (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                                 (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                                    (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                                    (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                                    (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                                    (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                                    (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                       (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                                       T
                                       (@category_theory.monad.Î·.{vâ‚ uâ‚} C ğ’ T _inst_1)
                                       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                                    (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                       (@category_theory.functor.comp.{vâ‚ vâ‚ vâ‚ uâ‚ uâ‚ uâ‚} C ğ’ C ğ’ C
                                          ğ’
                                          T
                                          T)
                                       T
                                       (@category_theory.monad.Î¼.{vâ‚ uâ‚} C ğ’ T _inst_1)
                                       X))
                                 (@category_theory.category_struct.id.{vâ‚ uâ‚} C
                                    (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                                    (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)))
                              true)
                           (@eq.trans.{1} Prop
                              (@eq.{vâ‚+1}
                                 (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                    (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                                    (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                                 (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                                    (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                                    (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                                    (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                                    (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                                    (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                       (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                                       T
                                       (@category_theory.monad.Î·.{vâ‚ uâ‚} C ğ’ T _inst_1)
                                       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                                    (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                       (@category_theory.functor.comp.{vâ‚ vâ‚ vâ‚ uâ‚ uâ‚ uâ‚} C ğ’ C ğ’ C
                                          ğ’
                                          T
                                          T)
                                       T
                                       (@category_theory.monad.Î¼.{vâ‚ uâ‚} C ğ’ T _inst_1)
                                       X))
                                 (@category_theory.category_struct.id.{vâ‚ uâ‚} C
                                    (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                                    (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)))
                              (@eq.{vâ‚+1}
                                 (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                    (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                                    (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                                 (@category_theory.category_struct.id.{vâ‚ uâ‚} C
                                    (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                                    (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                                 (@category_theory.category_struct.id.{vâ‚ uâ‚} C
                                    (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                                    (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)))
                              true
                              ((Î»
                                (a a_1 :
                                  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                    (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                                    (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                                (e_1 :
                                  @eq.{vâ‚+1}
                                    (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                       (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                                       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                                    a
                                    a_1)
                                (a_2 a_3 :
                                  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                    (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                                    (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                                (e_2 :
                                  @eq.{vâ‚+1}
                                    (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                       (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                                       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                                    a_2
                                    a_3),
                                  @congr.{vâ‚+1 1}
                                    (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                       (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                                       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                                    Prop
                                    (@eq.{vâ‚+1}
                                       (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                          (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                             (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                                          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                                       a)
                                    (@eq.{vâ‚+1}
                                       (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                          (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                             (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                                          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                                       a_1)
                                    a_2
                                    a_3
                                    (@congr_arg.{vâ‚+1 (max (vâ‚+1) 1)}
                                       (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                          (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                             (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                                          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                                       (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                          (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                             (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                                          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X) â†’
                                        Prop)
                                       a
                                       a_1
                                       (@eq.{vâ‚+1}
                                          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                             (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                                             (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)))
                                       e_1)
                                    e_2)
                                 (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                                    (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                                    (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                                    (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                                    (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                                    (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                       (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                                       T
                                       (@category_theory.monad.Î·.{vâ‚ uâ‚} C ğ’ T _inst_1)
                                       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                                    (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                       (@category_theory.functor.comp.{vâ‚ vâ‚ vâ‚ uâ‚ uâ‚ uâ‚} C ğ’ C ğ’ C
                                          ğ’
                                          T
                                          T)
                                       T
                                       (@category_theory.monad.Î¼.{vâ‚ uâ‚} C ğ’ T _inst_1)
                                       X))
                                 (@category_theory.category_struct.id.{vâ‚ uâ‚} C
                                    (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                                    (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                                 (@category_theory.monad.left_unit.{vâ‚ uâ‚} C ğ’ T _inst_1 X)
                                 (@category_theory.category_struct.id.{vâ‚ uâ‚} C
                                    (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                                    (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                                 (@category_theory.category_struct.id.{vâ‚ uâ‚} C
                                    (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                                    (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                                 (@eq.refl.{vâ‚+1}
                                    (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                       (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                                       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                                    (@category_theory.category_struct.id.{vâ‚ uâ‚} C
                                       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                                       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))))
                              (@propext
                                 (@eq.{vâ‚+1}
                                    (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                       (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                                       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                                    (@category_theory.category_struct.id.{vâ‚ uâ‚} C
                                       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                                       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                                    (@category_theory.category_struct.id.{vâ‚ uâ‚} C
                                       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                                       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)))
                                 true
                                 (@eq_self_iff_true.{vâ‚+1}
                                    (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                       (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                                       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                                    (@category_theory.category_struct.id.{vâ‚ uâ‚} C
                                       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                                       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))))))
                        trivial)
                   X)
                (@eq.symm.{vâ‚+1}
                   (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                      (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                      (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                         (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)))
                      (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                   (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                      (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                         (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)))
                      (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                         (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                      (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                      (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                         (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                         (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                         (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                            (@category_theory.functor.comp.{vâ‚ vâ‚ vâ‚ uâ‚ uâ‚ uâ‚} C ğ’ C ğ’ C ğ’ T T)
                            T
                            (@category_theory.monad.Î¼.{vâ‚ uâ‚} C ğ’ T _inst_1)
                            X))
                      (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                         (@category_theory.functor.comp.{vâ‚ vâ‚ vâ‚ uâ‚ uâ‚ uâ‚} C ğ’ C ğ’ C ğ’ T T)
                         T
                         (@category_theory.monad.Î¼.{vâ‚ uâ‚} C ğ’ T _inst_1)
                         X))
                   (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                      (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                         (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)))
                      (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                         (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                      (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                      (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                         (@category_theory.functor.comp.{vâ‚ vâ‚ vâ‚ uâ‚ uâ‚ uâ‚} C ğ’ C ğ’ C ğ’ T T)
                         T
                         (@category_theory.monad.Î¼.{vâ‚ uâ‚} C ğ’ T _inst_1)
                         (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                      (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                         (@category_theory.functor.comp.{vâ‚ vâ‚ vâ‚ uâ‚ uâ‚ uâ‚} C ğ’ C ğ’ C ğ’ T T)
                         T
                         (@category_theory.monad.Î¼.{vâ‚ uâ‚} C ğ’ T _inst_1)
                         X))
                   (@category_theory.monad.assoc.{vâ‚ uâ‚} C ğ’ T _inst_1 X)))))
       (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1
          (@category_theory.monad.algebra.mk.{vâ‚ uâ‚} C ğ’ T _inst_1
             (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T Y)
             (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                (@category_theory.functor.comp.{vâ‚ vâ‚ vâ‚ uâ‚ uâ‚ uâ‚} C ğ’ C ğ’ C ğ’ T T)
                T
                (@category_theory.monad.Î¼.{vâ‚ uâ‚} C ğ’ T _inst_1)
                Y)
             (@id.{0}
                (âˆ€ (X : C),
                   @eq.{vâ‚+1}
                     (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                        (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                           (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                        (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                           (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                           (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                        (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                     (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                        (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                        (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                           (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                           (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                        (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                           (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                        (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                        (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                           (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                           T
                           (@category_theory.monad.Î·.{vâ‚ uâ‚} C ğ’ T _inst_1)
                           (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                        (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                           (@category_theory.functor.comp.{vâ‚ vâ‚ vâ‚ uâ‚ uâ‚ uâ‚} C ğ’ C ğ’ C ğ’ T T)
                           T
                           (@category_theory.monad.Î¼.{vâ‚ uâ‚} C ğ’ T _inst_1)
                           X))
                     (@category_theory.category_struct.id.{vâ‚ uâ‚} C
                        (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                        (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)))
                (Î» (X : C),
                   @eq.mpr.{0}
                     (@eq.{vâ‚+1}
                        (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                           (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                              (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                           (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                           (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                        (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                           (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                           (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                           (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                              (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                           (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                           (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                              (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                              T
                              (@category_theory.monad.Î·.{vâ‚ uâ‚} C ğ’ T _inst_1)
                              (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                           (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                              (@category_theory.functor.comp.{vâ‚ vâ‚ vâ‚ uâ‚ uâ‚ uâ‚} C ğ’ C ğ’ C ğ’ T T)
                              T
                              (@category_theory.monad.Î¼.{vâ‚ uâ‚} C ğ’ T _inst_1)
                              X))
                        (@category_theory.category_struct.id.{vâ‚ uâ‚} C
                           (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                           (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)))
                     true
                     (@id.{0}
                        (@eq.{1} Prop
                           (@eq.{vâ‚+1}
                              (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                 (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                    (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                 (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                                 (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                              (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                                 (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                                 (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                                 (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                    (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                                 (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                                 (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                    (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                                    T
                                    (@category_theory.monad.Î·.{vâ‚ uâ‚} C ğ’ T _inst_1)
                                    (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                                 (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                    (@category_theory.functor.comp.{vâ‚ vâ‚ vâ‚ uâ‚ uâ‚ uâ‚} C ğ’ C ğ’ C ğ’
                                       T
                                       T)
                                    T
                                    (@category_theory.monad.Î¼.{vâ‚ uâ‚} C ğ’ T _inst_1)
                                    X))
                              (@category_theory.category_struct.id.{vâ‚ uâ‚} C
                                 (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                                 (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)))
                           true)
                        (@eq.trans.{1} Prop
                           (@eq.{vâ‚+1}
                              (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                 (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                    (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                 (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                                 (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                              (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                                 (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                                 (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                                 (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                    (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                                 (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                                 (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                    (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                                    T
                                    (@category_theory.monad.Î·.{vâ‚ uâ‚} C ğ’ T _inst_1)
                                    (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                                 (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                    (@category_theory.functor.comp.{vâ‚ vâ‚ vâ‚ uâ‚ uâ‚ uâ‚} C ğ’ C ğ’ C ğ’
                                       T
                                       T)
                                    T
                                    (@category_theory.monad.Î¼.{vâ‚ uâ‚} C ğ’ T _inst_1)
                                    X))
                              (@category_theory.category_struct.id.{vâ‚ uâ‚} C
                                 (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                                 (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)))
                           (@eq.{vâ‚+1}
                              (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                 (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                    (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                 (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                                 (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                              (@category_theory.category_struct.id.{vâ‚ uâ‚} C
                                 (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                                 (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                              (@category_theory.category_struct.id.{vâ‚ uâ‚} C
                                 (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                                 (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)))
                           true
                           ((Î»
                             (a a_1 :
                               @category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                 (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                    (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                 (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                                 (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                             (e_1 :
                               @eq.{vâ‚+1}
                                 (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                    (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                                    (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                                 a
                                 a_1)
                             (a_2 a_3 :
                               @category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                 (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                    (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                 (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                                 (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                             (e_2 :
                               @eq.{vâ‚+1}
                                 (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                    (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                                    (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                                 a_2
                                 a_3),
                               @congr.{vâ‚+1 1}
                                 (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                    (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                                    (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                                 Prop
                                 (@eq.{vâ‚+1}
                                    (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                       (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                                       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                                    a)
                                 (@eq.{vâ‚+1}
                                    (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                       (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                                       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                                    a_1)
                                 a_2
                                 a_3
                                 (@congr_arg.{vâ‚+1 (max (vâ‚+1) 1)}
                                    (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                       (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                                       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                                    (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                       (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                                       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X) â†’
                                     Prop)
                                    a
                                    a_1
                                    (@eq.{vâ‚+1}
                                       (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                          (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                             (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                                          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)))
                                    e_1)
                                 e_2)
                              (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                                 (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                                 (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                                 (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                    (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                                 (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                                 (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                    (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                                    T
                                    (@category_theory.monad.Î·.{vâ‚ uâ‚} C ğ’ T _inst_1)
                                    (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                                 (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                    (@category_theory.functor.comp.{vâ‚ vâ‚ vâ‚ uâ‚ uâ‚ uâ‚} C ğ’ C ğ’ C ğ’
                                       T
                                       T)
                                    T
                                    (@category_theory.monad.Î¼.{vâ‚ uâ‚} C ğ’ T _inst_1)
                                    X))
                              (@category_theory.category_struct.id.{vâ‚ uâ‚} C
                                 (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                                 (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                              (@category_theory.monad.left_unit.{vâ‚ uâ‚} C ğ’ T _inst_1 X)
                              (@category_theory.category_struct.id.{vâ‚ uâ‚} C
                                 (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                                 (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                              (@category_theory.category_struct.id.{vâ‚ uâ‚} C
                                 (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                                 (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                              (@eq.refl.{vâ‚+1}
                                 (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                    (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                                    (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                                 (@category_theory.category_struct.id.{vâ‚ uâ‚} C
                                    (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                                    (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))))
                           (@propext
                              (@eq.{vâ‚+1}
                                 (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                    (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                                    (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                                 (@category_theory.category_struct.id.{vâ‚ uâ‚} C
                                    (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                                    (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                                 (@category_theory.category_struct.id.{vâ‚ uâ‚} C
                                    (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                                    (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)))
                              true
                              (@eq_self_iff_true.{vâ‚+1}
                                 (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                    (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                                    (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                                 (@category_theory.category_struct.id.{vâ‚ uâ‚} C
                                    (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                                    (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))))))
                     trivial)
                Y)
             (@eq.symm.{vâ‚+1}
                (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                   (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                   (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                      (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                         (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T Y)))
                   (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T Y))
                (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                   (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                      (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                         (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T Y)))
                   (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                      (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T Y))
                   (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T Y)
                   (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                      (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                         (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T Y))
                      (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T Y)
                      (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                         (@category_theory.functor.comp.{vâ‚ vâ‚ vâ‚ uâ‚ uâ‚ uâ‚} C ğ’ C ğ’ C ğ’ T T)
                         T
                         (@category_theory.monad.Î¼.{vâ‚ uâ‚} C ğ’ T _inst_1)
                         Y))
                   (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                      (@category_theory.functor.comp.{vâ‚ vâ‚ vâ‚ uâ‚ uâ‚ uâ‚} C ğ’ C ğ’ C ğ’ T T)
                      T
                      (@category_theory.monad.Î¼.{vâ‚ uâ‚} C ğ’ T _inst_1)
                      Y))
                (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                   (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                      (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                         (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T Y)))
                   (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                      (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T Y))
                   (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T Y)
                   (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                      (@category_theory.functor.comp.{vâ‚ vâ‚ vâ‚ uâ‚ uâ‚ uâ‚} C ğ’ C ğ’ C ğ’ T T)
                      T
                      (@category_theory.monad.Î¼.{vâ‚ uâ‚} C ğ’ T _inst_1)
                      (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T Y))
                   (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ (â€¦ ğ’ C ğ’ T T) T â€¦ Y))
                â€¦))))
    â€¦
    â€¦'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 85  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 86  /-- The adjunction between the free and forgetful constructions for Eilenberg-Moore algebras for a monad.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 87      cf Lemma 5.2.8 of [Riehl][riehl2017]. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 88  def adj : free T âŠ£ forget T :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 89  adjunction.mk_of_hom_equiv</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 90  { hom_equiv := Î» X Y,</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 91    { to_fun := Î» f, (Î·_ T).app X â‰« f.f,</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 92      inv_fun := Î» f,</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 93      { f := T.map f â‰« Y.a,</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 94        h&#x27; :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 95        begin</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 96          dsimp, simp,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1239, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse bool (Î» (a : bool), bool.has_reflect a) interactive.types.only_flag â†’ @interactive.parse (list.{0} tactic.simp_arg_type) (Î» (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (Î» (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list â†’ @interactive.parse (list.{0} name) (Î» (a : list.{0} name), @list.reflect name (Î» (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (Î» (a : option.{0} unit), @option.has_reflect unit (Î» (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) â†’ @interactive.parse bool (Î» (a : bool), bool.has_reflect a) interactive.types.only_flag â†’ @interactive.parse (list.{0} tactic.simp_arg_type) (Î» (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (Î» (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list â†’ @interactive.parse (list.{0} name) (Î» (a : list.{0} name), @list.reflect name (Î» (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='`dsimp` is similar to `simp`, except that it only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [hâ‚ hâ‚‚ ... hâ‚™]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `háµ¢`&#x27;s, where the `háµ¢`&#x27;s are expressions. If an `háµ¢` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [hâ‚ hâ‚‚ ... hâ‚™]` is like `simp [hâ‚ hâ‚‚ ... hâ‚™]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idáµ¢`.

`simp at hâ‚ hâ‚‚ ... hâ‚™` simplifies the non-dependent hypotheses `hâ‚ : Tâ‚` ... `hâ‚™ : Tâ‚™`. The tactic fails if the target or another hypothesis depends on one of them. The token `âŠ¢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attrâ‚ ... attrâ‚™` simplifies the main goal target using the lemmas tagged with any of the attributes `[attrâ‚]`, ..., `[attrâ‚™]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 97          conv { to_rhs, rw [â†category.assoc, â†(Î¼_ T).naturality, category.assoc], erw algebra.assoc },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='blue'><a title='category_theory.category.assoc'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='category_theory.monad.Î¼'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='T'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='category_theory.category.assoc'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='category_theory.monad.algebra.assoc'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 68, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/monad/basic.lean&#x27;, &#x27;line&#x27;: 16, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/converter/interactive.lean&#x27;, &#x27;line&#x27;: 102, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/converter/interactive.lean&#x27;, &#x27;line&#x27;: 102, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse (option.{0} name) (Î» (a : option.{0} name), @option.has_reflect name (Î» (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit name (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.ident)) â†’ @interactive.parse (option.{0} pexpr) (Î» (a : option.{0} pexpr), @option.has_reflect pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) (lean.parser.pexpr std.prec.max))) â†’ conv.interactive.itactic â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (Î» (a : option.{0} name), @option.has_reflect name (Î» (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit name (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.ident)) â†’ @interactive.parse (option.{0} pexpr) (Î» (a : option.{0} pexpr), @option.has_reflect pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) (lean.parser.pexpr std.prec.max))) â†’ conv.interactive.itactic â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (Î» (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules â†’ opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} â†’ conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='âˆ€ (obj : Type uâ‚) [c : category_theory.category.{vâ‚ uâ‚} obj] {W X Y Z : obj} (f : @category_theory.has_hom.hom.{vâ‚ uâ‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} obj (@category_theory.category.to_category_struct.{vâ‚ uâ‚} obj c)) W X) (g : @category_theory.has_hom.hom.{vâ‚ uâ‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} obj (@category_theory.category.to_category_struct.{vâ‚ uâ‚} obj c)) X Y) (h : @category_theory.has_hom.hom.{vâ‚ uâ‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} obj (@category_theory.category.to_category_struct.{vâ‚ uâ‚} obj c)) Y Z), @eq.{vâ‚+1} (@category_theory.has_hom.hom.{vâ‚ uâ‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} obj (@category_theory.category.to_category_struct.{vâ‚ uâ‚} obj c)) W Z) (@category_theory.category_struct.comp.{vâ‚ uâ‚} obj (@category_theory.category.to_category_struct.{vâ‚ uâ‚} obj c) W Y Z (@category_theory.category_struct.comp.{vâ‚ uâ‚} obj (@category_theory.category.to_category_struct.{vâ‚ uâ‚} obj c) W X Y f g) h) (@category_theory.category_struct.comp.{vâ‚ uâ‚} obj (@category_theory.category.to_category_struct.{vâ‚ uâ‚} obj c) W X Z f (@category_theory.category_struct.comp.{vâ‚ uâ‚} obj (@category_theory.category.to_category_struct.{vâ‚ uâ‚} obj c) X Y Z g h))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (Î» (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules â†’ opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} â†’ conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] (T : @category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’) [c : @category_theory.monad.{vâ‚ uâ‚} C ğ’ T], @category_theory.has_hom.hom.{(max uâ‚ vâ‚) (max vâ‚ uâ‚)} (@category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’) (@category_theory.category_struct.to_has_hom.{(max uâ‚ vâ‚) (max vâ‚ uâ‚)} (@category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’) (@category_theory.category.to_category_struct.{(max uâ‚ vâ‚) (max vâ‚ uâ‚)} (@category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’) (@category_theory.functor.category.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’))) (@category_theory.functor.comp.{vâ‚ vâ‚ vâ‚ uâ‚ uâ‚ uâ‚} C ğ’ C ğ’ C ğ’ T T) T'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (Î» (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules â†’ opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} â†’ conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (Î» (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules â†’ opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} â†’ conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='âˆ€ (obj : Type uâ‚) [c : category_theory.category.{vâ‚ uâ‚} obj] {W X Y Z : obj} (f : @category_theory.has_hom.hom.{vâ‚ uâ‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} obj (@category_theory.category.to_category_struct.{vâ‚ uâ‚} obj c)) W X) (g : @category_theory.has_hom.hom.{vâ‚ uâ‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} obj (@category_theory.category.to_category_struct.{vâ‚ uâ‚} obj c)) X Y) (h : @category_theory.has_hom.hom.{vâ‚ uâ‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} obj (@category_theory.category.to_category_struct.{vâ‚ uâ‚} obj c)) Y Z), @eq.{vâ‚+1} (@category_theory.has_hom.hom.{vâ‚ uâ‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} obj (@category_theory.category.to_category_struct.{vâ‚ uâ‚} obj c)) W Z) (@category_theory.category_struct.comp.{vâ‚ uâ‚} obj (@category_theory.category.to_category_struct.{vâ‚ uâ‚} obj c) W Y Z (@category_theory.category_struct.comp.{vâ‚ uâ‚} obj (@category_theory.category.to_category_struct.{vâ‚ uâ‚} obj c) W X Y f g) h) (@category_theory.category_struct.comp.{vâ‚ uâ‚} obj (@category_theory.category.to_category_struct.{vâ‚ uâ‚} obj c) W X Z f (@category_theory.category_struct.comp.{vâ‚ uâ‚} obj (@category_theory.category.to_category_struct.{vâ‚ uâ‚} obj c) X Y Z g h))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (Î» (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules â†’ opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} â†’ conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (Î» (a : option.{0} name), @option.has_reflect name (Î» (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit name (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.ident)) â†’ @interactive.parse (option.{0} pexpr) (Î» (a : option.{0} pexpr), @option.has_reflect pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) (lean.parser.pexpr std.prec.max))) â†’ conv.interactive.itactic â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (Î» (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules â†’ opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} â†’ conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='âˆ€ {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] {T : @category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’} [_inst_1 : @category_theory.monad.{vâ‚ uâ‚} C ğ’ T] (c : @category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1), @eq.{vâ‚+1} (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 c))) (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 c)) (@category_theory.category_struct.comp.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’) (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 c))) (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 c)) (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 c) (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ (@category_theory.functor.comp.{vâ‚ vâ‚ vâ‚ uâ‚ uâ‚ uâ‚} C ğ’ C ğ’ C ğ’ T T) T (@category_theory.monad.Î¼.{vâ‚ uâ‚} C ğ’ T _inst_1) (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 c)) (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 c)) (@category_theory.category_struct.comp.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’) (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 c))) (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 c)) (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 c) (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 c)) (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 c) (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 c)) (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (Î» (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules â†’ opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} â†’ conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (Î» (a : option.{0} name), @option.has_reflect name (Î» (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit name (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.ident)) â†’ @interactive.parse (option.{0} pexpr) (Î» (a : option.{0} pexpr), @option.has_reflect pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) (lean.parser.pexpr std.prec.max))) â†’ conv.interactive.itactic â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='conv'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='to_rhs'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='conv'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='conv'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='conv'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;(at id)?&#x27;, &#x27;(in expr)?&#x27;, &#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;(at id)?&#x27;, &#x27;(in expr)?&#x27;, &#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (â†? expr), ... ] | â†? expr)&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;([ (â†? expr), ... ] | â†? expr)&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (â†? expr), ... ] | â†? expr)&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (â†? expr), ... ] | â†? expr)&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;([ (â†? expr), ... ] | â†? expr)&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;(at id)?&#x27;, &#x27;(in expr)?&#x27;, &#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (â†? expr), ... ] | â†? expr)&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;([ (â†? expr), ... ] | â†? expr)&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;(at id)?&#x27;, &#x27;(in expr)?&#x27;, &#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
T : @category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’,
_inst_1 : @category_theory.monad.{vâ‚ uâ‚} C ğ’ T,
X : C,
Y : @category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1,
f :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X
    (@category_theory.functor.obj.{vâ‚ vâ‚ (max uâ‚ vâ‚) uâ‚}
       (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
       (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)
       C
       ğ’
       (@category_theory.monad.forget.{vâ‚ uâ‚} C ğ’ T _inst_1)
       Y)
âŠ¢ @eq.{vâ‚+1}
    (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
       (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
       (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
    (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
             (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)))
       (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
       (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
             (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
          (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X
             (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
             f))
       (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
             (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)))
          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
             (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
          (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
          (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
             (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
             (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
             (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
          (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)))
    (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
       (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
       (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
          (@category_theory.functor.comp.{vâ‚ vâ‚ vâ‚ uâ‚ uâ‚ uâ‚} C ğ’ C ğ’ C ğ’ T T)
          T
          (@category_theory.monad.Î¼.{vâ‚ uâ‚} C ğ’ T _inst_1)
          X)
       (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
             (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
          (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
          (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X
             (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
             f)
          (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
T : @category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’,
_inst_1 : @category_theory.monad.{vâ‚ uâ‚} C ğ’ T,
X : C,
Y : @category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1,
f :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X
    (@category_theory.functor.obj.{vâ‚ vâ‚ (max uâ‚ vâ‚) uâ‚}
       (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
       (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)
       C
       ğ’
       (@category_theory.monad.forget.{vâ‚ uâ‚} C ğ’ T _inst_1)
       Y)
| @eq.{vâ‚+1}
    (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
       (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
       (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
    (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
             (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)))
       (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
       (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
             (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
          (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X
             (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
             f))
       (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
             (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)))
          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
             (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
          (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
          (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
             (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
             (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
             (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
          (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)))
    (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
       (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
       (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
          (@category_theory.functor.comp.{vâ‚ vâ‚ vâ‚ uâ‚ uâ‚ uâ‚} C ğ’ C ğ’ C ğ’ T T)
          T
          (@category_theory.monad.Î¼.{vâ‚ uâ‚} C ğ’ T _inst_1)
          X)
       (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
             (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
          (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
          (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X
             (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
             f)
          (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
T : @category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’,
_inst_1 : @category_theory.monad.{vâ‚ uâ‚} C ğ’ T,
X : C,
Y : @category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1,
f :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X
    (@category_theory.functor.obj.{vâ‚ vâ‚ (max uâ‚ vâ‚) uâ‚}
       (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
       (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)
       C
       ğ’
       (@category_theory.monad.forget.{vâ‚ uâ‚} C ğ’ T _inst_1)
       Y)
| @category_theory.category_struct.comp.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
    (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
    (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
    (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
    (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
       (@category_theory.functor.comp.{vâ‚ vâ‚ vâ‚ uâ‚ uâ‚ uâ‚} C ğ’ C ğ’ C ğ’ T T)
       T
       (@category_theory.monad.Î¼.{vâ‚ uâ‚} C ğ’ T _inst_1)
       X)
    (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
          (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
       (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
       (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X
          (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
          f)
       (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
T : @category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’,
_inst_1 : @category_theory.monad.{vâ‚ uâ‚} C ğ’ T,
X : C,
Y : @category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1,
f :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X
    (@category_theory.functor.obj.{vâ‚ vâ‚ (max uâ‚ vâ‚) uâ‚}
       (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
       (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)
       C
       ğ’
       (@category_theory.monad.forget.{vâ‚ uâ‚} C ğ’ T _inst_1)
       Y)
| @category_theory.category_struct.comp.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
    (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
    (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
       (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
    (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
    (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
          (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
       (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
          (@category_theory.functor.comp.{vâ‚ vâ‚ vâ‚ uâ‚ uâ‚ uâ‚} C ğ’ C ğ’ C ğ’ T T)
          T
          (@category_theory.monad.Î¼.{vâ‚ uâ‚} C ğ’ T _inst_1)
          X)
       (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X
          (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
          f))
    (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
T : @category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’,
_inst_1 : @category_theory.monad.{vâ‚ uâ‚} C ğ’ T,
X : C,
Y : @category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1,
f :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X
    (@category_theory.functor.obj.{vâ‚ vâ‚ (max uâ‚ vâ‚) uâ‚}
       (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
       (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)
       C
       ğ’
       (@category_theory.monad.forget.{vâ‚ uâ‚} C ğ’ T _inst_1)
       Y)
| @category_theory.category_struct.comp.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
    (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
    (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
       (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
    (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
    (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
          (@category_theory.functor.comp.{vâ‚ vâ‚ vâ‚ uâ‚ uâ‚ uâ‚} C ğ’ C ğ’ C ğ’ T T)
          X)
       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
          (@category_theory.functor.comp.{vâ‚ vâ‚ vâ‚ uâ‚ uâ‚ uâ‚} C ğ’ C ğ’ C ğ’ T T)
          (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
          (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
       (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
          (@category_theory.functor.comp.{vâ‚ vâ‚ vâ‚ uâ‚ uâ‚ uâ‚} C ğ’ C ğ’ C ğ’ T T)
          X
          (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
          f)
       (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
          (@category_theory.functor.comp.{vâ‚ vâ‚ vâ‚ uâ‚ uâ‚ uâ‚} C ğ’ C ğ’ C ğ’ T T)
          T
          (@category_theory.monad.Î¼.{vâ‚ uâ‚} C ğ’ T _inst_1)
          (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)))
    (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
T : @category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’,
_inst_1 : @category_theory.monad.{vâ‚ uâ‚} C ğ’ T,
X : C,
Y : @category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1,
f :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X
    (@category_theory.functor.obj.{vâ‚ vâ‚ (max uâ‚ vâ‚) uâ‚}
       (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
       (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)
       C
       ğ’
       (@category_theory.monad.forget.{vâ‚ uâ‚} C ğ’ T _inst_1)
       Y)
| @category_theory.category_struct.comp.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
    (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
    (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
       (@category_theory.functor.comp.{vâ‚ vâ‚ vâ‚ uâ‚ uâ‚ uâ‚} C ğ’ C ğ’ C ğ’ T T)
       (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
    (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
    (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
       (@category_theory.functor.comp.{vâ‚ vâ‚ vâ‚ uâ‚ uâ‚ uâ‚} C ğ’ C ğ’ C ğ’ T T)
       X
       (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
       f)
    (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
          (@category_theory.functor.comp.{vâ‚ vâ‚ vâ‚ uâ‚ uâ‚ uâ‚} C ğ’ C ğ’ C ğ’ T T)
          (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
          (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
       (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
       (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
          (@category_theory.functor.comp.{vâ‚ vâ‚ vâ‚ uâ‚ uâ‚ uâ‚} C ğ’ C ğ’ C ğ’ T T)
          T
          (@category_theory.monad.Î¼.{vâ‚ uâ‚} C ğ’ T _inst_1)
          (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
       (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
T : @category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’,
_inst_1 : @category_theory.monad.{vâ‚ uâ‚} C ğ’ T,
X : C,
Y : @category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1,
f :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X
    (@category_theory.functor.obj.{vâ‚ vâ‚ (max uâ‚ vâ‚) uâ‚}
       (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
       (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)
       C
       ğ’
       (@category_theory.monad.forget.{vâ‚ uâ‚} C ğ’ T _inst_1)
       Y)
| @category_theory.category_struct.comp.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
    (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
    (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
       (@category_theory.functor.comp.{vâ‚ vâ‚ vâ‚ uâ‚ uâ‚ uâ‚} C ğ’ C ğ’ C ğ’ T T)
       (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
    (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
    (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
       (@category_theory.functor.comp.{vâ‚ vâ‚ vâ‚ uâ‚ uâ‚ uâ‚} C ğ’ C ğ’ C ğ’ T T)
       X
       (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
       f)
    (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
             (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)))
       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
          (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
       (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
       (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
             (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
          (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
          (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
       (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
T : @category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’,
_inst_1 : @category_theory.monad.{vâ‚ uâ‚} C ğ’ T,
X : C,
Y : @category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1,
f :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X
    (@category_theory.functor.obj.{vâ‚ vâ‚ (max uâ‚ vâ‚) uâ‚}
       (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
       (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)
       C
       ğ’
       (@category_theory.monad.forget.{vâ‚ uâ‚} C ğ’ T _inst_1)
       Y)
âŠ¢ @eq.{vâ‚+1}
    (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
       (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
       (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
    (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
             (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)))
       (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
       (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
             (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
          (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X
             (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
             f))
       (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
             (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)))
          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
             (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
          (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
          (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
             (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
             (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
             (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
          (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)))
    (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
          (@category_theory.functor.comp.{vâ‚ vâ‚ vâ‚ uâ‚ uâ‚ uâ‚} C ğ’ C ğ’ C ğ’ T T)
          (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
       (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
       (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
          (@category_theory.functor.comp.{vâ‚ vâ‚ vâ‚ uâ‚ uâ‚ uâ‚} C ğ’ C ğ’ C ğ’ T T)
          X
          (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
          f)
       (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
             (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)))
          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
             (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
          (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
          (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
             (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
             (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
             (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
          (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 98          refl,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1263, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='Shorter name for the tactic `reflexivity`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
T : @category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’,
_inst_1 : @category_theory.monad.{vâ‚ uâ‚} C ğ’ T,
X : C,
Y : @category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1,
f :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X
    (@category_theory.functor.obj.{vâ‚ vâ‚ (max uâ‚ vâ‚) uâ‚}
       (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
       (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)
       C
       ğ’
       (@category_theory.monad.forget.{vâ‚ uâ‚} C ğ’ T _inst_1)
       Y)
âŠ¢ @eq.{vâ‚+1}
    (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
       (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
       (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
    (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
             (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)))
       (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
       (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
             (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
          (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X
             (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
             f))
       (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
             (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)))
          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
             (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
          (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
          (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
             (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
             (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
             (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
          (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)))
    (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
          (@category_theory.functor.comp.{vâ‚ vâ‚ vâ‚ uâ‚ uâ‚ uâ‚} C ğ’ C ğ’ C ğ’ T T)
          (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
       (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
       (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
          (@category_theory.functor.comp.{vâ‚ vâ‚ vâ‚ uâ‚ uâ‚ uâ‚} C ğ’ C ğ’ C ğ’ T T)
          X
          (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
          f)
       (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
             (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)))
          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
             (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
          (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
          (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
             (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
             (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
             (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
          (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 99        end },</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>100      left_inv := Î» f,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='green'><a title='@category_theory.has_hom.hom.{vâ‚ (max uâ‚ vâ‚)} (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1) (@category_theory.category_struct.to_has_hom.{vâ‚ (max uâ‚ vâ‚)} (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1) (@category_theory.category.to_category_struct.{vâ‚ (max uâ‚ vâ‚)} (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1))) (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ (max uâ‚ vâ‚)} C ğ’ (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1) (@category_theory.monad.free.{vâ‚ uâ‚} C ğ’ T _inst_1) X) Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>101      begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
T : @category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’,
_inst_1 : @category_theory.monad.{vâ‚ uâ‚} C ğ’ T,
X : C,
Y : @category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1,
f :
  @category_theory.has_hom.hom.{vâ‚ (max uâ‚ vâ‚)} (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
    (@category_theory.category_struct.to_has_hom.{vâ‚ (max uâ‚ vâ‚)}
       (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
       (@category_theory.category.to_category_struct.{vâ‚ (max uâ‚ vâ‚)}
          (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
          (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)))
    (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ (max uâ‚ vâ‚)} C ğ’
       (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
       (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)
       (@category_theory.monad.free.{vâ‚ uâ‚} C ğ’ T _inst_1)
       X)
    Y
âŠ¢ @eq.{vâ‚+1}
    (@category_theory.has_hom.hom.{vâ‚ (max uâ‚ vâ‚)} (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
       (@category_theory.category_struct.to_has_hom.{vâ‚ (max uâ‚ vâ‚)}
          (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
          (@category_theory.category.to_category_struct.{vâ‚ (max uâ‚ vâ‚)}
             (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)))
       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ (max uâ‚ vâ‚)} C ğ’
          (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
          (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)
          (@category_theory.monad.free.{vâ‚ uâ‚} C ğ’ T _inst_1)
          X)
       Y)
    ((Î»
      (f :
        @category_theory.has_hom.hom.{vâ‚ uâ‚} C
          (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
             (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
          X
          (@category_theory.functor.obj.{vâ‚ vâ‚ (max uâ‚ vâ‚) uâ‚}
             (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)
             C
             ğ’
             (@category_theory.monad.forget.{vâ‚ uâ‚} C ğ’ T _inst_1)
             Y)),
        @category_theory.monad.algebra.hom.mk.{vâ‚ uâ‚} C ğ’ T _inst_1
          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ (max uâ‚ vâ‚)} C ğ’
             (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)
             (@category_theory.monad.free.{vâ‚ uâ‚} C ğ’ T _inst_1)
             X)
          Y
          (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
             (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
             (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1
                (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ (max uâ‚ vâ‚)} C ğ’
                   (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)
                   (@category_theory.monad.free.{vâ‚ uâ‚} C ğ’ T _inst_1)
                   X))
             (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                (@category_theory.functor.obj.{vâ‚ vâ‚ (max uâ‚ vâ‚) uâ‚}
                   (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)
                   C
                   ğ’
                   (@category_theory.monad.forget.{vâ‚ uâ‚} C ğ’ T _inst_1)
                   Y))
             (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
             (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X
                (@category_theory.functor.obj.{vâ‚ vâ‚ (max uâ‚ vâ‚) uâ‚}
                   (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)
                   C
                   ğ’
                   (@category_theory.monad.forget.{vâ‚ uâ‚} C ğ’ T _inst_1)
                   Y)
                f)
             (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
          (@id.{0}
             (@eq.{vâ‚+1}
                (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                   (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                   (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                      (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1
                         (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ (max uâ‚ vâ‚)} C ğ’
                            (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
                            (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)
                            (@category_theory.monad.free.{vâ‚ uâ‚} C ğ’ T _inst_1)
                            X)))
                   (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                   (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                      (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1
                         (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ (max uâ‚ vâ‚)} C ğ’
                            (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
                            (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)
                            (@category_theory.monad.free.{vâ‚ uâ‚} C ğ’ T _inst_1)
                            X)))
                   (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                      (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                   (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                   (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                      (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1
                         (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ (max uâ‚ vâ‚)} C ğ’
                            (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
                            (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)
                            (@category_theory.monad.free.{vâ‚ uâ‚} C ğ’ T _inst_1)
                            X))
                      (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                      (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                         (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ (max uâ‚ vâ‚)} C ğ’
                               (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
                               (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)
                               (@category_theory.monad.free.{vâ‚ uâ‚} C ğ’ T _inst_1)
                               X))
                         (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                            (@category_theory.functor.obj.{vâ‚ vâ‚ (max uâ‚ vâ‚) uâ‚}
                               (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
                               (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)
                               C
                               ğ’
                               (@category_theory.monad.forget.{vâ‚ uâ‚} C ğ’ T _inst_1)
                               Y))
                         (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                         (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X
                            (@category_theory.functor.obj.{vâ‚ vâ‚ (max uâ‚ vâ‚) uâ‚}
                               (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
                               (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)
                               C
                               ğ’
                               (@category_theory.monad.forget.{vâ‚ uâ‚} C ğ’ T _inst_1)
                               Y)
                            f)
                         (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)))
                   (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                   (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                      (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1
                         (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ (max uâ‚ vâ‚)} C ğ’
                            (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
                            (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)
                            (@category_theory.monad.free.{vâ‚ uâ‚} C ğ’ T _inst_1)
                            X)))
                   (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1
                      (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ (max uâ‚ vâ‚)} C ğ’
                         (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
                         (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)
                         (@category_theory.monad.free.{vâ‚ uâ‚} C ğ’ T _inst_1)
                         X))
                   (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                   (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1
                      (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ (max uâ‚ vâ‚)} C ğ’
                         (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
                         (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)
                         (@category_theory.monad.free.{vâ‚ uâ‚} C ğ’ T _inst_1)
                         X))
                   (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                      (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1
                         (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ (max uâ‚ vâ‚)} C ğ’
                            (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
                            (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)
                            (@category_theory.monad.free.{vâ‚ uâ‚} C ğ’ T _inst_1)
                            X))
                      (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                         (@category_theory.functor.obj.{vâ‚ vâ‚ (max uâ‚ vâ‚) uâ‚}
                            (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
                            (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)
                            C
                            ğ’
                            (@category_theory.monad.forget.{vâ‚ uâ‚} C ğ’ T _inst_1)
                            Y))
                      (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                      (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X
                         (@category_theory.functor.obj.{vâ‚ vâ‚ (max uâ‚ vâ‚) uâ‚}
                            (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
                            (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)
                            C
                            ğ’
                            (@category_theory.monad.forget.{vâ‚ uâ‚} C ğ’ T _inst_1)
                            Y)
                         f)
                      (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))))
             (@eq.mpr.{0}
                (@eq.{vâ‚+1}
                   (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                      (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                      (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                         (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                      (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                   (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                      (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                         (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                      (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                         (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                      (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                      (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                         (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                         (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                         (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                               (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                            (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                            (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X
                               (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                               f)
                            (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)))
                      (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                   (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                      (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                         (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                      (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                      (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                      (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                         (@category_theory.functor.comp.{vâ‚ vâ‚ vâ‚ uâ‚ uâ‚ uâ‚} C ğ’ C ğ’ C ğ’ T T)
                         T
                         (@category_theory.monad.Î¼.{vâ‚ uâ‚} C ğ’ T _inst_1)
                         X)
                      (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                         (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                         (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                            (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                         (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                         (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X
                            (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                            f)
                         (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))))
                (@eq.{vâ‚+1}
                   (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                      (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                      (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                         (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                      (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                   (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                      (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                         (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                      (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                         (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                            (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)))
                      (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                      (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                         (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                         (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                            (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                         (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X
                            (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                            f))
                      (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                         (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                               (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)))
                         (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                            (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                         (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                         (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                               (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                            (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                            (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                         (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)))
                   (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                      (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                         (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                      (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                      (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                      (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                         (@category_theory.functor.comp.{vâ‚ vâ‚ vâ‚ uâ‚ uâ‚ uâ‚} C ğ’ C ğ’ C ğ’ T T)
                         T
                         (@category_theory.monad.Î¼.{vâ‚ uâ‚} C ğ’ T _inst_1)
                         X)
                      (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                         (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                         (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                            (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                         (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                         (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X
                            (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                            f)
                         (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))))
                (@id.{0}
                   (@eq.{1} Prop
                      (@eq.{vâ‚+1}
                         (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                            (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                               (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                            (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                         (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                               (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                            (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                            (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                               (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                               (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                                  (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                                  (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                     (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                                  (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                                  (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X
                                     (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                                     f)
                                  (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)))
                            (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                         (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                            (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                            (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                               (@category_theory.functor.comp.{vâ‚ vâ‚ vâ‚ uâ‚ uâ‚ uâ‚} C ğ’ C ğ’ C ğ’ T T)
                               T
                               (@category_theory.monad.Î¼.{vâ‚ uâ‚} C ğ’ T _inst_1)
                               X)
                            (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                               (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                  (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                               (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                               (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X
                                  (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                                  f)
                               (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))))
                      (@eq.{vâ‚+1}
                         (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                            (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                               (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                            (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                         (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                  (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)))
                            (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                            (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                  (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                               (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X
                                  (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                                  f))
                            (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                               (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                  (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                     (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)))
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                  (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                               (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                               (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                  (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                     (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                                  (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                                  (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                               (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)))
                         (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                            (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                            (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                               (@category_theory.functor.comp.{vâ‚ vâ‚ vâ‚ uâ‚ uâ‚ uâ‚} C ğ’ C ğ’ C ğ’ T T)
                               T
                               (@category_theory.monad.Î¼.{vâ‚ uâ‚} C ğ’ T _inst_1)
                               X)
                            (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                               (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                  (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                               (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                               (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X
                                  (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                                  f)
                               (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)))))
                   ((Î»
                     (a a_1 :
                       @category_theory.has_hom.hom.{vâ‚ uâ‚} C
                         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                         (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                         (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                     (e_1 :
                       @eq.{vâ‚+1}
                         (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                            (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                               (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                            (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                         a
                         a_1)
                     (a_2 a_3 :
                       @category_theory.has_hom.hom.{vâ‚ uâ‚} C
                         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                         (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                         (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                     (e_2 :
                       @eq.{vâ‚+1}
                         (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                            (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                               (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                            (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                         a_2
                         a_3),
                       @congr.{vâ‚+1 1}
                         (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                            (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                               (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                            (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                         Prop
                         (@eq.{vâ‚+1}
                            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                  (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                               (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                            a)
                         (@eq.{vâ‚+1}
                            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                  (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                               (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                            a_1)
                         a_2
                         a_3
                         (@congr_arg.{vâ‚+1 (max (vâ‚+1) 1)}
                            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                  (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                               (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                  (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                               (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y) â†’
                             Prop)
                            a
                            a_1
                            (@eq.{vâ‚+1}
                               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                  (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                     (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                                  (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)))
                            e_1)
                         e_2)
                      (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                         (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                         (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                            (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                         (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                         (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                            (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                            (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                               (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                  (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                               (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                               (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X
                                  (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                                  f)
                               (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)))
                         (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                      (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                         (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                         (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                               (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)))
                         (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                         (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                               (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                            (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X
                               (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                               f))
                         (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                  (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)))
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                               (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                            (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                            (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                  (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                               (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                               (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                            (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)))
                      (@eq.trans.{vâ‚+1}
                         (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                            (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                               (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                            (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                         (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                               (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                            (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                            (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                               (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                               (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                                  (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                                  (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                     (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                                  (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                                  (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X
                                     (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                                     f)
                                  (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)))
                            (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                         (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                               (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                            (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                            (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                               (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                  (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                  (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                     (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)))
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                  (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                               (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                  (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                                  (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                     (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                                  (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X
                                     (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                                     f))
                               (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                  (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                     (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                                  (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                                  â€¦))
                            â€¦)
                         â€¦
                         â€¦
                         â€¦)
                      â€¦
                      â€¦
                      â€¦))
                â€¦)))
       â€¦)
    f'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>102        ext1, dsimp,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/ext.lean&#x27;, &#x27;line&#x27;: 312, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1239, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse tactic.ext_patt (Î» (a : tactic.ext_patt), @list.reflect tactic.rcases_patt (Î» (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) tactic.ext_parse â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse bool (Î» (a : bool), bool.has_reflect a) interactive.types.only_flag â†’ @interactive.parse (list.{0} tactic.simp_arg_type) (Î» (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (Î» (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list â†’ @interactive.parse (list.{0} name) (Î» (a : list.{0} name), @list.reflect name (Î» (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='`ext1 id` selects and apply one extensionality lemma (with attribute
`ext`), using `id`, if provided, to name a local constant
introduced by the lemma. If `id` is omitted, the local constant is
named automatically, as per `intro`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`dsimp` is similar to `simp`, except that it only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='ext1'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;((patt) | patt_list)*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
T : @category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’,
_inst_1 : @category_theory.monad.{vâ‚ uâ‚} C ğ’ T,
X : C,
Y : @category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1,
f :
  @category_theory.has_hom.hom.{vâ‚ (max uâ‚ vâ‚)} (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
    (@category_theory.category_struct.to_has_hom.{vâ‚ (max uâ‚ vâ‚)}
       (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
       (@category_theory.category.to_category_struct.{vâ‚ (max uâ‚ vâ‚)}
          (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
          (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)))
    (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ (max uâ‚ vâ‚)} C ğ’
       (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
       (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)
       (@category_theory.monad.free.{vâ‚ uâ‚} C ğ’ T _inst_1)
       X)
    Y
âŠ¢ @eq.{vâ‚+1}
    (@category_theory.has_hom.hom.{vâ‚ (max uâ‚ vâ‚)} (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
       (@category_theory.category_struct.to_has_hom.{vâ‚ (max uâ‚ vâ‚)}
          (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
          (@category_theory.category.to_category_struct.{vâ‚ (max uâ‚ vâ‚)}
             (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)))
       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ (max uâ‚ vâ‚)} C ğ’
          (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
          (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)
          (@category_theory.monad.free.{vâ‚ uâ‚} C ğ’ T _inst_1)
          X)
       Y)
    ((Î»
      (f :
        @category_theory.has_hom.hom.{vâ‚ uâ‚} C
          (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
             (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
          X
          (@category_theory.functor.obj.{vâ‚ vâ‚ (max uâ‚ vâ‚) uâ‚}
             (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)
             C
             ğ’
             (@category_theory.monad.forget.{vâ‚ uâ‚} C ğ’ T _inst_1)
             Y)),
        @category_theory.monad.algebra.hom.mk.{vâ‚ uâ‚} C ğ’ T _inst_1
          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ (max uâ‚ vâ‚)} C ğ’
             (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)
             (@category_theory.monad.free.{vâ‚ uâ‚} C ğ’ T _inst_1)
             X)
          Y
          (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
             (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
             (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1
                (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ (max uâ‚ vâ‚)} C ğ’
                   (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)
                   (@category_theory.monad.free.{vâ‚ uâ‚} C ğ’ T _inst_1)
                   X))
             (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                (@category_theory.functor.obj.{vâ‚ vâ‚ (max uâ‚ vâ‚) uâ‚}
                   (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)
                   C
                   ğ’
                   (@category_theory.monad.forget.{vâ‚ uâ‚} C ğ’ T _inst_1)
                   Y))
             (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
             (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X
                (@category_theory.functor.obj.{vâ‚ vâ‚ (max uâ‚ vâ‚) uâ‚}
                   (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)
                   C
                   ğ’
                   (@category_theory.monad.forget.{vâ‚ uâ‚} C ğ’ T _inst_1)
                   Y)
                f)
             (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
          (@id.{0}
             (@eq.{vâ‚+1}
                (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                   (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                   (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                      (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1
                         (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ (max uâ‚ vâ‚)} C ğ’
                            (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
                            (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)
                            (@category_theory.monad.free.{vâ‚ uâ‚} C ğ’ T _inst_1)
                            X)))
                   (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                   (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                      (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1
                         (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ (max uâ‚ vâ‚)} C ğ’
                            (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
                            (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)
                            (@category_theory.monad.free.{vâ‚ uâ‚} C ğ’ T _inst_1)
                            X)))
                   (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                      (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                   (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                   (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                      (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1
                         (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ (max uâ‚ vâ‚)} C ğ’
                            (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
                            (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)
                            (@category_theory.monad.free.{vâ‚ uâ‚} C ğ’ T _inst_1)
                            X))
                      (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                      (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                         (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ (max uâ‚ vâ‚)} C ğ’
                               (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
                               (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)
                               (@category_theory.monad.free.{vâ‚ uâ‚} C ğ’ T _inst_1)
                               X))
                         (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                            (@category_theory.functor.obj.{vâ‚ vâ‚ (max uâ‚ vâ‚) uâ‚}
                               (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
                               (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)
                               C
                               ğ’
                               (@category_theory.monad.forget.{vâ‚ uâ‚} C ğ’ T _inst_1)
                               Y))
                         (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                         (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X
                            (@category_theory.functor.obj.{vâ‚ vâ‚ (max uâ‚ vâ‚) uâ‚}
                               (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
                               (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)
                               C
                               ğ’
                               (@category_theory.monad.forget.{vâ‚ uâ‚} C ğ’ T _inst_1)
                               Y)
                            f)
                         (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)))
                   (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                   (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                      (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1
                         (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ (max uâ‚ vâ‚)} C ğ’
                            (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
                            (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)
                            (@category_theory.monad.free.{vâ‚ uâ‚} C ğ’ T _inst_1)
                            X)))
                   (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1
                      (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ (max uâ‚ vâ‚)} C ğ’
                         (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
                         (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)
                         (@category_theory.monad.free.{vâ‚ uâ‚} C ğ’ T _inst_1)
                         X))
                   (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                   (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1
                      (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ (max uâ‚ vâ‚)} C ğ’
                         (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
                         (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)
                         (@category_theory.monad.free.{vâ‚ uâ‚} C ğ’ T _inst_1)
                         X))
                   (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                      (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1
                         (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ (max uâ‚ vâ‚)} C ğ’
                            (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
                            (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)
                            (@category_theory.monad.free.{vâ‚ uâ‚} C ğ’ T _inst_1)
                            X))
                      (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                         (@category_theory.functor.obj.{vâ‚ vâ‚ (max uâ‚ vâ‚) uâ‚}
                            (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
                            (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)
                            C
                            ğ’
                            (@category_theory.monad.forget.{vâ‚ uâ‚} C ğ’ T _inst_1)
                            Y))
                      (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                      (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X
                         (@category_theory.functor.obj.{vâ‚ vâ‚ (max uâ‚ vâ‚) uâ‚}
                            (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
                            (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)
                            C
                            ğ’
                            (@category_theory.monad.forget.{vâ‚ uâ‚} C ğ’ T _inst_1)
                            Y)
                         f)
                      (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))))
             (@eq.mpr.{0}
                (@eq.{vâ‚+1}
                   (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                      (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                      (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                         (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                      (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                   (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                      (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                         (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                      (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                         (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                      (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                      (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                         (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                         (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                         (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                               (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                            (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                            (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X
                               (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                               f)
                            (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)))
                      (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                   (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                      (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                         (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                      (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                      (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                      (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                         (@category_theory.functor.comp.{vâ‚ vâ‚ vâ‚ uâ‚ uâ‚ uâ‚} C ğ’ C ğ’ C ğ’ T T)
                         T
                         (@category_theory.monad.Î¼.{vâ‚ uâ‚} C ğ’ T _inst_1)
                         X)
                      (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                         (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                         (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                            (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                         (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                         (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X
                            (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                            f)
                         (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))))
                (@eq.{vâ‚+1}
                   (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                      (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                      (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                         (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                      (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                   (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                      (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                         (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                      (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                         (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                            (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)))
                      (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                      (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                         (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                         (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                            (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                         (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X
                            (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                            f))
                      (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                         (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                               (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)))
                         (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                            (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                         (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                         (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                               (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                            (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                            (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                         (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)))
                   (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                      (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                         (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                      (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                      (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                      (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                         (@category_theory.functor.comp.{vâ‚ vâ‚ vâ‚ uâ‚ uâ‚ uâ‚} C ğ’ C ğ’ C ğ’ T T)
                         T
                         (@category_theory.monad.Î¼.{vâ‚ uâ‚} C ğ’ T _inst_1)
                         X)
                      (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                         (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                         (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                            (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                         (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                         (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X
                            (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                            f)
                         (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))))
                (@id.{0}
                   (@eq.{1} Prop
                      (@eq.{vâ‚+1}
                         (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                            (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                               (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                            (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                         (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                               (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                            (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                            (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                               (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                               (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                                  (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                                  (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                     (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                                  (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                                  (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X
                                     (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                                     f)
                                  (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)))
                            (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                         (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                            (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                            (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                               (@category_theory.functor.comp.{vâ‚ vâ‚ vâ‚ uâ‚ uâ‚ uâ‚} C ğ’ C ğ’ C ğ’ T T)
                               T
                               (@category_theory.monad.Î¼.{vâ‚ uâ‚} C ğ’ T _inst_1)
                               X)
                            (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                               (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                  (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                               (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                               (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X
                                  (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                                  f)
                               (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))))
                      (@eq.{vâ‚+1}
                         (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                            (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                               (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                            (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                         (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                  (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)))
                            (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                            (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                  (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                               (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X
                                  (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                                  f))
                            (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                               (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                  (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                     (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)))
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                  (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                               (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                               (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                  (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                     (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                                  (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                                  (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                               (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)))
                         (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                            (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                            (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                               (@category_theory.functor.comp.{vâ‚ vâ‚ vâ‚ uâ‚ uâ‚ uâ‚} C ğ’ C ğ’ C ğ’ T T)
                               T
                               (@category_theory.monad.Î¼.{vâ‚ uâ‚} C ğ’ T _inst_1)
                               X)
                            (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                               (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                  (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                               (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                               (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X
                                  (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                                  f)
                               (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)))))
                   ((Î»
                     (a a_1 :
                       @category_theory.has_hom.hom.{vâ‚ uâ‚} C
                         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                         (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                         (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                     (e_1 :
                       @eq.{vâ‚+1}
                         (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                            (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                               (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                            (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                         a
                         a_1)
                     (a_2 a_3 :
                       @category_theory.has_hom.hom.{vâ‚ uâ‚} C
                         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                         (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                         (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                     (e_2 :
                       @eq.{vâ‚+1}
                         (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                            (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                               (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                            (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                         a_2
                         a_3),
                       @congr.{vâ‚+1 1}
                         (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                            (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                               (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                            (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                         Prop
                         (@eq.{vâ‚+1}
                            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                  (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                               (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                            a)
                         (@eq.{vâ‚+1}
                            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                  (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                               (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                            a_1)
                         a_2
                         a_3
                         (@congr_arg.{vâ‚+1 (max (vâ‚+1) 1)}
                            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                  (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                               (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                  (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                               (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y) â†’
                             Prop)
                            a
                            a_1
                            (@eq.{vâ‚+1}
                               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                  (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                     (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                                  (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)))
                            e_1)
                         e_2)
                      (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                         (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                         (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                            (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                         (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                         (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                            (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                            (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                               (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                  (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                               (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                               (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X
                                  (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                                  f)
                               (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)))
                         (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                      (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                         (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                         (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                               (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)))
                         (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                         (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                               (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                            (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X
                               (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                               f))
                         (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                  (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)))
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                               (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                            (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                            (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                  (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                               (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                               (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                            (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)))
                      (@eq.trans.{vâ‚+1}
                         (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                            (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                               (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                            (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                         (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                               (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                            (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                            (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                               (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                               (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                                  (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                                  (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                     (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                                  (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                                  (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X
                                     (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                                     f)
                                  (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)))
                            (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                         (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                               (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                            (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                            (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                               (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                  (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                  (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                     (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)))
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                  (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                               (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                  (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                                  (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                     (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                                  (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X
                                     (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                                     f))
                               (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                  (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                     (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                                  (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                                  â€¦))
                            â€¦)
                         â€¦
                         â€¦
                         â€¦)
                      â€¦
                      â€¦
                      â€¦))
                â€¦)))
       â€¦)
    f'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
T : @category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’,
_inst_1 : @category_theory.monad.{vâ‚ uâ‚} C ğ’ T,
X : C,
Y : @category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1,
f :
  @category_theory.has_hom.hom.{vâ‚ (max uâ‚ vâ‚)} (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
    (@category_theory.category_struct.to_has_hom.{vâ‚ (max uâ‚ vâ‚)}
       (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
       (@category_theory.category.to_category_struct.{vâ‚ (max uâ‚ vâ‚)}
          (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
          (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)))
    (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ (max uâ‚ vâ‚)} C ğ’
       (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
       (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)
       (@category_theory.monad.free.{vâ‚ uâ‚} C ğ’ T _inst_1)
       X)
    Y
âŠ¢ @eq.{vâ‚+1}
    (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
       (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
       (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1
          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ (max uâ‚ vâ‚)} C ğ’
             (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)
             (@category_theory.monad.free.{vâ‚ uâ‚} C ğ’ T _inst_1)
             X))
       (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
    (@category_theory.monad.algebra.hom.f.{vâ‚ uâ‚} C ğ’ T _inst_1
       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ (max uâ‚ vâ‚)} C ğ’
          (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
          (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)
          (@category_theory.monad.free.{vâ‚ uâ‚} C ğ’ T _inst_1)
          X)
       Y
       ((Î»
         (f :
           @category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X
             (@category_theory.functor.obj.{vâ‚ vâ‚ (max uâ‚ vâ‚) uâ‚}
                (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)
                C
                ğ’
                (@category_theory.monad.forget.{vâ‚ uâ‚} C ğ’ T _inst_1)
                Y)),
           @category_theory.monad.algebra.hom.mk.{vâ‚ uâ‚} C ğ’ T _inst_1
             (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ (max uâ‚ vâ‚)} C ğ’
                (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)
                (@category_theory.monad.free.{vâ‚ uâ‚} C ğ’ T _inst_1)
                X)
             Y
             (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1
                   (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ (max uâ‚ vâ‚)} C ğ’
                      (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
                      (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)
                      (@category_theory.monad.free.{vâ‚ uâ‚} C ğ’ T _inst_1)
                      X))
                (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                   (@category_theory.functor.obj.{vâ‚ vâ‚ (max uâ‚ vâ‚) uâ‚}
                      (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
                      (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)
                      C
                      ğ’
                      (@category_theory.monad.forget.{vâ‚ uâ‚} C ğ’ T _inst_1)
                      Y))
                (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X
                   (@category_theory.functor.obj.{vâ‚ vâ‚ (max uâ‚ vâ‚) uâ‚}
                      (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
                      (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)
                      C
                      ğ’
                      (@category_theory.monad.forget.{vâ‚ uâ‚} C ğ’ T _inst_1)
                      Y)
                   f)
                (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
             (@id.{0}
                (@eq.{vâ‚+1}
                   (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                      (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                      (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                         (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ (max uâ‚ vâ‚)} C ğ’
                               (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
                               (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)
                               (@category_theory.monad.free.{vâ‚ uâ‚} C ğ’ T _inst_1)
                               X)))
                      (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                   (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                      (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                         (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ (max uâ‚ vâ‚)} C ğ’
                               (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
                               (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)
                               (@category_theory.monad.free.{vâ‚ uâ‚} C ğ’ T _inst_1)
                               X)))
                      (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                         (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                      (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                      (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                         (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ (max uâ‚ vâ‚)} C ğ’
                               (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
                               (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)
                               (@category_theory.monad.free.{vâ‚ uâ‚} C ğ’ T _inst_1)
                               X))
                         (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                         (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                            (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ (max uâ‚ vâ‚)} C ğ’
                                  (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
                                  (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)
                                  (@category_theory.monad.free.{vâ‚ uâ‚} C ğ’ T _inst_1)
                                  X))
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                               (@category_theory.functor.obj.{vâ‚ vâ‚ (max uâ‚ vâ‚) uâ‚}
                                  (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
                                  (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)
                                  C
                                  ğ’
                                  (@category_theory.monad.forget.{vâ‚ uâ‚} C ğ’ T _inst_1)
                                  Y))
                            (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                            (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X
                               (@category_theory.functor.obj.{vâ‚ vâ‚ (max uâ‚ vâ‚) uâ‚}
                                  (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
                                  (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)
                                  C
                                  ğ’
                                  (@category_theory.monad.forget.{vâ‚ uâ‚} C ğ’ T _inst_1)
                                  Y)
                               f)
                            (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)))
                      (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                   (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                      (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                         (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ (max uâ‚ vâ‚)} C ğ’
                               (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
                               (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)
                               (@category_theory.monad.free.{vâ‚ uâ‚} C ğ’ T _inst_1)
                               X)))
                      (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1
                         (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ (max uâ‚ vâ‚)} C ğ’
                            (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
                            (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)
                            (@category_theory.monad.free.{vâ‚ uâ‚} C ğ’ T _inst_1)
                            X))
                      (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                      (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1
                         (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ (max uâ‚ vâ‚)} C ğ’
                            (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
                            (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)
                            (@category_theory.monad.free.{vâ‚ uâ‚} C ğ’ T _inst_1)
                            X))
                      (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                         (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ (max uâ‚ vâ‚)} C ğ’
                               (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
                               (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)
                               (@category_theory.monad.free.{vâ‚ uâ‚} C ğ’ T _inst_1)
                               X))
                         (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                            (@category_theory.functor.obj.{vâ‚ vâ‚ (max uâ‚ vâ‚) uâ‚}
                               (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
                               (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)
                               C
                               ğ’
                               (@category_theory.monad.forget.{vâ‚ uâ‚} C ğ’ T _inst_1)
                               Y))
                         (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                         (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X
                            (@category_theory.functor.obj.{vâ‚ vâ‚ (max uâ‚ vâ‚) uâ‚}
                               (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
                               (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)
                               C
                               ğ’
                               (@category_theory.monad.forget.{vâ‚ uâ‚} C ğ’ T _inst_1)
                               Y)
                            f)
                         (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))))
                (@eq.mpr.{0}
                   (@eq.{vâ‚+1}
                      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                         (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                         (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                      (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                         (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                         (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                            (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                         (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                         (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                            (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                            (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                               (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                  (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                               (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                               (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X
                                  (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                                  f)
                               (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)))
                         (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                      (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                         (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                         (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                         (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                         (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                            (@category_theory.functor.comp.{vâ‚ vâ‚ vâ‚ uâ‚ uâ‚ uâ‚} C ğ’ C ğ’ C ğ’ T T)
                            T
                            (@category_theory.monad.Î¼.{vâ‚ uâ‚} C ğ’ T _inst_1)
                            X)
                         (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                               (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                            (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                            (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X
                               (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                               f)
                            (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))))
                   (@eq.{vâ‚+1}
                      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                         (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                         (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                      (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                         (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                         (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                               (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)))
                         (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                         (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                               (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                            (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X
                               (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                               f))
                         (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                  (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)))
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                               (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                            (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                            (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                  (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                               (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                               (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                            (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)))
                      (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                         (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                         (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                         (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                         (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                            (@category_theory.functor.comp.{vâ‚ vâ‚ vâ‚ uâ‚ uâ‚ uâ‚} C ğ’ C ğ’ C ğ’ T T)
                            T
                            (@category_theory.monad.Î¼.{vâ‚ uâ‚} C ğ’ T _inst_1)
                            X)
                         (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                               (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                            (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                            (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X
                               (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                               f)
                            (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))))
                   (@id.{0}
                      (@eq.{1} Prop
                         (@eq.{vâ‚+1}
                            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                  (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                               (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                            (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                               (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                  (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                  (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                               (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                               (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                  (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                                  (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                                  (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                                     (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                                     (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                        (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                                     (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                                     (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X
                                        (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                                        f)
                                     (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)))
                               (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                            (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                               (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                  (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                               (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                               (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                  (@category_theory.functor.comp.{vâ‚ vâ‚ vâ‚ uâ‚ uâ‚ uâ‚} C ğ’ C ğ’ C ğ’ T
                                     T)
                                  T
                                  (@category_theory.monad.Î¼.{vâ‚ uâ‚} C ğ’ T _inst_1)
                                  X)
                               (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                                  (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                                  (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                     (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                                  (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                                  (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X
                                     (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                                     f)
                                  (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))))
                         (@eq.{vâ‚+1}
                            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                  (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                               (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                            (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                               (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                  (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                  (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                     (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)))
                               (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                               (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                  (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                                  (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                     (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                                  (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X
                                     (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                                     f))
                               (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                                  (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                     (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                        (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)))
                                  (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                     (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                                  (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                                  (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                     (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                        (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                                     (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                                     (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                                  (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)))
                            (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                               (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                  (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                               (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                               (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                  (@category_theory.functor.comp.{vâ‚ vâ‚ vâ‚ uâ‚ uâ‚ uâ‚} C ğ’ C ğ’ C ğ’ T
                                     T)
                                  T
                                  (@category_theory.monad.Î¼.{vâ‚ uâ‚} C ğ’ T _inst_1)
                                  X)
                               (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                                  (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                                  (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                     (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                                  (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                                  (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X
                                     (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                                     f)
                                  (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)))))
                      ((Î»
                        (a a_1 :
                          @category_theory.has_hom.hom.{vâ‚ uâ‚} C
                            (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                               (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                            (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                        (e_1 :
                          @eq.{vâ‚+1}
                            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                  (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                               (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                            a
                            a_1)
                        (a_2 a_3 :
                          @category_theory.has_hom.hom.{vâ‚ uâ‚} C
                            (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                               (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                            (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                        (e_2 :
                          @eq.{vâ‚+1}
                            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                  (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                               (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                            a_2
                            a_3),
                          @congr.{vâ‚+1 1}
                            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                  (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                               (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                            Prop
                            (@eq.{vâ‚+1}
                               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                  (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                     (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                                  (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                               a)
                            (@eq.{vâ‚+1}
                               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                  (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                     (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                                  (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                               a_1)
                            a_2
                            a_3
                            (@congr_arg.{vâ‚+1 (max (vâ‚+1) 1)}
                               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                  (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                     (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                                  (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                  (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                     (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                                  (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y) â†’
                                Prop)
                               a
                               a_1
                               (@eq.{vâ‚+1}
                                  (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                     (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                        (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                     (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                        (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                                     (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)))
                               e_1)
                            e_2)
                         (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                               (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                            (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                            (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                               (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                               (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                                  (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                                  (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                     (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                                  (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                                  (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X
                                     (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                                     f)
                                  (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)))
                            (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                         (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                  (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)))
                            (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                            (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                  (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                               (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X
                                  (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                                  f))
                            (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                               (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                  (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                     (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)))
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                  (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                               (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                               (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                  (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                     (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                                  (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                                  (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                               (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)))
                         (@eq.trans.{vâ‚+1}
                            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                  (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                               (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                            (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                               (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                  (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                  (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                               (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                               (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                  (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                                  (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                                  (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                                     (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                                     (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                        (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                                     (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                                     (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X
                                        (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                                        f)
                                     (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)))
                               (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                            (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                               (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                  (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                  (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                               (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                               (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                                  (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                     (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                                  (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                     (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                        (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)))
                                  (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                     (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                                  (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                     (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                                     (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                        (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                                     (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X
                                        (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                                        f))
                                  (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T â€¦ â€¦ â€¦))
                               â€¦)
                            â€¦
                            â€¦
                            â€¦)
                         â€¦
                         â€¦
                         â€¦))
                   â€¦)))
          â€¦))
    â€¦'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
T : @category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’,
_inst_1 : @category_theory.monad.{vâ‚ uâ‚} C ğ’ T,
X : C,
Y : @category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1,
f :
  @category_theory.has_hom.hom.{vâ‚ (max uâ‚ vâ‚)} (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
    (@category_theory.category_struct.to_has_hom.{vâ‚ (max uâ‚ vâ‚)}
       (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
       (@category_theory.category.to_category_struct.{vâ‚ (max uâ‚ vâ‚)}
          (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
          (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)))
    (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ (max uâ‚ vâ‚)} C ğ’
       (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
       (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)
       (@category_theory.monad.free.{vâ‚ uâ‚} C ğ’ T _inst_1)
       X)
    Y
âŠ¢ @eq.{vâ‚+1}
    (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
       (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
       (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
    (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
          (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
       (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
       (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X
          (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
          (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
             (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
             X
             (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
             (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
             (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                T
                (@category_theory.monad.Î·.{vâ‚ uâ‚} C ğ’ T _inst_1)
                X)
             (@category_theory.monad.algebra.hom.f.{vâ‚ uâ‚} C ğ’ T _inst_1
                (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ (max uâ‚ vâ‚)} C ğ’
                   (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)
                   (@category_theory.monad.free.{vâ‚ uâ‚} C ğ’ T _inst_1)
                   X)
                Y
                f)))
       (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
    (@category_theory.monad.algebra.hom.f.{vâ‚ uâ‚} C ğ’ T _inst_1
       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ (max uâ‚ vâ‚)} C ğ’
          (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
          (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)
          (@category_theory.monad.free.{vâ‚ uâ‚} C ğ’ T _inst_1)
          X)
       Y
       f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>103        simp only [free_obj_a, functor.map_comp, algebra.hom.h, category.assoc],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='category_theory.monad.free_obj_a'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.functor.map_comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.monad.algebra.hom.h'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.category.assoc'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 77, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (option.{0} unit) (Î» (a : option.{0} unit), @option.has_reflect unit (Î» (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) â†’ @interactive.parse bool (Î» (a : bool), bool.has_reflect a) interactive.types.only_flag â†’ @interactive.parse (list.{0} tactic.simp_arg_type) (Î» (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (Î» (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list â†’ @interactive.parse (list.{0} name) (Î» (a : list.{0} name), @list.reflect name (Î» (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='âˆ€ {C : Type ?l_1} [ğ’ : category_theory.category.{?l_2 ?l_1} C] (T : @category_theory.functor.{?l_2 ?l_2 ?l_1 ?l_1} C ğ’ C ğ’) [_inst_1 : @category_theory.monad.{?l_2 ?l_1} C ğ’ T] (X : C), @eq.{?l_2+1} (@category_theory.has_hom.hom.{?l_2 ?l_1} C (@category_theory.category_struct.to_has_hom.{?l_2 ?l_1} C (@category_theory.category.to_category_struct.{?l_2 ?l_1} C ğ’)) (@category_theory.functor.obj.{?l_2 ?l_2 ?l_1 ?l_1} C ğ’ C ğ’ (@category_theory.functor.comp.{?l_2 ?l_2 ?l_2 ?l_1 ?l_1 ?l_1} C ğ’ C ğ’ C ğ’ T T) X) (@category_theory.functor.obj.{?l_2 ?l_2 ?l_1 ?l_1} C ğ’ C ğ’ T X)) (@category_theory.monad.algebra.a.{?l_2 ?l_1} C ğ’ T _inst_1 (@category_theory.functor.obj.{?l_2 ?l_2 ?l_1 (max ?l_1 ?l_2)} C ğ’ (@category_theory.monad.algebra.{?l_2 ?l_1} C ğ’ T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{?l_2 ?l_1} C ğ’ T _inst_1) (@category_theory.monad.free.{?l_2 ?l_1} C ğ’ T _inst_1) X)) (@category_theory.nat_trans.app.{?l_2 ?l_2 ?l_1 ?l_1} C ğ’ C ğ’ (@category_theory.functor.comp.{?l_2 ?l_2 ?l_2 ?l_1 ?l_1 ?l_1} C ğ’ C ğ’ C ğ’ T T) T (@category_theory.monad.Î¼.{?l_2 ?l_1} C ğ’ T _inst_1) X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (Î» (a : option.{0} unit), @option.has_reflect unit (Î» (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) â†’ @interactive.parse bool (Î» (a : bool), bool.has_reflect a) interactive.types.only_flag â†’ @interactive.parse (list.{0} tactic.simp_arg_type) (Î» (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (Î» (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list â†’ @interactive.parse (list.{0} name) (Î» (a : list.{0} name), @list.reflect name (Î» (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='âˆ€ {C : Type ?l_1} [_inst_1 : category_theory.category.{?l_2 ?l_1} C] {D : Type ?l_3} [_inst_2 : category_theory.category.{?l_4 ?l_3} D] (c : @category_theory.functor.{?l_2 ?l_4 ?l_1 ?l_3} C _inst_1 D _inst_2) {X Y Z : C} (f : @category_theory.has_hom.hom.{?l_2 ?l_1} C (@category_theory.category_struct.to_has_hom.{?l_2 ?l_1} C (@category_theory.category.to_category_struct.{?l_2 ?l_1} C _inst_1)) X Y) (g : @category_theory.has_hom.hom.{?l_2 ?l_1} C (@category_theory.category_struct.to_has_hom.{?l_2 ?l_1} C (@category_theory.category.to_category_struct.{?l_2 ?l_1} C _inst_1)) Y Z), @eq.{?l_4+1} (@category_theory.has_hom.hom.{?l_4 ?l_3} D (@category_theory.category_struct.to_has_hom.{?l_4 ?l_3} D (@category_theory.category.to_category_struct.{?l_4 ?l_3} D _inst_2)) (@category_theory.functor.obj.{?l_2 ?l_4 ?l_1 ?l_3} C _inst_1 D _inst_2 c X) (@category_theory.functor.obj.{?l_2 ?l_4 ?l_1 ?l_3} C _inst_1 D _inst_2 c Z)) (@category_theory.functor.map.{?l_2 ?l_4 ?l_1 ?l_3} C _inst_1 D _inst_2 c X Z (@category_theory.category_struct.comp.{?l_2 ?l_1} C (@category_theory.category.to_category_struct.{?l_2 ?l_1} C _inst_1) X Y Z f g)) (@category_theory.category_struct.comp.{?l_4 ?l_3} D (@category_theory.category.to_category_struct.{?l_4 ?l_3} D _inst_2) (@category_theory.functor.obj.{?l_2 ?l_4 ?l_1 ?l_3} C _inst_1 D _inst_2 c X) (@category_theory.functor.obj.{?l_2 ?l_4 ?l_1 ?l_3} C _inst_1 D _inst_2 c Y) (@category_theory.functor.obj.{?l_2 ?l_4 ?l_1 ?l_3} C _inst_1 D _inst_2 c Z) (@category_theory.functor.map.{?l_2 ?l_4 ?l_1 ?l_3} C _inst_1 D _inst_2 c X Y f) (@category_theory.functor.map.{?l_2 ?l_4 ?l_1 ?l_3} C _inst_1 D _inst_2 c Y Z g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (Î» (a : option.{0} unit), @option.has_reflect unit (Î» (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) â†’ @interactive.parse bool (Î» (a : bool), bool.has_reflect a) interactive.types.only_flag â†’ @interactive.parse (list.{0} tactic.simp_arg_type) (Î» (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (Î» (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list â†’ @interactive.parse (list.{0} name) (Î» (a : list.{0} name), @list.reflect name (Î» (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='âˆ€ {C : Type ?l_1} [ğ’ : category_theory.category.{?l_2 ?l_1} C] {T : @category_theory.functor.{?l_2 ?l_2 ?l_1 ?l_1} C ğ’ C ğ’} [_inst_1 : @category_theory.monad.{?l_2 ?l_1} C ğ’ T] {A B : @category_theory.monad.algebra.{?l_2 ?l_1} C ğ’ T _inst_1} (c : @category_theory.monad.algebra.hom.{?l_2 ?l_1} C ğ’ T _inst_1 A B), @eq.{?l_2+1} (@category_theory.has_hom.hom.{?l_2 ?l_1} C (@category_theory.category_struct.to_has_hom.{?l_2 ?l_1} C (@category_theory.category.to_category_struct.{?l_2 ?l_1} C ğ’)) (@category_theory.functor.obj.{?l_2 ?l_2 ?l_1 ?l_1} C ğ’ C ğ’ T (@category_theory.monad.algebra.A.{?l_2 ?l_1} C ğ’ T _inst_1 A)) (@category_theory.monad.algebra.A.{?l_2 ?l_1} C ğ’ T _inst_1 B)) (@category_theory.category_struct.comp.{?l_2 ?l_1} C (@category_theory.category.to_category_struct.{?l_2 ?l_1} C ğ’) (@category_theory.functor.obj.{?l_2 ?l_2 ?l_1 ?l_1} C ğ’ C ğ’ T (@category_theory.monad.algebra.A.{?l_2 ?l_1} C ğ’ T _inst_1 A)) (@category_theory.functor.obj.{?l_2 ?l_2 ?l_1 ?l_1} C ğ’ C ğ’ T (@category_theory.monad.algebra.A.{?l_2 ?l_1} C ğ’ T _inst_1 B)) (@category_theory.monad.algebra.A.{?l_2 ?l_1} C ğ’ T _inst_1 B) (@category_theory.functor.map.{?l_2 ?l_2 ?l_1 ?l_1} C ğ’ C ğ’ T (@category_theory.monad.algebra.A.{?l_2 ?l_1} C ğ’ T _inst_1 A) (@category_theory.monad.algebra.A.{?l_2 ?l_1} C ğ’ T _inst_1 B) (@category_theory.monad.algebra.hom.f.{?l_2 ?l_1} C ğ’ T _inst_1 A B c)) (@category_theory.monad.algebra.a.{?l_2 ?l_1} C ğ’ T _inst_1 B)) (@category_theory.category_struct.comp.{?l_2 ?l_1} C (@category_theory.category.to_category_struct.{?l_2 ?l_1} C ğ’) (@category_theory.functor.obj.{?l_2 ?l_2 ?l_1 ?l_1} C ğ’ C ğ’ T (@category_theory.monad.algebra.A.{?l_2 ?l_1} C ğ’ T _inst_1 A)) (@category_theory.monad.algebra.A.{?l_2 ?l_1} C ğ’ T _inst_1 A) (@category_theory.monad.algebra.A.{?l_2 ?l_1} C ğ’ T _inst_1 B) (@category_theory.monad.algebra.a.{?l_2 ?l_1} C ğ’ T _inst_1 A) (@category_theory.monad.algebra.hom.f.{?l_2 ?l_1} C ğ’ T _inst_1 A B c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (Î» (a : option.{0} unit), @option.has_reflect unit (Î» (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) â†’ @interactive.parse bool (Î» (a : bool), bool.has_reflect a) interactive.types.only_flag â†’ @interactive.parse (list.{0} tactic.simp_arg_type) (Î» (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (Î» (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list â†’ @interactive.parse (list.{0} name) (Î» (a : list.{0} name), @list.reflect name (Î» (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='âˆ€ (obj : Type ?l_1) [c : category_theory.category.{?l_2 ?l_1} obj] {W X Y Z : obj} (f : @category_theory.has_hom.hom.{?l_2 ?l_1} obj (@category_theory.category_struct.to_has_hom.{?l_2 ?l_1} obj (@category_theory.category.to_category_struct.{?l_2 ?l_1} obj c)) W X) (g : @category_theory.has_hom.hom.{?l_2 ?l_1} obj (@category_theory.category_struct.to_has_hom.{?l_2 ?l_1} obj (@category_theory.category.to_category_struct.{?l_2 ?l_1} obj c)) X Y) (h : @category_theory.has_hom.hom.{?l_2 ?l_1} obj (@category_theory.category_struct.to_has_hom.{?l_2 ?l_1} obj (@category_theory.category.to_category_struct.{?l_2 ?l_1} obj c)) Y Z), @eq.{?l_2+1} (@category_theory.has_hom.hom.{?l_2 ?l_1} obj (@category_theory.category_struct.to_has_hom.{?l_2 ?l_1} obj (@category_theory.category.to_category_struct.{?l_2 ?l_1} obj c)) W Z) (@category_theory.category_struct.comp.{?l_2 ?l_1} obj (@category_theory.category.to_category_struct.{?l_2 ?l_1} obj c) W Y Z (@category_theory.category_struct.comp.{?l_2 ?l_1} obj (@category_theory.category.to_category_struct.{?l_2 ?l_1} obj c) W X Y f g) h) (@category_theory.category_struct.comp.{?l_2 ?l_1} obj (@category_theory.category.to_category_struct.{?l_2 ?l_1} obj c) W X Z f (@category_theory.category_struct.comp.{?l_2 ?l_1} obj (@category_theory.category.to_category_struct.{?l_2 ?l_1} obj c) X Y Z g h))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (Î» (a : option.{0} unit), @option.has_reflect unit (Î» (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) â†’ @interactive.parse bool (Î» (a : bool), bool.has_reflect a) interactive.types.only_flag â†’ @interactive.parse (list.{0} tactic.simp_arg_type) (Î» (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (Î» (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list â†’ @interactive.parse (list.{0} name) (Î» (a : list.{0} name), @list.reflect name (Î» (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [hâ‚ hâ‚‚ ... hâ‚™]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `háµ¢`&#x27;s, where the `háµ¢`&#x27;s are expressions. If an `háµ¢` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [hâ‚ hâ‚‚ ... hâ‚™]` is like `simp [hâ‚ hâ‚‚ ... hâ‚™]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idáµ¢`.

`simp at hâ‚ hâ‚‚ ... hâ‚™` simplifies the non-dependent hypotheses `hâ‚ : Tâ‚` ... `hâ‚™ : Tâ‚™`. The tactic fails if the target or another hypothesis depends on one of them. The token `âŠ¢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attrâ‚ ... attrâ‚™` simplifies the main goal target using the lemmas tagged with any of the attributes `[attrâ‚]`, ..., `[attrâ‚™]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [hâ‚ hâ‚‚ ... hâ‚™]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `háµ¢`&#x27;s, where the `háµ¢`&#x27;s are expressions. If an `háµ¢` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [hâ‚ hâ‚‚ ... hâ‚™]` is like `simp [hâ‚ hâ‚‚ ... hâ‚™]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idáµ¢`.

`simp at hâ‚ hâ‚‚ ... hâ‚™` simplifies the non-dependent hypotheses `hâ‚ : Tâ‚` ... `hâ‚™ : Tâ‚™`. The tactic fails if the target or another hypothesis depends on one of them. The token `âŠ¢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attrâ‚ ... attrâ‚™` simplifies the main goal target using the lemmas tagged with any of the attributes `[attrâ‚]`, ..., `[attrâ‚™]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [hâ‚ hâ‚‚ ... hâ‚™]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `háµ¢`&#x27;s, where the `háµ¢`&#x27;s are expressions. If an `háµ¢` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [hâ‚ hâ‚‚ ... hâ‚™]` is like `simp [hâ‚ hâ‚‚ ... hâ‚™]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idáµ¢`.

`simp at hâ‚ hâ‚‚ ... hâ‚™` simplifies the non-dependent hypotheses `hâ‚ : Tâ‚` ... `hâ‚™ : Tâ‚™`. The tactic fails if the target or another hypothesis depends on one of them. The token `âŠ¢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attrâ‚ ... attrâ‚™` simplifies the main goal target using the lemmas tagged with any of the attributes `[attrâ‚]`, ..., `[attrâ‚™]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [hâ‚ hâ‚‚ ... hâ‚™]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `háµ¢`&#x27;s, where the `háµ¢`&#x27;s are expressions. If an `háµ¢` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [hâ‚ hâ‚‚ ... hâ‚™]` is like `simp [hâ‚ hâ‚‚ ... hâ‚™]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idáµ¢`.

`simp at hâ‚ hâ‚‚ ... hâ‚™` simplifies the non-dependent hypotheses `hâ‚ : Tâ‚` ... `hâ‚™ : Tâ‚™`. The tactic fails if the target or another hypothesis depends on one of them. The token `âŠ¢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attrâ‚ ... attrâ‚™` simplifies the main goal target using the lemmas tagged with any of the attributes `[attrâ‚]`, ..., `[attrâ‚™]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [hâ‚ hâ‚‚ ... hâ‚™]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `háµ¢`&#x27;s, where the `háµ¢`&#x27;s are expressions. If an `háµ¢` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [hâ‚ hâ‚‚ ... hâ‚™]` is like `simp [hâ‚ hâ‚‚ ... hâ‚™]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idáµ¢`.

`simp at hâ‚ hâ‚‚ ... hâ‚™` simplifies the non-dependent hypotheses `hâ‚ : Tâ‚` ... `hâ‚™ : Tâ‚™`. The tactic fails if the target or another hypothesis depends on one of them. The token `âŠ¢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attrâ‚ ... attrâ‚™` simplifies the main goal target using the lemmas tagged with any of the attributes `[attrâ‚]`, ..., `[attrâ‚™]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
T : @category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’,
_inst_1 : @category_theory.monad.{vâ‚ uâ‚} C ğ’ T,
X : C,
Y : @category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1,
f :
  @category_theory.has_hom.hom.{vâ‚ (max uâ‚ vâ‚)} (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
    (@category_theory.category_struct.to_has_hom.{vâ‚ (max uâ‚ vâ‚)}
       (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
       (@category_theory.category.to_category_struct.{vâ‚ (max uâ‚ vâ‚)}
          (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
          (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)))
    (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ (max uâ‚ vâ‚)} C ğ’
       (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
       (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)
       (@category_theory.monad.free.{vâ‚ uâ‚} C ğ’ T _inst_1)
       X)
    Y
âŠ¢ @eq.{vâ‚+1}
    (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
       (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
       (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
    (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
          (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
       (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
       (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X
          (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
          (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
             (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
             X
             (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
             (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
             (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                T
                (@category_theory.monad.Î·.{vâ‚ uâ‚} C ğ’ T _inst_1)
                X)
             (@category_theory.monad.algebra.hom.f.{vâ‚ uâ‚} C ğ’ T _inst_1
                (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ (max uâ‚ vâ‚)} C ğ’
                   (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)
                   (@category_theory.monad.free.{vâ‚ uâ‚} C ğ’ T _inst_1)
                   X)
                Y
                f)))
       (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
    (@category_theory.monad.algebra.hom.f.{vâ‚ uâ‚} C ğ’ T _inst_1
       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ (max uâ‚ vâ‚)} C ğ’
          (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
          (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)
          (@category_theory.monad.free.{vâ‚ uâ‚} C ğ’ T _inst_1)
          X)
       Y
       f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
T : @category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’,
_inst_1 : @category_theory.monad.{vâ‚ uâ‚} C ğ’ T,
X : C,
Y : @category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1,
f :
  @category_theory.has_hom.hom.{vâ‚ (max uâ‚ vâ‚)} (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
    (@category_theory.category_struct.to_has_hom.{vâ‚ (max uâ‚ vâ‚)}
       (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
       (@category_theory.category.to_category_struct.{vâ‚ (max uâ‚ vâ‚)}
          (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
          (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)))
    (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ (max uâ‚ vâ‚)} C ğ’
       (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
       (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)
       (@category_theory.monad.free.{vâ‚ uâ‚} C ğ’ T _inst_1)
       X)
    Y
âŠ¢ @eq.{vâ‚+1}
    (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
       (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
       (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
    (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
       (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
       (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X
          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
          (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
             (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
             T
             (@category_theory.monad.Î·.{vâ‚ uâ‚} C ğ’ T _inst_1)
             X))
       (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
             (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1
                (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ (max uâ‚ vâ‚)} C ğ’
                   (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)
                   (@category_theory.monad.free.{vâ‚ uâ‚} C ğ’ T _inst_1)
                   X)))
          (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1
             (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ (max uâ‚ vâ‚)} C ğ’
                (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)
                (@category_theory.monad.free.{vâ‚ uâ‚} C ğ’ T _inst_1)
                X))
          (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
          (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
             (@category_theory.functor.comp.{vâ‚ vâ‚ vâ‚ uâ‚ uâ‚ uâ‚} C ğ’ C ğ’ C ğ’ T T)
             T
             (@category_theory.monad.Î¼.{vâ‚ uâ‚} C ğ’ T _inst_1)
             X)
          (@category_theory.monad.algebra.hom.f.{vâ‚ uâ‚} C ğ’ T _inst_1
             (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ (max uâ‚ vâ‚)} C ğ’
                (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)
                (@category_theory.monad.free.{vâ‚ uâ‚} C ğ’ T _inst_1)
                X)
             Y
             f)))
    (@category_theory.monad.algebra.hom.f.{vâ‚ uâ‚} C ğ’ T _inst_1
       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ (max uâ‚ vâ‚)} C ğ’
          (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
          (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)
          (@category_theory.monad.free.{vâ‚ uâ‚} C ğ’ T _inst_1)
          X)
       Y
       f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>104        erw [â†category.assoc, monad.right_unit, id_comp],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='category_theory.category.assoc'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.monad.right_unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.category.id_comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/monad/basic.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (Î» (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='âˆ€ (obj : Type uâ‚) [c : category_theory.category.{vâ‚ uâ‚} obj] {W X Y Z : obj} (f : @category_theory.has_hom.hom.{vâ‚ uâ‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} obj (@category_theory.category.to_category_struct.{vâ‚ uâ‚} obj c)) W X) (g : @category_theory.has_hom.hom.{vâ‚ uâ‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} obj (@category_theory.category.to_category_struct.{vâ‚ uâ‚} obj c)) X Y) (h : @category_theory.has_hom.hom.{vâ‚ uâ‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} obj (@category_theory.category.to_category_struct.{vâ‚ uâ‚} obj c)) Y Z), @eq.{vâ‚+1} (@category_theory.has_hom.hom.{vâ‚ uâ‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} obj (@category_theory.category.to_category_struct.{vâ‚ uâ‚} obj c)) W Z) (@category_theory.category_struct.comp.{vâ‚ uâ‚} obj (@category_theory.category.to_category_struct.{vâ‚ uâ‚} obj c) W Y Z (@category_theory.category_struct.comp.{vâ‚ uâ‚} obj (@category_theory.category.to_category_struct.{vâ‚ uâ‚} obj c) W X Y f g) h) (@category_theory.category_struct.comp.{vâ‚ uâ‚} obj (@category_theory.category.to_category_struct.{vâ‚ uâ‚} obj c) W X Z f (@category_theory.category_struct.comp.{vâ‚ uâ‚} obj (@category_theory.category.to_category_struct.{vâ‚ uâ‚} obj c) X Y Z g h))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (Î» (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='âˆ€ {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] (T : @category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’) [c : @category_theory.monad.{vâ‚ uâ‚} C ğ’ T] (X : C), @eq.{vâ‚+1} (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X) (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)) (@category_theory.category_struct.comp.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’) (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X) (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)) (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X) (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X) (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’) T (@category_theory.monad.Î·.{vâ‚ uâ‚} C ğ’ T c) X)) (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ (@category_theory.functor.comp.{vâ‚ vâ‚ vâ‚ uâ‚ uâ‚ uâ‚} C ğ’ C ğ’ C ğ’ T T) T (@category_theory.monad.Î¼.{vâ‚ uâ‚} C ğ’ T c) X)) (@category_theory.category_struct.id.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’) (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (Î» (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='âˆ€ (obj : Type uâ‚) [c : category_theory.category.{vâ‚ uâ‚} obj] {X Y : obj} (f : @category_theory.has_hom.hom.{vâ‚ uâ‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} obj (@category_theory.category.to_category_struct.{vâ‚ uâ‚} obj c)) X Y), @eq.{vâ‚+1} (@category_theory.has_hom.hom.{vâ‚ uâ‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} obj (@category_theory.category.to_category_struct.{vâ‚ uâ‚} obj c)) X Y) (@category_theory.category_struct.comp.{vâ‚ uâ‚} obj (@category_theory.category.to_category_struct.{vâ‚ uâ‚} obj c) X X Y (@category_theory.category_struct.id.{vâ‚ uâ‚} obj (@category_theory.category.to_category_struct.{vâ‚ uâ‚} obj c) X) f) f'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (Î» (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;([ (â†? expr), ... ] | â†? expr)&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;([ (â†? expr), ... ] | â†? expr)&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;([ (â†? expr), ... ] | â†? expr)&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;([ (â†? expr), ... ] | â†? expr)&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
T : @category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’,
_inst_1 : @category_theory.monad.{vâ‚ uâ‚} C ğ’ T,
X : C,
Y : @category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1,
f :
  @category_theory.has_hom.hom.{vâ‚ (max uâ‚ vâ‚)} (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
    (@category_theory.category_struct.to_has_hom.{vâ‚ (max uâ‚ vâ‚)}
       (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
       (@category_theory.category.to_category_struct.{vâ‚ (max uâ‚ vâ‚)}
          (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
          (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)))
    (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ (max uâ‚ vâ‚)} C ğ’
       (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
       (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)
       (@category_theory.monad.free.{vâ‚ uâ‚} C ğ’ T _inst_1)
       X)
    Y
âŠ¢ @eq.{vâ‚+1}
    (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
       (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
       (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
    (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
       (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
       (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X
          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
          (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
             (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
             T
             (@category_theory.monad.Î·.{vâ‚ uâ‚} C ğ’ T _inst_1)
             X))
       (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
             (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1
                (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ (max uâ‚ vâ‚)} C ğ’
                   (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
                   (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)
                   (@category_theory.monad.free.{vâ‚ uâ‚} C ğ’ T _inst_1)
                   X)))
          (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1
             (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ (max uâ‚ vâ‚)} C ğ’
                (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)
                (@category_theory.monad.free.{vâ‚ uâ‚} C ğ’ T _inst_1)
                X))
          (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
          (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
             (@category_theory.functor.comp.{vâ‚ vâ‚ vâ‚ uâ‚ uâ‚ uâ‚} C ğ’ C ğ’ C ğ’ T T)
             T
             (@category_theory.monad.Î¼.{vâ‚ uâ‚} C ğ’ T _inst_1)
             X)
          (@category_theory.monad.algebra.hom.f.{vâ‚ uâ‚} C ğ’ T _inst_1
             (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ (max uâ‚ vâ‚)} C ğ’
                (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)
                (@category_theory.monad.free.{vâ‚ uâ‚} C ğ’ T _inst_1)
                X)
             Y
             f)))
    (@category_theory.monad.algebra.hom.f.{vâ‚ uâ‚} C ğ’ T _inst_1
       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ (max uâ‚ vâ‚)} C ğ’
          (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
          (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)
          (@category_theory.monad.free.{vâ‚ uâ‚} C ğ’ T _inst_1)
          X)
       Y
       f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
T : @category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’,
_inst_1 : @category_theory.monad.{vâ‚ uâ‚} C ğ’ T,
X : C,
Y : @category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1,
f :
  @category_theory.has_hom.hom.{vâ‚ (max uâ‚ vâ‚)} (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
    (@category_theory.category_struct.to_has_hom.{vâ‚ (max uâ‚ vâ‚)}
       (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
       (@category_theory.category.to_category_struct.{vâ‚ (max uâ‚ vâ‚)}
          (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
          (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)))
    (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ (max uâ‚ vâ‚)} C ğ’
       (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
       (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)
       (@category_theory.monad.free.{vâ‚ uâ‚} C ğ’ T _inst_1)
       X)
    Y
âŠ¢ @eq.{vâ‚+1}
    (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
       (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
       (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
    (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
       (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1
          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ (max uâ‚ vâ‚)} C ğ’
             (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)
             (@category_theory.monad.free.{vâ‚ uâ‚} C ğ’ T _inst_1)
             X))
       (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
       (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
             (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
          (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1
             (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ (max uâ‚ vâ‚)} C ğ’
                (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)
                (@category_theory.monad.free.{vâ‚ uâ‚} C ğ’ T _inst_1)
                X))
          (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X
             (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
             (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                T
                (@category_theory.monad.Î·.{vâ‚ uâ‚} C ğ’ T _inst_1)
                X))
          (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
             (@category_theory.functor.comp.{vâ‚ vâ‚ vâ‚ uâ‚ uâ‚ uâ‚} C ğ’ C ğ’ C ğ’ T T)
             T
             (@category_theory.monad.Î¼.{vâ‚ uâ‚} C ğ’ T _inst_1)
             X))
       (@category_theory.monad.algebra.hom.f.{vâ‚ uâ‚} C ğ’ T _inst_1
          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ (max uâ‚ vâ‚)} C ğ’
             (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)
             (@category_theory.monad.free.{vâ‚ uâ‚} C ğ’ T _inst_1)
             X)
          Y
          f))
    (@category_theory.monad.algebra.hom.f.{vâ‚ uâ‚} C ğ’ T _inst_1
       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ (max uâ‚ vâ‚)} C ğ’
          (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
          (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)
          (@category_theory.monad.free.{vâ‚ uâ‚} C ğ’ T _inst_1)
          X)
       Y
       f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
T : @category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’,
_inst_1 : @category_theory.monad.{vâ‚ uâ‚} C ğ’ T,
X : C,
Y : @category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1,
f :
  @category_theory.has_hom.hom.{vâ‚ (max uâ‚ vâ‚)} (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
    (@category_theory.category_struct.to_has_hom.{vâ‚ (max uâ‚ vâ‚)}
       (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
       (@category_theory.category.to_category_struct.{vâ‚ (max uâ‚ vâ‚)}
          (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
          (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)))
    (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ (max uâ‚ vâ‚)} C ğ’
       (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
       (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)
       (@category_theory.monad.free.{vâ‚ uâ‚} C ğ’ T _inst_1)
       X)
    Y
âŠ¢ @eq.{vâ‚+1}
    (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
       (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
       (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
    (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
       (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1
          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ (max uâ‚ vâ‚)} C ğ’
             (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)
             (@category_theory.monad.free.{vâ‚ uâ‚} C ğ’ T _inst_1)
             X))
       (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
       (@category_theory.category_struct.id.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
       (@category_theory.monad.algebra.hom.f.{vâ‚ uâ‚} C ğ’ T _inst_1
          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ (max uâ‚ vâ‚)} C ğ’
             (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)
             (@category_theory.monad.free.{vâ‚ uâ‚} C ğ’ T _inst_1)
             X)
          Y
          f))
    (@category_theory.monad.algebra.hom.f.{vâ‚ uâ‚} C ğ’ T _inst_1
       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ (max uâ‚ vâ‚)} C ğ’
          (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
          (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)
          (@category_theory.monad.free.{vâ‚ uâ‚} C ğ’ T _inst_1)
          X)
       Y
       f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>105      end,</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>106      right_inv := Î» f,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='green'><a title='@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (@category_theory.functor.obj.{vâ‚ vâ‚ (max uâ‚ vâ‚) uâ‚} (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1) (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1) C ğ’ (@category_theory.monad.forget.{vâ‚ uâ‚} C ğ’ T _inst_1) Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>107      begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
T : @category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’,
_inst_1 : @category_theory.monad.{vâ‚ uâ‚} C ğ’ T,
X : C,
Y : @category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1,
f :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X
    (@category_theory.functor.obj.{vâ‚ vâ‚ (max uâ‚ vâ‚) uâ‚}
       (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
       (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)
       C
       ğ’
       (@category_theory.monad.forget.{vâ‚ uâ‚} C ğ’ T _inst_1)
       Y)
âŠ¢ @eq.{vâ‚+1}
    (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
       (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
       X
       (@category_theory.functor.obj.{vâ‚ vâ‚ (max uâ‚ vâ‚) uâ‚}
          (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
          (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)
          C
          ğ’
          (@category_theory.monad.forget.{vâ‚ uâ‚} C ğ’ T _inst_1)
          Y))
    ((Î»
      (f :
        @category_theory.has_hom.hom.{vâ‚ (max uâ‚ vâ‚)}
          (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
          (@category_theory.category_struct.to_has_hom.{vâ‚ (max uâ‚ vâ‚)}
             (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
             (@category_theory.category.to_category_struct.{vâ‚ (max uâ‚ vâ‚)}
                (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)))
          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ (max uâ‚ vâ‚)} C ğ’
             (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)
             (@category_theory.monad.free.{vâ‚ uâ‚} C ğ’ T _inst_1)
             X)
          Y),
        @category_theory.category_struct.comp.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
          X
          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
          (@category_theory.functor.obj.{vâ‚ vâ‚ (max uâ‚ vâ‚) uâ‚}
             (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)
             C
             ğ’
             (@category_theory.monad.forget.{vâ‚ uâ‚} C ğ’ T _inst_1)
             Y)
          (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
             (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
             T
             (@category_theory.monad.Î·.{vâ‚ uâ‚} C ğ’ T _inst_1)
             X)
          (@category_theory.monad.algebra.hom.f.{vâ‚ uâ‚} C ğ’ T _inst_1
             (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ (max uâ‚ vâ‚)} C ğ’
                (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)
                (@category_theory.monad.free.{vâ‚ uâ‚} C ğ’ T _inst_1)
                X)
             Y
             f))
       ((Î»
         (f :
           @category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X
             (@category_theory.functor.obj.{vâ‚ vâ‚ (max uâ‚ vâ‚) uâ‚}
                (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)
                C
                ğ’
                (@category_theory.monad.forget.{vâ‚ uâ‚} C ğ’ T _inst_1)
                Y)),
           @category_theory.monad.algebra.hom.mk.{vâ‚ uâ‚} C ğ’ T _inst_1
             (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ (max uâ‚ vâ‚)} C ğ’
                (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)
                (@category_theory.monad.free.{vâ‚ uâ‚} C ğ’ T _inst_1)
                X)
             Y
             (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1
                   (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ (max uâ‚ vâ‚)} C ğ’
                      (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
                      (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)
                      (@category_theory.monad.free.{vâ‚ uâ‚} C ğ’ T _inst_1)
                      X))
                (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                   (@category_theory.functor.obj.{vâ‚ vâ‚ (max uâ‚ vâ‚) uâ‚}
                      (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
                      (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)
                      C
                      ğ’
                      (@category_theory.monad.forget.{vâ‚ uâ‚} C ğ’ T _inst_1)
                      Y))
                (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X
                   (@category_theory.functor.obj.{vâ‚ vâ‚ (max uâ‚ vâ‚) uâ‚}
                      (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
                      (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)
                      C
                      ğ’
                      (@category_theory.monad.forget.{vâ‚ uâ‚} C ğ’ T _inst_1)
                      Y)
                   f)
                (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
             (@id.{0}
                (@eq.{vâ‚+1}
                   (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                      (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                      (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                         (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ (max uâ‚ vâ‚)} C ğ’
                               (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
                               (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)
                               (@category_theory.monad.free.{vâ‚ uâ‚} C ğ’ T _inst_1)
                               X)))
                      (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                   (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                      (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                         (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ (max uâ‚ vâ‚)} C ğ’
                               (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
                               (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)
                               (@category_theory.monad.free.{vâ‚ uâ‚} C ğ’ T _inst_1)
                               X)))
                      (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                         (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                      (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                      (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                         (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ (max uâ‚ vâ‚)} C ğ’
                               (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
                               (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)
                               (@category_theory.monad.free.{vâ‚ uâ‚} C ğ’ T _inst_1)
                               X))
                         (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                         (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                            (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ (max uâ‚ vâ‚)} C ğ’
                                  (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
                                  (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)
                                  (@category_theory.monad.free.{vâ‚ uâ‚} C ğ’ T _inst_1)
                                  X))
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                               (@category_theory.functor.obj.{vâ‚ vâ‚ (max uâ‚ vâ‚) uâ‚}
                                  (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
                                  (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)
                                  C
                                  ğ’
                                  (@category_theory.monad.forget.{vâ‚ uâ‚} C ğ’ T _inst_1)
                                  Y))
                            (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                            (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X
                               (@category_theory.functor.obj.{vâ‚ vâ‚ (max uâ‚ vâ‚) uâ‚}
                                  (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
                                  (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)
                                  C
                                  ğ’
                                  (@category_theory.monad.forget.{vâ‚ uâ‚} C ğ’ T _inst_1)
                                  Y)
                               f)
                            (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)))
                      (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                   (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                      (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                         (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ (max uâ‚ vâ‚)} C ğ’
                               (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
                               (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)
                               (@category_theory.monad.free.{vâ‚ uâ‚} C ğ’ T _inst_1)
                               X)))
                      (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1
                         (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ (max uâ‚ vâ‚)} C ğ’
                            (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
                            (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)
                            (@category_theory.monad.free.{vâ‚ uâ‚} C ğ’ T _inst_1)
                            X))
                      (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                      (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1
                         (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ (max uâ‚ vâ‚)} C ğ’
                            (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
                            (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)
                            (@category_theory.monad.free.{vâ‚ uâ‚} C ğ’ T _inst_1)
                            X))
                      (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                         (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ (max uâ‚ vâ‚)} C ğ’
                               (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
                               (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)
                               (@category_theory.monad.free.{vâ‚ uâ‚} C ğ’ T _inst_1)
                               X))
                         (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                            (@category_theory.functor.obj.{vâ‚ vâ‚ (max uâ‚ vâ‚) uâ‚}
                               (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
                               (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)
                               C
                               ğ’
                               (@category_theory.monad.forget.{vâ‚ uâ‚} C ğ’ T _inst_1)
                               Y))
                         (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                         (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X
                            (@category_theory.functor.obj.{vâ‚ vâ‚ (max uâ‚ vâ‚) uâ‚}
                               (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
                               (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)
                               C
                               ğ’
                               (@category_theory.monad.forget.{vâ‚ uâ‚} C ğ’ T _inst_1)
                               Y)
                            f)
                         (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))))
                (@eq.mpr.{0}
                   (@eq.{vâ‚+1}
                      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                         (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                         (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                      (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                         (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                         (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                            (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                         (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                         (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                            (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                            (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                               (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                  (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                               (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                               (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X
                                  (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                                  f)
                               (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)))
                         (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                      (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                         (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                         (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                         (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                         (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                            (@category_theory.functor.comp.{vâ‚ vâ‚ vâ‚ uâ‚ uâ‚ uâ‚} C ğ’ C ğ’ C ğ’ T T)
                            T
                            (@category_theory.monad.Î¼.{vâ‚ uâ‚} C ğ’ T _inst_1)
                            X)
                         (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                               (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                            (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                            (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X
                               (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                               f)
                            (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))))
                   (@eq.{vâ‚+1}
                      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                         (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                         (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                      (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                         (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                         (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                               (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)))
                         (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                         (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                               (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                            (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X
                               (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                               f))
                         (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                  (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)))
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                               (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                            (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                            (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                  (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                               (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                               (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                            (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)))
                      (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                         (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                         (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                         (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                         (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                            (@category_theory.functor.comp.{vâ‚ vâ‚ vâ‚ uâ‚ uâ‚ uâ‚} C ğ’ C ğ’ C ğ’ T T)
                            T
                            (@category_theory.monad.Î¼.{vâ‚ uâ‚} C ğ’ T _inst_1)
                            X)
                         (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                               (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                            (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                            (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X
                               (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                               f)
                            (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))))
                   (@id.{0}
                      (@eq.{1} Prop
                         (@eq.{vâ‚+1}
                            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                  (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                               (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                            (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                               (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                  (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                  (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                               (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                               (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                  (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                                  (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                                  (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                                     (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                                     (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                        (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                                     (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                                     (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X
                                        (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                                        f)
                                     (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)))
                               (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                            (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                               (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                  (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                               (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                               (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                  (@category_theory.functor.comp.{vâ‚ vâ‚ vâ‚ uâ‚ uâ‚ uâ‚} C ğ’ C ğ’ C ğ’ T
                                     T)
                                  T
                                  (@category_theory.monad.Î¼.{vâ‚ uâ‚} C ğ’ T _inst_1)
                                  X)
                               (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                                  (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                                  (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                     (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                                  (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                                  (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X
                                     (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                                     f)
                                  (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))))
                         (@eq.{vâ‚+1}
                            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                  (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                               (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                            (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                               (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                  (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                  (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                     (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)))
                               (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                               (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                  (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                                  (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                     (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                                  (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X
                                     (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                                     f))
                               (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                                  (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                     (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                        (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)))
                                  (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                     (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                                  (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                                  (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                     (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                        (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                                     (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                                     (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                                  (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)))
                            (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                               (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                  (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                               (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                               (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                  (@category_theory.functor.comp.{vâ‚ vâ‚ vâ‚ uâ‚ uâ‚ uâ‚} C ğ’ C ğ’ C ğ’ T
                                     T)
                                  T
                                  (@category_theory.monad.Î¼.{vâ‚ uâ‚} C ğ’ T _inst_1)
                                  X)
                               (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                                  (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                                  (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                     (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                                  (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                                  (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X
                                     (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                                     f)
                                  (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)))))
                      ((Î»
                        (a a_1 :
                          @category_theory.has_hom.hom.{vâ‚ uâ‚} C
                            (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                               (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                            (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                        (e_1 :
                          @eq.{vâ‚+1}
                            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                  (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                               (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                            a
                            a_1)
                        (a_2 a_3 :
                          @category_theory.has_hom.hom.{vâ‚ uâ‚} C
                            (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                               (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                            (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                        (e_2 :
                          @eq.{vâ‚+1}
                            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                  (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                               (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                            a_2
                            a_3),
                          @congr.{vâ‚+1 1}
                            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                  (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                               (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                            Prop
                            (@eq.{vâ‚+1}
                               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                  (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                     (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                                  (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                               a)
                            (@eq.{vâ‚+1}
                               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                  (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                     (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                                  (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                               a_1)
                            a_2
                            a_3
                            (@congr_arg.{vâ‚+1 (max (vâ‚+1) 1)}
                               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                  (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                     (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                                  (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                  (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                     (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                                  (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y) â†’
                                Prop)
                               a
                               a_1
                               (@eq.{vâ‚+1}
                                  (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                     (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                        (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                     (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                        (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                                     (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)))
                               e_1)
                            e_2)
                         (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                               (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                            (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                            (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                               (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                               (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                                  (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                                  (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                     (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                                  (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                                  (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X
                                     (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                                     f)
                                  (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)))
                            (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                         (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                  (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)))
                            (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                            (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                  (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                               (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X
                                  (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                                  f))
                            (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                               (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                  (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                     (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)))
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                  (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                               (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                               (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                  (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                     (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                                  (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                                  (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                               (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)))
                         (@eq.trans.{vâ‚+1}
                            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                  (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                               (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                            (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                               (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                  (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                  (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                               (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                               (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                  (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                                  (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                                  (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                                     (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                                     (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                        (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                                     (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                                     (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X
                                        (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                                        f)
                                     (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)))
                               (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                            (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                               (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                  (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                  (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                               (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                               (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                                  (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T â€¦)
                                  â€¦
                                  â€¦
                                  â€¦
                                  â€¦)
                               â€¦)
                            â€¦
                            â€¦
                            â€¦)
                         â€¦
                         â€¦
                         â€¦))
                   â€¦)))
          f))
    f'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>108        dsimp,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1239, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse bool (Î» (a : bool), bool.has_reflect a) interactive.types.only_flag â†’ @interactive.parse (list.{0} tactic.simp_arg_type) (Î» (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (Î» (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list â†’ @interactive.parse (list.{0} name) (Î» (a : list.{0} name), @list.reflect name (Î» (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='`dsimp` is similar to `simp`, except that it only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
T : @category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’,
_inst_1 : @category_theory.monad.{vâ‚ uâ‚} C ğ’ T,
X : C,
Y : @category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1,
f :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X
    (@category_theory.functor.obj.{vâ‚ vâ‚ (max uâ‚ vâ‚) uâ‚}
       (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
       (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)
       C
       ğ’
       (@category_theory.monad.forget.{vâ‚ uâ‚} C ğ’ T _inst_1)
       Y)
âŠ¢ @eq.{vâ‚+1}
    (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
       (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
       X
       (@category_theory.functor.obj.{vâ‚ vâ‚ (max uâ‚ vâ‚) uâ‚}
          (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
          (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)
          C
          ğ’
          (@category_theory.monad.forget.{vâ‚ uâ‚} C ğ’ T _inst_1)
          Y))
    ((Î»
      (f :
        @category_theory.has_hom.hom.{vâ‚ (max uâ‚ vâ‚)}
          (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
          (@category_theory.category_struct.to_has_hom.{vâ‚ (max uâ‚ vâ‚)}
             (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
             (@category_theory.category.to_category_struct.{vâ‚ (max uâ‚ vâ‚)}
                (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)))
          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ (max uâ‚ vâ‚)} C ğ’
             (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)
             (@category_theory.monad.free.{vâ‚ uâ‚} C ğ’ T _inst_1)
             X)
          Y),
        @category_theory.category_struct.comp.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
          X
          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
          (@category_theory.functor.obj.{vâ‚ vâ‚ (max uâ‚ vâ‚) uâ‚}
             (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
             (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)
             C
             ğ’
             (@category_theory.monad.forget.{vâ‚ uâ‚} C ğ’ T _inst_1)
             Y)
          (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
             (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
             T
             (@category_theory.monad.Î·.{vâ‚ uâ‚} C ğ’ T _inst_1)
             X)
          (@category_theory.monad.algebra.hom.f.{vâ‚ uâ‚} C ğ’ T _inst_1
             (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ (max uâ‚ vâ‚)} C ğ’
                (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)
                (@category_theory.monad.free.{vâ‚ uâ‚} C ğ’ T _inst_1)
                X)
             Y
             f))
       ((Î»
         (f :
           @category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X
             (@category_theory.functor.obj.{vâ‚ vâ‚ (max uâ‚ vâ‚) uâ‚}
                (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)
                C
                ğ’
                (@category_theory.monad.forget.{vâ‚ uâ‚} C ğ’ T _inst_1)
                Y)),
           @category_theory.monad.algebra.hom.mk.{vâ‚ uâ‚} C ğ’ T _inst_1
             (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ (max uâ‚ vâ‚)} C ğ’
                (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
                (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)
                (@category_theory.monad.free.{vâ‚ uâ‚} C ğ’ T _inst_1)
                X)
             Y
             (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1
                   (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ (max uâ‚ vâ‚)} C ğ’
                      (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
                      (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)
                      (@category_theory.monad.free.{vâ‚ uâ‚} C ğ’ T _inst_1)
                      X))
                (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                   (@category_theory.functor.obj.{vâ‚ vâ‚ (max uâ‚ vâ‚) uâ‚}
                      (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
                      (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)
                      C
                      ğ’
                      (@category_theory.monad.forget.{vâ‚ uâ‚} C ğ’ T _inst_1)
                      Y))
                (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X
                   (@category_theory.functor.obj.{vâ‚ vâ‚ (max uâ‚ vâ‚) uâ‚}
                      (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
                      (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)
                      C
                      ğ’
                      (@category_theory.monad.forget.{vâ‚ uâ‚} C ğ’ T _inst_1)
                      Y)
                   f)
                (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
             (@id.{0}
                (@eq.{vâ‚+1}
                   (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                      (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                      (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                         (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ (max uâ‚ vâ‚)} C ğ’
                               (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
                               (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)
                               (@category_theory.monad.free.{vâ‚ uâ‚} C ğ’ T _inst_1)
                               X)))
                      (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                   (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                      (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                         (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ (max uâ‚ vâ‚)} C ğ’
                               (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
                               (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)
                               (@category_theory.monad.free.{vâ‚ uâ‚} C ğ’ T _inst_1)
                               X)))
                      (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                         (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                      (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                      (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                         (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ (max uâ‚ vâ‚)} C ğ’
                               (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
                               (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)
                               (@category_theory.monad.free.{vâ‚ uâ‚} C ğ’ T _inst_1)
                               X))
                         (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                         (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                            (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ (max uâ‚ vâ‚)} C ğ’
                                  (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
                                  (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)
                                  (@category_theory.monad.free.{vâ‚ uâ‚} C ğ’ T _inst_1)
                                  X))
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                               (@category_theory.functor.obj.{vâ‚ vâ‚ (max uâ‚ vâ‚) uâ‚}
                                  (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
                                  (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)
                                  C
                                  ğ’
                                  (@category_theory.monad.forget.{vâ‚ uâ‚} C ğ’ T _inst_1)
                                  Y))
                            (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                            (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X
                               (@category_theory.functor.obj.{vâ‚ vâ‚ (max uâ‚ vâ‚) uâ‚}
                                  (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
                                  (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)
                                  C
                                  ğ’
                                  (@category_theory.monad.forget.{vâ‚ uâ‚} C ğ’ T _inst_1)
                                  Y)
                               f)
                            (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)))
                      (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                   (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                      (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                         (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ (max uâ‚ vâ‚)} C ğ’
                               (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
                               (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)
                               (@category_theory.monad.free.{vâ‚ uâ‚} C ğ’ T _inst_1)
                               X)))
                      (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1
                         (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ (max uâ‚ vâ‚)} C ğ’
                            (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
                            (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)
                            (@category_theory.monad.free.{vâ‚ uâ‚} C ğ’ T _inst_1)
                            X))
                      (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                      (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1
                         (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ (max uâ‚ vâ‚)} C ğ’
                            (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
                            (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)
                            (@category_theory.monad.free.{vâ‚ uâ‚} C ğ’ T _inst_1)
                            X))
                      (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                         (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ (max uâ‚ vâ‚)} C ğ’
                               (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
                               (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)
                               (@category_theory.monad.free.{vâ‚ uâ‚} C ğ’ T _inst_1)
                               X))
                         (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                            (@category_theory.functor.obj.{vâ‚ vâ‚ (max uâ‚ vâ‚) uâ‚}
                               (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
                               (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)
                               C
                               ğ’
                               (@category_theory.monad.forget.{vâ‚ uâ‚} C ğ’ T _inst_1)
                               Y))
                         (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                         (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X
                            (@category_theory.functor.obj.{vâ‚ vâ‚ (max uâ‚ vâ‚) uâ‚}
                               (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
                               (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)
                               C
                               ğ’
                               (@category_theory.monad.forget.{vâ‚ uâ‚} C ğ’ T _inst_1)
                               Y)
                            f)
                         (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))))
                (@eq.mpr.{0}
                   (@eq.{vâ‚+1}
                      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                         (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                         (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                      (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                         (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                         (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                            (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                         (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                         (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                            (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                            (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                               (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                  (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                               (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                               (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X
                                  (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                                  f)
                               (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)))
                         (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                      (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                         (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                         (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                         (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                         (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                            (@category_theory.functor.comp.{vâ‚ vâ‚ vâ‚ uâ‚ uâ‚ uâ‚} C ğ’ C ğ’ C ğ’ T T)
                            T
                            (@category_theory.monad.Î¼.{vâ‚ uâ‚} C ğ’ T _inst_1)
                            X)
                         (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                               (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                            (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                            (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X
                               (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                               f)
                            (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))))
                   (@eq.{vâ‚+1}
                      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                         (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                         (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                      (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                         (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                         (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                               (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)))
                         (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                         (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                               (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                            (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X
                               (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                               f))
                         (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                  (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)))
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                               (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                            (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                            (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                  (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                               (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                               (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                            (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)))
                      (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                         (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                         (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                         (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                         (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                            (@category_theory.functor.comp.{vâ‚ vâ‚ vâ‚ uâ‚ uâ‚ uâ‚} C ğ’ C ğ’ C ğ’ T T)
                            T
                            (@category_theory.monad.Î¼.{vâ‚ uâ‚} C ğ’ T _inst_1)
                            X)
                         (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                               (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                            (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                            (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X
                               (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                               f)
                            (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))))
                   (@id.{0}
                      (@eq.{1} Prop
                         (@eq.{vâ‚+1}
                            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                  (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                               (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                            (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                               (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                  (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                  (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                               (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                               (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                  (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                                  (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                                  (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                                     (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                                     (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                        (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                                     (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                                     (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X
                                        (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                                        f)
                                     (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)))
                               (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                            (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                               (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                  (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                               (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                               (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                  (@category_theory.functor.comp.{vâ‚ vâ‚ vâ‚ uâ‚ uâ‚ uâ‚} C ğ’ C ğ’ C ğ’ T
                                     T)
                                  T
                                  (@category_theory.monad.Î¼.{vâ‚ uâ‚} C ğ’ T _inst_1)
                                  X)
                               (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                                  (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                                  (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                     (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                                  (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                                  (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X
                                     (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                                     f)
                                  (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))))
                         (@eq.{vâ‚+1}
                            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                  (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                               (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                            (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                               (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                  (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                  (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                     (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)))
                               (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                               (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                  (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                                  (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                     (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                                  (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X
                                     (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                                     f))
                               (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                                  (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                     (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                        (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)))
                                  (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                     (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                                  (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                                  (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                     (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                        (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                                     (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                                     (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                                  (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)))
                            (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                               (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                  (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                               (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                               (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                  (@category_theory.functor.comp.{vâ‚ vâ‚ vâ‚ uâ‚ uâ‚ uâ‚} C ğ’ C ğ’ C ğ’ T
                                     T)
                                  T
                                  (@category_theory.monad.Î¼.{vâ‚ uâ‚} C ğ’ T _inst_1)
                                  X)
                               (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                                  (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                                  (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                     (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                                  (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                                  (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X
                                     (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                                     f)
                                  (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)))))
                      ((Î»
                        (a a_1 :
                          @category_theory.has_hom.hom.{vâ‚ uâ‚} C
                            (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                               (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                            (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                        (e_1 :
                          @eq.{vâ‚+1}
                            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                  (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                               (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                            a
                            a_1)
                        (a_2 a_3 :
                          @category_theory.has_hom.hom.{vâ‚ uâ‚} C
                            (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                               (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                            (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                        (e_2 :
                          @eq.{vâ‚+1}
                            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                  (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                               (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                            a_2
                            a_3),
                          @congr.{vâ‚+1 1}
                            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                  (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                               (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                            Prop
                            (@eq.{vâ‚+1}
                               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                  (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                     (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                                  (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                               a)
                            (@eq.{vâ‚+1}
                               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                  (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                     (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                                  (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                               a_1)
                            a_2
                            a_3
                            (@congr_arg.{vâ‚+1 (max (vâ‚+1) 1)}
                               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                  (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                     (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                                  (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                  (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                     (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                                  (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y) â†’
                                Prop)
                               a
                               a_1
                               (@eq.{vâ‚+1}
                                  (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                     (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                        (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                     (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                        (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                                     (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)))
                               e_1)
                            e_2)
                         (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                               (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                            (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                            (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                               (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                               (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                                  (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                                  (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                     (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                                  (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                                  (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X
                                     (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                                     f)
                                  (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)))
                            (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                         (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                            (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                  (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)))
                            (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                            (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                  (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                               (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X
                                  (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                                  f))
                            (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                               (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                  (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                     (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)))
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                  (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                               (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                               (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                  (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                     (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                                  (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                                  (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                               (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)))
                         (@eq.trans.{vâ‚+1}
                            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                  (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                               (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                            (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                               (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                  (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                  (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                               (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                               (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                  (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                                  (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                                  (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                                     (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
                                     (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                        (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                                     (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                                     (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X
                                        (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                                        f)
                                     (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)))
                               (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                            (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                               (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                  (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X))
                               (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
                                  (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
                               (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
                               (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                                  (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T â€¦)
                                  â€¦
                                  â€¦
                                  â€¦
                                  â€¦)
                               â€¦)
                            â€¦
                            â€¦
                            â€¦)
                         â€¦
                         â€¦
                         â€¦))
                   â€¦)))
          f))
    f'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
T : @category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’,
_inst_1 : @category_theory.monad.{vâ‚ uâ‚} C ğ’ T,
X : C,
Y : @category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1,
f :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X
    (@category_theory.functor.obj.{vâ‚ vâ‚ (max uâ‚ vâ‚) uâ‚}
       (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
       (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)
       C
       ğ’
       (@category_theory.monad.forget.{vâ‚ uâ‚} C ğ’ T _inst_1)
       Y)
âŠ¢ @eq.{vâ‚+1}
    (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
       (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
       X
       (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
    (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
       X
       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
       (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
       (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
          (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
          T
          (@category_theory.monad.Î·.{vâ‚ uâ‚} C ğ’ T _inst_1)
          X)
       (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
             (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
          (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
          (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X
             (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
             f)
          (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)))
    f'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>109        erw [â†category.assoc, â†(Î·_ T).naturality, functor.id_map,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='category_theory.category.assoc'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='category_theory.monad.Î·'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='T'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='category_theory.functor.id_map'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/monad/basic.lean&#x27;, &#x27;line&#x27;: 16, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 62, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (Î» (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='âˆ€ (obj : Type uâ‚) [c : category_theory.category.{vâ‚ uâ‚} obj] {W X Y Z : obj} (f : @category_theory.has_hom.hom.{vâ‚ uâ‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} obj (@category_theory.category.to_category_struct.{vâ‚ uâ‚} obj c)) W X) (g : @category_theory.has_hom.hom.{vâ‚ uâ‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} obj (@category_theory.category.to_category_struct.{vâ‚ uâ‚} obj c)) X Y) (h : @category_theory.has_hom.hom.{vâ‚ uâ‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} obj (@category_theory.category.to_category_struct.{vâ‚ uâ‚} obj c)) Y Z), @eq.{vâ‚+1} (@category_theory.has_hom.hom.{vâ‚ uâ‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} obj (@category_theory.category.to_category_struct.{vâ‚ uâ‚} obj c)) W Z) (@category_theory.category_struct.comp.{vâ‚ uâ‚} obj (@category_theory.category.to_category_struct.{vâ‚ uâ‚} obj c) W Y Z (@category_theory.category_struct.comp.{vâ‚ uâ‚} obj (@category_theory.category.to_category_struct.{vâ‚ uâ‚} obj c) W X Y f g) h) (@category_theory.category_struct.comp.{vâ‚ uâ‚} obj (@category_theory.category.to_category_struct.{vâ‚ uâ‚} obj c) W X Z f (@category_theory.category_struct.comp.{vâ‚ uâ‚} obj (@category_theory.category.to_category_struct.{vâ‚ uâ‚} obj c) X Y Z g h))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (Î» (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] (T : @category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’) [c : @category_theory.monad.{vâ‚ uâ‚} C ğ’ T], @category_theory.has_hom.hom.{(max uâ‚ vâ‚) (max vâ‚ uâ‚)} (@category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’) (@category_theory.category_struct.to_has_hom.{(max uâ‚ vâ‚) (max vâ‚ uâ‚)} (@category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’) (@category_theory.category.to_category_struct.{(max uâ‚ vâ‚) (max vâ‚ uâ‚)} (@category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’) (@category_theory.functor.category.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’))) (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’) T'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (Î» (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (Î» (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='âˆ€ {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] {X Y : C} (f : @category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X Y), @eq.{vâ‚+1} (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’) X) (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’) Y)) (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’) X Y f) f'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (Î» (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;([ (â†? expr), ... ] | â†? expr)&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;([ (â†? expr), ... ] | â†? expr)&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (â†? expr), ... ] | â†? expr)&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (â†? expr), ... ] | â†? expr)&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;([ (â†? expr), ... ] | â†? expr)&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
T : @category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’,
_inst_1 : @category_theory.monad.{vâ‚ uâ‚} C ğ’ T,
X : C,
Y : @category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1,
f :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X
    (@category_theory.functor.obj.{vâ‚ vâ‚ (max uâ‚ vâ‚) uâ‚}
       (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
       (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)
       C
       ğ’
       (@category_theory.monad.forget.{vâ‚ uâ‚} C ğ’ T _inst_1)
       Y)
âŠ¢ @eq.{vâ‚+1}
    (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
       (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
       X
       (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
    (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
       X
       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
       (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
       (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
          (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
          T
          (@category_theory.monad.Î·.{vâ‚ uâ‚} C ğ’ T _inst_1)
          X)
       (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
             (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
          (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
          (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X
             (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
             f)
          (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)))
    f'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
T : @category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’,
_inst_1 : @category_theory.monad.{vâ‚ uâ‚} C ğ’ T,
X : C,
Y : @category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1,
f :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X
    (@category_theory.functor.obj.{vâ‚ vâ‚ (max uâ‚ vâ‚) uâ‚}
       (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
       (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)
       C
       ğ’
       (@category_theory.monad.forget.{vâ‚ uâ‚} C ğ’ T _inst_1)
       Y)
âŠ¢ @eq.{vâ‚+1}
    (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
       (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
       X
       (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
    (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
       X
       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
          (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
       (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
       (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
          X
          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X)
          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
             (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
          (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
             (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
             T
             (@category_theory.monad.Î·.{vâ‚ uâ‚} C ğ’ T _inst_1)
             X)
          (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T X
             (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
             f))
       (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
    f'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
T : @category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’,
_inst_1 : @category_theory.monad.{vâ‚ uâ‚} C ğ’ T,
X : C,
Y : @category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1,
f :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X
    (@category_theory.functor.obj.{vâ‚ vâ‚ (max uâ‚ vâ‚) uâ‚}
       (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
       (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)
       C
       ğ’
       (@category_theory.monad.forget.{vâ‚ uâ‚} C ğ’ T _inst_1)
       Y)
âŠ¢ @eq.{vâ‚+1}
    (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
       (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
       X
       (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
    (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
       X
       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
          (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
       (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
       (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
             (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
             X)
          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
             (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
             (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
             (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
          (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
             (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
             X
             (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
             f)
          (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
             (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
             T
             (@category_theory.monad.Î·.{vâ‚ uâ‚} C ğ’ T _inst_1)
             (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)))
       (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
    f'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
T : @category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’,
_inst_1 : @category_theory.monad.{vâ‚ uâ‚} C ğ’ T,
X : C,
Y : @category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1,
f :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X
    (@category_theory.functor.obj.{vâ‚ vâ‚ (max uâ‚ vâ‚) uâ‚}
       (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
       (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)
       C
       ğ’
       (@category_theory.monad.forget.{vâ‚ uâ‚} C ğ’ T _inst_1)
       Y)
âŠ¢ @eq.{vâ‚+1}
    (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
       (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
       X
       (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
    (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
       X
       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
          (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
       (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
       (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
             (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
             X)
          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
             (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
             (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
             (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
          f
          (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
             (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
             T
             (@category_theory.monad.Î·.{vâ‚ uâ‚} C ğ’ T _inst_1)
             (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)))
       (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
    f'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>110              category.assoc, Y.unit, comp_id],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='category_theory.category.assoc'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='category_theory.category.comp_id'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (Î» (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='âˆ€ (obj : Type uâ‚) [c : category_theory.category.{vâ‚ uâ‚} obj] {W X Y Z : obj} (f : @category_theory.has_hom.hom.{vâ‚ uâ‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} obj (@category_theory.category.to_category_struct.{vâ‚ uâ‚} obj c)) W X) (g : @category_theory.has_hom.hom.{vâ‚ uâ‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} obj (@category_theory.category.to_category_struct.{vâ‚ uâ‚} obj c)) X Y) (h : @category_theory.has_hom.hom.{vâ‚ uâ‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} obj (@category_theory.category.to_category_struct.{vâ‚ uâ‚} obj c)) Y Z), @eq.{vâ‚+1} (@category_theory.has_hom.hom.{vâ‚ uâ‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} obj (@category_theory.category.to_category_struct.{vâ‚ uâ‚} obj c)) W Z) (@category_theory.category_struct.comp.{vâ‚ uâ‚} obj (@category_theory.category.to_category_struct.{vâ‚ uâ‚} obj c) W Y Z (@category_theory.category_struct.comp.{vâ‚ uâ‚} obj (@category_theory.category.to_category_struct.{vâ‚ uâ‚} obj c) W X Y f g) h) (@category_theory.category_struct.comp.{vâ‚ uâ‚} obj (@category_theory.category.to_category_struct.{vâ‚ uâ‚} obj c) W X Z f (@category_theory.category_struct.comp.{vâ‚ uâ‚} obj (@category_theory.category.to_category_struct.{vâ‚ uâ‚} obj c) X Y Z g h))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (Î» (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{vâ‚+1} (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y) (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)) (@category_theory.category_struct.comp.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’) (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y) (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)) (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y) (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’) T (@category_theory.monad.Î·.{vâ‚ uâ‚} C ğ’ T _inst_1) (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)) (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)) (@category_theory.category_struct.id.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’) (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (Î» (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='âˆ€ (obj : Type uâ‚) [c : category_theory.category.{vâ‚ uâ‚} obj] {X Y : obj} (f : @category_theory.has_hom.hom.{vâ‚ uâ‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} obj (@category_theory.category.to_category_struct.{vâ‚ uâ‚} obj c)) X Y), @eq.{vâ‚+1} (@category_theory.has_hom.hom.{vâ‚ uâ‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} obj (@category_theory.category.to_category_struct.{vâ‚ uâ‚} obj c)) X Y) (@category_theory.category_struct.comp.{vâ‚ uâ‚} obj (@category_theory.category.to_category_struct.{vâ‚ uâ‚} obj c) X Y Y f (@category_theory.category_struct.id.{vâ‚ uâ‚} obj (@category_theory.category.to_category_struct.{vâ‚ uâ‚} obj c) Y)) f'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (Î» (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (â†? expr), ... ] | â†? expr)&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;([ (â†? expr), ... ] | â†? expr)&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;([ (â†? expr), ... ] | â†? expr)&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;([ (â†? expr), ... ] | â†? expr)&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
T : @category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’,
_inst_1 : @category_theory.monad.{vâ‚ uâ‚} C ğ’ T,
X : C,
Y : @category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1,
f :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X
    (@category_theory.functor.obj.{vâ‚ vâ‚ (max uâ‚ vâ‚) uâ‚}
       (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
       (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)
       C
       ğ’
       (@category_theory.monad.forget.{vâ‚ uâ‚} C ğ’ T _inst_1)
       Y)
âŠ¢ @eq.{vâ‚+1}
    (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
       (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
       X
       (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
    (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
       X
       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
          (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
       (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
       (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
             (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
             X)
          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
             (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
             (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
             (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
          f
          (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
             (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
             T
             (@category_theory.monad.Î·.{vâ‚ uâ‚} C ğ’ T _inst_1)
             (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)))
       (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
    f'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
T : @category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’,
_inst_1 : @category_theory.monad.{vâ‚ uâ‚} C ğ’ T,
X : C,
Y : @category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1,
f :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X
    (@category_theory.functor.obj.{vâ‚ vâ‚ (max uâ‚ vâ‚) uâ‚}
       (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
       (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)
       C
       ğ’
       (@category_theory.monad.forget.{vâ‚ uâ‚} C ğ’ T _inst_1)
       Y)
âŠ¢ @eq.{vâ‚+1}
    (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
       (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
       X
       (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
    (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
       X
       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
          (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
          (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
       (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
       f
       (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
             (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
             (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ T
             (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
          (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
          (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
             (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
             T
             (@category_theory.monad.Î·.{vâ‚ uâ‚} C ğ’ T _inst_1)
             (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
          (@category_theory.monad.algebra.a.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)))
    f'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
T : @category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’,
_inst_1 : @category_theory.monad.{vâ‚ uâ‚} C ğ’ T,
X : C,
Y : @category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1,
f :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X
    (@category_theory.functor.obj.{vâ‚ vâ‚ (max uâ‚ vâ‚) uâ‚}
       (@category_theory.monad.algebra.{vâ‚ uâ‚} C ğ’ T _inst_1)
       (@category_theory.monad.algebra.EilenbergMoore.{vâ‚ uâ‚} C ğ’ T _inst_1)
       C
       ğ’
       (@category_theory.monad.forget.{vâ‚ uâ‚} C ğ’ T _inst_1)
       Y)
âŠ¢ @eq.{vâ‚+1}
    (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
       (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
       X
       (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
    (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
       X
       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
          (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
          (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y))
       (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)
       f
       (@category_theory.category_struct.id.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
          (@category_theory.monad.algebra.A.{vâ‚ uâ‚} C ğ’ T _inst_1 Y)))
    f'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>111      end }}</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>112  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>113  end monad</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>114  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>115  end category_theory</code></pre>
</body>